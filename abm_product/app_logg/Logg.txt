extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 43 "/usr/include/sys/types.h"
extern "C" {
}
extern "C" {
#line 45 "/usr/include/sys/inttypes.h"
extern "C" {
}
extern "C" {
#line 33 "/usr/include/stdint.h"
extern "C" {
#line 45
typedef signed char		int8_t;
typedef signed short		int16_t;
typedef signed int		int32_t;

typedef signed long		int64_t;
#line 56
typedef unsigned char		uint8_t;
typedef unsigned short		uint16_t;
typedef unsigned int		uint32_t;
#line 61
typedef unsigned long		uint64_t;
#line 74
typedef int64_t			intmax_t;
typedef uint64_t		uintmax_t;
#line 86
typedef signed long		intptr_t;
typedef unsigned long		uintptr_t;
#line 93
typedef signed char		int_least8_t;
typedef signed short		int_least16_t;
typedef signed int		int_least32_t;

typedef signed long		int_least64_t;
#line 104
typedef unsigned char		uint_least8_t;
typedef unsigned short		uint_least16_t;
typedef unsigned int		uint_least32_t;

typedef unsigned long		uint_least64_t;
#line 121
typedef signed char	int_fast8_t;
typedef int16_t		int_fast16_t;
typedef int32_t		int_fast32_t;
typedef unsigned char	uint_fast8_t;
typedef uint16_t	uint_fast16_t;
typedef uint32_t	uint_fast32_t;

typedef int64_t		int_fast64_t;
typedef uint64_t	uint_fast64_t;
#line 290
}
}
extern "C" {
#line 58 "/usr/include/sys/inttypes.h"
typedef struct {
	intmax_t quot;
	intmax_t rem;
} imaxdiv_t;
#line 79
extern intmax_t strtoimax(const char * restrict, char ** restrict, int);
#line 89
extern intmax_t imaxabs(intmax_t);
extern imaxdiv_t imaxdiv (intmax_t, intmax_t); 
extern uintmax_t strtoumax(const char * restrict, char ** restrict, int);
#line 101
extern intmax_t wcstoimax(const wchar_t * restrict, wchar_t ** restrict, int );
extern uintmax_t wcstoumax(const wchar_t * restrict, wchar_t ** restrict, int);
#line 109
typedef int64_t         intfast_t;
typedef uint64_t        uintfast_t;
#line 560
typedef signed int	__long32_t;
typedef unsigned int	__ulong32_t;
#line 574
typedef signed long	__long64_t;
typedef unsigned long	__ulong64_t;
#line 590
typedef signed int	int32long64_t;
typedef unsigned int	uint32long64_t;
#line 603
typedef signed long	long32int64_t;
typedef unsigned long	ulong32int64_t;
#line 618
typedef signed char		int8;
typedef signed short		int16;
typedef signed int		int32;

typedef long			int64;
#line 629
typedef unsigned char		u_int8;
typedef unsigned char		u_int8_t;
typedef unsigned short		u_int16;
typedef unsigned short		u_int16_t;
typedef unsigned int		u_int32;
typedef unsigned int		u_int32_t;

typedef unsigned long		u_int64;
typedef unsigned long		u_int64_t;
#line 654
}
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 84 "/usr/include/sys/types.h"
typedef long		ptrdiff_t;
#line 98
typedef unsigned int	wctype_t;
#line 107
typedef long	fpos_t;
#line 111
typedef long long fpos64_t;
#line 122
typedef long		time_t;
#line 131
typedef int		clock_t;
#line 136
typedef	unsigned long	size_t;
#line 147
typedef	unsigned char	uchar_t;
#line 150
typedef	unsigned short	ushort_t;
typedef	unsigned int	uint_t;
typedef unsigned long	ulong_t;
#line 156
typedef	signed long	ssize_t;
#line 162
typedef int		level_t;
typedef	__long64_t	daddr_t;	 
typedef	int		daddr32_t;	 

typedef	int64_t		daddr64_t;	 

typedef	char *		caddr_t;	 
typedef	__ulong64_t	ino_t;		 
typedef	uint_t 		ino32_t;	 

typedef	uint64_t 	ino64_t;	 

typedef short		cnt_t;
#line 179
typedef	__ulong64_t	dev_t;		 

typedef uint_t 		dev32_t;	 

typedef uint64_t 	dev64_t;	 

typedef	int		chan_t;		 
typedef int		time32_t;		 
typedef int		pid32_t;		 
typedef int		tid32_t;		 

typedef uint64_t     pid64_t;      
typedef uint64_t     tid64_t;      

typedef int64_t      time64_t;     
#line 201
typedef unsigned int __ptr32;
typedef unsigned int __cptr32;
#line 208
typedef int soff_t;			 
#line 215
typedef long		off_t;		 
#line 220
typedef long long 	off64_t;
#line 223
typedef	long		paddr_t;
#line 228
typedef	int32long64_t	key_t;
#line 233
typedef __long64_t	timer_t;	 

typedef int		timer32_t;	 

typedef int64_t 	timer64_t;	 

typedef	short		nlink_t;
#line 244
typedef	uint_t		mode_t;		 
#line 250
typedef uint_t		uid_t;		 
typedef uint_t		gid_t;		 
#line 254
typedef	__ptr32 	mid_t;		 
#line 258
typedef	int32long64_t	pid_t;		 
#line 261
typedef __long64_t	tid_t;		 
typedef char		slab_t[12];	 
typedef long		mtyp_t;		 
typedef int             boolean_t;
typedef int     	crid_t;
#line 271
typedef __long64_t	blkcnt_t;  
#line 277
typedef __long64_t	blksize_t;  
#line 282
typedef int		blkcnt32_t;  
typedef int		blksize32_t;  

typedef uint64_t	blkcnt64_t;  
typedef uint64_t	blksize64_t;  
#line 290
typedef ulong_t 	fsblkcnt_t;	 
typedef ulong_t		fsfilcnt_t;	 
#line 295
	typedef	int		wint_t;		 
#line 299
typedef uint32long64_t	id_t;		 
typedef unsigned int	useconds_t;	 
typedef signed   int	suseconds_t;	 
#line 305
typedef long long       clockid_t;       
#line 314
typedef struct sigset_t	{
#line 317
	unsigned long ss_set[4];
#line 330
} sigset_t;

typedef struct {

	unsigned int losigs, hisigs;
#line 338
} sigset32_t;
#line 341
typedef struct {
	uint64_t ss_set[4];
} sigset64_t;
#line 352
typedef int signal_t;
#line 357
typedef struct fsid_t {
#line 362
	unsigned int val[2];
#line 367
} fsid_t;
#line 375
typedef struct fsid64_t {

	uint64_t val[2];
#line 381
} fsid64_t;

typedef void *pthread_attr_t;
typedef	void *pthread_condattr_t;	
typedef	void *pthread_mutexattr_t;
#line 388
typedef	void *pthread_rwlockattr_t;
#line 392
typedef	void *pthread_barrierattr_t;
#line 395
typedef unsigned int pthread_t;
typedef unsigned int pthread_key_t;

typedef struct
{

	long	__mt_word[8];
#line 405
}
pthread_mutex_t;

typedef struct
{

	long	__cv_word[6];
#line 415
}
pthread_cond_t;

typedef struct
{

        long    __on_word[9];
#line 425
}
pthread_once_t;
#line 429
typedef struct
{

	long	__sp_word[3];
#line 436
}
pthread_spinlock_t;

typedef struct
{

	long	__br_word[5];
#line 446
}
pthread_barrier_t;
#line 451
typedef struct
{

	long	__rw_word[10];
#line 458
}
pthread_rwlock_t;
#line 466
typedef struct  _quad { int val[2]; } quad;
}
extern "C" {
}
extern "C" {
#line 38 "/usr/include/sys/vm_types.h"
typedef int             vmid_t;          
typedef uint_t		vmhandle_t;	 
#line 42
typedef int             vmid32_t;        
typedef uint_t		vmhandle32_t;	 
#line 51
typedef long32int64_t	kvmid_t;	 
typedef ulong32int64_t	kvmhandle_t;	 
#line 57
typedef long		vmid64_t;
typedef long		rpn64_t;
typedef long            cnt64_t;         
typedef long            psize_t;         
#line 73
typedef int32long64_t	vmidx_t;	 

typedef uint32long64_t  vmfkey_t;        

typedef uint32long64_t  vmprkey_t;       
typedef int32long64_t	vmkey_t;	 
typedef int32long64_t	vmhwkey_t;       
typedef int32long64_t	vpn_t;		 
typedef int32long64_t	rpn_t;		 

typedef unsigned long   ptex_t;          
typedef unsigned long   swhatx_t;        

typedef uint32long64_t  esid_t;          
#line 91
typedef ushort_t	aptx_t;		 
#line 94
typedef int             pdtx_t;          
typedef short           psx_t;           
typedef ushort_t        pshift_t;        
typedef ushort_t        sshift_t;        

typedef int             unidx_t;         
typedef int             snidx_t;         
typedef int             vmnodeidx_t;     

typedef int		kvpn_t;		 

   typedef int		krpn_t;		 

typedef int32long64_t   vmsize_t;	 

typedef int32long64_t   vmm_lock_t;      
#line 117
typedef unsigned long ureg_t;		 
#line 136
typedef struct

vmaddr_t

{		 

	vmhandle_t	srval;		 
	caddr_t		offset;		 
#line 148
} vmaddr_t;
#line 152
typedef struct

adspace_t

{		 

	ulong32int64_t	alloc;		 
	vmhandle_t	srval[16];	 
#line 164
} adspace_t;
#line 193
typedef enum _MR_ATTR_TYPE {
  BadAttr = 0,
  VirtAddr = 1
} MR_ATTR_TYPE;

typedef enum _MR_LABEL_TYPE {
  BadMem = 0,
  FreeMem = 1,
  IPLCB = 2,
  RMALLOC = 3,
  PM_HEAP = 4,
  RTAS_HEAP = 5,
  TCE_TABLE = 6,
  IO_SPACE = 7,
  HUGE_PAGE = 8
} MR_LABEL_TYPE;

typedef struct {
	unsigned long long	mr_addr;	 
	unsigned long long	mr_size;	 
	unsigned char	mr_att;			 
	unsigned char	mr_label;		 
	unsigned short	mr_nodeid;		 
	char	reserved[4];			 
} iplcb_map_reg_t;
#line 250
typedef vmhandle_t      vmlpghandle_t;     
}
extern "C" {
#line 48 "/usr/include/sys/m_types.h"
typedef struct label_t
{					 

	struct label_t   *prev;		 
	ulong_t           iar;		 
	ulong_t           stack;	 
	ulong_t           toc;		 
	ulong_t           cr;            
	ulong_t           intpri;	 
	ulong_t           reg[19];	 
#line 67
} label_t;

typedef int32long64_t	ext_t;		  
}
extern "C" {
#line 475 "/usr/include/sys/types.h"
typedef char *		va_list;
#line 515
typedef void * __ptr64;
typedef char * __cptr64;
#line 527
typedef ushort_t	UniChar;
typedef uint_t		UTF32Char;
#line 533
typedef	uchar_t		uchar;
typedef	ushort_t	ushort;
typedef	uint_t		uint;
typedef ulong_t		ulong;

typedef	struct { int r[1]; } *	physadr_t;
typedef	physadr_t	physadr;
#line 542
typedef	unsigned char	u_char;
typedef	unsigned short	u_short;
typedef	unsigned int	u_int;
typedef	unsigned long	u_long;

typedef	int	swblk_t;
#line 552
struct sigset	{

	unsigned long ss_set[4];
#line 559
};
#line 562
struct fsid {

	unsigned int	val[2];
#line 568
};
#line 577
struct fileid {			 
	uint_t	fid_len;
	ino32_t	fid_ino;
	uint_t	fid_gen;
	char	fid_x[20 - (sizeof(ino32_t) + 2) - sizeof(uint_t)];
};
#line 598
struct fid {
	uint_t	fid_len;
	char	fid_data[20];
};
typedef struct fid fid_t;
#line 605
struct fhandle {
	char x[32];		 
};
typedef struct fhandle fhandle_t;

struct filehandle {			 
	fsid_t		fh_fsid;		 
	struct fileid	fh_fid;			 
};
#line 622
struct unique_id {
       __ulong32_t word1;
       __ulong32_t word2;
       __ulong32_t word3;
       __ulong32_t word4;
};
typedef struct unique_id unique_id_t;
#line 654
typedef	long long  offset_t;		 
#line 664
typedef long long ssize64_t;
#line 670
typedef long long longlong_t;         
typedef unsigned long long u_longlong_t;
#line 674
typedef unsigned int class_id_t;
#line 678
typedef uint_t          liobn_t;        

typedef unsigned long long unit_addr_t;    
#line 687
typedef unsigned long long size64_t;    
#line 694
}
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 47 "/usr/include/wchar.h"
extern "C" {
}
extern "C" {
#line 47 "/usr/include/stdio.h"
extern "C" {
#line 137
typedef struct {
	unsigned char	*_ptr;
	unsigned char	*_base;
	unsigned char   *_bufendp;
	char	*__newbase;
	void	*_lock;
	int	_cnt;
	int	_file;
	int	__stdioid;
	short	_flag;
	short	_unused;
	long	_unused1[4];
} FILE;
#line 167
extern FILE	_iob[16];
#line 180
extern size_t 		fread(void *restrict, size_t, size_t, FILE *restrict);
extern size_t		fwrite(const void *restrict, size_t, size_t,FILE *restrict);
}
extern "C" {
}
extern "C" {
#line 191
extern int  vscanf(const char *restrict, va_list);
extern int  vfscanf(FILE *restrict, const char *restrict, va_list);
extern int  vsscanf(const char *restrict, const char *restrict, va_list);
#line 242
extern int	__flsbuf(unsigned char, FILE *);
extern int	__filbuf(FILE *);
extern int 	ferror(FILE *);
extern int 	feof(FILE *);
extern void 	clearerr(FILE *);
extern int 	putchar(int);
extern int 	getchar(void);
extern int 	putc(int, FILE *);
extern int 	getc(FILE *);
extern int	remove(const char *);
extern int	rename(const char *, const char *);
extern FILE 	*tmpfile(void);
extern char 	*tmpnam(char *);
extern int 	fclose(FILE *);
extern int 	fflush(FILE *);
extern FILE *	fopen(const char *restrict, const char *restrict);
extern FILE *	freopen(const char *restrict, const char *restrict, FILE *restrict);
extern void 	setbuf(FILE *restrict, char *restrict);
extern int 	setvbuf(FILE *restrict, char *restrict, int, size_t);
extern int	fprintf(FILE *restrict, const char *restrict, ...); 
extern int	fscanf(FILE *restrict, const char *restrict, ...);
extern int	printf(const char *restrict, ...); 
extern int	scanf(const char *restrict, ...); 
extern int	sprintf(char *restrict, const char *restrict, ...); 

extern int	snprintf(char *restrict, size_t, const char *restrict, ...);

extern int	sscanf(const char *restrict, const char *restrict, ...); 
#line 272
extern int	vfprintf(FILE *restrict, const char *restrict, va_list);
extern int	vprintf(const char *restrict, va_list); 
extern int	vsprintf(char *restrict, const char *restrict, va_list);

extern int	vsnprintf(char *restrict, size_t, const char *restrict, va_list);
#line 289
extern int 	fgetc(FILE *);
extern char *	fgets(char *restrict, int, FILE *restrict);
extern int 	fputc(int, FILE *);
extern int 	fputs(const char *restrict, FILE *restrict);
extern char 	*gets(char *);
extern int 	puts(const char *);
extern int	ungetc(int, FILE *);
extern int	fgetpos(FILE *restrict, fpos_t *restrict);
extern int 	fseek(FILE *, long int, int);
extern int	fsetpos(FILE *, const fpos_t *);
extern long	ftell(FILE *);
extern void	rewind(FILE *);
extern void 	perror(const char *); 
#line 307
extern int	getc_unlocked(FILE *);
extern int	getchar_unlocked(void);
extern int	putc_unlocked(int, FILE *);
extern int	putchar_unlocked(int);
#line 431
extern int 	fileno(FILE *);
extern FILE 	*fdopen(int,const char *);
extern char	*ctermid(char *);
extern FILE 	*popen(const char *, const char *);
extern int 	pclose(FILE *);
#line 438
extern void	flockfile(FILE *);
extern void	funlockfile(FILE *);
extern int	fseeko(FILE *, off_t, int);
extern off_t	ftello(FILE *);
extern int	ftrylockfile(FILE *);
extern void	funlockfile(FILE *);
#line 459
extern	char	*optarg;
extern	int	opterr;
extern	int	optind;
extern	int	optopt;
#line 478
extern int 	getw(FILE *);
extern int      getopt(int, char * const [], const char*);
extern char     *cuserid(char *);
extern int 	putw(int, FILE *);

extern char 	*tempnam(const char*, const char*);
}
extern "C" {
#line 35 "/usr/include/sys/limits.h"
extern "C" {
}
extern "C" {
#line 234 "/usr/include/float.h"
	extern  unsigned   int SINFINITY;
	extern  unsigned   int _DBLINF[2];
	extern  unsigned   int SQNAN;
	extern  unsigned   int DQNAN[2];
	extern  unsigned   int SSNAN;
	extern  unsigned   int DSNAN[2];
#line 265
typedef	unsigned short fprnd_t;
#line 274
fprnd_t fp_read_rnd(void);
fprnd_t fp_swap_rnd(fprnd_t rnd);
}
extern "C" {
#line 447 "/usr/include/sys/limits.h"
}
}
extern "C" {
#line 497 "/usr/include/stdio.h"
extern int fgetpos64(FILE *, fpos64_t *);
extern FILE *fopen64(const char *, const char *);
extern FILE *freopen64(const char *, const char *, FILE *);
extern int fseeko64(FILE *, off64_t, int);
extern int fsetpos64(FILE *, const fpos64_t *);
extern off64_t ftello64(FILE *);
#line 509
extern void setbuffer(FILE *, char *, size_t);
extern void setlinebuf(FILE *);
#line 574
}
}
#line 8 "/usr/vacpp/include/stdio.h"
inline int ferror(FILE * _p)
{
	return ((_p)->_flag & 0040);
}
#line 16
inline void clearerr(FILE * _p)
{
	((void) ((_p)->_flag &= ~(0040 | 0020)));
}
#line 24
inline int feof(FILE * _p) 
{
	return ((_p)->_flag & 0020); 
}
extern "C" {
}
extern "C" {
#line 44 "/usr/include/time.h"
extern "C" {
#line 92
struct	tm {	 
	int	tm_sec;
	int	tm_min;
	int	tm_hour;
	int	tm_mday;
	int	tm_mon;
	int	tm_year;
	int	tm_wday;
	int	tm_yday;
	int	tm_isdst;
};
#line 134
    extern size_t 	strftime(char *restrict, size_t, const char *restrict, const struct tm *restrict);
    extern clock_t 	clock(void);
    extern double 	difftime(time_t, time_t);
    extern time_t 	mktime(struct tm *);

    extern time_t 	time(time_t *);

    extern char 	*asctime(const struct tm *);
    extern char 	*ctime(const time_t *);
    extern struct tm *gmtime(const time_t *);
    extern struct tm *localtime(const time_t *);
#line 154
    extern char		*asctime_r(const struct tm *restrict, char *restrict);
    extern char		*ctime_r(const time_t *, char *);
    extern struct tm	*gmtime_r(const time_t *restrict, struct tm *restrict);
    extern struct tm	*localtime_r(const time_t *restrict, struct tm *restrict);
}
extern "C" {
}
extern "C" {
#line 188
extern char *tzname[];
#line 193
    extern void tzset(void);
#line 199
    extern long timezone;
    extern int daylight;
#line 204
    extern char         *strptime(const char *, const char *, struct tm *);
#line 209
    extern int getdate_err;
#line 213
    extern struct tm *getdate(const char *);
#line 220
struct timespec {
    time_t tv_sec;          
    long   tv_nsec;         
};
#line 226
struct itimerspec {
    struct  timespec it_interval;  
    struct  timespec it_value;     
};
#line 237
extern int clock_getres(clockid_t, struct timespec *);
extern int clock_gettime(clockid_t, struct timespec *);
extern int clock_settime(clockid_t, const struct timespec *);
extern int clock_getcpuclockid(pid_t, clockid_t *);
extern int nanosleep(const struct timespec *, struct timespec *);
#line 245
extern int timer_create(clockid_t, void *restrict, timer_t *restrict);

extern int timer_delete(timer_t);
extern int timer_gettime(timer_t, struct itimerspec *);
extern int timer_getoverrun(timer_t);
extern int timer_settime(timer_t, int, const struct itimerspec *restrict, struct itimerspec *restrict);
#line 254
extern int clock_nanosleep(clockid_t, int, const struct timespec*, struct timespec*);		
}
extern "C" {
#line 33 "/usr/include/stddef.h"
extern "C" {
#line 86
}
}
extern "C" {
#line 270 "/usr/include/time.h"
    extern unsigned char *NLctime(long *);
    extern unsigned char *NLasctime(struct tm *);
    extern char *NLstrtime(char *, size_t, const char *, const struct tm *);
#line 291
    extern char *ctime64(const time64_t *);
    extern struct tm *localtime64(const time64_t *);
    extern struct tm *gmtime64(const time64_t *);
    extern char *asctime64(const struct tm *);
    extern time64_t mktime64(struct tm *);

    extern char *ctime64_r(const time64_t *, char *);
    extern struct tm *localtime64_r(const time64_t *restrict, 
                                    struct tm *restrict);
    extern struct tm *gmtime64_r(const time64_t *restrict, 
                                 struct tm *restrict);
    extern char *asctime64_r(const struct tm *restrict, char *restrict);
#line 308
}
}
extern "C" {
#line 69 "/usr/include/wchar.h"
typedef char *   mbstate_t;      
#line 101
extern int	vfwscanf(FILE * restrict, const wchar_t * restrict, va_list);
extern int	vswscanf(const wchar_t * restrict, const wchar_t * restrict, va_list);
extern int	vwscanf(const wchar_t * restrict, va_list);
extern long double wcstold(const wchar_t * restrict, wchar_t ** restrict);
extern float wcstof(const wchar_t * restrict, wchar_t ** restrict);
#line 119
extern long long int wcstoll(
     const wchar_t * restrict,               
     wchar_t ** restrict,            
     int );                      
extern unsigned long long int wcstoull(
     const wchar_t * restrict,               
     wchar_t ** restrict,            
     int );                      
#line 196
extern wint_t fgetwc(FILE *);
extern wchar_t *fgetws(wchar_t * restrict, int, FILE * restrict);
extern int fputws(const wchar_t * restrict, FILE * restrict);
extern wint_t getwc(FILE *);
extern wint_t getwchar(void);
#line 203
extern int iswalnum(wint_t);
extern int iswalpha(wint_t);
extern int iswcntrl(wint_t);
extern int iswdigit(wint_t);
extern int iswgraph(wint_t);
extern int iswlower(wint_t);
extern int iswprint(wint_t);
extern int iswpunct(wint_t);
extern int iswspace(wint_t);
extern int iswupper(wint_t);
extern int iswxdigit(wint_t);
extern int iswctype (wint_t, wctype_t);
extern int towlower(wint_t);
extern int towupper(wint_t);
#line 220
extern wint_t fputwc(wchar_t, FILE *);
extern wint_t putwc(wchar_t, FILE *);
extern wint_t putwchar(wchar_t);
#line 232
extern wchar_t *wcschr(const wchar_t *,  wchar_t);

extern wint_t ungetwc(wint_t, FILE *);
extern wctype_t wctype(const char*);
extern wchar_t *wcscat(wchar_t * restrict, const wchar_t *restrict);
extern int wcscmp(const wchar_t *, const wchar_t *);
extern int wcscoll(const wchar_t *, const wchar_t *);
extern wchar_t *wcscpy(wchar_t * restrict, const wchar_t * restrict);
extern size_t wcscspn(const wchar_t *, const wchar_t *);

static size_t wcsftime(wchar_t *__wcsftime_wcs, size_t __wcsftime_maxsize,
	 const wchar_t *__wcsftime_format,
	 const struct tm *__wcsftime_timptr)
{
    extern size_t __iso_wcsftime(wchar_t *, size_t, const wchar_t *,
				 const struct tm *);
    return __iso_wcsftime(__wcsftime_wcs, __wcsftime_maxsize, __wcsftime_format,
			  __wcsftime_timptr);
}
#line 260
extern wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
extern wchar_t *wcsrchr(const wchar_t *, wchar_t);

extern size_t wcslen(const wchar_t *);
extern wchar_t *wcsncat(wchar_t * restrict, const wchar_t * restrict, size_t);
extern int wcsncmp(const wchar_t *, const wchar_t *, size_t);
extern wchar_t *wcsncpy(wchar_t * restrict, const wchar_t * restrict, size_t);
extern size_t wcsspn(const wchar_t *, const wchar_t *);
extern double wcstod(const wchar_t * restrict, wchar_t ** restrict);

static wchar_t *wcstok(wchar_t *__wcstok_ws1, const wchar_t *__wcstok_ws2,
		       wchar_t **__wcstok_ptr)
{
    extern wchar_t *__iso_wcstok(wchar_t *, const wchar_t *, wchar_t **);
    return __iso_wcstok(__wcstok_ws1, __wcstok_ws2, __wcstok_ptr);
}
#line 282
extern long wcstol(const wchar_t * restrict, wchar_t ** restrict, int);
extern unsigned long wcstoul(const wchar_t * restrict, wchar_t ** restrict, int);

extern wchar_t *wcswcs(const wchar_t *, const wchar_t *);
extern int wcswidth(const wchar_t *, size_t);
extern int wcwidth(wchar_t);

extern size_t wcsxfrm(wchar_t * restrict, const wchar_t * restrict, size_t);
#line 292
extern wint_t btowc(int);
extern int fwprintf(FILE * restrict, const wchar_t * restrict, ...);
extern int fwscanf(FILE * restrict, const wchar_t * restrict, ...);
extern int fwide(FILE *, int);
extern int mbsinit(const mbstate_t *);
extern size_t mbrlen(const char * restrict, size_t, mbstate_t *restrict);
extern size_t mbrtowc(wchar_t * restrict, const char * restrict, size_t, mbstate_t * restrict);
extern size_t mbsrtowcs(wchar_t * restrict, const char ** restrict, size_t, mbstate_t * restrict);
extern int swprintf(wchar_t * restrict, size_t, const wchar_t * restrict, ...);
extern int swscanf(const wchar_t * restrict, const wchar_t * restrict, ...);

extern int vfwprintf(FILE * restrict, const wchar_t * restrict, va_list);
extern int vwprintf(const wchar_t * restrict, va_list);
extern int vswprintf(wchar_t * restrict, size_t, const wchar_t * restrict, va_list);
#line 319
extern wchar_t *wcsstr(const wchar_t *, const wchar_t *);
extern wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);

extern size_t wcrtomb(char * restrict, wchar_t, mbstate_t *  restrict);
extern size_t wcsrtombs(char * restrict, const wchar_t ** restrict, size_t, mbstate_t * restrict);
extern int wctob(wint_t);
extern wctype_t wctype(const char *);
extern int wmemcmp(const wchar_t *, const wchar_t *, size_t); 
extern wchar_t *wmemcpy(wchar_t * restrict, const wchar_t * restrict, size_t); 
extern wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t); 
extern wchar_t *wmemset(wchar_t *, wchar_t, size_t); 
extern int wprintf(const wchar_t * restrict, ...);
extern int wscanf(const wchar_t * restrict, ...);
#line 356
extern wchar_t *getws(wchar_t *);
extern int putws(const wchar_t *);
extern int wsprintf(wchar_t *, const char *, ...);

extern int vwsprintf(wchar_t *, const char *, va_list);
#line 366
extern int wcscasecmp(const wchar_t *, const wchar_t *);
extern wchar_t *wcsdup(const wchar_t *);
extern int wcsncasecmp(const wchar_t *, const wchar_t *, size_t);
extern size_t wcsnlen(const wchar_t *, size_t);
extern size_t wcsnrtombs(char *, const wchar_t **, size_t, size_t, mbstate_t *);
extern size_t mbsnrtowcs(wchar_t *, const char **, size_t, size_t, mbstate_t *);
extern wchar_t *wcpcpy(wchar_t *, const wchar_t *);
extern wchar_t *wcpncpy(wchar_t *, const wchar_t *, size_t);
#line 377
extern wchar_t *strtows(wchar_t *, char *);
extern char    *wstrtos(char *, wchar_t *);
#line 408
}
}
extern "C" {
#line 71 "/usr/include/curses.h"
        typedef int attr_t;
#line 85
        typedef struct {
             attr_t  a;
             wchar_t c;
             wchar_t z[5];
        } cchar_t;
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 37 "/usr/include/sys/ioctl.h"
extern "C" {
}
extern "C" {
#line 54 "/usr/include/sys/ttychars.h"
struct ttychars {
	char	tc_erase;	 
	char	tc_kill;	 
	char	tc_intrc;	 
	char	tc_quitc;	 
	char	tc_startc;	 
	char	tc_stopc;	 
	char	tc_eofc;	 
	char	tc_brkc;	 
	char	tc_suspc;	 
	char	tc_dsuspc;	 
	char	tc_rprntc;	 
	char	tc_flushc;	 
	char	tc_werasc;	 
	char	tc_lnextc;	 
};
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 66 "/usr/include/sys/ioctl.h"
enum tty_ioctl {
    TXISATTY = ('X'<<8),		 
    TXTTYNAME,				 
    TXGETLD,				 
    TXSETLD,				 
    TXGETCD,				 
    TXADDCD,				 
    TXDELCD,				 
    TXSBAUD,				 
    TXGBAUD,				 
    TXSETIHOG,				 
    TXSETOHOG,				 
    TXGPGRP,				 
    TXSPGRP,				 
    TXSETMASK				 
};
#line 85
union txname {				 
    int tx_which;			 
    char tx_name[32];		 
};
#line 96
struct winsize {
	unsigned short	ws_row;			 
	unsigned short	ws_col;			 
	unsigned short	ws_xpixel;		 
	unsigned short	ws_ypixel;		 
};
#line 105
struct tchars {
	char	t_intrc;	 
	char	t_quitc;	 
	char	t_startc;	 
	char	t_stopc;	 
	char	t_eofc;		 
	char	t_brkc;		 
};
struct ltchars {
	char	t_suspc;	 
	char	t_dsuspc;	 
	char	t_rprntc;	 
	char	t_flushc;	 
	char	t_werasc;	 
	char	t_lnextc;	 
};
#line 126
struct sgttyb {
	char	sg_ispeed;		 
	char	sg_ospeed;		 
	char	sg_erase;		 
	char	sg_kill;		 
	short	sg_flags;		 
};
#line 137
struct ttysize {
	unsigned short	ts_lines;
	unsigned short	ts_cols;
	unsigned short	ts_xxx;
	unsigned short	ts_yyy;
};
#line 482
int stty(int fd, struct sgttyb *sg);
int gtty(int fd, struct sgttyb *sg);
#line 490
}
}
#line 3 "/usr/vacpp/include/sys/ioctl.h"
extern "C" {
int ioctl(int, int ...);
int ioctlx(int, int, void *, long);
}
extern "C" {
}
extern "C" {
#line 62 "/usr/include/sys/ttmap.h"
struct ttrule {
       short   tm_next;		 
       char    tm_pattern [10+1];	 
       char    tm_replace [16+1];	 
};			 
#line 79
struct ttmap {
	struct ttmap	*tm_next;	 
	int		tm_len;		 
	int		tm_count;	 
	unsigned char	tm_flags;	 
	short		tm_num_rules;	 
	short		tm_default;	 
	short		tm_first_wild;	 
	char		tm_mapname [32];      
	short		tm_hash [256];	 
	struct ttrule	tm_rule [1];	 
};
#line 107
struct ttmapinfo {
	struct ttmap	*tm_map;	 
	char		tm_trouble;	 
	char		tm_state;	 
	char		tm_bufindx;	 
	short		tm_rulindx;	 
	char		tm_buffer [10];  
};
#line 125
struct tty_map {
	char		tm_version;	 
	unsigned char	tm_flags;	 
	char		tm_mapname [32];  
	char		*tm_addr;	 
	int		tm_len;		 
};
}
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 57 "/usr/include/termios.h"
typedef unsigned int	tcflag_t;

typedef unsigned char   cc_t;
#line 62
typedef unsigned int	speed_t;
#line 68
struct termios {
	tcflag_t	c_iflag;	 
	tcflag_t	c_oflag;	 
	tcflag_t	c_cflag;	 
	tcflag_t	c_lflag;	 
	cc_t		c_cc[16];	 
};
#line 100
extern int tcgetattr(int, struct termios *);

extern pid_t tcgetsid(int);

extern int tcsetattr(int, int, const struct termios *);
extern int tcsendbreak(int, int);
extern int tcdrain(int);
extern int tcflush(int, int);
extern int tcflow(int, int);
extern speed_t cfgetospeed(const struct termios *);
extern speed_t cfgetispeed(const struct termios *);
extern int cfsetospeed(struct termios *, speed_t);
extern int cfsetispeed(struct termios *, speed_t);
#line 120
extern int 			 

setcsmap(
	const char *path);	 
extern int cfmakeraw(struct termios *);
extern int cfsetspeed(struct termios *, speed_t);
}
extern "C" {
#line 62 "/usr/include/sys/termio.h"
struct termio {
        unsigned short c_iflag;          
        unsigned short c_oflag;          
        unsigned short c_cflag;          
        unsigned short c_lflag;          
        char c_line;                     
        unsigned char c_cc[8];         
};
#line 82
struct  tty_page {
        char          tp_flags;
        unsigned char tp_slen;
};
}
extern "C" {
}
extern "C" {
#line 128 "/usr/include/curses.h"
    typedef struct termios SGTTY;
}
extern "C" {
#line 608 "/usr/include/term.h"
typedef char *charptr;
struct strs {
    charptr
	_back_tab,		 
	_bell,			 
	_carriage_return,	 
	_change_scroll_region,	 
	_clear_all_tabs,	 
	_clear_screen,		 
	_clr_eol,		 
	_clr_eos,		 
	_column_address,	 
	_command_character,	 
	_crsr_address,		 
	_crsr_down,		 
	_crsr_home,		 
	_crsr_invisible,	 
	_crsr_left,		 
	_crsr_mem_address,	 
	_crsr_normal,		 
	_crsr_right,		 
	_crsr_to_ll,		 
	_crsr_up,		 
	_crsr_visible,		 
	_dlt_character,	 
	_dlt_line,		 
	_dis_status_line,	 
	_down_half_line,	 
	_entr_alt_charset_mode,	 
	_entr_blink_mode,	 
	_entr_bold_mode,	 
	_entr_ca_mode,		 
	_entr_delete_mode,	 
	_entr_dim_mode,		 
	_entr_insert_mode,	 
	_entr_secure_mode,	 
	_entr_protected_mode,	 
	_entr_reverse_mode,	 
	_entr_standout_mode,	 
	_entr_underline_mode,	 
	_erase_chars,		 
	_exit_alt_charset_mode,	 
	_exit_attribute_mode,	 
	_exit_ca_mode,		 
	_exit_delete_mode,	 
	_exit_insert_mode,	 
	_exit_standout_mode,	 
	_exit_underline_mode,	 
	_flash_screen,		 
	_form_feed,		 
	_from_status_line,	 
	_init_1string,		 
	_init_2string,		 
	_init_3string,		 
	_init_file,		 
	_ins_character,	 
	_ins_line,		 
	_ins_padding,		 
	_ky_backspace,		 
	_ky_catab,		 
	_ky_clear,		 
	_ky_ctab,		 
	_ky_dc,			 
	_ky_dl,			 
	_ky_down,		 
	_ky_eic,		 
	_ky_eol,		 
	_ky_eos,		 
	_ky_f0,			 
	_ky_f1,			 
	_ky_f10,		 
	_ky_f2,			 
	_ky_f3,			 
	_ky_f4,			 
	_ky_f5,			 
	_ky_f6,			 
	_ky_f7,			 
	_ky_f8,			 
	_ky_f9,			 
	_ky_home,		 
	_ky_ic,			 
	_ky_il,			 
	_ky_left,		 
	_ky_ll,			 
	_ky_npage,		 
	_ky_ppage,		 
	_ky_right,		 
	_ky_sf,			 
	_ky_sr,			 
	_ky_stab,		 
	_ky_up,			 
	_kpad_local,		 
	_kpad_xmit,		 
	_lab_f0,		 
	_lab_f1,		 
	_lab_f10,		 
	_lab_f2,		 
	_lab_f3,		 
	_lab_f4,		 
	_lab_f5,		 
	_lab_f6,		 
	_lab_f7,		 
	_lab_f8;			 
};

struct strs2 {
    charptr
	_lab_f9,		 
	_meta_off,		 
	_meta_on,		 
	_newline,		 
	_pad_char,		 
	_prm_dch,		 
	_prm_delete_line,	 
	_prm_down_cursor,	 
	_prm_ich,		 
	_prm_index,		 
	_prm_insert_line,	 
	_prm_left_cursor,	 
	_prm_right_cursor,	 
	_prm_rindex,		 
	_prm_up_cursor,		 
	_pkey_key,		 
	_pkey_local,		 
	_pkey_xmit,		 
	_print_screen,		 
	_prtr_off,		 
	_prtr_on,		 
	_repeat_char,		 
	_reset_1string,		 
	_reset_2string,		 
	_reset_3string,		 
	_reset_file,		 
	_restore_cursor,	 
	_row_address,		 
	_save_cursor,		 
	_scrll_forward,		 
	_scrll_reverse,		 
	_set_attributes,	 
	_set_tab,		 
	_set_window,		 
	_tab,			 
	_to_status_line,	 
	_underline_char,	 
	_up_half_line,		 
	_init_prog,		 
	_ky_a1,			 
	_ky_a3,			 
	_ky_b2,			 
	_ky_c1,			 
	_ky_c3,			 
	_prtr_non,		 
	_box_chars_1,		 
	_box_chars_2,		 
	_box_attr_1,		 
	_box_attr_2,		 
	_color_bg_0,		 
	_color_bg_1,		 
	_color_bg_2,		 
	_color_bg_3,		 
	_color_bg_4,		 
	_color_bg_5,		 
	_color_bg_6,		 
	_color_bg_7,		 
	_color_fg_0,		 
	_color_fg_1,		 
	_color_fg_2,		 
	_color_fg_3,		 
	_color_fg_4,		 
	_color_fg_5,		 
	_color_fg_6,		 
	_color_fg_7,		 
	_font_0,		 
	_font_1,		 
	_font_2,		 
	_font_3,		 
	_font_4,		 
	_font_5,		 
	_font_6,		 
	_font_7,		 
	_ky_back_tab,		 
	_ky_do,			 
	_ky_command,		 
	_ky_command_pane,	 
	_ky_end,		 
	_ky_help,		 
	_ky_newline,		 
	_ky_next_pane,		 
	_ky_prev_cmd,		 
	_ky_prev_pane,		 
	_ky_quit,		 
	_ky_select_aix,		 
	_ky_scroll_left,	 
	_ky_scroll_right,	 
	_ky_tab,		 
	_ky_smap_in1,		 
	_ky_smap_out1,		 
	_ky_smap_in2,		 
	_ky_smap_out2,		 
	_ky_smap_in3,		 
	_ky_smap_out3,		 
	_ky_smap_in4,		 
	_ky_smap_out4,		 
	_ky_smap_in5,		 
	_ky_smap_out5,		 
	_appl_defined_str,	 
	_ky_smap_in6;		 
};

struct strs3 {
    charptr
	_ky_smap_out6,		 
	_ky_smap_in7,		 
	_ky_smap_out7,		 
	_ky_smap_in8,		 
	_ky_smap_out8,		 
	_ky_smap_in9,		 
	_ky_smap_out9,		 
	_ky_sf1,		 
	_ky_sf2,		 
	_ky_sf3,		 
	_ky_sf4,		 
	_ky_sf5,		 
	_ky_sf6,		 
	_ky_sf7,		 
	_ky_sf8,		 
	_ky_sf9,		 
	_ky_sf10,		 
	_ky_f11,		 
	_ky_f12,		 
	_ky_f13,		 
	_ky_f14,		 
	_ky_f15,		 
	_ky_f16,		 
	_ky_f17,		 
	_ky_f18,		 
	_ky_f19,		 
	_ky_f20,		 
	_ky_f21,		 
	_ky_f22,		 
	_ky_f23,		 
	_ky_f24,		 
	_ky_f25,		 
	_ky_f26,		 
	_ky_f27,		 
	_ky_f28,		 
	_ky_f29,		 
	_ky_f30,		 
	_ky_f31,		 
	_ky_f32,		 
	_ky_f33,		 
	_ky_f34,		 
	_ky_f35,		 
	_ky_f36,		 
	_ky_f37,		 
	_ky_f38,		 
	_ky_f39,		 
	_ky_f40,		 
	_ky_f41,		 
	_ky_f42,		 
	_ky_f43,		 
	_ky_f44,		 
	_ky_f45,		 
	_ky_f46,		 
	_ky_f47,		 
	_ky_f48,		 
	_ky_f49,		 
	_ky_f50,		 
	_ky_f51,		 
	_ky_f52,		 
	_ky_f53,		 
	_ky_f54,		 
	_ky_f55,		 
	_ky_f56,		 
	_ky_f57,		 
	_ky_f58,		 
	_ky_f59,		 
	_ky_f60,		 
	_ky_f61,		 
	_ky_f62,		 
	_ky_f63,		 
	_ky_action,		 
	_entr_topline_mode,	 
	_entr_bottom_mode,	 
	_entr_rvert_mode,	 
	_entr_lvert_mode,	 
	_char_padding,		 
	_acs_chars,		 
	_plab_norm,		 
	_ky_btab,		 
	_entr_xon_mode,		 
	_exit_xon_mode,		 
	_entr_am_mode,		 
	_exit_am_mode,		 
	_xon_character,		 
	_xoff_character,	 
	_ena_acs,		 
	_labl_on,		 
	_labl_off,		 
	_ky_beg,		 
	_ky_cancel,		 
	_ky_close,		 
	_ky_copy,		 
	_ky_create,		 
	_ky_enter,		 
	_ky_exit,		 
	_ky_find,		 
	_ky_mark,		 
	_ky_message,		 
	_ky_move,		 
	_ky_next;		 
};

struct strs4 {
    charptr
	_ky_open,		 
	_ky_options,		 
	_ky_previous,		 
	_ky_print,		 
	_ky_redo,		 
	_ky_reference,		 
	_ky_refresh,		 
	_ky_replace,		 
	_ky_restart,		 
	_ky_resume,		 
	_ky_save,		 
	_ky_suspend,		 
	_ky_undo,		 
	_ky_sbeg,		 
	_ky_scancel,		 
	_ky_scommand,		 
	_ky_scopy,		 
	_ky_screate,		 
	_ky_sdc,		 
	_ky_sdl,		 
	_ky_select,		 
	_ky_send,		 
	_ky_seol,		 
	_ky_sexit,		 
	_ky_sfind,		 
	_ky_shelp,		 
	_ky_shome,		 
	_ky_sic,		 
	_ky_sleft,		 
	_ky_smessage,		 
	_ky_smove,		 
	_ky_snext,		 
	_ky_soptions,		 
	_ky_sprevious,		 
	_ky_sprint,		 
	_ky_sredo,		 
	_ky_sreplace,		 
	_ky_sright,		 
	_ky_srsume,		 
	_ky_ssave,		 
	_ky_ssuspend,		 
	_ky_sundo,		 
	_req_for_input,		 
	_clr_bol,		 
	_clear_margins,		 
	_set_left_margin,	 
	_set_right_margin,	 
	_labl_format,		 
	_set_clock,		 
	_display_clock,		 
	_remove_clock,		 
	_create_window,		 
	_goto_window,		 
	_hangup,		 
	_dial_phone,		 
	_quick_dial,		 
	_tone,			 
	_pulse,			 
	_flash_hook,		 
	_fixed_pause,		 
	_wait_tone,		 
	_user0,			 
	_user1,			 
	_user2,			 
	_user3,			 
	_user4,			 
	_user5,			 
	_user6,			 
	_user7,			 
	_user8,			 
	_user9,			 
	_orig_pair,		 
	_orig_colors,		 
	_initialize_color,	 
	_initialize_pair,	 
	_set_color_pair,	 
	_set_foreground,	 
	_set_background,	 
	_change_char_pitch,	 
	_change_line_pitch,	 
	_change_res_horz,	 
	_change_res_vert,	 
	_define_char,		 
	_entr_doublewide_mode,	 
	_entr_draft_quality,	 
	_entr_italics_mode,	 
	_entr_leftward_mode,	 
	_entr_micro_mode,	 
	_entr_near_letter_quality,	 
	_entr_normal_quality,	 
	_entr_shadow_mode,	 
	_entr_subscript_mode,	 
	_entr_superscript_mode,	 
	_entr_upward_mode,	 
	_exit_doublewide_mode,	 
	_exit_italics_mode,	 
	_exit_leftward_mode,	 
	_exit_micro_mode,	 
	_exit_shadow_mode,	 
	_exit_subscript_mode,	 
	_exit_superscript_mode,	 
	_exit_upward_mode,	 
	_micro_column_address,	 
	_micro_down,		 
	_micro_left,		 
	_micro_right,		 
	_micro_row_address,	 
	_micro_up,		 
	_order_of_pins,		 
	_prm_down_micro,	 
	_prm_left_micro,	 
	_prm_right_micro,	 
	_prm_up_micro,		 
	_select_char_set,	 
	_set_bottom_margin,	 
	_set_bottom_margin_parm, 
	_set_left_margin_parm,	 
	_set_right_margin_parm,	 
	_set_top_margin,	 
	_set_top_margin_parm,	 
	_start_bit_image,	 
	_start_char_set_def,	 
	_stop_bit_image,	 
	_stop_char_set_def,	 
	_subscript_characters,	 
	_superscript_characters, 
	_these_cause_cr,	 
	_zero_motion,		 
	_char_set_names,	 
	_ky_mouse,		 
	_mouse_info,		 
	_req_mouse_pos,		 
	_get_mouse,		 
	_set_a_foreground,	 
	_set_a_background,	 
	_pkey_plab,		 
	_device_type,		 
	_code_set_init,		 
	_set0_des_seq,		 
	_set1_des_seq,		 
	_set2_des_seq,		 
	_set3_des_seq,		 
	_set_lr_margin,		 
	_set_tb_margin,		 
	_bit_image_repeat,	 
	_bit_image_newline,	 
	_bit_image_carriage_return,	 
	_color_names,		 
	_define_bit_image_region,	 
	_end_bit_image_region,	 
	_set_color_band,	 
	_set_page_length,	 
	_display_pc_char,	 
	_entr_pc_charset_mode,	 
	_exit_pc_charset_mode,	 
	_entr_scancode_mode,	 
	_exit_scancode_mode,	 
	_pc_term_options,	 
	_scancode_escape,	 
	_alt_scancode_esc,	 
	_set_pglen_inch,	 
	Sentinel;		 
};

struct _bool_struct {
    char
	_auto_left_margin,	 
	_auto_right_margin,	 
	_no_esc_ctlc,		 
	_ceol_standout_glitch,	 
	_eat_newline_glitch,	 
	_erase_overstrike,	 
	_generic_type,		 
	_hard_copy,		 
	_has_meta_key,		 
	_has_status_line,	 
	_ins_null_glitch,	 
	_mem_above,		 
	_mem_below,		 
	_move_insert_mode,	 
	_move_standout_mode,	 
	_over_strike,		 
	_status_line_esc_ok,	 
	_dest_tabs_magic_smso,	 
	_tilde_glitch,		 
	_transparent_underline,	 
	_xon_xoff,		 
	_needs_xon_xoff,	 
	_prtr_silent,		 
	_hard_cursor,		 
	_non_rev_rmcup,		 
	_no_pad_char,		 
	_non_dest_scroll_region, 
	_can_change,		 
	_back_color_erase,	 
	_hue_lightness_saturation,	 
	_col_addr_glitch,	 
	_cr_cancels_micro_mode,	 
	_has_print_wheel,	 
	_row_addr_glitch,	 
	_semi_auto_right_margin, 
	_cpi_changes_res,	 
	_lpi_changes_res,	 
	Sentinel;		 
};

struct _num_struct {
    short
	_columns,		 
	_init_tabs,		 
	_lines,			 
	_lines_of_memory,	 
	_magic_cookie_glitch,	 
	_padding_baud_rate,	 
	_virtual_terminal,	 
	_width_status_line,	 
	_num_labels,		 
	_labl_height,		 
	_labl_width,		 
	_max_attributes,	 
	_maximum_windows,	 
	_max_colors,		 
	_max_pairs,		 
	_no_color_video,	 
	_buffer_capacity,	 
	_dot_vert_spacing,	 
	_dot_horz_spacing,	 
	_max_micro_address,	 
	_max_micro_jump,	 
	_micro_col_size,	 
	_micro_line_size,	 
	_number_of_pins,	 
	_output_res_char,	 
	_output_res_line,	 
	_output_res_horz_inch,	 
	_output_res_vert_inch,	 
	_print_rate,		 
	_wide_char_size,	 
	_buttons,		 
	_bit_image_entwining,	 
	_bit_image_type,	 
	Sentinel;		 
};

struct _str_struct {
	struct strs strs;
	struct strs2 strs2;
	struct strs3 strs3;
	struct strs4 strs4;
};
#line 1185
struct _Vr2_Astrs {
    charptr
	_s1,  _s2,  _s3,  _s4,  _s5,  _s6,  _s7,  _s8,  _s9,  _s10,
	_s11, _s12, _s13, _s14, _s15, _s16, _s17, _s18, _s19, _s20,
	_s21, _s22, _s23, _s24, _s25, _s26, _s27, _s28, _s29, _s30,
	_s31, _s32, _s33, _s34, _s35, _s36, _s37, _s38, _s39, _s40,
	_s41, _s42, _s43, _s44, _s45, _s46, _s47, _s48, _s49, _s50,
	_s51, _s52, _s53, _s54, _s55, _s56, _s57, _s58, _s59, _s60,
	_s61, _s62, _s63, _s64, _s65, _s66, _s67, _s68, _s69, _s70,
	_s71, _s72, _s73, _s74, _s75, _s76, _s77, _s78, _s79, _s80,
	_s81, _s82, _s83, _s84, _s85, _s86, _s87, _s88, _s89, _s90,
	_s91, _s92, _s93, _s94, _s95, _s96, _s97, _s98, _s99, _s100;
};

struct _Vr2_Bstrs {
    charptr
	_s101, _s102, _s103, _s104, _s105, _s106, _s107, _s108, _s109, _s110,
	_s111, _s112, _s113, _s114, _s115, _s116, _s117, _s118, _s119, _s120,
	_s121, _s122, _s123, _s124, _s125, _s126, _s127, _s128, _s129, _s130,
	_s131, _s132, _s133, _s134, _s135, _s136, _s137, _s138, _s139, _s140,
	_s141, _s142, _s143, _s144, _s145;
};
#line 1209
typedef struct {
	char *_sends;	 
	short _keyval;	 
} _KEY_MAP;

typedef struct {
	short  foreground;    
	short  background;    
	bool   init;          
} _Color_pair;
#line 1221
typedef struct {
	short	r, g, b;
} _Color;
#line 1233
	typedef short	Mbstate_t;   
#line 1237
struct term {

    char
	_b1,  _b2,  _b3,  _b4,  _b5,  _b6,  _b7,  _b8,  _b9,  _b10,
	_b11, _b12, _b13, _b14, _b15, _b16, _b17, _b18, _b19, _b20, _b21;
    short
	_c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8;
	struct _Vr2_Astrs _Vr2_Astrs;
	struct _Vr2_Bstrs _Vr2_Bstrs;

	short Filedes;		 
	SGTTY Ottyb,		 
	      Nttyb;		 
#line 1254
	int newlmode, oldlmode;	 
#line 1257
	struct _bool_struct *_bools;
	struct _num_struct *_nums;
	struct _str_struct *_strs;
	char *_strtab;

	long timeout;		 
#line 1265
	attr_t sgr_mode;		 
	attr_t sgr_faked;		 
	int    _delay;			 
	int    _inputfd;		 
	int    _check_fd;		 
	_KEY_MAP	**_keys,	 
			*internal_keys;	 
	short		_ksz,		 
			_lastkey_ordered, 
			_lastmacro_ordered, 
			_first_macro;
	bool				 
			funckeystarter[0400];	
	bool		_fl_rawmode,	 
			fl_typeahdok,	 
			_cursorstate,	 
			_iwait;		 
	short		_regs[26];	 

	int				 
			_input_queue[32];
	short		_ungotten;	 
	char		_chars_on_queue;  
	cchar_t		*_acsmap;	 
	char		*turn_on_seq[9];
	attr_t		bit_vector;
	char		*cursor_seq[3];
	char		_termname[15];
	char		*turn_off_seq[3];
	attr_t		check_turn_off;
    	_Color_pair	_cur_pair;
    	_Color_pair	*_pairs_tbl;
    	_Color		*_color_tbl;
	Mbstate_t	 shift_state;
};

typedef struct term TERMINAL;
#line 1307
extern TERMINAL			*cur_term;
extern struct _bool_struct	*cur_bools;
extern struct _num_struct	*cur_nums;
extern struct _str_struct	*cur_strs;
#line 1348
extern	short	term_errno;

extern	char	term_parm_err[], *term_err_strings[], *Def_term;

extern char *const boolnames[];
extern char *const boolcodes[];
extern char *const boolfnames[];
extern char *const numnames[];
extern char *const numcodes[];
extern char *const numfnames[];
extern char *const strnames[];
extern char *const strcodes[];
extern char *const strfnames[];
#line 1363
extern	TERMINAL	*setcurterm(TERMINAL *);
#line 1368
extern  char    *tparm(char *, long, long, long, long,  
                  long, long, long, long, long);       
#line 1373
extern  char	*tgoto(const char *, int, int),
		*tgetstr(char *, char **),
		*tigetstr(char *),
		*termname(void);

extern	int	tgetent(char *, const char *), tgetflag(char *), tgetnum(char *),
        	tigetflag(char *), tigetnum(char *),
		tputs(const char *, int, int (*)(int)), putp(const char *);

extern	int	resetterm(void), fixterm(void), saveterm(void),
		restartterm(char *, int, int *), delterm(TERMINAL *);

extern	void	termerr(void), tinputfd(int);
}
extern "C" {
#line 155 "/usr/include/curses.h"
	typedef unsigned int chtype;
#line 163
typedef unsigned short _ochtype;
#line 182
typedef struct _win_st	WINDOW;
typedef struct screen	SCREEN;
typedef struct _Mouse	MOUSE_STATUS;

struct _win_st
{
	short		_cury, _curx;	 
	short		_maxy, _maxx;	 
	short		_begy, _begx;	 
	char		_flags;
	short		_yoffset;	 
	bool		_clear,		 
			_leave,		 
			_immed,		 
			_sync;		 
	WINDOW		*_padwin;	 
	short		*_firstch;	 
	short		*_lastch;	 
	short		_tmarg, _bmarg;	 

	unsigned	_scroll		: 1;	 
	unsigned	_use_idl	: 1;	
	unsigned	_use_keypad	: 1;
	unsigned	_notimeout	: 1;
	unsigned	_use_idc	: 1;	
	attr_t		_attrs;		 
	cchar_t		_bkgd;		 
	int		_delay;		
#line 214
	short		_ndescs;	 
	short		_parx, _pary;	 
	WINDOW		*_parent;	 
	cchar_t		**_y;		 

	char		_waitc[4+1]; 
};
#line 235
struct _Mouse {
	int x, y;
	short button[3];
	int   changes;
};
#line 256
extern	int	LINES, COLS, TABSIZE, COLORS, COLOR_PAIRS;

extern	short	curs_errno;

extern	WINDOW	*stdscr, *curscr;

extern  MOUSE_STATUS	Mouse_status;

extern	char	ttytype[];

extern char	curs_parm_err[],
		*curs_err_strings[];

extern	cchar_t	*wacs_map;
#line 298
extern	WINDOW	*m_initscr(void);

extern	SCREEN	*m_newterm(char *, FILE *, FILE *);

extern	int	m_addch(int), m_addstr(char *), m_clear(void), m_erase(void),
		m_move(int, int), m_refresh(void);
#line 319
extern	SCREEN	*newscreen(char *, int, int, int, FILE *, FILE *),
		*setcurscreen(SCREEN *);

extern	WINDOW	*initscr32(void),
		*newwin(int, int, int, int),
		*newpad(int, int),
		*derwin(WINDOW *, int, int, int, int),
		*dupwin(WINDOW *),
		*getwin(FILE *);

extern	int	wgetch(WINDOW *);  

extern  int     chgat(int, attr_t, short, const void *),
                mvchgat(int, int, int, attr_t, short, const void *),
                mvwchgat(WINDOW *, int, int, int, attr_t, short, const void *),
                wchgat(WINDOW *, int, attr_t, short, const void *); 

extern	char	*longname(void),	 
		*termname(void),	 
		*keyname(int), 	 
		*key_name(wchar_t), 
		*slk_label(int),
		erasechar(void),
		killchar(void),
		*unctrl(chtype);

extern  wchar_t *wunctrl(cchar_t *);

extern  int     erasewchar(wchar_t *), killwchar(wchar_t *);

extern  chtype	termattrs(void);

extern  attr_t	term_attrs(void);

extern  int     vid32puts(chtype, int (*)(int)), vid32attr(chtype),
                vid_puts(attr_t, short, void *, int (*)(int)),
                vid_attr(attr_t, short, void *);

extern	void	vidupdate(chtype, chtype, int (*)(int)),
		wsyncup(WINDOW *), wsyncdown(WINDOW *),
		delscreen(SCREEN *), curserr(void),
		_setqiflush(int),
		wcursyncup(WINDOW *);

extern	int	cbreak(void), nocbreak(void),
		reset_prog_mode(void), reset_shell_mode(void),
		def_prog_mode(void), _setecho(int), _setnonl(int),
		def_shell_mode(void), raw(void),
		savetty(void), traceon(void), _meta(int),
		traceoff(void), noraw(void), flushinp(void),
		_getsyx(int *, int *),
		_ring(int), resetty(void),
		ripoffline(int, int (*)(WINDOW *, int)),
		setsyx(int, int), slk_refresh(void),
		slk_restore(void),
		wstandend(WINDOW *), wstandout(WINDOW *),
		w32attroff(WINDOW *, int), w32attron(WINDOW *, int),
		w32attrset(WINDOW *, int), 
                wattr_off(WINDOW *, attr_t, void *),
                wattr_on(WINDOW *, attr_t, void *),
	        wattr_set(WINDOW *, attr_t, short, void *),
		wrefresh(WINDOW *);

extern	int	copywin(const WINDOW * , WINDOW *,int,int,int,int,int,int,int),
		curs_set(int), delay_output(int), delwin(WINDOW *),
		doupdate(void), draino(int), endwin(void), 
		baudrate(void), 
		keypad(WINDOW *, bool),
		mvcur(int, int, int, int);

extern	int	mvprintw(int, int, char *, ...), mvscanw(int, int, char *, ...),
		mvwprintw(WINDOW *, int, int, char *, ...),
		mvwscanw(WINDOW *, int, int, char *, ...),
		printw(char *, ...), scanw(char *, ...),
		wprintw(WINDOW *, char *, ...), wscanw(WINDOW *, char *, ...);
#line 400
extern  int	vwprintw(WINDOW *, char *, void *),
        	vw_printw(WINDOW *, char *, void *),
		vwscanw(WINDOW *, char *, void *),
		vw_scanw(WINDOW *, char *, void *);
extern int vsscanf(const char *, const char *, va_list); 
#line 407
extern	int	mvwin(WINDOW *, int, int), mvderwin(WINDOW *, int, int),
		napms(int), newkey(char *, int, int),
		_overlay (WINDOW *, WINDOW *, int),
		p32echochar(WINDOW *, chtype),
		pnoutrefresh(WINDOW *, int, int, int, int, int, int),
		prefresh(WINDOW *, int, int, int, int, int, int);

extern  void	filter(void);

extern  int     wattr_get(WINDOW *, attr_t *, short *, void *);

extern 	int	putwin(WINDOW *, FILE *), wredrawln(WINDOW *, int, int),
		scr_dump(const char *), setupterm(char *, int, int *);

extern	int	slk_attron(const chtype), slk_attroff(const chtype),                             slk_attrset(const chtype),
        	slk_attr_on(const attr_t, void *), 
		slk_attr_off(const attr_t, void *),     
                slk_attr_set(const attr_t, short, void *),
		slk_clear(void), slk_noutrefresh(void),
		slk_color(short),
		slk_set(int, const char *, int),
		slk_wset(int, const wchar_t *, int),
		slk_start(int, int *), slk_touch(void), start_color(void),
		typeahead(int);

extern	bool	can_change_color(void), has_colors(void), has_ic(void),
                has_il(void), isendwin(void);

extern int	w32addch(WINDOW *, const chtype),
		waddchnstr(WINDOW *, const chtype *, int),
		waddnstr(WINDOW *, const char * , int),
		wbkgd(WINDOW *, chtype),
		wborder(WINDOW *, chtype, chtype, chtype, chtype,
				  chtype, chtype, chtype, chtype),
		wclrtobot(WINDOW *), wclrtoeol(WINDOW *),
		wdelch(WINDOW *), w32echochar(WINDOW *, const chtype),
		wgetstr(WINDOW *, char *),
		wgetnstr(WINDOW *, char *, int),
		whline(WINDOW *, chtype, int),
		wvline(WINDOW *, chtype, int),
		winchnstr(WINDOW *, chtype *, int),
		winchstr(WINDOW *, chtype *),
		winnstr(WINDOW *, char *, int),
		w32insch(WINDOW *, chtype),
		winsdelln(WINDOW *, int),
		winsnstr(WINDOW *, const char *, int),
		winstr(WINDOW *, char *),
		wmove(WINDOW *, int, int),
		wnoutrefresh(WINDOW *),
		wredrawln(WINDOW *, int, int),
		wscrl(WINDOW *, int),
		wsetscrreg(WINDOW *, int, int),
		wtouchln(WINDOW *, int, int, int);

extern	int	crmode(void), nocrmode(void), ungetch(int);

extern	int	mouse_set(long int), mouse_on(long int),
		mouse_off(long int), request_mouse_pos(void),
		map_button(unsigned long);

extern	void	wmouse_position (WINDOW *, int *, int *);

extern unsigned long getmouse(void), getbmap(void);

extern	int	PAIR_NUMBER(int); 

extern	int	pair_content(short, short *, short *),
		color_content(short, short *, short *, short *),
		COLOR_PAIR(int),
		init_color(short, short, short, short),
		init_pair(short, short, short),
		idlok(WINDOW *, bool);

extern	void	immedok(WINDOW *, bool);

extern int	unget_wch(const wchar_t),
		waddnwstr(WINDOW *, const wchar_t *, int),
		wgetn_wstr(WINDOW *, wint_t *, int),
		wget_wch(WINDOW *, wint_t *),
		wget_wstr(WINDOW *, wint_t *),
		winnwstr(WINDOW *, wchar_t *, int),
		wins_nwstr(WINDOW *, const wchar_t *, int),
		wins_wch(WINDOW *, const cchar_t *),
		win_wchnstr(WINDOW *, cchar_t *, int),
		winwstr(WINDOW *, wchar_t *);

int add_wch(const cchar_t * );	
int win_wch(WINDOW *, cchar_t *);
int wadd_wch(WINDOW *, const cchar_t * );
int mvadd_wch(int, int, const cchar_t * );
int mvwadd_wch(WINDOW *, int, int, const cchar_t *);
int add_wchnstr(const cchar_t * , int);
int add_wchstr(const cchar_t * );
int wadd_wchnstr(WINDOW *, const cchar_t * , int);
int wadd_wchstr(WINDOW *, const cchar_t * );
int mvadd_wchnstr(int, int, const cchar_t * , int);
int mvadd_wchstr(int, int, const cchar_t * );
int mvwadd_wchnstr(WINDOW *, int, int, const cchar_t * , int);
int mvwadd_wchstr(WINDOW *, int, int, const cchar_t * );
void bkgrndset(const cchar_t *);
int bkgrnd(const cchar_t *);
int getbkgrnd(cchar_t *);
int wbkgrnd(WINDOW *, const cchar_t *);
void wbkgrndset(WINDOW *, const cchar_t *);
int wgetbkgrnd(WINDOW *, cchar_t *);
int border_set(const cchar_t *, const cchar_t *, const cchar_t *,
               const cchar_t *, const cchar_t *, const cchar_t *,
               const cchar_t *, const cchar_t *);
int wborder_set(WINDOW *, const cchar_t *, const cchar_t *,
                const cchar_t *, const cchar_t *, const cchar_t *,
                const cchar_t *, const cchar_t *, const cchar_t *);
int box_set(WINDOW *, const cchar_t *, const cchar_t *);
int getcchar(const cchar_t *, wchar_t *, attr_t *, short *, void *);
int setcchar(cchar_t *, const wchar_t *, const attr_t, short, const void *);
int hline_set(const cchar_t *, int);
int mvhline_set(int, int, const cchar_t *, int);
int mvvline_set(int, int, const cchar_t *, int);
int mvwhline_set(WINDOW *, int, int, const cchar_t *, int);
int mvwvline_set(WINDOW *, int, int, const cchar_t *, int);
int whline_set(WINDOW *, const cchar_t *, int);
int vline_set(const cchar_t *, int);
int wvline_set(WINDOW *, const cchar_t *, int);
int pecho_wchar(WINDOW *, const cchar_t *);
int echo_wchar(const cchar_t *);
int wecho_wchar(WINDOW *, const cchar_t *);
int wget_wch(WINDOW *, wint_t *);
int wget_wstr(WINDOW *, wint_t *);
int wgetn_wstr(WINDOW *, wint_t *, int);
int wins_wch(WINDOW *, const cchar_t *);
#line 711
extern	int	getcury(WINDOW *), getcurx(WINDOW *),
		getbegy(WINDOW *), getbegx(WINDOW *),
		getmaxy(WINDOW *), getmaxx(WINDOW *),
		getpary(WINDOW *), getparx(WINDOW *);

extern chtype	getbkgd(WINDOW *), getattrs(WINDOW *);
}
extern "C" {
#line 48 "/usr/include/unctrl.h"
extern char	*_unctrl[];
}
extern "C" {
#line 1205 "/usr/include/curses.h"
extern	void	wbkgdset(WINDOW *, chtype),
		idcok(WINDOW *, bool),
		wtimeout(WINDOW *, int), use_env(bool);

extern	int	syncok(WINDOW *, bool),
		notimeout(WINDOW *, bool),
		clearok(WINDOW *, bool),
		leaveok(WINDOW *, bool),
		scrollok(WINDOW *, bool),
		nodelay(WINDOW *, bool),
		touchwin(WINDOW *), redrawwin(WINDOW *),
		winchstr(WINDOW *, chtype *), winstr(WINDOW *, char *),
		untouchwin(WINDOW *);

extern  bool    is_linetouched(WINDOW *, int), is_wintouched(WINDOW *);

extern  chtype  winch(WINDOW *);

extern	WINDOW	*subwin(WINDOW *, int, int, int, int);
#line 1282
extern	int	overlay(const WINDOW *, WINDOW *),                                               overwrite(const WINDOW *, WINDOW *),
		wdeleteln(WINDOW *), winsertln(WINDOW *),
		wstandend(WINDOW *), wstandout(WINDOW *),
		beep(void), flash(void), scroll(WINDOW *), slk_init(int),
		scr_init(const char *), scr_restore(const char *),                                 scr_set(const char *),
		box32(WINDOW *, chtype, chtype), touchline(WINDOW *, int, int),
		waddstr(WINDOW *, const char *), werase(WINDOW *),
		wclear(WINDOW *), intrflush(WINDOW *, bool),
		meta(WINDOW *, bool), setterm(char *), gettmode(void),
		halfdelay(int), echo(void), noecho(void), nl(void), nonl(void);

extern	WINDOW *subpad(WINDOW *, int, int, int, int);

extern  SCREEN  *newterm32(char *, FILE *, FILE *);
}
#line 20 "/usr/vacpp/include/stdlib.h"
# pragma info(none)
#line 36
      inline int abs (int );
#line 40
      inline long labs (long );
#line 43
      inline long long llabs(long long);
#line 46
      inline void imul_dbl(long ,long ,long *);
      inline void umul_dbl(unsigned long ,unsigned long ,
                    unsigned long *);
extern "C" {
#line 44 "/usr/include/stdlib.h"
extern "C" {
#line 79
typedef struct div_t  {	         
	int quot;                
	int rem;                 
} div_t;

typedef struct ldiv_t  {	 
	long int quot;           
	long int rem;            
} ldiv_t;
#line 94
extern size_t __getmbcurmax (void);
extern int __getmaxdispwidth (void);
#line 105
        extern double   strtod(const char * restrict, char ** restrict);        extern long int strtol(const char * restrict, char ** restrict,
int);
        extern unsigned long int strtoul(const char * restrict, char ** restrict, int);
#line 118
	extern void     	_Exit(int);
	extern float    	____strtof(const char * restrict, char ** restrict);
#line 127
typedef struct lldiv_t {
     long long int quot;  
     long long int rem ;  
} lldiv_t;
#line 140
extern long long int    atoll(const char *);  
extern long long int llabs( long long int );
extern lldiv_t lldiv( long long int, long long int ); 

extern long long int strtoll(
     const char * restrict,  
     char ** restrict,       
     int );                      
extern unsigned long long int strtoull(
     const char * restrict,  
     char ** restrict,       
     int );                      
#line 161
static long double 
strtold(const char * restrict __a, char ** restrict __b) {
	return ((long double)strtod (__a, __b));
}
#line 180
	extern int	 	mblen(const char *, size_t);
	extern size_t 	mbstowcs(wchar_t * restrict, const char * restrict, size_t);
	extern int		mbtowc(wchar_t * restrict, const char * restrict, size_t);
	extern size_t	wcstombs(char * restrict, const wchar_t * restrict, size_t);
	extern int		wctomb(char *, const wchar_t);
#line 236
	extern double 	atof(const char *);
	extern int 	atoi(const char *);
	extern long int atol(const char *);
	extern int 	rand(void);
	extern void	srand(unsigned int);
	extern void 	*calloc(size_t, size_t);
	extern void	free(void *);
	extern void	*malloc(size_t);
	extern void 	*realloc(void *, size_t);
	extern void	abort(void);
	extern int	atexit(void (*)(void));
	extern void	exit(int);
	extern char	*getenv(const char *);
	extern int 	system(const char *);
	extern void 	*bsearch(const void *, const void *, size_t, size_t, int(*)(const void *,const void *));
	extern void 	qsort(void *, size_t, size_t, int(*)(const void *,const void *));
#line 262
	extern int 	abs(int);
	extern struct div_t	div(int, int);
	extern long int	labs(long int);
	extern struct ldiv_t 	ldiv(long int, long int);
#line 286
extern int posix_memalign(void **,size_t,size_t);
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 48 "/usr/include/sys/wait.h"
extern "C" {
}
extern "C" {
#line 54 "/usr/include/sys/resource.h"
extern "C" {
}
#line 4 "/usr/vacpp/include/sys/time.h"
struct timestruc_t;
extern "C" {
#line 50 "/usr/include/sys/time.h"
extern "C" {
#line 90
struct timeval {
	time_t		tv_sec;			 

	suseconds_t	tv_usec;		 
#line 97
};
#line 102
struct timeval32 {
    int32_t tv_sec;      
    int32_t tv_usec; 
};
#line 112
struct timeval64 {
    int64_t tv_sec;	 
    int32_t tv_usec;
#line 118
};
#line 125
struct timezone {
	int		tz_minuteswest;	 
	int		tz_dsttime;	 
};
#line 142
struct	itimerval {
	struct		timeval it_interval; 	 
	struct		timeval it_value; 	 
};
#line 156
extern int getitimer(int, struct itimerval *);
extern int setitimer(int, const struct itimerval *restrict, struct itimerval *restrict);
extern int gettimeofday(struct timeval *restrict, void *restrict);

extern int settimeofday(struct timeval *, struct timezone *);

extern int utimes(const char *, const struct timeval *);
#line 180
typedef struct 

fd_set

{
        long fds_bits[(65534/(sizeof(long) * 8)+1)];   
} fd_set;
#line 200
extern int pselect(int, void *restrict, void *restrict, void *restrict, const struct timespec *restrict, const sigset_t *restrict);
#line 220
extern int __fd_select(int, fd_set *restrict, fd_set *restrict, 
			fd_set *restrict, struct timeval *restrict);
static int select(int __fds, 
		fd_set *restrict __readlist,
		fd_set *restrict __writelist,
		fd_set *restrict __exceptlist,
		struct timeval *restrict __timeout)  
		{
			return __fd_select(__fds, __readlist, __writelist,
						__exceptlist, __timeout);
		}
#line 256
extern void     *memset(void *, int, size_t);
#line 358
struct timestruc_t {
        time_t		tv_sec;          
        suseconds_t	tv_nsec;         
};
#line 367
struct timestruc32_t {
    int32_t     tv_sec;          
    int32_t     tv_nsec;         
};
#line 375
struct timestruc64_t {
    int64_t     tv_sec;          
    int32_t     tv_nsec;         
};
#line 390
struct itimerstruc_t {
        struct  timestruc_t it_interval;  
        struct  timestruc_t it_value;     
};
#line 399
struct itimerstruc32_t {
    struct  timestruc32_t it_interval;  
    struct  timestruc32_t it_value;     
};
#line 407
struct itimerstruc64_t {
    struct  timestruc64_t it_interval;  
    struct  timestruc64_t it_value;     
};
#line 422
typedef struct timebasestruct {
	int		flag;     
	unsigned int	tb_high;  
	unsigned int	tb_low;	  
	} timebasestruct_t;	

int read_real_time(timebasestruct_t *, size_t);
int read_wall_time(timebasestruct_t *, size_t);
int time_base_to_time(timebasestruct_t *, size_t);
#line 571
}
}
#line 8 "/usr/vacpp/include/sys/time.h"
extern "C" {

int gettimeofday(struct timeval*, void*);
#line 14
int settimeofday(struct timeval*, struct timezone*);
int usleep (unsigned int);
struct itimerval;
int setitimer (int, const itimerval*, itimerval*);
int getitimer (int, itimerval*);
int nsleep (timestruc_t*, timestruc_t*);
}
extern "C" {
#line 102 "/usr/include/sys/resource.h"
typedef unsigned long 	rlim_t;	
struct rlimit {
	rlim_t		rlim_cur;	 
	rlim_t		rlim_max;	 
};
#line 112
typedef unsigned long long rlim64_t;
struct rlimit64 {
	rlim64_t	rlim_cur;	 
	rlim64_t	rlim_max;	 
};
#line 156
struct	rusage
{
	struct timeval 	ru_utime;	 
	struct timeval 	ru_stime;	 
	long		ru_maxrss;
	long		ru_ixrss;	 
	long		ru_idrss;	 
	long		ru_isrss;	 
	long		ru_minflt;	 
	long		ru_majflt;	 
	long		ru_nswap;	 
	long		ru_inblock;	 
	long		ru_oublock;	 
	long		ru_msgsnd;	 
	long		ru_msgrcv;	 
	long		ru_nsignals;	 
	long		ru_nvcsw;	 
	long		ru_nivcsw;	 

};
#line 184
struct	rusage64
{

	struct timeval32 ru_utime;	 
	struct timeval32 ru_stime;	 
#line 193
	long long	ru_maxrss;
	long long	ru_ixrss;	 
	long long	ru_idrss;	 
	long long	ru_isrss;	 
	long long	ru_minflt;	 
	long long	ru_majflt;	 
	long long	ru_nswap;	 
	long long	ru_inblock;	 
	long long	ru_oublock;	 
	long long	ru_msgsnd;	 
	long long	ru_msgrcv;	 
	long long	ru_nsignals;	 
	long long	ru_nvcsw;	 
	long long	ru_nivcsw;	 
};
#line 213
struct	trusage64
{
	struct timeval64 ru_utime;	 
	struct timeval64 ru_stime;	 
	longlong_t	 ru_maxrss;
	longlong_t	 ru_ixrss;	 
	longlong_t	 ru_idrss;	 
	longlong_t	 ru_isrss;	 
	longlong_t	 ru_minflt;	 
	longlong_t	 ru_majflt;	 
	longlong_t	 ru_nswap;	 
	longlong_t	 ru_inblock;	 
	longlong_t	 ru_oublock;	 
	longlong_t	 ru_msgsnd;	 
	longlong_t	 ru_msgrcv;	 
	longlong_t	 ru_nsignals;	 
	longlong_t	 ru_nvcsw;	 
	longlong_t	 ru_nivcsw;	 
};
#line 237
struct trusage32
{
        struct timeval32 ru_utime;       
        struct timeval32 ru_stime;       
        signed int      ru_maxrss;
        signed int      ru_ixrss;        
        signed int      ru_idrss;        
        signed int      ru_isrss;        
        signed int      ru_minflt;       
        signed int      ru_majflt;       
        signed int      ru_nswap;        
        signed int      ru_inblock;      
        signed int      ru_oublock;      
        signed int      ru_msgsnd;       
        signed int      ru_msgrcv;       
        signed int      ru_nsignals;     
        signed int      ru_nvcsw;        
        signed int      ru_nivcsw;       
};
#line 324
extern int getpriority(int, id_t);
extern int setpriority(int, id_t, int);
extern int getrlimit(int, struct rlimit *);
extern int setrlimit(int, const struct rlimit *);
#line 330
extern int getrlimit64(int, struct rlimit64 *);
extern int setrlimit64(int, const struct rlimit64 *);
#line 339
extern int getrusage(int, struct rusage *);

extern int getrusage64(int, struct rusage64 *);
#line 366
}
}
extern "C" {
}
extern "C" {
#line 69 "/usr/include/sys/signal.h"
extern "C" {
#line 100
extern void (*signal(int, void (*)(int)))(int);
#line 108
extern int raise(int);
#line 111
typedef volatile int sig_atomic_t;  
#line 237
union sigval
{
#line 242
        void *  sival_ptr;	 

        int     sival_int;	 
};
#line 258
typedef struct {
	int si_signo;		 
	int si_errno;		 
	int si_code;		 
#line 275
	pid_t si_pid;		 
#line 278
	uid_t si_uid;		 
#line 299
	int si_status;		 
	void *si_addr;		 
#line 306
	long si_band;		 
#line 309
        union sigval si_value;	 
#line 314
        int __si_flags;

        int __pad[3];		 
#line 322
} siginfo_t;
#line 330
struct sigaction {
   union {
#line 338
	void	(*__su_handler)(int);	 
#line 342
	void    (*__su_sigaction) (int, siginfo_t *, void *);
#line 346
    } sa_union;
	sigset_t sa_mask;		 
	int	sa_flags;		 
};
}
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 49 "/usr/include/sys/mstsave.h"
struct

mstsave
#line 55
{

	struct mstsave *prev;		 
	label_t		*kjmpbuf;	 
	char		*stackfix;	 
	char		intpri; 	 
	char		backt;		 
	char		rsvd[2];	 
	pid_t		curid;		 

	int		excp_type;	 
	ulong_t		iar;		 
	ulong_t		msr;		 
	ulong_t		cr;		 
	ulong_t		lr;		 
	ulong_t		ctr;		 
	ulong_t		xer;		 
	ulong_t		mq;		 
 	ulong_t		tid;		 
	ulong_t		fpscr;		 
	char		fpeu;		 
	char            fpinfo;          
	uchar		fpscr24_31;	 
	char            pad[1];          
	ulong_t         except[5];	 
	char            pad1[4];         
	ulong_t         o_iar;           
	ulong_t         o_toc;           
	ulong_t         o_arg1;          
	ulong_t		excbranch;	
#line 88
	ulong_t         fpscrx;          
	ulong_t         o_vaddr;         
	ulong_t		cachealign[7];	 
	adspace_t	as;		 
	ulong_t		gpr[32];	 
	double		fpr[32];	 
#line 133
};
#line 245
extern char __pmap_stack[];
}
extern "C" {
#line 42 "/usr/include/sys/context.h"
extern "C" {
#line 63
typedef struct {
#line 68
	void  *ss_sp;		 
	size_t ss_size;		 
#line 72
	int    ss_flags;	 

	int    __pad[4];	 

} stack_t;
#line 84
typedef struct {
        unsigned long long ss_sp;        
        unsigned long long ss_size;      
        int                ss_flags;     
        int                __pad[4];     
} stack64_t;
#line 120
struct __context64 {
	unsigned long long	gpr[32]; 	 
	unsigned long long	msr;		 
	unsigned long long	iar;		 
	unsigned long long	lr;		 
	unsigned long long	ctr;		 
	unsigned int		cr;		 
	unsigned int		xer;		 
	unsigned int		fpscr;		 
	unsigned int		fpscrx;		 
        unsigned long long      except[1];       
	double  		fpr[32];	 
	char			fpeu;		 
	char			fpinfo;		 
	char			fpscr24_31;	 
        char                    pad[1];
        int                     excp_type;       
};
#line 173
struct sigcontext64 {
	int  		   sc_onstack;	 
	sigset64_t	sc_mask;	 
	int 		   sc_uerror;	 
	struct __context64 sc_context;	 
};
#line 253
typedef struct {
	unsigned int __v[4];
} __vmxreg_t;

typedef struct __vmx_context {
	__vmxreg_t 	__vr[32];	 
	unsigned int	__pad1[3];	 
	unsigned int	__vscr;		 
	unsigned int	__vrsave;	 
	unsigned int	__pad2[3];	 	
} __vmx_context_t;
#line 293
typedef struct __extctx {
	unsigned int	__flags;	 
	unsigned int	__rsvd1[3];	 
	union {
	    __vmx_context_t	__vmx;	 
	} __u1;

	unsigned int	__ukeys[2];	 
#line 303
	char	__reserved[(4096 - sizeof(__vmx_context_t) - (7 * sizeof(int)))]; 
#line 306
	int		__extctx_magic;   
#line 310
} __extctx_t;
#line 329
struct	__jmpbuf {
#line 340
	struct	__context64 jmp_context;
#line 346
}; 
#line 355
struct	__sigcontext {

	int		sc_onstack;	 
#line 361
	sigset_t	sc_mask;	 

	int		sc_uerror;	 
	struct __jmpbuf sc_jmpbuf;	 
#line 375
};
#line 384
typedef struct __jmpbuf   mcontext_t;

typedef struct ucontext_t {
	int	    __sc_onstack;  
#line 392
        sigset_t    uc_sigmask;   
#line 395
        int	    __sc_uerror;   
	mcontext_t  uc_mcontext;   
#line 400
	struct ucontext_t *uc_link; 
#line 403
	stack_t     uc_stack;      
#line 407
	__extctx_t  *__extctx;	   
#line 410
	int	__extctx_magic;   
#line 414
	int	    __pad[1];	   
#line 424
} ucontext_t;
#line 427
}
}
extern "C" {
#line 376 "/usr/include/sys/signal.h"
struct	sigstack {
	void	*ss_sp;			 
	int	ss_onstack;		 
};
#line 469
extern int sigmask(int);
}
extern "C" {
}
extern "C" {
#line 654
struct sigevent {
	union sigval		sigev_value;
	int			sigev_signo;
	int			sigev_notify;
#line 662
	void			(*sigev_notify_function)(union sigval);
	pthread_attr_t *	sigev_notify_attributes;

};
#line 687
struct osigevent {
#line 691
	void		*sevt_value;

	signal_t	sevt_signo;
};
#line 1012
struct	sigvec {
#line 1024
   union {
#line 1031
	void    (*sv_handler)(int);	 
#line 1035
        void    (*sv_sigaction) (int, siginfo_t *, void *);
   } sv_union;
	int     sv_mask;         
	int     sv_flags;

};                           
#line 1099
extern int sigblock(int);
extern int siglocalmask(int, const sigset_t *);
extern int sigvec(int, struct sigvec *, struct sigvec *);
#line 1109
extern int siggetmask(void);
extern int sigsetmask(int);
#line 1152
extern int kill(pid_t, int);
extern int sigprocmask(int, const sigset_t *restrict, sigset_t *restrict);
extern int sigsuspend(const sigset_t *);
#line 1160
extern int sigwait(const sigset_t *restrict, int *restrict);
#line 1164
extern int sigaction(int, const struct sigaction *restrict, struct sigaction *restrict);

extern int sigemptyset(sigset_t *);
extern int sigfillset(sigset_t *);
extern int sigaddset(sigset_t *, int);
extern int sigdelset(sigset_t *, int);
extern int sigismember(const sigset_t *, int);
extern int sigpending(sigset_t *);
#line 1174
extern void (*bsd_signal (int, void (*)(int)))(int); 
extern int killpg(pid_t, int);
extern int sighold(int);
extern int sigignore(int);
extern int siginterrupt(int, int);
extern int sigpause(int);
extern int sigrelse(int);
extern void (*sigset(int, void(*)(int)))(int);

extern int sigaltstack(const stack_t *restrict, stack_t *restrict);

extern int sigstack(struct sigstack *, struct sigstack *);
#line 1190
extern int pthread_kill(pthread_t, int);
extern int pthread_sigmask(int, const sigset_t *, sigset_t *);
extern int sigqueue(pid_t, int, const union sigval);
struct timespec;
extern int sigtimedwait(const sigset_t *restrict, siginfo_t *restrict, const struct timespec *restrict);
extern int sigwaitinfo(const sigset_t *restrict, siginfo_t *restrict);
#line 1219
}
}
#line 6 "/usr/vacpp/include/sys/signal.h"
extern "C" {
int sigpause (int);
int sigsetmask (int);
int sigblock (int);
}
extern "C" {
#line 144 "/usr/include/sys/wait.h"
typedef enum {P_ALL, P_PID, P_PGID} idtype_t;
#line 162
extern pid_t wait(int *);

extern pid_t waitpid(pid_t, int *, int);
#line 178
extern int waitid(idtype_t, id_t, siginfo_t *, int);
#line 183
extern pid_t ____wait3(int *, int, struct rusage *);
#line 188
extern pid_t kwaitpid(int *, pid_t, int, struct rusage *, siginfo_t *);

extern pid_t kwaitpid64(int *, pid_t, int, struct rusage64 *, siginfo_t *);
#line 194
extern pid_t wait364(int *, int, struct rusage64 *);
#line 208
extern pid_t wait4(pid_t, int *, int, struct rusage *);
#line 228
}
}
#line 13 "/usr/vacpp/include/sys/wait.h"
extern "C" {
pid_t wait3 (int*, int, struct rusage*);
}
extern "C" {
#line 382 "/usr/include/stdlib.h"
	extern double 		drand48(void);
	extern double 		erand48(unsigned short[]);
	extern long 		jrand48(unsigned short[]);
	extern void 		lcong48(unsigned short int *);
	extern long 		lrand48(void);
	extern long 		mrand48(void);
	extern long 		nrand48(unsigned short[]);
	extern unsigned short 	*seed48(unsigned short[]);
	extern void 		setkey(const char *);
	extern void 		srand48(long);

	extern int 		putenv(char *);
#line 411
	extern	int	rand_r(unsigned int *);
#line 435
	extern long a64l(const char *);
	extern char *ecvt(double, int, int *, int *);
	extern char *fcvt(double, int, int *, int *);
	extern char *gcvt(double, int, char *);
	extern int  getsubopt(char **, char *const *, char **);
	extern int  grantpt(int);
	extern char *initstate(unsigned, char *, size_t);
	extern char *l64a(long);
	extern char *mktemp(char *);
	extern int  mkstemp(char *);
#line 449
	extern int  mkstemp64(char *);

	extern char *ptsname(int);
	extern long random(void);
	extern char *realpath(const char *, char *);
	extern char *setstate(const char *);
	extern void srandom(unsigned);
	extern int  unlockpt(int);
#line 472
	extern int  	posix_openpt	(int);
	extern int      setenv		(const char *, const char *, int);
	extern int      unsetenv	(const char *);
}
extern "C" {
#line 39 "/usr/include/sys/localedef.h"
struct __LC_locale;              
struct _LC_locale_objhdl;        
}
extern "C" {
#line 39 "/usr/include/sys/lc_core.h"
extern "C" {
#line 52
typedef struct {

    unsigned short
	__type_id,
	__magic;
    unsigned long
	__version;

    size_t  __size;

} _LC_object_t;
#line 102
typedef struct {

    _LC_object_t  __hdr;
#line 108
    int __catgets;
    int __catclose;
#line 112
    int __compress;
    int __decompress;
    int __start_compress;
    int __end_compress;
#line 118
    int __init;
    void    *__data;
} _LC_core_car_t;

typedef struct {

    _LC_object_t  __hdr;
#line 127
    int __nl_langinfo;
#line 130
    int __mbtowc;
    int __mbstowcs;
    int __wctomb;
    int __wcstombs;
#line 136
    int __mblen;
#line 139
    int __wcswidth;
    int __wcwidth;
#line 143
    int __mbtopc;
    int __mbstopcs;
    int __pctomb;
    int __pcstombs;
#line 149
    int __csid;
    int __wcsid;
#line 153
    int __init;
    void     *__data;
} _LC_core_charmap_t;
#line 158
typedef struct {

    _LC_object_t  __hdr; 
#line 163
    int __towupper;
    int __towlower;
#line 167
    int __get_wctype;
    int __is_wctype;
#line 171
    int __init;
    void     *__data;
} _LC_core_ctype_t;

typedef struct {

    _LC_object_t  __hdr;
#line 180
    int __strcoll;
    int __strxfrm;
#line 184
    int __wcscoll;
    int __wcsxfrm;
#line 188
    int __fnmatch;
#line 191
    int __regcomp;
    int __regerror;
    int __regexec;
    int __regfree;
#line 197
    int __init;
    void     *__data;
} _LC_core_collate_t;
#line 202
typedef struct {

    _LC_object_t  __hdr;
#line 207
    int __nl_langinfo;
#line 210
    int __strftime;
    int __strptime;
#line 214
    int __wcsftime;
#line 217
    int __init;
    void     *__data;
} _LC_core_time_t;
#line 222
typedef struct {

    _LC_object_t  __hdr;
#line 227
    int __nl_langinfo;
#line 230
    int __strfmon;
#line 233
    int __init;
    void     *__data;
} _LC_core_monetary_t;
#line 238
typedef struct {

    _LC_object_t  __hdr;
#line 243
    int __nl_langinfo;
#line 246
    int __init;
    void     *__data;
} _LC_core_numeric_t;
#line 251
typedef struct {

    _LC_object_t  __hdr;
#line 256
    int __nl_langinfo;
#line 259
    int __rpmatch;
#line 262
    int __init;
    void        *__data;
} _LC_core_resp_t;

typedef struct {

    _LC_object_t __hdr;
#line 271
    int __nl_langinfo;
    int __localeconv;
#line 275
    int __init;
    void         *__data;
} _LC_core_locale_t;
#line 281
}
}
extern "C" {
}
extern "C" {
#line 40 "/usr/include/locale.h"
extern "C" {
#line 51
struct lconv {
   char *decimal_point;		 
   char *thousands_sep;		 
   char *grouping;		 
   char *int_curr_symbol;	 
   char *currency_symbol;	 
   char *mon_decimal_point;	 
   char *mon_thousands_sep;	 
   char *mon_grouping;		 
   char *positive_sign;		 
   char *negative_sign;		 
   char int_frac_digits;	 
   char frac_digits;		 
   char p_cs_precedes;		 
   char p_sep_by_space;		 
   char n_cs_precedes;		 
   char n_sep_by_space;		 
   char p_sign_posn;		 
   char n_sign_posn;		 
#line 72
   char *left_parenthesis;	 
   char *right_parenthesis;	 
#line 80
   char int_p_cs_precedes;       
   char int_p_sep_by_space;      
   char int_n_cs_precedes;       
   char int_n_sep_by_space;      
   char int_p_sign_posn;         
   char int_n_sign_posn;         
#line 94
} ;
#line 110
struct lconv *localeconv(void);
char   *setlocale(int, const char *);
#line 117
typedef struct lconv lconv;
#line 204
}
}
#line 3 "/usr/vacpp/include/locale.h"
typedef void* __xlocale_ptr;
extern "C" {
}
extern "C" {
#line 39 "/usr/include/sys/localedef31.h"
typedef struct  coldesc  {                      
	short     cd_stroff;                    
	short	  cd_repoff;
	short     cd_cval;
	short	  cd_cuniq;
} coldesc_t;
#line 49
typedef struct collation_table {                 
	short    lc_version;                     
	short	 lc_length;			 
	char     *lc_locale_name;		 
	int      len_collate;
	short    *lc_collate;                    
	int      len_coluniq;
	short    *lc_coluniq;                    
	int      len_coldesc;
	coldesc_t *lc_coldesc;                   
	int	 len_strings;			
	wchar_t  *lc_strings;			 
	int	 high_cvalue;			 
} col_t;
#line 70
typedef struct char_classification_table {       
	short      lc_version; 		 
	short	   lc_length;  		 
	short      lc_code_type; 	 
	short      mb_cur_max;   	 
	short      mb_cur_min;   	 
	short      lc_dsp_width;                  
	char       *lc_locale_name; 	 
	int        len_caseconv;   	 
	wchar_t    *lc_caseconv;   	 
	int	   len_ctype;
	unsigned short *lc_ctype;	 	
} ctype_t;
#line 88
typedef	struct lc_monetary_table {
	short  	lc_version;
	short 	lc_length;		 
	char   	*lc_locale_name;	 
	char 	*int_curr_symbol;	 
	char 	*currency_symbol;	 
	char 	*mon_decimal_point;	 
	char 	*mon_thousands_sep;	 
	char 	*mon_grouping;		 
	char 	*positive_sign;		 
	char 	*negative_sign;		 
	char 	int_frac_digits;	 
	char 	frac_digits;		 
	char 	p_cs_precedes;		 
	char 	p_sep_by_space;		 
	char 	n_cs_precedes;		 
	char 	n_sep_by_space;		 
	char 	p_sign_posn;		 
	char 	n_sign_posn;		 
} mon_t;
#line 113
typedef struct numeric_table {                   
	short	lc_version;
	short	lc_length;		 
	char    *lc_locale_name;	 
	char 	*decimal_point;
	char 	*thousands_sep;
	char	*grouping;
} num_t;
#line 126
typedef struct lc_messages_table {
	short	lc_version;
	short	lc_length;		 
	char    *lc_locale_name;	 
	char 	*messages;		 
	char 	*yes_string;		 
	char 	*no_string;		 
} msg_t;
#line 139
typedef struct lc_time_table {
	short   lc_version;
	short	lc_length;	  
	char    *lc_locale_name;  
	char    *t_fmt;          
	char    *d_fmt;          
	char    *nlldate;        
	char    *d_t_fmt;        
	char    *abday;          
	char    *day;            
	char    *abmon;          
	char    *mon;            
#line 155
	char    *misc;           
	char    *tstrs;          
	char    *tunits;         
#line 161
	char	*year;		 
	char    *am_pm;          
} tim_t;
#line 170
typedef struct wchar_mapping_table {             
	short    lc_version;
	short	 lc_length;			 
	char     *lc_identifier;
} map_t;
#line 183
typedef struct localeinfo_table {           
	char     lc_mag0, lc_mag1;       
	short    lc_version;             
	short    lc_code_type;                 
	short	 lc_length;		 
	col_t    *lc_coltbl;		 
	ctype_t  *lc_chrtbl;		 
	mon_t    *lc_montbl;		 
	num_t    *lc_numtbl;		 
	tim_t    *lc_timtbl;		 
	msg_t    *lc_msgtbl;		 
	map_t    *lc_maptbl;		 
} loc_t;
}
extern "C" {
#line 66 "/usr/include/sys/localedef.h"
typedef struct {

    _LC_core_charmap_t core;

    char     *cm_csname;	 

    size_t   cm_mb_cur_max;      
    size_t   cm_mb_cur_min;	 

    unsigned char
	     cm_max_disp_width;  
#line 79
    unsigned 
	char *cm_cstab;		 

    struct __LC_locale 		 
             *loc_rec;

    void     *__meth_ptr;	 
    void     *__data_ptr;	 

} _LC_charmap_t;

typedef struct _LC_charmap_objhdl _LC_charmap_objhdl_t;

struct _LC_charmap_objhdl {
	_LC_charmap_t *obj;
#line 96
	void *(**meth)();
#line 99
struct _LC_locale_objhdl *loc_hdl;	 
#line 102
};
#line 110
typedef	struct {

    _LC_core_monetary_t   core;

    char *int_curr_symbol;	    
    char *currency_symbol;	    
    char *mon_decimal_point;	    
    char *mon_thousands_sep;	    
    char *mon_grouping;		    
    char *positive_sign;	    
    char *negative_sign;	    
    signed char int_frac_digits;    
    signed char frac_digits;	    
    signed char p_cs_precedes;	    
    signed char p_sep_by_space;	    
    signed char n_cs_precedes;	    
    signed char n_sep_by_space;	    
    signed char p_sign_posn;	    
    signed char n_sign_posn;	    
    char *debit_sign;		    
    char *credit_sign;		    
    char *left_parenthesis;	    
    char *right_parenthesis;	    

    struct __LC_locale 		    
             *loc_rec;		    

    void     *__meth_ptr;	    
    void     *__data_ptr;	    
#line 141
    signed char int_p_cs_precedes;  
    signed char int_p_sep_by_space; 
    signed char int_n_cs_precedes;  
    signed char int_n_sep_by_space; 
    signed char int_p_sign_posn;    
    signed char int_n_sign_posn;    
#line 156
} _LC_monetary_t;

typedef struct _LC_monetary_objhdl _LC_monetary_objhdl_t;
struct _LC_monetary_objhdl {
	_LC_monetary_t *obj;
#line 163
	void *(**meth)();
#line 166
struct _LC_locale_objhdl *loc_hdl;	 
#line 169
};
#line 176
typedef struct {

    _LC_core_numeric_t core;

    char     *decimal_point;
    char     *thousands_sep;
    char     *grouping;

    struct __LC_locale 		    
             *loc_rec;		    

    void     *__meth_ptr;	    
    void     *__data_ptr;	    

} _LC_numeric_t;

typedef struct _LC_numeric_objhdl _LC_numeric_objhdl_t;
struct _LC_numeric_objhdl {
	_LC_numeric_t *obj;
#line 197
	void *(**meth)();
#line 200
struct _LC_locale_objhdl *loc_hdl;	 
#line 203
};
#line 211
typedef struct  {

    _LC_core_resp_t core;

    char     *yesexpr;	      
    char     *noexpr;	      
    char     *yesstr;	      
    char     *nostr;	      

    struct __LC_locale	      
             *loc_rec;	      

    void     *__meth_ptr;     
    void     *__data_ptr;     

} _LC_resp_t;

typedef struct _LC_resp_objhdl _LC_resp_objhdl_t;
struct _LC_resp_objhdl {
	_LC_resp_t *obj;
#line 233
	void *(**meth)();
#line 236
struct _LC_locale_objhdl *loc_hdl;	 
#line 239
};
#line 247
typedef struct {

    _LC_core_time_t core;

    char *d_fmt;  
    char *t_fmt;  
    char *d_t_fmt;
    char *t_fmt_ampm;
    char *abday[7];  
    char *day[7];    
    char *abmon[12];  
    char *mon[12];    
    char *am_pm[2];
    char *era;
    char *era_year;
    char *era_d_fmt;
    char *alt_digits;
    char *era_d_t_fmt;
    char *era_t_fmt;

    struct __LC_locale	      
             *loc_rec;	      

    void     *__meth_ptr;     
    void     *__data_ptr;     

} _LC_time_t;

typedef struct _LC_time_objhdl _LC_time_objhdl_t;
struct _LC_time_objhdl {
	_LC_time_t *obj;
#line 280
	void *(**meth)();
#line 283
struct _LC_locale_objhdl *loc_hdl;	 
#line 286
};
#line 293
typedef struct {
    unsigned
	short  n[4+1];
} _LC_weight_t;    
#line 303
typedef struct {

    char         *ce_sym;	 
    _LC_weight_t ce_wgt;	 

} _LC_collel_t;
#line 315
typedef struct {
    _LC_weight_t   ct_wgt;     
#line 319
    _LC_collel_t   *ct_collel; 

} _LC_coltbl_t;
#line 334
typedef struct {
    char *tgt_wgt_str[4+1];
#line 338
} _LC_subs_t;
#line 346
typedef struct {

    _LC_core_collate_t core;

    unsigned			             
	char    co_nord;	             

    _LC_weight_t co_sort;	             
#line 356
    wchar_t     co_wc_min;		     
    wchar_t     co_wc_max;		     

    wchar_t     co_col_min;		     
    wchar_t     co_col_max;		     

    _LC_coltbl_t *co_coltbl;		     

    unsigned
	char    co_nsubs;		     
    _LC_subs_t  *co_subs;		     

    unsigned
	short	co_special;		     
#line 374
    struct __LC_locale	                     
                *loc_rec;	             

    void        *__meth_ptr;                 
    void        *__data_ptr;                 

} _LC_collate_t;

typedef struct _LC_collate_objhdl _LC_collate_objhdl_t;
struct _LC_collate_objhdl {
	_LC_collate_t *obj;
#line 387
	void *(**meth)();
#line 390
struct _LC_locale_objhdl *loc_hdl;	 
#line 393
};
#line 407
typedef struct {

    char    *name;
    unsigned
	int mask;

} _LC_classnm_t;
#line 421
typedef struct {

  _LC_core_ctype_t core;
#line 426
  wchar_t      min_wc;
  wchar_t      max_wc;
#line 430
  wchar_t      *upper;
  wchar_t      *lower;
#line 434
  unsigned
      int      *mask;         
  unsigned
      int      *qmask;	      
  unsigned
      char     *qidx;	      
#line 442
  unsigned
      char     nclasses;
 _LC_classnm_t *classnms;

    struct __LC_locale	      
               *loc_rec;      

    void       *__meth_ptr;   
    void       *__data_ptr;   

} _LC_ctype_t;

typedef struct _LC_ctype_objhdl _LC_ctype_objhdl_t;
struct _LC_ctype_objhdl {
	_LC_ctype_t *obj;
#line 459
	void *(**meth)();
#line 462
struct _LC_locale_objhdl *loc_hdl;	 
#line 465
};
#line 480
typedef struct __LC_locale {

    _LC_core_locale_t core;

    char           *nl_info[63];
    struct lconv   *nl_lconv;

    _LC_charmap_objhdl_t  lc_charmap;
    _LC_collate_objhdl_t  lc_collate;
    _LC_ctype_objhdl_t    lc_ctype;
    _LC_monetary_objhdl_t lc_monetary;
    _LC_numeric_objhdl_t  lc_numeric;
    _LC_resp_objhdl_t     lc_resp;
    _LC_time_objhdl_t     lc_time;

    struct __LC_locale    *loc_rec;        
#line 498
    void                  *__meth_ptr;     
    void                  *__data_ptr;     

    char		  *__nl_yesstr;    
    char		  *__nl_nostr;     
    char		  *__nl_crncystr;  

} _LC_locale_t;

typedef struct _LC_locale_objhdl _LC_locale_objhdl_t;
struct _LC_locale_objhdl {
	_LC_locale_t *obj;
#line 512
	void *(**meth)();
#line 515
struct _LC_locale_objhdl *loc_hdl;	 
#line 518
};
#line 527
typedef struct _LC_object_handle _LC_object_handle_t;
struct _LC_object_handle {
    union {
	_LC_object_t	      lc_object;
	_LC_locale_objhdl_t   lc_locale;
        _LC_charmap_objhdl_t  lc_charmap;
        _LC_collate_objhdl_t  lc_collate;
        _LC_ctype_objhdl_t    lc_ctype;
        _LC_monetary_objhdl_t lc_monetary;
        _LC_numeric_objhdl_t  lc_numeric;
        _LC_resp_objhdl_t     lc_resp;
        _LC_time_objhdl_t     lc_time;
    } obj;
#line 542
    void    *(**meth)();
#line 545
struct _LC_locale_objhdl *loc_hdl;	 
#line 548
};
#line 551
typedef struct {
    _LC_object_t	hdr;		   
    _LC_locale_objhdl_t handle;		   
} _LC_load_object_t;
#line 562
extern _LC_charmap_objhdl_t  *__lc_charmap_ptr;
extern _LC_collate_objhdl_t  *__lc_collate_ptr;
extern _LC_ctype_objhdl_t    *__lc_ctype_ptr;
extern _LC_monetary_objhdl_t *__lc_monetary_ptr;
extern _LC_numeric_objhdl_t  *__lc_numeric_ptr;
extern _LC_resp_objhdl_t     *__lc_resp_ptr;
extern _LC_time_objhdl_t     *__lc_time_ptr;
extern _LC_locale_objhdl_t   *__lc_locale_ptr;
#line 572
extern _LC_charmap_objhdl_t  __lc_charmap;
extern _LC_collate_objhdl_t  __lc_collate;
extern _LC_ctype_objhdl_t    __lc_ctype;
extern _LC_monetary_objhdl_t __lc_monetary;
extern _LC_numeric_objhdl_t  __lc_numeric;
extern _LC_resp_objhdl_t     __lc_resp;
extern _LC_time_objhdl_t     __lc_time;
extern _LC_locale_objhdl_t   __lc_locale;
}
extern "C" {
#line 566 "/usr/include/stdlib.h"
extern char *optarg;
extern int optind;
extern int opterr;
#line 583
	extern float    ____atoff(char *);
	extern void     imul_dbl(long, long, long *);
	extern void     umul_dbl(unsigned long, unsigned long, unsigned long *);
	extern int	on_exit(void (*)(int, void *), void *);
	extern int      unatexit(void (*)(void));
#line 612
	extern double	 		wcstod(const wchar_t *, wchar_t **);
	extern long int	 		wcstol(const wchar_t *, wchar_t **, int);
	extern unsigned long int 	wcstoul(const wchar_t *, wchar_t **, int);

	extern int			rpmatch(const char *);
	extern int			clearenv(void);
	extern int			getopt(int, char* const*, const char*);
	extern char			*getpass(const char *);

        extern int  			ttyslot(void);
        extern void 			*valloc(size_t);
#line 661
extern void *vec_malloc(size_t);
extern void *vec_calloc(size_t, size_t);
#line 692
}
}
#line 53 "/usr/vacpp/include/stdlib.h"
      extern "builtin" char *__alloca (size_t);
#line 122
    extern "C" {
      float atoff(char *);
      float strtof(const char *, char**);
    }
#line 130
      extern "builtin" div_t   __div(int, int);
      extern "builtin" ldiv_t   __ldiv(long, long);

        inline div_t div (int __numer, int __denom) { return __div(__numer, __denom); }
        extern "C++" inline ldiv_t div (long __numer, long __denom) { return __ldiv(__numer, __denom); }
        inline ldiv_t ldiv (long __numer, long __denom) { return __ldiv(__numer, __denom); }
#line 141
      extern "builtin" int   __abs(int);
      extern "builtin" long   __labs(long);

      inline int abs (int __n) { return __abs(__n);}
#line 148
      inline long labs (long __n) { return __labs(__n);}
#line 152
      extern "builtin" long long  __llabs(long long);

      inline long long llabs(long long __n) { return __llabs(__n);}
#line 160
      extern "builtin" void __imul_dbl(long,long,long *);
      extern "builtin" void __umul_dbl(unsigned long,unsigned long,unsigned long *);
      inline void imul_dbl(long __a,long __b,long *__c)
        { __imul_dbl(__a,__b,__c); }
      inline void umul_dbl(unsigned long __a,unsigned long __b,
                    unsigned long *__c)
        { __umul_dbl(__a,__b,__c); }
#line 241
# pragma info(restore)
extern "C" {
#line 42 "/usr/include/unistd.h"
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 86 "/usr/include/sys/access.h"
	extern char *acl_get(char *);
	extern char *acl_fget(int);
	extern int   acl_chg(char *, int, int, int);
	extern int   acl_fchg(int, int, int, int);
	extern int   acl_put(char *, char *, int);
	extern int   acl_fput(int, char *, int);
	extern int   acl_set(char *, int, int, int);
	extern int   acl_fset(int, int, int, int);
	extern int   accessx(char *, int, int);
}
extern "C" {
#line 138 "/usr/include/unistd.h"
extern int access(const char *, int);
extern unsigned int alarm(unsigned int);
extern int chdir(const char *);
extern int chown(const char *, uid_t, gid_t);
extern int close(int);
extern char *ctermid(char *);
extern int dup(int);
extern int dup2(int, int);
extern int execl(const char *, const char *, ...);
extern int execv(const char *, char *const []);
extern int execle(const char *, const char *, ...);
extern int execve(const char *, char *const [], char *const []);
extern int execlp(const char *, const char *, ...);
extern int execvp(const char *, char *const []);
extern void _exit(int);
extern pid_t fork(void);
extern long fpathconf(int, int);
extern char *getcwd(char *, size_t);
extern gid_t getegid(void);
extern uid_t geteuid(void);
extern gid_t getgid(void);
extern int getgroups(int, gid_t []);
extern char *getlogin(void);

extern pid_t getpgrp(void);

extern pid_t getpid(void);
extern pid_t getppid(void);
extern uid_t getuid(void);
extern int isatty(int);
extern int link(const char *, const char *);
extern off_t lseek(int, off_t, int);

extern off64_t	lseek64(int, off64_t, int);

extern long pathconf(const char *, int);
extern int pause(void);
extern int pipe(int []);

extern int pthread_atfork(void (*)(void), void (*)(void), void (*)(void));

extern ssize_t read(int, void *, size_t);
extern int rmdir(const char *);
extern int setgid(gid_t);
extern int setpgid(pid_t, pid_t);
extern pid_t setsid(void);
extern int setuid(uid_t);
extern unsigned int sleep(unsigned int);
extern long sysconf(int);
extern pid_t tcgetpgrp(int);
extern int tcsetpgrp(int, pid_t);
extern char *ttyname(int);
extern int unlink(const char *);
extern ssize_t write(int, const void *, size_t);
#line 285
extern  char    *optarg;
extern  int     optind, opterr, optopt;
#line 301
	extern	size_t	confstr(int, char*, size_t);
	extern  char    *crypt(const char *, const char *);
	extern  void    encrypt(char *, int);
	extern  int     fsync(int);
	extern	int	getopt(int, char* const*, const char*);
	extern	int	nice(int);
	extern  void    swab(const void *, void *, ssize_t);
	extern int	fdatasync(int);

	extern  char    *getpass(const char *);
	extern  int     chroot(const char *);
}
extern "C" {
#line 38 "/usr/include/sys/lockf.h"
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 46 "/usr/include/sys/stat.h"
extern "C" {
}
extern "C" {
}
extern "C" {
#line 65
struct	stat 
{
	dev_t	st_dev;		
#line 72
	ino_t	st_ino;		 
#line 77
	mode_t	st_mode;	 

	nlink_t st_nlink;	 
	ushort_t st_flag;	 
#line 87
	uid_t	st_uid;		 
	gid_t	st_gid;		 
#line 91
	dev_t	st_rdev;       	
#line 97
	int	st_ssize;	  	

	time_t	st_atime;	 
	int	st_atime_n;
	time_t	st_mtime;	 
	int	st_mtime_n;
	time_t	st_ctime;	 
	int	st_ctime_n;
	blksize_t st_blksize;	 
	blkcnt_t st_blocks;	
#line 109
	int	st_vfstype;	 
	uint_t	st_vfs;		 
	uint_t	st_type;	 
	uint_t	st_gen;		 
#line 115
	uint_t	st_reserved[9];

	uint_t	st_padto_ll; 
	off_t	st_size;	 

};
#line 177
struct	stat64 
{
	dev_t	st_dev;		
#line 184
	ino_t	st_ino;		 
	mode_t	st_mode;	 
	nlink_t st_nlink;	 
	ushort_t st_flag;	 
	uid_t	st_uid;		 
	gid_t	st_gid;		 
	dev_t	st_rdev;       	
#line 193
	soff_t	st_ssize;	  	
	time_t	st_atime;	 
	int	st_atime_n;
	time_t	st_mtime;	 
	int	st_mtime_n;
	time_t	st_ctime;	 
	int	st_ctime_n;
	blksize_t st_blksize;	 
	blkcnt_t st_blocks;	
#line 204
	int	st_vfstype;	 
	uint_t	st_vfs;		 
	uint_t	st_type;	 
	uint_t	st_gen;		 
	uint_t	st_reserved[10];
#line 212
	off64_t		st_size;  

};
#line 220
struct stat64x
{
	dev64_t		st_dev;		
#line 228
	ino64_t		st_ino;		 
	mode_t		st_mode;	 
	nlink_t		st_nlink;	 
	ushort_t	st_flag;	 
	uid_t		st_uid;		 
	gid_t		st_gid;		 
	dev64_t		st_rdev;       	
#line 242
	off64_t		st_size;	 
#line 245
	time64_t	st_atime;	 
	int32_t		st_atime_n;	 
	int32_t		st_pad1;	 
	time64_t	st_mtime;	 
	int32_t		st_mtime_n;	 
	int32_t		st_pad2;	 
	time64_t	st_ctime;	 
	int32_t		st_ctime_n;	 
	int32_t		st_pad3;	 
	blksize64_t	st_blksize;	 
	blkcnt64_t	st_blocks;	
#line 258
	int32_t		st_vfstype;	 
	uint32_t	st_vfs;		 
	uint32_t	st_type;	 
	uint32_t	st_gen;		 
	uint32_t	st_reserved[11]; 
};					 
#line 271
	extern int	stat64x(const char *restrict, struct stat64x *restrict);
	extern int	fstat64x(int, struct stat64x *restrict);
	extern int	lstat64x(const char *restrict, struct stat64x *restrict);
#line 291
	extern mode_t	umask(mode_t); 
#line 319
	extern int	mkdir(const char *, mode_t); 
	extern int	stat(const char *restrict, struct stat *restrict);
	extern int	fstat(int, struct stat *);

	extern int	stat64(const char *restrict, struct stat64 *restrict);
	extern int	fstat64(int, struct stat64 *);
#line 327
	extern int	chmod(const char *, mode_t);
#line 330
	extern int	fchmod(int, mode_t);
	extern int	lstat(const char *restrict, struct stat *restrict);

	extern int	lstat64(const char *restrict, struct stat64 *restrict);
#line 336
	extern int	mknod(const char *, mode_t, dev_t);
#line 342
	extern int	mkfifo(const char *, mode_t);
#line 383
int statx(char *, struct stat *, int, int);
int fstatx(int, struct stat *, int, int);
#line 389
}
}
extern "C" {
#line 62 "/usr/include/sys/lockf.h"
	extern int lockf (int, int, off_t);

	extern int lockf64 (int, int, off64_t);
#line 72
}
}
extern "C" {
#line 777 "/usr/include/unistd.h"
	extern int		brk(void *);
	extern int              getpagesize(void);

	extern int		__fd_getdtablesize(void);
	static int		getdtablesize()
				{
					return __fd_getdtablesize();
				}
#line 791
        extern void             *sbrk(intptr_t);
#line 796
	extern int		fchdir(int);
	extern int		fchown(int, uid_t, gid_t);
	extern int		ftruncate(int, off_t);

	extern int		ftruncate64(int, off64_t);

	extern int		gethostname(char *, size_t);
	extern long		gethostid(void);
	extern pid_t		getpgid(pid_t);
	extern pid_t		getsid(pid_t);
	extern char		*getwd(char *);
	extern int		lchown(const char *, uid_t, gid_t);
#line 824
	extern int readlink(const char *, char *, size_t);
#line 828
	extern pid_t		setpgrp(void);

	extern int		setregid(gid_t, gid_t);
	extern int		setreuid(uid_t, uid_t);
	extern int		symlink(const char *, const char *);
	extern void		sync(void);
	extern int		truncate(const char *, off_t);

	extern int		truncate64(const char *, off64_t);

	extern useconds_t	ualarm(useconds_t, useconds_t);
	extern int		usleep(useconds_t);
	extern pid_t		vfork(void);

	extern int		getlogin_r(char *, size_t);
	extern int		ttyname_r(int, char *, size_t);
#line 850
	extern ssize_t		pread(int, void *, size_t, off_t);
	extern ssize_t		pwrite(int, const void *, size_t, off_t);

	extern ssize_t		pread64(int, void *, size_t, off64_t);
	extern ssize_t		pwrite64(int, const void *, size_t, off64_t);
#line 864
extern char **environ;
#line 870
	extern pid_t		f_fork(void);
#line 896
	extern char *		cuserid(char *);
	extern int		setegid(gid_t);
	extern int		seteuid(uid_t);
	extern int		setrgid(gid_t);
	extern int		setruid(uid_t);

	extern int		ioctl(int, int, ...);
#line 905
	extern int		ioctlx(int, int, void *, long);
	extern int		ioctl32(int, int, ...);
	extern int		ioctl32x(int, int, unsigned int, unsigned int);

	extern int		setgroups(int, gid_t []);

	extern int	readx(int, char*, unsigned, long);
	extern int	writex(int, char*, unsigned, long);
#line 918
	extern off_t	fclear(int, off_t);
	extern int	fsync_range(int, int, off_t, off_t);

	extern off64_t	fclear64(int, off64_t);
	extern int	fsync_range64(int, int, off64_t, off64_t);

	extern offset_t llseek(int, offset_t, int);
	extern char *	getusershell(void);
	extern void	setusershell(void);
	extern void	endusershell(void);
	extern char *	get_current_dir_name(void);
	extern int	sysfs(int, ...);
	extern int	finfo(const char *, int, void *, int32long64_t);
	extern int	ffinfo(int, int, void *, int32long64_t);
#line 942
}
}
#line 21 "/usr/vacpp/include/unistd.h"
extern "C" {
#line 24
int acct(const char*);			 
int closepl();				 
int mount(const char*, const char*, int); 
int openpl();				 
int rmount(const char *,const char *, const char *, int);

int stime(const long*);			 
void sys3b(int, int ...);		 
int umount(const char*);		 
#line 57
}
#line 20 "/usr/vacpp/include/string.h"
# pragma info(none)
#line 28
      inline char *strcpy(char *, const char *);
      inline int   strcmp(const char *, const char *);

        inline size_t strlen(const char *);
        inline char  *strchr(const char *, int );
        inline char  *strrchr(const char *, int );
        inline char  *strcat(char *, const char *);
        inline void  *memchr(const void *, int , size_t);
        inline void  *memcpy(void *, const void *, size_t);
        inline void  *memmove(void *s1, const void *, size_t );
        inline int    memcmp(const void *, const void *, size_t );
        inline void  *memset(void *, int , size_t );
#line 42
          inline void  *memccpy(void *, const void *, int , size_t);
          inline char  *strncat(char *, const char *, size_t );
          inline int   strncmp(const char *, const char *, size_t );
          inline char  *strncpy(char *, const char *, size_t);
#line 49
          inline char  *index(const char *, int );
          inline char  *rindex(const char *, int );
extern "C" {
#line 48 "/usr/include/string.h"
extern "C" {
#line 95
        extern void     	*memchr(const void *, int, size_t);

	extern void     *memcpy(void * restrict, const void * restrict, size_t);
        extern void     *memset(void *, int, size_t);
        extern size_t   strcspn(const char *, const char *);
        extern size_t   strlen(const char *);
        extern size_t   strspn(const char *, const char *);
#line 138
	extern char		*strchr(const char *, int);
	extern char		*strpbrk(const char *, const char *);
	extern char		*strrchr(const char *, int);
	extern char		*strstr(const char *, const char *);
#line 144
        extern void     *memmove(void *, const void *, size_t);
        extern char     *strcpy(char * restrict, const char * restrict);
        extern char     *strncpy(char * restrict, const char * restrict, size_t);
        extern char     *strcat(char * restrict, const char * restrict);
        extern char     *strncat(char * restrict, const char * restrict, size_t);
        extern int      memcmp(const void *, const void *,size_t);
        extern int      strcmp(const char *, const char *);
        extern int      strncmp(const char *,const char *,size_t);
        extern int      strncollen(const char *, const int );
        extern char     *strtok(char * restrict, const char * restrict);
        extern char     *strerror(int);
        extern int      strcoll(const char *, const char *);
        extern size_t strxfrm(char * restrict, const char * restrict, size_t);
	extern char *strtok_r(char *, const char *, char **);

	    extern int	strerror_r(int, char *, size_t);
#line 171
        extern void     *memccpy(void * restrict, const void * restrict, int, size_t);
#line 180
extern char *strdup(const char *);
#line 237
	extern wchar_t		*wcschr(const wchar_t *, wchar_t);
	extern wchar_t		*wcspbrk(const wchar_t *, const wchar_t *);
	extern wchar_t		*wcsrchr(const wchar_t *, wchar_t);
#line 242
        extern char     *index(const char *, int);
        extern char     *rindex(const char *, int);

	extern void     swab(const void *, void *, ssize_t); 
        extern wchar_t  *wcscat(wchar_t *, const wchar_t *);
        extern int      wcscmp(const wchar_t *, const wchar_t *);
        extern wchar_t  *wcscpy(wchar_t *, const wchar_t *);
        extern size_t   wcscspn(const wchar_t *, const wchar_t *);
        extern size_t   wcslen(const wchar_t *);
        extern wchar_t  *wcsncat(wchar_t *, const wchar_t *, size_t);
        extern int      wcsncmp(const wchar_t *, const wchar_t *, size_t);
        extern wchar_t  *wcsncpy(wchar_t *, const wchar_t *, size_t);
        extern size_t   wcsspn(const wchar_t *, const wchar_t *);
        extern wchar_t  *wcswcs(const wchar_t *, const wchar_t *);
        extern int      wcswidth(const wchar_t *, size_t);
        extern int      wcwidth(wchar_t);
        extern int      wcscoll(const wchar_t *, const wchar_t *);
        extern size_t	wcsxfrm(wchar_t *, const wchar_t *, size_t);
	extern char	*__linux_strerror_r(int, char *, size_t);
	extern char *	strndup(const char *, size_t);
	extern size_t	strnlen(const char *, size_t);
	extern char *	strsep(char **, const char *);
	extern void *	memmem(const void *, size_t, const void *, size_t);
	extern char *	stpcpy(char *, const char *);
	extern char *	stpncpy(char *, const char *, size_t);
	extern char *	strsignal(int);
#line 273
	extern int	strcasecmp(const char *, const char *);
	extern int	strncasecmp(const char *, const char *, size_t);
#line 329
}
}
#line 72 "/usr/vacpp/include/string.h"
      extern "builtin" char *__strcpy(char *, const char *);
      extern "builtin" int   __strcmp(const char *, const char *);

      inline char *strcpy(char *__s1, const char *__s2)
        { return __strcpy (__s1, __s2);}
      inline int   strcmp(const char *__s1, const char *__s2)
        { return __strcmp (__s1, __s2);}
#line 99
        extern "builtin" size_t __strlen(const char *);
        extern "builtin" char *__strchr(const char *, int );
        extern "builtin" char *__strrchr(const char *, int );
        extern "builtin" char  *__strcat(char *, const char *);
        extern "builtin" void  *__memchr(const void *, int , size_t );
        extern "builtin" void  *__memcpy(void *, const void *, size_t );
        extern "builtin" void  *__memmove(void *, const void *, size_t );
        extern "builtin" int __memcmp(const void *, const void *, size_t );
        extern "builtin" void  *__memset(void *, int , size_t );
#line 110
          extern "builtin" void  *__memccpy(void *, const void *, int , size_t );
          extern "builtin" char  *__strncat(char *, const char *, size_t );
          extern "builtin" int  __strncmp(const char *, const char *, size_t );
          extern "builtin" char  *__strncpy(char *, const char *, size_t );
#line 116
        inline size_t strlen(const char *__s)
          { return __strlen (__s); }
        inline char  *strchr(const char *__s, int __c)
          { return __strchr (__s, __c); }
        inline char  *strrchr(const char *__s, int __c)
          { return __strrchr (__s, __c); }
        inline char  *strcat(char *__s1, const char *__s2)
          { return __strcat (__s1, __s2); }
        inline void  *memchr(const void *__s, int __c, size_t __n)
          { return __memchr (__s, __c, __n); }
        inline void  *memcpy(void *__s1, const void *__s2, size_t __n)
          { return __memcpy (__s1, __s2, __n); }
        inline void  *memmove(void *__s1, const void *__s2, size_t __n)
          { return __memmove (__s1, __s2, __n); }
        inline int    memcmp(const void *__s1, const void *__s2, size_t __n)
          { return __memcmp (__s1, __s2, __n); }
        inline void  *memset(void *__s, int __c, size_t __n)
          { return __memset (__s, __c, __n); }
#line 136
        inline void  *memccpy(void *__target, const void *__source, int __c, size_t __n)
          { return __memccpy (__target, __source, __c, __n); }
        inline char  *strncat(char *__s1, const char *__s2, size_t __n)
          { return __strncat (__s1, __s2, __n); }
        inline int   strncmp(const char *__s1, const char *__s2, size_t __n)
          { return __strncmp (__s1, __s2, __n); }
        inline char  *strncpy(char *__s1, const char *__s2, size_t __n)
          { return __strncpy (__s1, __s2, __n); }
#line 150
          inline char  *index(const char *__s, int __c)
            {return __strchr(__s, __c);}
          inline char  *rindex(const char *__s, int __c)
            {return __strrchr(__s, __c);}
#line 202
# pragma info(restore)
#line 13 "/usr/vacpp/include/sys/wait.h"
extern "C" {
pid_t wait3 (int*, int, struct rusage*);
}
#line 13 "/usr/vacpp/include/iostream"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 46
#pragma object_model(compat)
#line 51
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/istream"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 46
#pragma object_model(compat)
#line 51
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/ostream"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 46
#pragma object_model(compat)
#line 20 "/usr/vacpp/include/yvals.h"
  #pragma info(none)

    #pragma report(level, E)

  #pragma info(restore)
#line 100
namespace std {
#line 103
  typedef bool _Bool;
#line 194
  class _Lock;

  class _Lockit
          {        
  public:
          enum _Mux {_Loc, _Mal, _Str, _Nolock = 0xFFFF};
          _Lockit(int);
          ~_Lockit();
  private:
          _Lock *_L;
          };
#line 734
};
#line 737
  #pragma info(none)

    #pragma report(pop)

  #pragma info(restore)
#line 51 "/usr/vacpp/include/ostream"
#pragma namemangling(v5)
#line 13 "/usr/vacpp/include/ios"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 46
#pragma object_model(compat)
#line 51
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/xlocnum"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 46
#pragma object_model(compat)
#line 51
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/cerrno"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 31
#pragma object_model(compat)
#line 35
  #pragma namemangling(v7)
extern "C" {
#line 62 "/usr/include/errno.h"
extern int errno;
#line 70
extern	char	*sys_errlist[];
extern	int	sys_nerr;
}
#line 60 "/usr/vacpp/include/cerrno"
#pragma namemangling()
#pragma object_model(pop)
#line 67
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 13 "/usr/vacpp/include/climits"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 31
#pragma object_model(compat)
#line 35
  #pragma namemangling(v7)
extern "C" {
}
#line 60 "/usr/vacpp/include/climits"
#pragma namemangling()
#pragma object_model(pop)
#line 67
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 13 "/usr/vacpp/include/cstdio"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 39
#pragma object_model(compat)
#line 43
  #pragma namemangling(v7)
#line 68
namespace std {
#line 72
using ::size_t; using ::fpos_t; using ::FILE;
using ::clearerr; using ::fclose; using ::feof;
using ::ferror; using ::fflush; using ::fgetc;
using ::fgetpos; using ::fgets; using ::fopen;
using ::fprintf; using ::fputc; using ::fputs;
using ::fread; using ::freopen; using ::fscanf;
using ::fseek; using ::fsetpos; using ::ftell;
using ::fwrite; using ::gets; using ::perror;
using ::printf; using ::puts; using ::remove;
using ::rename; using ::rewind; using ::scanf;
using ::setbuf; using ::setvbuf; using ::sprintf;
using ::sscanf; using ::tmpfile; using ::tmpnam;
using ::ungetc; using ::vfprintf; using ::vprintf;
using ::vsprintf;
};

#pragma namemangling()
#pragma object_model(pop)
#line 95
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 13 "/usr/vacpp/include/cstdlib"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 39
#pragma object_model(compat)
#line 43
  #pragma namemangling(v7)
#line 71
namespace std {
using ::size_t; using ::div_t; using ::ldiv_t;
using ::abort; using ::abs; using ::atexit;
using ::atof; using ::atoi; using ::atol;
using ::bsearch; using ::calloc; using ::div;
using ::exit; using ::free; using ::getenv;
using ::labs; using ::ldiv; using ::malloc;
using ::mblen; using ::mbstowcs; using ::mbtowc;
using ::qsort; using ::rand; using ::realloc;
using ::srand; using ::strtod; using ::strtol;
using ::strtoul; using ::system;
using ::wcstombs; using ::wctomb;
};

#pragma namemangling()
#pragma object_model(pop)
#line 92
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 13 "/usr/vacpp/include/streambuf"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 46
#pragma object_model(compat)
#line 51
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/xiosbase"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 46
#pragma object_model(compat)
#line 51
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/xlocale"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 46
#pragma object_model(compat)
#line 51
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/cstring"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 39
#pragma object_model(compat)
#line 43
  #pragma namemangling(v7)
#line 68
namespace std {
using ::size_t; using ::memcmp; using ::memcpy;
using ::memmove; using ::memset; using ::strcat;
using ::strcmp; using ::strcoll; using ::strcpy;
using ::strcspn; using ::strerror; using ::strlen;
using ::strncat; using ::strncmp; using ::strncpy;
using ::strspn; using ::strtok; using ::strxfrm;
using ::strchr; using ::strpbrk; using ::strrchr;
using ::strstr; using ::memchr; 
};

#pragma namemangling()
#pragma object_model(pop)
#line 86
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 21 "/usr/vacpp/include/stdexcept"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 32
#pragma object_model(compat)
#line 37
  #pragma namemangling(v7)
#line 5 "/usr/vacpp/include/exception"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 20
#pragma object_model (compat)
#line 30
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/xstddef"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 40
#pragma object_model(compat)
#line 45
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/cstddef"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 39
#pragma object_model(compat)
#line 43
  #pragma namemangling(v7)
#line 68
namespace std {
using ::ptrdiff_t; using ::size_t;
};

#pragma namemangling()
#pragma object_model(pop)
#line 79
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 72 "/usr/vacpp/include/xstddef"
namespace std {
#line 112
enum _Uninitialized {_Noinit};
#line 115
void _Nomemory();
#line 120
extern "C" {
typedef void _Atexit_fun();
}
#line 126
template <class _T>
struct _Is_signed_aux {
        static const bool value = false;
};

template <>
struct _Is_signed_aux<signed char> {
        static const bool value = true;
};

template <>
struct _Is_signed_aux<short> {
        static const bool value = true;
};

template <>
struct _Is_signed_aux<int> {
        static const bool value = true;
};

template <>
struct _Is_signed_aux<long> {
        static const bool value = true;
};
#line 152
template <>
struct _Is_signed_aux<long long> {
        static const bool value = true;
};
#line 158
template <class _T>
struct _Is_unsigned_aux {
        static const bool value = false;
};

template <>
struct _Is_unsigned_aux<unsigned char> {
        static const bool value = true;
};

template <>
struct _Is_unsigned_aux<unsigned short> {
        static const bool value = true;
};

template <>
struct _Is_unsigned_aux<unsigned int> {
        static const bool value = true;
};

template <>
struct _Is_unsigned_aux<unsigned long> {
        static const bool value = true;
};
#line 184
template <>
struct _Is_unsigned_aux<unsigned long long> {
        static const bool value = true;
};
#line 190
template <class _T, class _U>
struct _Is_same_aux {
        static const bool value = false;
};

template <class _T>
struct _Is_same_aux<_T, _T> {
        static const bool value = true;
};

template <class _T>
struct _Is_integral_aux {
        static const bool value =
                _Is_signed_aux<_T>::value ||
                _Is_unsigned_aux<_T>::value ||
                _Is_same_aux<_T, bool>::value ||
                _Is_same_aux<_T, char>::value ||
                _Is_same_aux<_T, wchar_t>::value;
};

template <bool _Cond, class _TrueCase, class _FalseCase>
struct _ConditionalExpression {
        static const std::size_t value = _FalseCase::value;
};

template <class _TrueCase, class _FalseCase>
struct _ConditionalExpression<true, _TrueCase, _FalseCase> {
        static const std::size_t value = _TrueCase::value;
};

};
#line 228
#pragma namemangling()

#pragma object_model(pop)
#line 237
#pragma info(none)

#pragma report(pop)

#pragma info(restore)
#line 54 "/usr/vacpp/include/exception"
namespace std {

class exception;
typedef void (*_Prhand)(const exception&);
extern _Prhand  _Raise_handler;
void _Throw(const exception&);
class exception {
public:
        static _Prhand _Set_raise_handler(_Prhand _Pn)
                {const _Prhand _Po = _Raise_handler;
                _Raise_handler = _Pn;
                return _Po; }
        explicit exception(const char *_S =

	    "unknown" 
#line 74
	    )
                throw ()
                : _Ptr(_S) {}
        exception(const exception& _R) throw ()
                : _Ptr(_R._Ptr) {}
        exception& operator=(const exception& _R) throw ()
                {_Ptr = _R._Ptr;
                return *this; }
        virtual ~exception()
                {}
        virtual const char *what() const throw ()
                {return _Ptr; }
        void _Raise() const
                {if (_Raise_handler != 0)
                        (*_Raise_handler)(*this);
                _Doraise();
                throw (*this); }
protected:
        virtual void _Doraise() const
                {}
        const char *_Ptr;
        };

class bad_exception : public exception {
public:
        bad_exception(const char *_S =

	    "bad exception"
#line 107
	    )
                throw ()
                : exception(_S) {}
        virtual ~bad_exception() throw ()
                {}
protected:
        virtual void _Doraise() const
                {throw (*this); }
        };

typedef void (*terminate_handler)();
typedef void (*unexpected_handler)();

terminate_handler set_terminate(terminate_handler)
        throw ();
unexpected_handler set_unexpected(unexpected_handler)
        throw ();
#line 132
void terminate();
void unexpected();
bool uncaught_exception();
};

#pragma namemangling()
#line 140
#pragma object_model (pop)
#line 147
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 13 "/usr/vacpp/include/xstring"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 24
        extern "C" int __n_pthreads;               
#line 54
#pragma object_model(compat)
#line 59
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/xmemory"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 40
#pragma object_model(compat)
#line 45
  #pragma namemangling(v7)
#line 4 "/usr/vacpp/include/new"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 23
#pragma object_model (compat)
#line 29
  #pragma namemangling(v7)
#line 54
namespace std {

class bad_alloc : public exception {
public:
        bad_alloc(const char *_S = "bad allocation") throw ()
                : exception(_S) {}
        virtual ~bad_alloc() throw ()
                {}
protected:
        virtual void _Doraise() const
                {throw (*this); }
        };

typedef void (*new_handler)();
struct nothrow_t {};
extern nothrow_t nothrow;
#line 80
       new_handler set_new_handler(new_handler) throw ();
#line 93
       bool __set_new_throws_exception(bool) throw ();
};
#line 98
   void operator delete(void *) throw ();
   void *operator new(size_t) throw (std::bad_alloc);
   void *operator new(size_t, const std::nothrow_t&) throw ();
   void *operator new(size_t, void *_P) throw ();
   void operator delete[](void *) throw ();
   void *operator new[](size_t) throw (std::bad_alloc);
   void *operator new[](size_t, const std::nothrow_t&) throw ();
   void *operator new[](size_t, void *_P) throw ();
   void operator delete(void *_P, const std::nothrow_t&) throw ();
inline void operator delete(void *, void *) throw () {}
  void operator delete[](void *_P, const std::nothrow_t&) throw ();
inline void operator delete[](void *, void *) throw () {}
#line 160
#pragma namemangling()
#line 163
#pragma object_model (pop)
#line 170
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 13 "/usr/vacpp/include/xutility"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 40
#pragma object_model(compat)
#line 45
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/utility"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 40
#pragma object_model(compat)
#line 45
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/iosfwd"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 46
#pragma object_model(compat)
#line 51
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/cwchar"
#pragma info(none)

   #pragma info(none)

#pragma info(restore)
#line 39
#pragma object_model(compat)
#line 43
  #pragma namemangling(v7)
#line 74
namespace std {

using ::fgetwc; using ::fgetws; using ::fputwc;
using ::fputws; using ::fwide; using ::fwprintf;
using ::fwscanf; using ::getwc; using ::getwchar;
using ::putwc; using ::putwchar;
using ::swscanf; using ::ungetwc; using ::vfwprintf;
using ::vwprintf; using ::wprintf; using ::wscanf;
#line 84
using ::wcscoll; using ::wcsxfrm;
using ::swprintf; using ::vswprintf;
using ::mbrlen; using ::mbrtowc;
using ::mbsrtowcs; using ::mbsinit; using ::wcrtomb;
using ::wcsrtombs; using ::wcstol; 
using ::btowc; using ::wctob; using ::wcstod; using ::wcstoul;
using ::wcsftime;

using ::mbstate_t; using ::size_t; using ::wint_t;
using ::wcscat;
using ::wcschr; using ::wcscmp;
using ::wcscpy; using ::wcscspn; using ::wcslen;
using ::wcsncat; using ::wcsncmp; using ::wcsncpy;
using ::wcspbrk; using ::wcsrchr; using ::wcsspn;
using ::wcsstr; using ::wcstok;
using ::wmemchr; using ::wmemcmp; using ::wmemcpy;
using ::wmemmove; using ::wmemset; 
using ::tm;
};
#line 105
#pragma namemangling()
#pragma object_model(pop)
#line 112
#pragma info(none)

   #pragma info(restore)

#pragma info(restore)
#line 78 "/usr/vacpp/include/iosfwd"
namespace std {
#line 84
   typedef long streamoff;
#line 87
typedef int streamsize;
extern fpos_t _Fpz;
extern const streamoff _BADOFF;
#line 102
template<class _St>
        class fpos {
        typedef fpos<_St> _Myt;
public:
        fpos(streamoff _O = 0)
                : _Off(_O), _Fpos(_Fpz), _State(_Stz) {}
        fpos(_St _S, fpos_t _F)
                : _Off(0), _Fpos(_F), _State(_S) {}
#line 114
        _St state() const
                {return (_State); }
        void state(_St _S)
                {_State = _S; }
        fpos_t seekpos() const
                {return (_Fpos); }
        operator streamoff() const
                {return (_Off + ((long)(_Fpos))); }
        streamoff operator-(const _Myt& _R) const
                {return ((streamoff)*this - (streamoff)_R); }
        _Myt& operator+=(streamoff _O)
                {_Off += _O;
                return (*this); }
        _Myt& operator-=(streamoff _O)
                {_Off -= _O;
                return (*this); }
        _Myt operator+(streamoff _O) const
                {_Myt _Tmp = *this;
                return (_Tmp += _O); }
        _Myt operator-(streamoff _O) const
                {_Myt _Tmp = *this;
                return (_Tmp -= _O); }
        bool operator==(const _Myt& _R) const
                {return ((streamoff)*this == (streamoff)_R); }
        bool operator!=(const _Myt& _R) const
                {return (!(*this == _R)); }
private:
        static _St _Stz;
        streamoff _Off;
        fpos_t _Fpos;
        _St _State;
        };
#line 154
template<class _St>
        _St fpos<_St>::_Stz;
typedef fpos<mbstate_t> streampos;
typedef streampos wstreampos;

template<class _E>
        struct char_traits {
        typedef _E char_type;
        typedef _E int_type;
        typedef streampos pos_type;
        typedef streamoff off_type;
        typedef mbstate_t state_type;
        static void assign(_E& _X, const _E& _Y)
                {_X = _Y; }
        static bool eq(const _E& _X, const _E& _Y)
                {return (_X == _Y); }
        static bool lt(const _E& _X, const _E& _Y)
                {return (_X < _Y); }
        static int compare(const _E *_U, const _E *_V,
                size_t _N)
                {for (size_t _I = 0; _I < _N; ++_I, ++_U, ++_V)
                        if (!eq(*_U, *_V))
                                return (lt(*_U, *_V) ? -1 : +1);
                return (0); }
        static size_t length(const _E *_U)
                {size_t _N;
                for (_N = 0; !eq(*_U, _E()); ++_U)
                        ++_N;
                return (_N); }
        static _E *copy(_E *_U, const _E *_V, size_t _N)
                {_E *_S = _U;
                for (; 0 < _N; --_N, ++_U, ++_V)
                        assign(*_U, *_V);
                return (_S); }
        static const _E *find(const _E *_U, size_t _N,
                const _E& _C)
                {for (; 0 < _N; --_N, ++_U)
                        if (eq(*_U, _C))
                                return (_U);
                return (0); }
        static _E *move(_E *_U, const _E *_V, size_t _N)
                {_E *_Ans = _U;
                if (_V < _U && _U < _V + _N)
                        for (_U += _N, _V += _N; 0 < _N; --_N)
                                assign(*--_U, *--_V);
                else
                        for (; 0 < _N; --_N, ++_U, ++_V)
                                assign(*_U, *_V);
                return (_Ans); }
        static _E *assign(_E *_U, size_t _N, _E _C)
                {_E *_Ans = _U;
                for (; 0 < _N; --_N, ++_U)
                        assign(*_U, _C);
                return (_Ans); }
        static _E to_char_type(const int_type& _C)
                {return (_C); }
        static int_type to_int_type(const _E& _C)
                {return (_C); }
        static bool eq_int_type(const int_type& _X,
                const int_type& _Y)
                {return (_X == _Y); }
        static int_type eof()
                {return ((int_type)(-1)); }
        static int_type not_eof(const int_type& _C)
                {return (_C != eof() ? _C : !eof()); }
        };

template<> struct char_traits<wchar_t> {
        typedef wchar_t _E;
        typedef _E char_type;    
        typedef wint_t int_type;
        typedef streampos pos_type;
        typedef streamoff off_type;
        typedef mbstate_t state_type;
        static void assign(_E& _X, const _E& _Y)
                {_X = _Y; }
        static bool eq(const _E& _X, const _E& _Y)
                {return (_X == _Y); }
        static bool lt(const _E& _X, const _E& _Y)
                {return (_X < _Y); }
        static int compare(const _E *_U, const _E *_V,
                size_t _N)
                {return (wmemcmp(_U, _V, _N)); }
        static size_t length(const _E *_U)
                {return (wcslen(_U)); }
        static _E *copy(_E *_U, const _E *_V, size_t _N)
                {return (wmemcpy(_U, _V, _N)); }
        static const _E *find(const _E *_U, size_t _N,
                const _E& _C)
                {return ((const _E *)wmemchr(_U, _C, _N)); }
        static _E *move(_E *_U, const _E *_V, size_t _N)
                {return (wmemmove(_U, _V, _N)); }
        static _E *assign(_E *_U, size_t _N, _E _C)
                {return (wmemset(_U, _C, _N)); }
        static _E to_char_type(const int_type& _C)
                {return (_C); }
        static int_type to_int_type(const _E& _C)
                {return (_C); }
        static bool eq_int_type(const int_type& _X,
                const int_type& _Y)
                {return (_X == _Y); }
        static int_type eof()
                {return ((-1)); }
        static int_type not_eof(const int_type& _C)
                {return (_C != eof() ? _C : !eof()); }
        };

template<> struct char_traits<char> {
        typedef char _E;
        typedef _E char_type;
        typedef int int_type;
        typedef streampos pos_type;
        typedef streamoff off_type;
        typedef mbstate_t state_type;
        static void assign(_E& _X, const _E& _Y)
                {_X = _Y; }
        static bool eq(const _E& _X, const _E& _Y)
                {return (_X == _Y); }
        static bool lt(const _E& _X, const _E& _Y)
                {return (_X < _Y); }
        static int compare(const _E *_U, const _E *_V,
                size_t _N)
                {return (memcmp(_U, _V, _N)); }
        static size_t length(const _E *_U)
                {return (strlen(_U)); }
        static _E *copy(_E *_U, const _E *_V, size_t _N)
                {return ((_E *)memcpy(_U, _V, _N)); }
        static const _E *find(const _E *_U, size_t _N,
                const _E& _C)
                {return ((const _E *)memchr(_U, _C, _N)); }
        static _E *move(_E *_U, const _E *_V, size_t _N)
                {return ((_E *)memmove(_U, _V, _N)); }
        static _E *assign(_E *_U, size_t _N, _E _C)
                {return ((_E *)memset(_U, _C, _N)); }
        static _E to_char_type(const int_type& _C)
                {return ((_E)_C); }
        static int_type to_int_type(const _E& _C)
                {return ((unsigned char)_C); }
        static bool eq_int_type(const int_type& _X,
                const int_type& _Y)
                {return (_X == _Y); }
        static int_type eof()
                {return ((-1)); }
        static int_type not_eof(const int_type& _C)
                {return (_C != eof() ? _C : !eof()); }
        };
#line 302
template<class _T>
        class allocator;
#line 307
class ios_base;

template<class _E, class _Tr = char_traits<_E> >
        class basic_ios;
#line 316
template<class _E, class _Tr = char_traits<_E> >
        class istreambuf_iterator;
template<class _E, class _Tr = char_traits<_E> >
        class ostreambuf_iterator;
#line 325
template<class _E, class _Tr = char_traits<_E> >
        class basic_streambuf;
template<class _E, class _Tr = char_traits<_E> >
        class basic_istream;
template<class _E, class _Tr = char_traits<_E> >
        class basic_ostream;
template<class _E, class _Tr = char_traits<_E> >
        class basic_iostream;
template<class _E, class _Tr = char_traits<_E>,
        class _A = allocator<_E> >
        class basic_stringbuf;
template<class _E, class _Tr = char_traits<_E>,
        class _A = allocator<_E> >
        class basic_istringstream;
template<class _E, class _Tr = char_traits<_E>,
        class _A = allocator<_E> >
        class basic_ostringstream;
template<class _E, class _Tr = char_traits<_E>,
        class _A = allocator<_E> >
        class basic_stringstream;
template<class _E, class _Tr = char_traits<_E> >
        class basic_filebuf;
template<class _E, class _Tr = char_traits<_E> >
        class basic_ifstream;
template<class _E, class _Tr = char_traits<_E> >
        class basic_ofstream;
template<class _E, class _Tr = char_traits<_E> >
        class basic_fstream;
#line 355
typedef basic_ios<char, char_traits<char> > ios;
typedef basic_streambuf<char, char_traits<char> > streambuf;
typedef basic_istream<char, char_traits<char> > istream;
typedef basic_ostream<char, char_traits<char> > ostream;
typedef basic_iostream<char, char_traits<char> > iostream;
typedef basic_stringbuf<char, char_traits<char>,
        allocator<char> > stringbuf;
typedef basic_istringstream<char, char_traits<char>,
        allocator<char> > istringstream;
typedef basic_ostringstream<char, char_traits<char>,
        allocator<char> > ostringstream;
typedef basic_stringstream<char, char_traits<char>,
        allocator<char> > stringstream;
typedef basic_filebuf<char, char_traits<char> > filebuf;
typedef basic_ifstream<char, char_traits<char> > ifstream;
typedef basic_ofstream<char, char_traits<char> > ofstream;
typedef basic_fstream<char, char_traits<char> > fstream;
#line 374
typedef basic_ios<wchar_t, char_traits<wchar_t> > wios;
typedef basic_streambuf<wchar_t, char_traits<wchar_t> >
        wstreambuf;
typedef basic_istream<wchar_t, char_traits<wchar_t> > wistream;
typedef basic_ostream<wchar_t, char_traits<wchar_t> > wostream;
typedef basic_iostream<wchar_t, char_traits<wchar_t> > wiostream;
typedef basic_stringbuf<wchar_t, char_traits<wchar_t>,
        allocator<wchar_t> > wstringbuf;
typedef basic_istringstream<wchar_t, char_traits<wchar_t>,
        allocator<wchar_t> > wistringstream;
typedef basic_ostringstream<wchar_t, char_traits<wchar_t>,
        allocator<wchar_t> > wostringstream;
typedef basic_stringstream<wchar_t, char_traits<wchar_t>,
        allocator<wchar_t> > wstringstream;
typedef basic_filebuf<wchar_t, char_traits<wchar_t> > wfilebuf;
typedef basic_ifstream<wchar_t, char_traits<wchar_t> > wifstream;
typedef basic_ofstream<wchar_t, char_traits<wchar_t> > wofstream;
typedef basic_fstream<wchar_t, char_traits<wchar_t> > wfstream;
#line 396
};

#pragma namemangling()

#pragma object_model(pop)
#line 407
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 69 "/usr/vacpp/include/utility"
namespace std {

template<class _T1, class _T2> struct pair {
        typedef _T1 first_type;
        typedef _T2 second_type;
        pair()
                : first(_T1()), second(_T2()) {}
        pair(const _T1& _V1, const _T2& _V2)
                : first(_V1), second(_V2) {}
        template<class _U1, class _U2>
                pair(const pair<_U1, _U2>& _X)
                : first(_X.first), second(_X.second) {}
        _T1 first;
        _T2 second;
        };
template<class _T1, class _T2> inline
        bool operator==(const pair<_T1, _T2>& _X,
                const pair<_T1, _T2>& _Y)
        {return (_X.first == _Y.first && _X.second == _Y.second); }
template<class _T1, class _T2> inline
        bool operator!=(const pair<_T1, _T2>& _X,
                const pair<_T1, _T2>& _Y)
        {return (!(_X == _Y)); }
template<class _T1, class _T2> inline
        bool operator<(const pair<_T1, _T2>& _X,
                const pair<_T1, _T2>& _Y)
        {return (_X.first < _Y.first ||
                !(_Y.first < _X.first) && _X.second < _Y.second); }
template<class _T1, class _T2> inline
        bool operator>(const pair<_T1, _T2>& _X,
                const pair<_T1, _T2>& _Y)
        {return (_Y < _X); }
template<class _T1, class _T2> inline
        bool operator<=(const pair<_T1, _T2>& _X,
                const pair<_T1, _T2>& _Y)
        {return (!(_Y < _X)); }
template<class _T1, class _T2> inline
        bool operator>=(const pair<_T1, _T2>& _X,
                const pair<_T1, _T2>& _Y)
        {return (!(_X < _Y)); }
template<class _T1, class _T2> inline
        pair<_T1, _T2> make_pair(_T1 _X, _T2 _Y)
        {return (pair<_T1, _T2>(_X, _Y)); }

        namespace rel_ops {
template<class _Ty> inline
        bool operator!=(const _Ty& _X, const _Ty& _Y)
        {return (!(_X == _Y)); }
template<class _Ty> inline
        bool operator>(const _Ty& _X, const _Ty& _Y)
        {return (_Y < _X); }
template<class _Ty> inline
        bool operator<=(const _Ty& _X, const _Ty& _Y)
        {return (!(_Y < _X)); }
template<class _Ty> inline
        bool operator>=(const _Ty& _X, const _Ty& _Y)
        {return (!(_X < _Y)); }
        }
};

#pragma namemangling()

#pragma object_model(pop)
#line 138
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 69 "/usr/vacpp/include/xutility"
namespace std {
#line 74
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag
        : public input_iterator_tag {};
struct bidirectional_iterator_tag
        : public forward_iterator_tag {};
struct random_access_iterator_tag
        : public bidirectional_iterator_tag  {};
struct _Int_iterator_tag {};
#line 85
template<class _C, class _Ty, class _D = ptrdiff_t,
        class _Pt = _Ty *, class _Rt = _Ty&>
        struct iterator {
        typedef _C iterator_category;
        typedef _Ty value_type;
        typedef _D difference_type;
        typedef _Pt pointer;
        typedef _Rt reference;
        };

template<class _Ty, class _D, class _Pt, class _Rt>
        struct _Bidit : public iterator<bidirectional_iterator_tag,
                _Ty, _D, _Pt, _Rt> {};
template<class _Ty, class _D, class _Pt, class _Rt>
        struct _Ranit : public iterator<random_access_iterator_tag,
                _Ty, _D, _Pt, _Rt> {};
struct _Outit : public iterator<output_iterator_tag,
        void, void, void, void> {};
#line 105
template<class _It>
        struct iterator_traits {
        typedef typename _It::iterator_category iterator_category;
        typedef typename _It::value_type value_type;
        typedef typename _It::difference_type difference_type;
        typedef typename _It::pointer pointer;
        typedef typename _It::reference reference;
        };

template<class _Ty>
        struct iterator_traits<_Ty *> {
        typedef random_access_iterator_tag iterator_category;
        typedef _Ty value_type;
        typedef ptrdiff_t difference_type;
        typedef _Ty *pointer;
        typedef _Ty& reference;
        };
template<class _Ty>
        struct iterator_traits<const _Ty *> {
        typedef random_access_iterator_tag iterator_category;
        typedef _Ty value_type;
        typedef ptrdiff_t difference_type;
        typedef const _Ty *pointer;
        typedef const _Ty& reference;
        };

template<> struct iterator_traits<_Bool>
        {        
        typedef _Int_iterator_tag iterator_category;
        };

template<> struct iterator_traits<char>
        {        
        typedef _Int_iterator_tag iterator_category;
        };

template<> struct iterator_traits<signed char>
        {        
        typedef _Int_iterator_tag iterator_category;
        };

template<> struct iterator_traits<unsigned char>
        {        
        typedef _Int_iterator_tag iterator_category;
        };

template<> struct iterator_traits<wchar_t>
        {        
        typedef _Int_iterator_tag iterator_category;
        };

template<> struct iterator_traits<short>
        {        
        typedef _Int_iterator_tag iterator_category;
        };

template<> struct iterator_traits<unsigned short>
        {        
        typedef _Int_iterator_tag iterator_category;
        };

template<> struct iterator_traits<int>
        {        
        typedef _Int_iterator_tag iterator_category;
        };

template<> struct iterator_traits<unsigned int>
        {        
        typedef _Int_iterator_tag iterator_category;
        };

template<> struct iterator_traits<long>
        {        
        typedef _Int_iterator_tag iterator_category;
        };

template<> struct iterator_traits<unsigned long>
        {        
        typedef _Int_iterator_tag iterator_category;
        };
#line 187
template<> struct iterator_traits<long long>
        {        
        typedef _Int_iterator_tag iterator_category;
        };

template<> struct iterator_traits<unsigned long long>
        {        
        typedef _Int_iterator_tag iterator_category;
        };
#line 199
template<class _Iter> inline
        typename iterator_traits<_Iter>::iterator_category
                _Iter_cat(const _Iter&)
        {        
        typename iterator_traits<_Iter>::iterator_category _Cat;
        return (_Cat); }
template<class _C, class _Ty, class _D,
        class _Pt, class _Rt> inline
        _C _Iter_cat(const iterator<_C, _Ty, _D, _Pt, _Rt>&)
        {_C _X;
        return (_X); }
#line 212
template<class _II, class _D> inline
        void _Distance2(_II _F, _II _L, _D& _N,
                input_iterator_tag)
        {for (; _F != _L; ++_F)
                ++_N; }
template<class _II, class _D> inline
        void _Distance2(_II _F, _II _L, _D& _N,
                forward_iterator_tag)
        {for (; _F != _L; ++_F)
                ++_N; }
template<class _II, class _D> inline
        void _Distance2(_II _F, _II _L, _D& _N,
                bidirectional_iterator_tag)
        {for (; _F != _L; ++_F)
                ++_N; }
template<class _RI, class _D> inline
        void _Distance2(_RI _F, _RI _L, _D& _N,
                random_access_iterator_tag)
        {_N += _L - _F; }
template<class _II, class _D> inline
        void _Distance(_II _F, _II _L, _D& _N)
        {_Distance2(_F, _L, _N, _Iter_cat(_F)); }
template<class _II> inline
        typename iterator_traits<_II>::difference_type distance(_II _F, _II _L)
        {typename iterator_traits<_II>::difference_type _N = 0;
        _Distance2(_F, _L, _N, _Iter_cat(_F));
        return (_N); }
#line 241
template<class _Ty, class _D, class _Pt, class _Rt,
        class _Pt2, class _Rt2>
        class _Ptrit : public iterator<random_access_iterator_tag,
                _Ty, _D, _Pt, _Rt> {
public:
        typedef _Ptrit<_Ty, _D, _Pt, _Rt, _Pt2, _Rt2> _Myt;
        _Ptrit()
                {}
        explicit _Ptrit(_Pt _P)
                : current(_P) {}
        _Ptrit(const _Ptrit<_Ty, _D, _Pt2, _Rt2, _Pt2, _Rt2>& _X)
                : current(_X.base()) {}
        _Pt base() const
                {return (current); }
        _Rt operator*() const
                {return (*current); }
        _Pt operator->() const
                {return (&**this); }
        _Myt& operator++()
                {++current;
                return (*this); }
        _Myt operator++(int)
                {_Myt _Tmp = *this;
                ++current;
                return (_Tmp); }
        _Myt& operator--()
                {--current;
                return (*this); }
        _Myt operator--(int)
                {_Myt _Tmp = *this;
                --current;
                return (_Tmp); }
        bool operator==(int _Y) const
                {return (current == (_Pt)_Y); }
        bool operator==(const _Myt& _Y) const
                {return (current == _Y.current); }
        bool operator!=(const _Myt& _Y) const
                {return (!(*this == _Y)); }
        _Myt& operator+=(_D _N)
                {current += _N;
                return (*this); }
        _Myt operator+(_D _N) const
                {return (_Myt(current + _N)); }
        _Myt& operator-=(_D _N)
                {current -= _N;
                return (*this); }
        _Myt operator-(_D _N) const
                {return (_Myt(current - _N)); }
        _Rt operator[](_D _N) const
                {return (*(*this + _N)); }
        bool operator<(const _Myt& _Y) const
                {return (current < _Y.current); }
        bool operator>(const _Myt& _Y) const
                {return (_Y < *this); }
        bool operator<=(const _Myt& _Y) const
                {return (!(_Y < *this)); }
        bool operator>=(const _Myt& _Y) const
                {return (!(*this < _Y)); }
        _D operator-(const _Myt& _Y) const
                {return (current - _Y.current); }
protected:
        _Pt current;
        };

template<class _Ty>
_Ty _GetRawPtr(_Ty _P)
        {return _P; }

template<class _Ty, class _D, class _Pt, class _Rt,
         class _Pt2, class _Rt2>
_Pt _GetRawPtr(const _Ptrit<_Ty, _D, _Pt, _Rt, _Pt2, _Rt2> & _P)
        {return _P.base(); }

template<class _Ty, class _D, class _Pt, class _Rt, class _Pt2, class _Rt2> inline
        bool operator==(const _Ptrit<_Ty, _D, _Pt, _Rt, _Pt, _Rt> &lhs,
                const _Ptrit<_Ty, _D, _Pt2, _Rt2, _Pt, _Rt> &rhs)
        {return (lhs.base() == rhs.base()); }

template<class _Ty, class _D, class _Pt, class _Rt, class _Pt2, class _Rt2> inline
        bool operator!=(const _Ptrit<_Ty, _D, _Pt, _Rt, _Pt, _Rt> &lhs,
                const _Ptrit<_Ty, _D, _Pt2, _Rt2, _Pt, _Rt> &rhs)
        {return (!(lhs == rhs)); }

template<class _Ty, class _D, class _Pt, class _Rt, class _Pt2, class _Rt2> inline
        bool operator<(const _Ptrit<_Ty, _D, _Pt, _Rt, _Pt, _Rt> &lhs,
                const _Ptrit<_Ty, _D, _Pt2, _Rt2, _Pt, _Rt> &rhs)
        {return (lhs.base() < rhs.base()); }

template<class _Ty, class _D, class _Pt, class _Rt, class _Pt2, class _Rt2> inline
        bool operator>(const _Ptrit<_Ty, _D, _Pt, _Rt, _Pt, _Rt> &lhs,
                const _Ptrit<_Ty, _D, _Pt2, _Rt2, _Pt, _Rt> &rhs)
        {return (rhs < lhs); }

template<class _Ty, class _D, class _Pt, class _Rt, class _Pt2, class _Rt2> inline
        bool operator<=(const _Ptrit<_Ty, _D, _Pt, _Rt, _Pt, _Rt> &lhs,
                const _Ptrit<_Ty, _D, _Pt2, _Rt2, _Pt, _Rt> &rhs)
        {return !(rhs < lhs); }

template<class _Ty, class _D, class _Pt, class _Rt, class _Pt2, class _Rt2> inline
        bool operator>=(const _Ptrit<_Ty, _D, _Pt, _Rt, _Pt, _Rt> &lhs,
                const _Ptrit<_Ty, _D, _Pt2, _Rt2, _Pt, _Rt> &rhs)
        {return !(lhs < rhs); }

template<class _Ty, class _D, class _Pt, class _Rt, class _Pt2, class _Rt2> inline
        _D operator-(const _Ptrit<_Ty, _D, _Pt, _Rt, _Pt, _Rt> &lhs,
                const _Ptrit<_Ty, _D, _Pt2, _Rt2, _Pt, _Rt> &rhs)
        {return (lhs.base() - rhs.base()); }

template<class _Ty, class _D, class _Pt, class _Rt,
        class _Pt2, class _Rt2> inline
        _Ptrit<_Ty, _D, _Pt, _Rt, _Pt2, _Rt2>
                operator+(_D _N,
                        const _Ptrit<_Ty, _D, _Pt, _Rt, _Pt2, _Rt2>& _Y)
        {return (_Y + _N); }
#line 357
template<class _RI>
        class reverse_iterator : public iterator<
                typename iterator_traits<_RI>::iterator_category,
                typename iterator_traits<_RI>::value_type,
                typename iterator_traits<_RI>::difference_type,
                typename iterator_traits<_RI>::pointer,
                typename iterator_traits<_RI>::reference> {
public:
        typedef reverse_iterator<_RI> _Myt;
        typedef typename iterator_traits<_RI>::difference_type _D;
        typedef typename iterator_traits<_RI>::pointer _Pt;
        typedef typename iterator_traits<_RI>::reference _Rt;
        typedef _RI iterator_type;
        reverse_iterator()
                {}
        explicit reverse_iterator(_RI _X)
                : current(_X) {}
        template<class _U>
                reverse_iterator(const reverse_iterator<_U>& _X)
                : current(_X.base()) {}
        _RI base() const
                {return (current); }
        _Rt operator*() const
                {_RI _Tmp = current;
                return (*--_Tmp); }
        _Pt operator->() const
                {return (&**this); }
        _Myt& operator++()
                {--current;
                return (*this); }
        _Myt operator++(int)
                {_Myt _Tmp = *this;
                --current;
                return (_Tmp); }
        _Myt& operator--()
                {++current;
                return (*this); }
        _Myt operator--(int)
                {_Myt _Tmp = *this;
                ++current;
                return (_Tmp); }
        bool _Eq(const _Myt& _Y) const
                {return (current == _Y.current); }

        _Myt& operator+=(_D _N)
                {current -= _N;
                return (*this); }
        _Myt operator+(_D _N) const
                {return (_Myt(current - _N)); }
        _Myt& operator-=(_D _N)
                {current += _N;
                return (*this); }
        _Myt operator-(_D _N) const
                {return (_Myt(current + _N)); }
        _Rt operator[](_D _N) const
                {return (*(*this + _N)); }
        bool _Lt(const _Myt& _Y) const
                {return (_Y.current < current); }
        _D _Mi(const _Myt& _Y) const
                {return (_Y.current - current); }
protected:
        _RI current;
        };
#line 422
template<class _RI, class _D> inline
        reverse_iterator<_RI> operator+(_D _N,
                const reverse_iterator<_RI>& _Y)
        {return (_Y + _N); }
template<class _RI> inline
        typename reverse_iterator<_RI>::_D
                operator-(const reverse_iterator<_RI>& _X,
                const reverse_iterator<_RI>& _Y)
        {return (_X._Mi(_Y)); }
template<class _RI> inline
        bool operator==(const reverse_iterator<_RI>& _X,
                const reverse_iterator<_RI>& _Y)
        {return (_X._Eq(_Y)); }
template<class _RI> inline
        bool operator!=(const reverse_iterator<_RI>& _X,
                const reverse_iterator<_RI>& _Y)
        {return (!(_X == _Y)); }
template<class _RI> inline
        bool operator<(const reverse_iterator<_RI>& _X,
                const reverse_iterator<_RI>& _Y)
        {return (_X._Lt(_Y)); }
template<class _RI> inline
        bool operator>(const reverse_iterator<_RI>& _X,
                const reverse_iterator<_RI>& _Y)
        {return (_Y < _X); }
template<class _RI> inline
        bool operator<=(const reverse_iterator<_RI>& _X,
                const reverse_iterator<_RI>& _Y)
        {return (!(_Y < _X)); }
template<class _RI> inline
        bool operator>=(const reverse_iterator<_RI>& _X,
                const reverse_iterator<_RI>& _Y)
        {return (!(_X < _Y)); }
#line 457
  template<class _BI>
        class _Revbidit : public iterator<
                typename iterator_traits<_BI>::iterator_category,
                typename iterator_traits<_BI>::value_type,
                typename iterator_traits<_BI>::difference_type,
                typename iterator_traits<_BI>::pointer,
                typename iterator_traits<_BI>::reference> {
  public:
        typedef _Revbidit<_BI> _Myt;
        typedef typename iterator_traits<_BI>::difference_type _D;
        typedef typename iterator_traits<_BI>::pointer _Pt;
        typedef typename iterator_traits<_BI>::reference _Rt;
        typedef _BI iterator_type;
        _Revbidit()
                {}
        explicit _Revbidit(_BI _X)
                : current(_X) {}
        _BI base() const
                {return (current); }
        _Rt operator*() const
                {_BI _Tmp = current;
                return (*--_Tmp); }
        _Pt operator->() const
                {_Rt _Tmp = **this;
                return (&_Tmp); }
        _Myt& operator++()
                {--current;
                return (*this); }
        _Myt operator++(int)
                {_Myt _Tmp = *this;
                --current;
                return (_Tmp); }
        _Myt& operator--()
                {++current;
                return (*this); }
        _Myt operator--(int)
                {_Myt _Tmp = *this;
                ++current;
                return (_Tmp); }
        bool operator==(const _Myt& _Y) const
                {return (current == _Y.current); }
        bool operator!=(const _Myt& _Y) const
                {return (!(*this == _Y)); }
  protected:
        _BI current;
        };
#line 505
template<class _E, class _Tr>
        class istreambuf_iterator
                : public iterator<input_iterator_tag,
                        _E, typename _Tr::off_type, _E *, _E&> {
public:
        typedef istreambuf_iterator<_E, _Tr> _Myt;
        typedef _E char_type;
        typedef _Tr traits_type;
        typedef basic_streambuf<_E, _Tr> streambuf_type;
        typedef basic_istream<_E, _Tr> istream_type;
        typedef typename traits_type::int_type int_type;

        istreambuf_iterator(streambuf_type *_Sb = 0) throw ()
                : _Sbuf(_Sb), _Got(_Sb == 0) {}
        istreambuf_iterator(istream_type& _I) throw ()
                : _Sbuf(_I.rdbuf()), _Got(_I.rdbuf() == 0) {}
        const _E& operator*() const
                {if (!_Got)
                        ((_Myt *)this)->_Peek();
                return (_Val); }
        const _E *operator->() const
                {return (&**this); }
        _Myt& operator++()
                {_Inc();
                return (*this); }
        _Myt operator++(int)
                {if (!_Got)
                        _Peek();
                _Myt _Tmp = *this;
                _Inc();
                return (_Tmp); }
        bool equal(const _Myt& _X) const;
private:
        void _Inc();
        _E _Peek();
        streambuf_type *_Sbuf;
        bool _Got;
        _E _Val;
        };
#line 546
template<class _E, class _Tr> inline
        bool operator==(const istreambuf_iterator<_E, _Tr>& _X,
                const istreambuf_iterator<_E, _Tr>& _Y)
        {return (_X.equal(_Y)); }
template<class _E, class _Tr> inline
        bool operator!=(const istreambuf_iterator<_E, _Tr>& _X,
                const istreambuf_iterator<_E, _Tr>& _Y)
        {return (!(_X == _Y)); }
#line 556
template<class _E, class _Tr>
        class ostreambuf_iterator
                : public _Outit {
        typedef ostreambuf_iterator<_E, _Tr> _Myt;
public:
        typedef _E char_type;
        typedef _Tr traits_type;
        typedef basic_streambuf<_E, _Tr> streambuf_type;
        typedef basic_ostream<_E, _Tr> ostream_type;

        ostreambuf_iterator(streambuf_type *_Sb) throw ()
                : _Failed(false), _Sbuf(_Sb) {}
        ostreambuf_iterator(ostream_type& _O) throw ()
                : _Failed(false), _Sbuf(_O.rdbuf()) {}
        _Myt& operator=(_E _X)
                {if (_Sbuf == 0
                        || traits_type::eq_int_type(_Tr::eof(),
                                _Sbuf->sputc(_X)))
                        _Failed = true;
                return (*this); }
        _Myt& operator*()
                {return (*this); }
        _Myt& operator++()
                {return (*this); }
        _Myt& operator++(int)
                {return (*this); }
        bool failed() const throw ()
                {return (_Failed); }
private:
        bool _Failed;
        streambuf_type *_Sbuf;
        };
#line 592
template<class _II, class _OI> inline
        _OI copy(_II _F, _II _L, _OI _X)
        {for (; _F != _L; ++_X, ++_F)
                *_X = *_F;
        return (_X); }
#line 599
template<class _BI1, class _BI2> inline
        _BI2 copy_backward(_BI1 _F, _BI1 _L, _BI2 _X)
        {while (_F != _L)
                *--_X = *--_L;
        return (_X); }
#line 606
template<class _II1, class _II2> inline
        bool equal(_II1 _F, _II1 _L, _II2 _X)
        {return (mismatch(_F, _L, _X).first == _L); }
#line 611
template<class _II1, class _II2, class _Pr> inline
        bool equal(_II1 _F, _II1 _L, _II2 _X, _Pr _P)
        {return (mismatch(_F, _L, _X, _P).first == _L); }
#line 616
template<class _FI, class _Ty> inline
        void fill(_FI _F, _FI _L, const _Ty& _X)
        {for (; _F != _L; ++_F)
                *_F = _X; }
#line 622
template<class _OI, class _Sz, class _Ty> inline
        void fill_n(_OI _F, _Sz _N, const _Ty& _X)
        {for (; 0 < _N; --_N, ++_F)
                *_F = _X; }
#line 628
template<class _II1, class _II2>
        bool lexicographical_compare(_II1 _F1, _II1 _L1,
                _II2 _F2, _II2 _L2);
#line 633
template<class _II1, class _II2, class _Pr>
        bool lexicographical_compare(_II1 _F1, _II1 _L1,
                _II2 _F2, _II2 _L2, _Pr _P);
#line 643
template<class _Ty> inline
        const _Ty& max(const _Ty& _X, const _Ty& _Y)
        {return (_X < _Y ? _Y : _X); }

template<class _Ty> inline
        const _Ty& min(const _Ty& _X, const _Ty& _Y)
        {return (_Y < _X ? _Y : _X); }
#line 653
template<class _Ty, class _Pr> inline
        const _Ty& max(const _Ty& _X, const _Ty& _Y, _Pr _P)
        {return (_P(_X, _Y) ? _Y : _X); }

template<class _Ty, class _Pr> inline
        const _Ty& min(const _Ty& _X, const _Ty& _Y, _Pr _P)
        {return (_P(_Y, _X) ? _Y : _X); }
#line 662
template<class _II1, class _II2> inline
        pair<_II1, _II2> mismatch(_II1 _F, _II1 _L, _II2 _X)
        {for (; _F != _L && *_F == *_X; ++_F, ++_X)
                ;
        return (pair<_II1, _II2>(_F, _X)); }
#line 669
template<class _II1, class _II2, class _Pr> inline
        pair<_II1, _II2> mismatch(_II1 _F, _II1 _L, _II2 _X, _Pr _P)
        {for (; _F != _L && _P(*_F, *_X); ++_F, ++_X)
                ;
        return (pair<_II1, _II2>(_F, _X)); }
#line 676
template<class _Ty> inline
        void swap(_Ty& _X, _Ty& _Y)
        {_Ty _Tmp = _X;
        _X = _Y, _Y = _Tmp; }
};

#pragma implementation("xutility.t")
#line 31 "/usr/vacpp/include/xutility.t"
namespace std {
template<class _E, class _Tr>
inline
bool istreambuf_iterator<_E, _Tr>::equal(const _Myt& _X) const
        {if (!_Got)
                ((_Myt *)this)->_Peek();
        if (!_X._Got)
                ((_Myt *)&_X)->_Peek();
        return (_Sbuf == 0 && _X._Sbuf == 0
                || _Sbuf != 0 && _X._Sbuf != 0); }

template<class _E, class _Tr>
inline
void istreambuf_iterator<_E, _Tr>::_Inc()
         {if (_Sbuf == 0
                 || traits_type::eq_int_type(traits_type::eof(),
                         _Sbuf->sbumpc()))
                 _Sbuf = 0, _Got = true;
         else
                 _Got = false; }

template<class _E, class _Tr>
inline
_E istreambuf_iterator<_E, _Tr>::_Peek()
        {int_type _C;
        if (_Sbuf == 0
                || traits_type::eq_int_type(traits_type::eof(),
                        _C = _Sbuf->sgetc()))
                _Sbuf = 0;
        else
                _Val = traits_type::to_char_type(_C);
        _Got = true;
        return (_Val); }

template<class _II1, class _II2>
inline
bool lexicographical_compare(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2)
        {for (; _F1 != _L1 && _F2 != _L2; ++_F1, ++_F2)
                if (*_F1 < *_F2)
                        return (true);
                else if (*_F2 < *_F1)
                        return (false);
        return (_F1 == _L1 && _F2 != _L2); }

template<class _II1, class _II2, class _Pr>
inline
bool lexicographical_compare(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2, _Pr _P)
        {for (; _F1 != _L1 && _F2 != _L2; ++_F1, ++_F2)
                if (_P(*_F1, *_F2))
                        return (true);
                else if (_P(*_F2, *_F1))
                        return (false);
        return (_F1 == _L1 && _F2 != _L2); }

};
#line 688 "/usr/vacpp/include/xutility"
#pragma namemangling()

#pragma object_model(pop)
#line 697
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 88 "/usr/vacpp/include/xmemory"
extern "C" int __n_pthreads;               
#line 91
namespace std {
#line 94
        inline bool _IsThreaded() {return __n_pthreads != -1; }
        inline bool _IsPotentiallyThreaded() {return __n_pthreads != -1; }
#line 103
class _Pool {
public:
        enum { _BLOCK_SIZE=4096 };
        enum { _ARRAY_SIZE = 128 };

        enum { _ALIGNMENT = sizeof (void *) };
        enum { _MAX_SIZE = _ARRAY_SIZE * _ALIGNMENT };
#line 117
        struct _PoolObj {
                _PoolObj *_Next;
        };
#line 123
        class _Block {
        public:
                _Block() {_Init(); }
                _Block(_Block * _Next, size_t _N) {_Init(_Next, _N); }
                ~_Block() {delete(_NextBlock); }

                _PoolObj * _GetNextFree(size_t _N)
                        {if (_NextFree >= _N)
                                {_NextFree -= _N;
                                return (_PoolObj *)(_Data + _NextFree); }
                        else
                                {return (0); }}

        private:
                _Block(const _Block &);
                _Block & operator=(const _Block &);

                void _Init(_Block * _Next = (0), size_t _N = 1)
                        {_NextFree = _BLOCK_SIZE;
                        _NextBlock = _Next; }

                _PoolObj _Data[_BLOCK_SIZE];

                int             _NextFree;
                _Block          * _NextBlock; 
        };
#line 152
        class _BlockList {
        public:
                _BlockList() : _Data((0)) { }
                ~_BlockList() {delete _Data; }

                _PoolObj * _GetNextFree(size_t _N)
                        {_PoolObj * _Ret = (_Data == (0)) ? (0)
                                           : _Data->_GetNextFree(_N);
                        if (_Ret == (0))
                                {_Data = new _Block(_Data, _N);
                                 if (_Data != (0))
                                        {_Ret = _Data->_GetNextFree(_N); }
                                 else
                                        {throw bad_alloc(); }}
                        return _Ret; }
        private:
                _BlockList(const _BlockList &);
                _BlockList & operator=(const _BlockList &);

                _Block * _Data;
        };
#line 176
        class _ObjStack {
        public:
                _ObjStack() : _NextObj((0)) { }

                void _Push(_PoolObj * _Obj)
                        {if (_Obj != (0))
                                {_Obj->_Next = _NextObj;
                                _NextObj = _Obj; }}

                _PoolObj * _Pop()
                         {_PoolObj * _Ret = _NextObj;
                         if (_NextObj != (0))
                                 {_NextObj = _NextObj->_Next; }
                         return _Ret; }

        private:
                _ObjStack(const _ObjStack &);
                _ObjStack & operator=(const _ObjStack &);

                _PoolObj * _NextObj;
        };

        _Pool(size_t _Sz) : _Size(_Sz) { }
        ~_Pool() { }

        void *_Allocate()
                {_PoolObj * _Ret = _FreeStack._Pop();
                if (_Ret == (0))
                        {const size_t _Idx = (_Size + sizeof(_PoolObj) - 1)
                                                     / sizeof(_PoolObj);
                        _Ret = _Data._GetNextFree(_Idx); }
                return _Ret; }

        void _Deallocate(void *_P)
                {_FreeStack._Push((_PoolObj *)_P); }

private:
        _Pool(const _Pool &);
        _Pool & operator=(const _Pool &);

        const size_t _Size;
        _BlockList _Data;
        _ObjStack _FreeStack;
        };
#line 224
class _PoolAllocators {
public:
        static void *_Allocate(size_t _N)
                {void *_Ret;
                if ((_N > _Pool::_MAX_SIZE) ||
                    _IsPotentiallyThreaded())
                        {_Ret = operator new(_N); }
                else
                        {const size_t _Index = (_N - 1) / _Pool::_ALIGNMENT;

                        if (_PoolAllocatorArray[_Index] == (0))
                               {_PoolAllocatorArray[_Index] = new _Pool(_N);
                               if (_PoolAllocatorArray[_Index] == (0))
                                       {throw bad_alloc(); }}

                        _Ret = _PoolAllocatorArray[_Index]->_Allocate(); }

                return _Ret; }

        static void _Deallocate(void *_P, size_t _N)
                {if ((_N > _Pool::_MAX_SIZE) || _IsPotentiallyThreaded())
                        {operator delete(_P); }
                else
                        {const static bool _DeletePtrInitialized =
                                ((_DeletePtr = &::operator delete), true); 
                        const size_t _Idx = (_N - 1) / _Pool::_ALIGNMENT;
                        _PoolAllocatorArray[_Idx]->_Deallocate(_P); }}

        ~_PoolAllocators()
                {if (_DeletePtr != (0))
                        {for(int i=0; i<_Pool::_ARRAY_SIZE; ++i)
                                {_DeletePtr(_PoolAllocatorArray[i]); }}}

private:
        _PoolAllocators()
                {for(int i=0; i<_Pool::_ARRAY_SIZE; ++i)
                        {_PoolAllocatorArray[i] = (0); }}

        _PoolAllocators(const _PoolAllocators &);
        _PoolAllocators & operator=(const _PoolAllocators &);

        static _PoolAllocators _PoolAllocatorDestroyer;
        static _Pool *_PoolAllocatorArray[_Pool::_ARRAY_SIZE];

        typedef void (* _Delete_t) (void *);
        static _Delete_t _DeletePtr;
        };
#line 273
template<class _Ty> inline
        _Ty *_Allocate(size_t _N, _Ty *)
        {
#line 279
        _Ty * _Ret = ((_Ty *)operator new(_N * sizeof (_Ty)));

        if (_Ret == (0))
                {throw bad_alloc(); }

        return _Ret;
        }
#line 288
template<class _T1, class _T2> inline
        void _Construct(_T1 *_P, const _T2& _V)
        {new ((void *)_P) _T1(_V); }
#line 293
template<class _Ty> inline
        void _Destroy(_Ty *_P)
        {_P->_Ty::~_Ty(); }
template<> inline void _Destroy(char *_P)
        {}
template<> inline void _Destroy(wchar_t *_P)
        {}
#line 302
template<class _Ty>
        class allocator {
public:
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef _Ty * pointer;
        typedef const _Ty * const_pointer;
        typedef _Ty & reference;
        typedef const _Ty & const_reference;
        typedef _Ty value_type;
        template<class _U>
                struct rebind {
                        typedef allocator<_U> other;
                };
        pointer address(reference _X) const
                {return (&_X); }
        const_pointer address(const_reference _X) const
                {return (&_X); }
        allocator()
                {}
        allocator(const allocator<_Ty>&)
                {}
        template<class _U>
                allocator(const allocator<_U>&)
                {}
        template<class _U>
                allocator<_Ty>& operator=(const allocator<_U>&)
                {return (*this); }
        template<class _U>
                pointer allocate(size_type _N, const _U *)
                {return (_Allocate(_N, (pointer)0)); }
        pointer allocate(size_type _N)
                {return (_Allocate(_N, (pointer)0)); }
        pointer allocate(size_type _N, const void *)
                {return (_Allocate(_N, (pointer)0)); }
        void deallocate(pointer _P, size_type _N)
                {
#line 342
                operator delete(_P);

                }
        void construct(pointer _P, const _Ty& _V)
                {_Construct(_P, _V); }
        void destroy(pointer _P)
                {_Destroy(_P); }
        size_t max_size() const
                {size_t _N = (size_t)(-1) / sizeof (_Ty);
                return (0 < _N ? _N : 1); }
        };
#line 355
template<class _Ty, class _U> inline
        bool operator==(const allocator<_Ty>&, const allocator<_U>&) throw()
        {return (true); }
template<class _Ty, class _U> inline
        bool operator!=(const allocator<_Ty>&, const allocator<_U>&) throw()
        {return (false); }
#line 363
template<> class allocator<void> {
public:
        typedef void _Ty;
        typedef _Ty * pointer;
        typedef const _Ty * const_pointer;
        typedef _Ty value_type;
        template<class _U>
                struct rebind {
                        typedef allocator<_U> other;
                };

        allocator()
                {}
        allocator(const allocator<_Ty>&)
                {}
        template<class _U>
                allocator(const allocator<_U>&)
                {}
        template<class _U>
                allocator<_Ty>& operator=(const allocator<_U>&)
                {return (*this); }
        };
};

#pragma namemangling()

#pragma object_model(pop)
#line 396
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 83 "/usr/vacpp/include/xstring"
namespace std {

class _String_base {
public:
        void _Xlen() const;
        void _Xran() const;
        };
#line 96
template<class _Ty, class _A>
        class _String_val : public _String_base {
protected:
        typedef typename _A::template
                rebind<_Ty>::other _Alty;
        _String_val(_Alty _Al = _Alty())
                : _Alval(_Al) {}
        _Alty _Alval;
        };
#line 117
template<class _E,
        class _Tr = char_traits<_E>,
        class _Ax = allocator<_E> >
        class basic_string : public _String_val<_E, _Ax> {
public:
        typedef basic_string<_E, _Tr, _Ax> _Myt;
        typedef _String_val<_E, _Ax> _Mybase;
        typedef typename _Mybase::_Alty _A;
        typedef typename _A::size_type size_type;
        typedef typename _A::difference_type difference_type;
        typedef typename _A::pointer _Tptr;
        typedef typename _A::const_pointer _Ctptr;
        typedef _Tptr pointer;
        typedef _Ctptr const_pointer;
        typedef typename _A::reference reference;
        typedef typename _A::const_reference const_reference;
        typedef typename _A::value_type value_type;
        typedef _Ptrit<value_type, difference_type, _Tptr,
                reference, _Tptr, reference> iterator;
        typedef _Ptrit<value_type, difference_type, _Ctptr,
                const_reference, _Tptr, reference> const_iterator;
        typedef typename std::reverse_iterator<iterator>
                reverse_iterator;
        typedef typename std::reverse_iterator<const_iterator>
                const_reverse_iterator;

        basic_string()
                : _Mybase()
                {_Tidy(); }
        explicit basic_string(const _A& _Al)
                : _Mybase(_Al)
                {_Tidy(); }
        basic_string(const _Myt& _X)
                : _Mybase(_X._Alval)
                {_Tidy(), assign(_X, 0, npos); }
        basic_string(const _Myt& _X, size_type _P,
                size_type _M = npos)
                : _Mybase(_X.get_allocator())
                {_Tidy(), assign(_X, _P, _M); }
        basic_string(const _Myt& _X, size_type _P, size_type _M,
                const _A& _Al)
                : _Mybase(_Al)
                {_Tidy(), assign(_X, _P, _M); }
        basic_string(const _E *_S, size_type _N)
                : _Mybase()
                {_Tidy(), assign(_S, _N); }
        basic_string(const _E *_S, size_type _N, const _A& _Al)
                : _Mybase(_Al)
                {_Tidy(), assign(_S, _N); }
        basic_string(const _E *_S)
                : _Mybase()
                {_Tidy(), assign(_S); }
        basic_string(const _E *_S, const _A& _Al)
                : _Mybase(_Al)
                {_Tidy(), assign(_S); }
        basic_string(size_type _N, _E _C)
                : _Mybase()
                {_Tidy(), assign(_N, _C); }
        basic_string(size_type _N, _E _C, const _A& _Al)
                : _Mybase(_Al)
                {_Tidy(), assign(_N, _C); }
        basic_string(iterator _F, iterator _L)
                : _Mybase()
                {_Tidy();
                if (_F != _L)
                        assign(&*_F, _L - _F); }
        basic_string(iterator _F, iterator _L, const _A& _Al)
                : _Mybase(_Al)
                {_Tidy();
                if (_F != _L)
                        assign(&*_F, _L - _F); }
        template<class _It>
                basic_string(_It _F, _It _L)
                : _Mybase()
                {_Construct(_F, _L, _Iter_cat(_F)); }
        template<class _It>
                basic_string(_It _F, _It _L, const _A& _Al)
                : _Mybase(_Al)
                {_Construct(_F, _L, _Iter_cat(_F)); }
        template<class _It>
                void _Construct(_It _F, _It _L, _Int_iterator_tag)
                {_Tidy(), assign((size_type)_F, (_E)_L); }
        template<class _It>
                void _Construct(_It _F, _It _L, input_iterator_tag)
                {_Tidy();
                for (; _F != _L; ++_F)
                        append((size_type)1, (_E)*_F); }
        template<class _It>
                void _Construct(_It _F, _It _L, forward_iterator_tag)
                {_Tidy();
                size_type _M = 0;
                _Distance(_F, _L, _M);
                reserve(_M);
                for (; _F != _L; ++_F)
                        append((size_type)1, (_E)*_F); }
        typedef const_pointer _It;
        basic_string(_It _F, _It _L)
                : _Mybase()
                {_Tidy();
                if (_F != _L)
                        assign(&*_F, _L - _F); }
        basic_string(_It _F, _It _L, const _A& _Al)
                : _Mybase(_Al)
                {_Tidy();
                if (_F != _L)
                        assign(&*_F, _L - _F); }
        ~basic_string()
                {_Tidy(true); }
        typedef _Tr traits_type;
        typedef _A allocator_type;

        enum _Mref {_FROZEN = 255, _MAX_REFS = 254};
#line 237
        static const size_type npos;
        _Myt& operator=(const _Myt& _X)
                {return (assign(_X)); }
        _Myt& operator=(const _E *_S)
                {return (assign(_S)); }
        _Myt& operator=(_E _C)
                {return (assign(1, _C)); }
        _Myt& operator+=(const _Myt& _X)
                {return (append(_X)); }
        _Myt& operator+=(const _E *_S)
                {return (append(_S)); }
        _Myt& operator+=(_E _C)
                {return (append((size_type)1, _C)); }
        _Myt& append(const _Myt& _X)
                {return (append(_X, 0, npos)); }
        _Myt& append(const _Myt& _X, size_type _P, size_type _M);
        _Myt& append(const _E *_S, size_type _M);
        _Myt& append(const _E *_S)
                {return (append(_S, _Tr::length(_S))); }
        _Myt& append(size_type _M, _E _C);
        template<class _It>
                _Myt& append(_It _F, _It _L)
                {return (_Append(_F, _L, _Iter_cat(_F))); }
        template<class _It>
                _Myt& _Append(_It _F, _It _L, _Int_iterator_tag)
                {return (append((size_type)_F, (_E)_L)); }
        template<class _It>
                _Myt& _Append(_It _F, _It _L, input_iterator_tag)
                {return (replace(end(), end(), _F, _L)); }
        _Myt& assign(const _Myt& _X)
                {return (assign(_X, 0, npos)); }
        _Myt& assign(const _Myt& _X, size_type _P, size_type _M);
        _Myt& assign(const _E *_S, size_type _N);
        _Myt& assign(const _E *_S)
                {return (assign(_S, _Tr::length(_S))); }
        _Myt& assign(size_type _N, _E _C);
        template<class _It>
                _Myt& assign(_It _F, _It _L)
                {return (_Assign(_F, _L, _Iter_cat(_F))); }
        template<class _It>
                _Myt& _Assign(_It _F, _It _L, _Int_iterator_tag)
                {return (assign((size_type)_F, (_E)_L)); }
        template<class _It>
                _Myt& _Assign(_It _F, _It _L, input_iterator_tag)
                {return (replace(begin(), end(), _F, _L)); }
        _Myt& insert(size_type _P0, const _Myt& _X)
                {return (insert(_P0, _X, 0, npos)); }
        _Myt& insert(size_type _P0, const _Myt& _X, size_type _P,
                size_type _M);
        _Myt& insert(size_type _P0, const _E *_S, size_type _M);
        _Myt& insert(size_type _P0, const _E *_S)
                {return (insert(_P0, _S, _Tr::length(_S))); }
        _Myt& insert(size_type _P0, size_type _M, _E _C);
        iterator insert(iterator _P)
                {return (insert(_P, _E())); }
        iterator insert(iterator _P, _E _C)
                {size_type _P0 = _Pdif(_P, begin());
                insert(_P0, 1, _C);
                return (begin() + _P0); }
        void insert(iterator _P, size_type _M, _E _C)
                {size_type _P0 = _Pdif(_P, begin());
                insert(_P0, _M, _C); }
        template<class _It>
                void insert(iterator _P, _It _F, _It _L)
                {_Insert(_P, _F, _L, _Iter_cat(_F)); }
        template<class _It>
                void _Insert(iterator _P, _It _F, _It _L,
                        _Int_iterator_tag)
                {insert(_P, (size_type)_F, (_E)_L); }
        template<class _It>
                void _Insert(iterator _P, _It _F, _It _L,
                        input_iterator_tag)
                {replace(_P, _P, _F, _L); }
        _Myt& erase(size_type _P0 = 0, size_type _M = npos);
        iterator erase(iterator _P)
                {size_type _M = _Pdif(_P, begin());
                erase(_M, 1);
                return (iterator(_Psum(_Ptr, _M))); }
        iterator erase(iterator _F, iterator _L)
                {size_type _M = _Pdif(_F, begin());
                erase(_M, _Pdif(_L, _F));
                return (iterator(_Psum(_Ptr, _M))); }
        void clear()
                {erase(begin(), end()); }
        _Myt& replace(size_type _P0, size_type _N0, const _Myt& _X)
                {return (replace(_P0, _N0, _X, 0, npos)); }
        _Myt& replace(size_type _P0, size_type _N0, const _Myt& _X,
                size_type _P, size_type _M);
        _Myt& replace(size_type _P0, size_type _N0, const _E *_S,
                size_type _M);
        _Myt& replace(size_type _P0, size_type _N0, const _E *_S)
                {return (replace(_P0, _N0, _S, _Tr::length(_S))); }
        _Myt& replace(size_type _P0, size_type _N0,
                size_type _M, _E _C);
        _Myt& replace(iterator _F, iterator _L, const _Myt& _X)
                {return (replace(
                        _Pdif(_F, begin()), _Pdif(_L, _F), _X)); }
        _Myt& replace(iterator _F, iterator _L, const _E *_S,
                size_type _M)
                {return (replace(
                        _Pdif(_F, begin()), _Pdif(_L, _F), _S, _M)); }
        _Myt& replace(iterator _F, iterator _L, const _E *_S)
                {return (replace(
                        _Pdif(_F, begin()), _Pdif(_L, _F), _S)); }
        _Myt& replace(iterator _F, iterator _L, size_type _M, _E _C)
                {return (replace(
                        _Pdif(_F, begin()), _Pdif(_L, _F), _M, _C)); }
        template<class _It>
                _Myt& replace(iterator _F1, iterator _L1,
                        _It _F2, _It _L2)
                {return (_Replace(_F1, _L1, _F2, _L2, _Iter_cat(_F2))); }
        template<class _It>
                _Myt& _Replace(iterator _F1, iterator _L1,
                        _It _F2, _It _L2, _Int_iterator_tag)
                {return (replace(_F1, _L1, (size_type)_F2, (_E)_L2)); }
        template<class _It>
                _Myt& _Replace(iterator _F1, iterator _L1,
                        _It _F2, _It _L2, input_iterator_tag)
                {_Myt _X;
                for (; _F2 != _L2; ++_F2)
                        _X.append((size_type)1, (_E)*_F2);
                replace(_F1, _L1, _X);
                return (*this); }
        _Myt& replace(iterator _F1, iterator _L1,
                iterator _F2, iterator _L2);
        _Myt& replace(iterator _F1, iterator _L1,
                _It _F2, _It _L2);
        iterator begin()
                {_Freeze();
                return (iterator(_Ptr)); }
        const_iterator begin() const
                {return (const_iterator(_Ptr)); }
        iterator end()
                {_Freeze();
                return (iterator(_Psum(_Ptr, _Len))); }
        const_iterator end() const
                {return (const_iterator(_Psum(_Ptr, _Len))); }
        reverse_iterator rbegin()
                {return (reverse_iterator(end())); }
        const_reverse_iterator rbegin() const
                {return (const_reverse_iterator(end())); }
        reverse_iterator rend()
                {return (reverse_iterator(begin())); }
        const_reverse_iterator rend() const
                {return (const_reverse_iterator(begin())); }
        reference at(size_type _P0)
                {if (_Len <= _P0)
                        _String_base::_Xran();
                _Freeze();
                return (_Ptr[_P0]); }
        const_reference at(size_type _P0) const
                {if (_Len <= _P0)
                        _String_base::_Xran();
                return (_Ptr[_P0]); }
        reference operator[](size_type _P0)
                {if (_Len < _P0 || _Ptr == 0)
                        return ((reference)*_Nullstr());
                _Freeze();
                return (_Ptr[_P0]); }
        const_reference operator[](size_type _P0) const
                {if (_Ptr == 0)
                        return (*_Nullstr());
                else
                        return (_Ptr[_P0]); }
        void push_back(_E _C)
                {insert(end(), _C); }
        const _E *c_str() const
                {return (_Ptr == 0 ? _Nullstr() : _Ptr); }
        const _E *data() const
                {return (c_str()); }
        size_type length() const
                {return (_Len); }
        size_type size() const
                {return (_Len); }
        size_type max_size() const
                {size_type _N = _Mybase::_Alval.max_size();
                return (_N <= 2 ? 1 : _N - 2); }
        void resize(size_type _N)
                {resize(_N, _E()); }
        void resize(size_type _N, _E _C)
                {_N <= _Len ? erase(_N) : append(_N - _Len, _C); }
        size_type capacity() const
                {return (_Res); }
        void reserve(size_type _N = 0)
                {if (_Res < _N)
                        _Grow(_N); }
        bool empty() const
                {return (_Len == 0); }
        size_type copy(_E *_S, size_type _N, size_type _P0 = 0) const;
        void swap(_Myt& _X);
        size_type find(const _Myt& _X, size_type _P = 0) const
                {return (find(_X.c_str(), _P, _X.size())); }
        size_type find(const _E *_S, size_type _P,
                size_type _N) const;
        size_type find(const _E *_S, size_type _P = 0) const
                {return (find(_S, _P, _Tr::length(_S))); }
        size_type find(_E _C, size_type _P = 0) const
                {return (find((const _E *)&_C, _P, 1)); }
        size_type rfind(const _Myt& _X, size_type _P = npos) const
                {return (rfind(_X.c_str(), _P, _X.size())); }
        size_type rfind(const _E *_S, size_type _P,
                size_type _N) const;
        size_type rfind(const _E *_S, size_type _P = npos) const
                {return (rfind(_S, _P, _Tr::length(_S))); }
        size_type rfind(_E _C, size_type _P = npos) const
                {return (rfind((const _E *)&_C, _P, 1)); }
        size_type find_first_of(const _Myt& _X,
                size_type _P = 0) const
                {return (find_first_of(_X.c_str(), _P, _X.size())); }
        size_type find_first_of(const _E *_S, size_type _P,
                size_type _N) const;
        size_type find_first_of(const _E *_S, size_type _P = 0) const
                {return (find_first_of(_S, _P, _Tr::length(_S))); }
        size_type find_first_of(_E _C, size_type _P = 0) const
                {return (find((const _E *)&_C, _P, 1)); }
        size_type find_last_of(const _Myt& _X,
                size_type _P = npos) const
                {return (find_last_of(_X.c_str(), _P, _X.size())); }
        size_type find_last_of(const _E *_S, size_type _P,
                size_type _N) const;
        size_type find_last_of(const _E *_S,
                size_type _P = npos) const
                {return (find_last_of(_S, _P, _Tr::length(_S))); }
        size_type find_last_of(_E _C, size_type _P = npos) const
                {return (rfind((const _E *)&_C, _P, 1)); }
        size_type find_first_not_of(const _Myt& _X,
                size_type _P = 0) const
                {return (find_first_not_of(_X.c_str(), _P,
                        _X.size())); }
        size_type find_first_not_of(const _E *_S, size_type _P,
                size_type _N) const;
        size_type find_first_not_of(const _E *_S,
                size_type _P = 0) const
                {return (find_first_not_of(_S, _P, _Tr::length(_S))); }
        size_type find_first_not_of(_E _C, size_type _P = 0) const
                {return (find_first_not_of((const _E *)&_C, _P, 1)); }
        size_type find_last_not_of(const _Myt& _X,
                size_type _P = npos) const
                {return (find_last_not_of(_X.c_str(), _P, _X.size())); }
        size_type find_last_not_of(const _E *_S, size_type _P,
                 size_type _N) const;
        size_type find_last_not_of(const _E *_S,
                size_type _P = npos) const
                {return (find_last_not_of(_S, _P, _Tr::length(_S))); }
        size_type find_last_not_of(_E _C, size_type _P = npos) const
                {return (find_last_not_of((const _E *)&_C, _P, 1)); }
        _Myt substr(size_type _P = 0, size_type _M = npos) const
                {return (_Myt(*this, _P, _M)); }
        int compare(const _Myt& _X) const
                {return (compare(0, _Len, _X.c_str(), _X.size())); }
        int compare(size_type _P0, size_type _N0,
                const _Myt& _X) const
                {return (compare(_P0, _N0, _X, 0, npos)); }
        int compare(size_type _P0, size_type _N0, const _Myt& _X,
                size_type _P, size_type _M) const
                {if (_X.size() < _P)
                        _String_base::_Xran();
                if (_X._Len - _P < _M)
                        _M = _X._Len - _P;
                return (compare(_P0, _N0, _X.c_str() + _P, _M)); }
        int compare(const _E *_S) const
                {return (compare(0, _Len, _S, _Tr::length(_S))); }
        int compare(size_type _P0, size_type _N0, const _E *_S) const
                {return (compare(_P0, _N0, _S, _Tr::length(_S))); }
        int compare(size_type _P0, size_type _N0, const _E *_S,
                size_type _M) const;
        allocator_type get_allocator() const
                {return (_Mybase::_Alval); }
private:
        enum {_MIN_SIZE = sizeof (_E) <= 32 ? 31 : 7};
        void _Copy(size_type _N);
        void _Eos(size_type _N)
                {_Tr::assign(_Ptr[_Len = _N], _E()); }
        void _Freeze()
                {if (_Ptr != 0
                        && _Refcnt(_Ptr) != 0 && !__is_frozen(_Ptr))
                        _Grow(_Len);
                if (_Ptr != 0)
                        _Refcnt(_Ptr) = _FROZEN; 
#line 520
		}
        bool _Grow(size_type _N, bool _Trim = false);
        bool _Inside(const _E *_S)
                {return (_Ptr != 0 && _Ptr <= _S && _S <= _Ptr + _Len); }
        static const _E *_Nullstr()
                {static const _E _C = _E();
                return (&_C); }
        static size_type _Pdif(const_iterator _P2,
                const_iterator _P1)
                {return (_P2.base() == 0 ? 0 : _P2 - _P1); }
        static const_pointer _Psum(const_pointer _P, size_type _N)
                {return (_P == 0 ? 0 : _P + _N); }
        static pointer _Psum(pointer _P, size_type _N)
                {return (_P == 0 ? 0 : _P + _N); }
        unsigned char& _Refcnt(const _E *_U)
                {return (((unsigned char *)_U)[-1]); }
        bool  __is_frozen(const _E * _P) {

                    return (__n_pthreads != -1) ? true : (_Refcnt(_P) == _FROZEN);
#line 542
                }
        bool __hasMaxRefs(const _E * _P) {
                    return (_Refcnt(_P) == _MAX_REFS);
                }
        void _Tidy(bool _Built = false);
        void _InitPtr() {

                    _Refcnt(_Ptr) = (__n_pthreads != -1) ? _FROZEN : 0;
#line 560
                }
#line 567
        _E *_Ptr;
        size_type _Len, _Res;
        };

template<class _E, class _Tr, class _A>
        const typename basic_string<_E, _Tr, _A>::size_type
                basic_string<_E, _Tr, _A>::npos =
                        (basic_string<_E, _Tr, _A>::size_type)(-1);

template<class _E, class _Tr, class _A> inline
        void swap(basic_string<_E, _Tr, _A>& _X,
                basic_string<_E, _Tr, _A>& _Y)
        {_X.swap(_Y); }

typedef basic_string<char, char_traits<char>, allocator<char> >
        string;
typedef basic_string<wchar_t, char_traits<wchar_t>,
        allocator<wchar_t> > wstring;
#line 591
};

#pragma implementation("xstring.t")
#line 31 "/usr/vacpp/include/xstring.t"
namespace std {
#line 35
template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::append(const _Myt& _X, size_type _P, size_type _M)
        {if (_X.size() < _P)
                _String_base::_Xran();
        size_type _N = _X.size() - _P;
        if (_N < _M)
                _M = _N;
        if (max_size() - _Len < _M)
                _String_base::_Xlen();
        if (0 < _M && _Grow(_N = _Len + _M))
                {_Tr::copy(_Ptr + _Len, &_X.c_str()[_P], _M);
                _Eos(_N); }
        return (*this); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::append(const _E *_S, size_type _M)
        {if (_Inside(_S))
                return (append(*this, _S - _Ptr, _M));
        if (max_size() - _Len < _M)
                _String_base::_Xlen();
        size_type _N;
        if (0 < _M && _Grow(_N = _Len + _M))
                {_Tr::copy(_Ptr + _Len, _S, _M);
                _Eos(_N); }
        return (*this); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::append(size_type _M, _E _C)
        {
        if (max_size() - _Len < _M)
                _String_base::_Xlen();
        size_type _N;
        if (0 < _M && _Grow(_N = _Len + _M))
                {_Tr::assign(_Ptr + _Len, _M, _C);
                _Eos(_N); }
        return (*this); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::assign(const _Myt& _X, size_type _P, size_type _M)
        {if (_X.size() < _P)
                _String_base::_Xran();
        size_type _N = _X.size() - _P;
        if (_M < _N)
                _N = _M;
        if (this == &_X)
                erase((size_type)(_P + _N)), erase(0, _P);
        else if (0 < _N && _N == _X.size()
                && !__is_frozen(_X.c_str())
                && !__hasMaxRefs(_X.c_str())
                && _Mybase::_Alval == _X._Alval)
                {_Tidy(true);
                _Ptr = (_E *)_X.c_str();
                _Len = _X.size();
                _Res = _X.capacity();
                ++_Refcnt(_Ptr); }
        else if (_Grow(_N, true))
                {_Tr::copy(_Ptr, &_X.c_str()[_P], _N);
                _Eos(_N); }
        return (*this); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::assign(const _E *_S, size_type _N)
        {if (_Inside(_S))
                return (assign(*this, _S - _Ptr, _N));
        if (_Grow(_N, true))
                {_Tr::copy(_Ptr, _S, _N);
                _Eos(_N); }
        return (*this); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::assign(size_type _N, _E _C)
        {if (_N == max_size())
                _String_base::_Xlen();
        if (_Grow(_N, true))
                {_Tr::assign(_Ptr, _N, _C);
                _Eos(_N); }
        return (*this); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt& basic_string<_E, _Tr, _Ax>
        ::insert(size_type _P0, const _Myt& _X, size_type _P, size_type _M)
        {if (_Len < _P0 || _X.size() < _P)
                _String_base::_Xran();
        size_type _N = _X.size() - _P;
        if (_N < _M)
                _M = _N;
        if (max_size() - _Len < _M)
                _String_base::_Xlen();
        if (0 < _M && _Grow(_N = _Len + _M))
                {_Tr::move(_Ptr + _P0 + _M, _Ptr + _P0, _Len - _P0);
                if (this == &_X)
                        _Tr::move(_Ptr + _P0,
                                _Ptr + (_P0 < _P ? _P + _M : _P), _M);
                else
                        _Tr::copy(_Ptr + _P0, &_X.c_str()[_P], _M);
                _Eos(_N); }
        return (*this); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::insert(size_type _P0, const _E *_S, size_type _M)
        {if (_Inside(_S))
                return (insert(_P0, *this, _S - _Ptr, _M));
        if (_Len < _P0)
                _String_base::_Xran();
        if (max_size() - _Len < _M)
                _String_base::_Xlen();
        size_type _N;
        if (0 < _M && _Grow(_N = _Len + _M))
                {_Tr::move(_Ptr + _P0 + _M, _Ptr + _P0, _Len - _P0);
                _Tr::copy(_Ptr + _P0, _S, _M);
                _Eos(_N); }
        return (*this); }
#line 164
template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::insert(size_type _P0, size_type _M, _E _C)
        {if (_Len < _P0)
                _String_base::_Xran();
        if (max_size() - _Len < _M)
                _String_base::_Xlen();
        size_type _N;
        if (0 < _M && _Grow(_N = _Len + _M))
                {_Tr::move(_Ptr + _P0 + _M, _Ptr + _P0, _Len - _P0);
                _Tr::assign(_Ptr + _P0, _M, _C);
                _Eos(_N); }
        return (*this); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::erase(size_type _P0, size_type _M)
        {if (_Len < _P0)
                _String_base::_Xran();
        if (_Len - _P0 < _M)
                _M = _Len - _P0;
        if (0 < _M)
                {_Freeze();
                _Tr::move(_Ptr + _P0, _Ptr + _P0 + _M,
                        _Len - _P0 - _M);
                size_type _N = _Len - _M;
                if (_Grow(_N))
                        _Eos(_N); }
        return (*this); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::replace(size_type _P0, size_type _N0, const _Myt& _X,
        size_type _P, size_type _M)
        {if (_Len < _P0 || _X.size() < _P)
                _String_base::_Xran();
        if (_Len - _P0 < _N0)
                _N0 = _Len - _P0;
        size_type _N = _X.size() - _P;
        if (_N < _M)
                _M = _N;
        if ((_M > max_size() ? 0 : max_size() - _M) < _Len - _N0)
                _String_base::_Xlen();
        size_type _Nm = _Len - _N0 - _P0;
        _N = _Len + _M - _N0;
        if (_Len < _N)
                _Grow(_N);
        else if (0 < _M || 0 < _N0)
                _Freeze();
        if (this != &_X)
                {_Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);
                _Tr::copy(_Ptr + _P0, &_X.c_str()[_P], _M); }
        else if (_M <= _N0)
                {_Tr::move(_Ptr + _P0, _Ptr + _P, _M);
                _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm); }
        else if (_P <= _P0)
                {_Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);
                _Tr::move(_Ptr + _P0, _Ptr + _P, _M); }
        else if (_P0 + _N0 <= _P)
                {_Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);
                _Tr::move(_Ptr + _P0, _Ptr + (_P + _M - _N0), _M); }
        else
                {_Tr::move(_Ptr + _P0, _Ptr + _P, _N0);
                _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);
                _Tr::move(_Ptr + _P0 + _N0, _Ptr + _P + _M,
                        _M - _N0); }
        if (_Len < _N || _Grow(_N))
                _Eos(_N);
        return (*this); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::replace(size_type _P0, size_type _N0, const _E *_S,
        size_type _M)
        {if (_Inside(_S))
                return (replace(_P0, _N0, *this, _S - _Ptr, _M));
        if (_Len < _P0)
                _String_base::_Xran();
        if (_Len - _P0 < _N0)
                _N0 = _Len - _P0;
        if ((_M > max_size() ? 0 : max_size() - _M) < _Len - _N0)
                _String_base::_Xlen();
        size_type _Nm = _Len - _N0 - _P0;
        if (_M < _N0)
                {_Freeze();
                _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm); }
        size_type _N;
        if ((0 < _M || 0 < _N0) && _Grow(_N = _Len + _M - _N0))
                {if (_N0 < _M)
                        _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);
                _Tr::copy(_Ptr + _P0, _S, _M);
                _Eos(_N); }
        return (*this); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::replace(size_type _P0, size_type _N0,
                size_type _M, _E _C)
        {if (_Len < _P0)
                _String_base::_Xran();
        if (_Len - _P0 < _N0)
                _N0 = _Len - _P0;
        if ((_M > max_size() ? 0 : max_size() - _M) < _Len - _N0)
                _String_base::_Xlen();
        size_type _Nm = _Len - _N0 - _P0;
        if (_M < _N0)
                {_Freeze();
                _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm); }
        size_type _N;
        if ((0 < _M || 0 < _N0) && _Grow(_N = _Len + _M - _N0))
                {if (_N0 < _M)
                        _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);
                _Tr::assign(_Ptr + _P0, _M, _C);
                _Eos(_N); }
        return (*this); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::replace(iterator _F1, iterator _L1,
        iterator _F2, iterator _L2)
        {if (_F2 == _L2)
                erase(_Pdif(_F1, begin()), _Pdif(_L1, _F1));
        else
                replace(_Pdif(_F1, begin()), _Pdif(_L1, _F1),
                        &*_F2, _L2 - _F2);
        return (*this); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::_Myt&
basic_string<_E, _Tr, _Ax>::replace(iterator _F1, iterator _L1,
        _It _F2, _It _L2)
        {if (_F2 == _L2)
                erase(_Pdif(_F1, begin()), _Pdif(_L1, _F1));
        else
                replace(_Pdif(_F1, begin()), _Pdif(_L1, _F1),
                        &*_F2, _L2 - _F2);
        return (*this); }
#line 310
template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::size_type
basic_string<_E, _Tr, _Ax>::copy(_E *_S, size_type _N, size_type _P0) const
        {if (_Len < _P0)
                _String_base::_Xran();
        if (_Len - _P0 < _N)
                _N = _Len - _P0;
        if (0 < _N)
                _Tr::copy(_S, _Ptr + _P0, _N);
        return (_N); }

template<class _E, class _Tr, class _Ax>
inline
void basic_string<_E, _Tr, _Ax>::swap(_Myt& _X)
        {if (_Mybase::_Alval == _X._Alval)
                {_E *_Tptr = _Ptr;
                _Ptr = _X._Ptr, _X._Ptr = _Tptr;
                size_type _Tlen = _Len;
                _Len = _X._Len, _X._Len = _Tlen;
                size_type _Tres = _Res;
                _Res = _X._Res, _X._Res = _Tres; }
        else
                {_Myt _Ts = *this; *this = _X, _X = _Ts; }}

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::size_type
basic_string<_E, _Tr, _Ax>::find(const _E *_S, size_type _P,
        size_type _N) const
        {if (_N == 0 && _P <= _Len)
                return (_P);
        size_type _Nm;
        if (_P < _Len && _N <= (_Nm = _Len - _P))
                {const _E *_U, *_V;
                for (_Nm -= _N - 1, _V = _Ptr + _P;
                        (_U = _Tr::find(_V, _Nm, *_S)) != 0;
                        _Nm -= _U - _V + 1, _V = _U + 1)
                        if (_Tr::compare(_U, _S, _N) == 0)
                                return (_U - _Ptr); }
        return (npos); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::size_type
basic_string<_E, _Tr, _Ax>::rfind(const _E *_S, size_type _P,
        size_type _N) const
        {if (_N == 0)
                return (_P < _Len ? _P : _Len);
        if (_N <= _Len)
                for (const _E *_U = _Ptr +
                        + (_P < _Len - _N ? _P : _Len - _N); ; --_U)
                        if (_Tr::eq(*_U, *_S)
                                && _Tr::compare(_U, _S, _N) == 0)
                                return (_U - _Ptr);
                        else if (_U == _Ptr)
                                break;
        return (npos); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::size_type
basic_string<_E, _Tr, _Ax>::find_first_of(const _E *_S, size_type _P,
        size_type _N) const
        {if (_N == max_size())
          _String_base::_Xlen();
        if (0 < _N && _P < _Len)
                {const _E *const _V = _Ptr + _Len;
                for (const _E *_U = _Ptr + _P; _U < _V; ++_U)
                        if (_Tr::find(_S, _N, *_U) != 0)
                                return (_U - _Ptr); }
        return (npos); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::size_type
basic_string<_E, _Tr, _Ax>::find_last_of(const _E *_S, size_type _P,
        size_type _N) const
        {if (_N == max_size())
          _String_base::_Xlen();
        if (0 < _N && 0 < _Len)
                for (const _E *_U = _Ptr
                        + (_P < _Len ? _P : _Len - 1); ; --_U)
                        if (_Tr::find(_S, _N, *_U) != 0)
                                return (_U - _Ptr);
                        else if (_U == _Ptr)
                                break;
        return (npos); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::size_type
basic_string<_E, _Tr, _Ax>::find_first_not_of(const _E *_S, size_type _P,
        size_type _N) const
        {if (_P < _Len)
                {const _E *const _V = _Ptr + _Len;
                for (const _E *_U = _Ptr + _P; _U < _V; ++_U)
                        if (_Tr::find(_S, _N, *_U) == 0)
                                return (_U - _Ptr); }
        return (npos); }

template<class _E, class _Tr, class _Ax>
inline
typename basic_string<_E, _Tr, _Ax>::size_type
basic_string<_E, _Tr, _Ax>::find_last_not_of(const _E *_S, size_type _P,
         size_type _N) const
        {if (0 < _Len)
                for (const _E *_U = _Ptr
                        + (_P < _Len ? _P : _Len - 1); ; --_U)
                        if (_Tr::find(_S, _N, *_U) == 0)
                                return (_U - _Ptr);
                        else if (_U == _Ptr)
                                break;
        return (npos); }

template<class _E, class _Tr, class _Ax>
inline
int basic_string<_E, _Tr, _Ax>::compare(size_type _P0, size_type _N0, const _E *_S,
                size_type _M) const
        {if (_Len < _P0)
                _String_base::_Xran();
        if (_Len - _P0 < _N0)
                _N0 = _Len - _P0;
        size_type _Ans = _N0 == 0 ? 0
                : _Tr::compare(_Psum(_Ptr, _P0), _S,
                        _N0 < _M ? _N0 : _M);
        return (_Ans != 0 ? _Ans : _N0 < _M ? -1
                : _N0 == _M ? 0 : +1); }

template<class _E, class _Tr, class _Ax>
inline
void basic_string<_E, _Tr, _Ax>::_Copy(size_type _N)
        {size_type _Ns = _N | _MIN_SIZE;
        if (max_size() < _Ns)
                _Ns = _N;
        _E *_S;
        try {
                _S = _Mybase::_Alval.allocate(_Ns + 2, (void *)0);
        } catch (...) {
                _Ns = _N;
                _S = _Mybase::_Alval.allocate(_Ns + 2, (void *)0);
        }
        if (0 < _Len)
                _Tr::copy(_S + 1, _Ptr, _Len);
        size_type _Olen = _Len;
        _Tidy(true);
        _Ptr = _S + 1;
        _InitPtr();
        _Res = _Ns;
        _Eos(_Olen); }

template<class _E, class _Tr, class _Ax>
inline
bool basic_string<_E, _Tr, _Ax>::_Grow(size_type _N, bool _Trim)
        {if (max_size() < _N)
                _String_base::_Xlen();
        if (_Trim)
                _Len = 0;
        else if (_N < _Len)
                _Len = _N;
        if (_Ptr != 0
                && _Refcnt(_Ptr) != 0 && !__is_frozen(_Ptr) && !__hasMaxRefs(_Ptr))
                if (_N == 0)
                        {_Tidy(true);
                        return (false); }
                else
                        {_Copy(_N);
                        return (true); }
        if (_N == 0)
                {if (_Trim)
                        _Tidy(true);
                else if (_Ptr != 0)
                        _Eos(0);
                return (false); }
        else
                {if (_Trim && (_MIN_SIZE < _Res || _Res < _N))
                        {_Tidy(true);
                        _Copy(_N); }
                else if (!_Trim && _Res < _N)
                        {size_type _Inc = _Res / 2;
                        _Copy(_N - _Inc < _Res
                                && _Res <= max_size() - _Inc
                                        ? _Res + _Inc : _N); }
                return (true); }}

template<class _E, class _Tr, class _Ax>
inline
void basic_string<_E, _Tr, _Ax>::_Tidy(bool _Built)
        {if (!_Built || _Ptr == 0)
                ;
        else if (_Refcnt(_Ptr) == 0 || __is_frozen(_Ptr))
                _Mybase::_Alval.deallocate(_Ptr - 1, _Res + 2);
        else
                --_Refcnt(_Ptr);
        _Ptr = 0, _Len = 0, _Res = 0; }
#line 512
};
#line 599 "/usr/vacpp/include/xstring"
#pragma namemangling()

#pragma object_model (pop)
#line 608
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 62 "/usr/vacpp/include/stdexcept"
namespace std {

class logic_error : public exception {
public:
        explicit logic_error(const string& _S)
                : exception("logic error"), _Str(_S) {}
        virtual ~logic_error()
                {}
        virtual const char *what() const throw ()
                {return (_Str.c_str()); }
protected:
        virtual void _Doraise() const
                {throw (*this); }
private:
        string _Str;
        };

class domain_error : public logic_error {
public:
        explicit domain_error(const string& _S)
                : logic_error(_S) {}
        virtual ~domain_error()
                {}
protected:
        virtual void _Doraise() const
                {throw (*this); }
        };

class invalid_argument : public logic_error {
public:
        explicit invalid_argument(const string& _S)
                : logic_error(_S) {}
        virtual ~invalid_argument()
                {}
protected:
        virtual void _Doraise() const
                {throw (*this); }
        };

class length_error : public logic_error {
public:
        explicit length_error(const string& _S)
                : logic_error(_S) {}
        virtual ~length_error()
                {}
protected:
        virtual void _Doraise() const
                {throw (*this); }
        };

class out_of_range : public logic_error {
public:
        explicit out_of_range(const string& _S)
                : logic_error(_S) {}
        virtual ~out_of_range()
                {}
protected:
        virtual void _Doraise() const
                {throw (*this); }
        };

class runtime_error : public exception {
public:
        explicit runtime_error(const string& _S)
                : exception("runtime error"), _Str(_S) {}
        virtual ~runtime_error()
                {}
        virtual const char *what() const throw ()
                {return (_Str.c_str()); }
protected:
        virtual void _Doraise() const
                {throw (*this); }
private:
        string _Str;
        };

class overflow_error : public runtime_error {
public:
        explicit overflow_error(const string& _S)
                : runtime_error(_S) {}
        virtual ~overflow_error()
                {}
protected:
        virtual void _Doraise() const
                {throw (*this); }
        };

class underflow_error : public runtime_error {
public:
        explicit underflow_error(const string& _S)
                : runtime_error(_S) {}
        virtual ~underflow_error()
                {}
protected:
        virtual void _Doraise() const
                {throw (*this); }
        };

class range_error : public runtime_error {
public:
        explicit range_error(const string& _S)
                : runtime_error(_S) {}
        virtual ~range_error()
                {}
protected:
        virtual void _Doraise() const
                {throw (*this); }
        };
};

#pragma namemangling()

#pragma object_model(pop)
#line 177
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 4 "/usr/vacpp/include/typeinfo"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 19
#pragma object_model (compat)
#line 29
  #pragma namemangling(v7)
#line 54
namespace std {
class type_info {
  public:
    virtual             ~type_info();
    bool                operator==(const type_info&) const;
    bool                operator!=(const type_info&) const;
    bool                before(const type_info&) const;
    const char*         name() const;

  private:
                        type_info(const type_info&);
    type_info&          operator=(const type_info&);

  protected:
    char *              typeName;

    char *              mangledName;

};

inline const char * type_info::name() const {
  return typeName;
}

inline bool type_info::operator==(const type_info&x) const {
#line 82
  return (&x==this) || (strcmp(x.mangledName,this->mangledName)==0);

}

inline bool type_info::operator!=(const type_info&x) const {
#line 90
  return (&x!=this) && (strcmp(x.mangledName,this->mangledName)!=0);

}

inline bool type_info::before(const type_info&x) const {
#line 98
  return (&x!=this) && (strcmp(x.mangledName,this->mangledName)>=0);

}
#line 103
class bad_cast : public exception {
public:
        bad_cast(const char *_S =

	    "bad cast"
#line 113
	    ) throw ()
                : exception(_S) {}
        virtual ~bad_cast() throw ()
                {}
protected:
        virtual void _Doraise() const
                {throw (*this); }
        };

class bad_typeid : public exception {
public:
        bad_typeid(const char *_S =

	    "bad typeid"
#line 132
	    ) throw ()
                : exception(_S) {}
        virtual ~bad_typeid() throw ()
                {}
protected:
        virtual void _Doraise() const
                {throw (*this); }
        };

class __non_rtti_object : public bad_typeid{
public:
        __non_rtti_object( const char *_S =

	    "non rtti object"
#line 151
	    ) throw ()
                : bad_typeid( _S ) {}
        };
};

#pragma namemangling()
#line 159
#pragma object_model (pop)
#line 166
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 13 "/usr/vacpp/include/xlocinfo"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 46
#pragma object_model(compat)
#line 51
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/xlocinfo.h"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 46
#pragma object_model(compat)
#line 51
  #pragma namemangling(v7)
extern "C" {
#line 73 "/usr/include/ctype.h"
	extern int	isalpha(int);
	extern int	isalnum(int);

	extern int      isblank(int);

	extern int	iscntrl(int);
	extern int	isdigit(int);
	extern int	isgraph(int);
	extern int	islower(int);
	extern int	isprint(int);
	extern int	ispunct(int);
	extern int	isspace(int);
	extern int	isupper(int);
	extern int	isxdigit(int);
	extern int	toupper(int);
	extern int	tolower(int);
#line 118
	extern int	isascii(int);
	extern int	toascii(int);
#line 137
	extern int	is_wctype(wint_t, wctype_t);
	extern wctype_t	get_wctype(char *);
}
#line 141 "/usr/vacpp/include/xlocinfo.h"
typedef struct _Collvec {
#line 144
        __xlocale_ptr _Ptr;
#line 148
        } _Collvec;

typedef struct _Ctypevec {
#line 153
        __xlocale_ptr _Ptr;
#line 157
        const short *_Table;
        int _Delfl;

        } _Ctypevec;

typedef struct _Cvtvec {
#line 165
        __xlocale_ptr _Ptr;
#line 170
        } _Cvtvec;
#line 173
_Collvec _Getcoll(const char *);
_Ctypevec _Getctype(const char *);
_Cvtvec _Getcvt(const char *);
void *_Gettnames(const char *);
lconv *_Getmonpunct(const char *);
lconv *_Getnumpunct(const char *);

extern "C" {
        _Collvec _Getcoll();
        _Ctypevec _Getctype();
        _Cvtvec _Getcvt();
        char *_Getdays();
        char *_Getmonths();
        void *_Gettnames();
        int _Mbrtowc(wchar_t *, const char *, size_t,
                mbstate_t *, const _Cvtvec *);
        extern float _Stof(const char *, char **, long);
        extern double _Stod(const char *, char **, long);
        extern long double _Stold(const char *, char **, long);
        int _Strcoll(const char *, const char *,
                const char *, const char *, const _Collvec *);
        size_t _Strftime(char *, size_t, const char *,
                const struct tm *, void *);
        size_t _Strxfrm(char *, char *,
                const char *, const char *, const _Collvec *);
        int _Tolower(int, const _Ctypevec *);
        int _Toupper(int, const _Ctypevec *);
        int _Towlower(int, const _Ctypevec *);
        int _Towupper(int, const _Ctypevec *);
        int _Wcrtomb(char *, wchar_t, mbstate_t *,
                const _Cvtvec *);
        int _Wcscoll(const wchar_t *, const wchar_t *,
                const wchar_t *, const wchar_t *, const _Collvec *);
        size_t _Wcsxfrm(wchar_t *, wchar_t *,
                const wchar_t *, const wchar_t *, const _Collvec *);
        bool _DoIs(short, char, const _Ctypevec *);
        bool _DoIsW(short, wchar_t, const _Ctypevec *);
}

#pragma namemangling()

#pragma object_model(pop)
#line 221
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 78 "/usr/vacpp/include/xlocinfo"
namespace std {
#line 83
class _Timevec {
public:
        _Timevec(void *_P = 0)
                : _Ptr(_P) {}
        _Timevec(const _Timevec& _Rhs)
                {*this = _Rhs; }
        ~_Timevec() {}
        _Timevec& operator=(const _Timevec& _Rhs)
                {_Ptr = _Rhs._Ptr;
                ((_Timevec *)&_Rhs)->_Ptr = 0;
                return (*this); }
        void *_Getptr() const
                {return (_Ptr); }
private:
        void *_Ptr;
        };
#line 101
class _Locinfo {
public:
        typedef :: _Collvec _Collvec;
        typedef :: _Ctypevec _Ctypevec;
        typedef :: _Cvtvec _Cvtvec;
        typedef std::_Timevec _Timevec;

        _Locinfo(const char * = "C", int = 0);
#line 115
        _Locinfo(int, const char *);
        ~_Locinfo();
        _Locinfo& _Addcats(int, const char *);
        _Locinfo& _Addcats2(int, const char *);
        string _Getname() const
                {return (_Nname.c_str()); }
        _Collvec _Getcoll() const
                {return (::_Getcoll(_Nname.c_str())); }
        _Ctypevec _Getctype() const
                {return (::_Getctype(_Nname.c_str())); }
        _Cvtvec _Getcvt() const
                {return (::_Getcvt(_Nname.c_str())); }
        _Timevec _Gettnames() const
                {return (_Timevec(::_Gettnames(_Nname.c_str()))); }
        const lconv *_Getmonpunct() const
                {return (::_Getmonpunct(_Nname.c_str())); }
        const lconv *_Getnumpunct() const
                {return (::_Getnumpunct(_Nname.c_str())); }
        const char *_Getdays() const;
        const char *_Getmonths() const;
        const char *_Getfalse() const
                {return ("false"); }
        const char *_Gettrue() const
                {return ("true"); }

        const lconv *_Getlconv() const
                {return (localeconv()); }
private:
        _Lockit _Lk;
        string _Days, _Months, _Oname, _Nname;
        static bool _usesLocaleCache;
        };
#line 149
template<class _E>
        int _LStrcoll(const _E *_F1, const _E *_L1,
                const _E *_F2, const _E *_L2, const _Locinfo::_Collvec *);
template<> inline int _LStrcoll(
        const char *_F1, const char *_L1,
        const char *_F2, const char *_L2,
        const _Locinfo::_Collvec *_V)
        {return (_Strcoll(_F1, _L1, _F2, _L2, _V)); }
#line 159
template<class _E> inline
        size_t _LStrxfrm(_E *_F1, _E *_L1,
                const _E *_F2, const _E *_L2, const _Locinfo::_Collvec *)
        {size_t _N = _L2 - _F2;
        if (_N <= (size_t)(_L1 - _F1))
                memcpy(_F1, _F2, _N * sizeof (_E));
        return (_N); }
template<> inline size_t _LStrxfrm(
        char *_F1, char *_L1,
        const char *_F2, const char *_L2,
        const _Locinfo::_Collvec *_V)
        {return (_Strxfrm(_F1, _L1, _F2, _L2, _V)); }
#line 177
};

std::string _GetCatName(int, const char *);

#pragma implementation("xlocinfo.t")
#line 31 "/usr/vacpp/include/xlocinfo.t"
namespace std {
#line 35
inline
const char * _Locinfo::_Getdays() const
        {char *_S = :: _Getdays();
        if (_S != 0)
                {((_Locinfo *)this)->_Days = _S, free(_S); }
        return (_Days.size() != 0 ? _Days.c_str()
                        : ":Sun:Sunday:Mon:Monday:Tue:Tuesday"
                        ":Wed:Wednesday:Thu:Thursday:Fri:Friday"
                        ":Sat:Saturday"); }
#line 46
inline
const char * _Locinfo::_Getmonths() const
        {char *_S = :: _Getmonths();
        if (_S != 0)
                {((_Locinfo *)this)->_Months = _S, free(_S); }
        return (_Months.size() != 0 ? _Months.c_str()
                        : ":1:01:Jan:January:2:02:Feb:February:3:03:Mar:March"
                        ":4:04:Apr:April:5:05:May:May:6:06:Jun:June"
                        ":7:07:Jul:July:8:08:Aug:August:9:09:Sep:September"
                        ":10:10:Oct:October:11:11:Nov:November:12:12:Dec:December"); }

template<class _E>
inline
int _LStrcoll(const _E *_F1, const _E *_L1,
                const _E *_F2, const _E *_L2, const _Locinfo::_Collvec *)
        {for (; _F1 != _L1 && _F2 != _L2; ++_F1, ++_F2)
                if (*_F1 < *_F2)
                        return (-1);
                else if (*_F2 < *_F1)
                        return (+1);
        return (_F2 != _L2 ? -1 : _F1 != _L1 ? +1 : 0); }

template<>
inline
int _LStrcoll(const wchar_t *_F1, const wchar_t *_L1,
                const wchar_t *_F2, const wchar_t *_L2,
                const _Locinfo::_Collvec * _Coll)
        { return _Wcscoll(_F1, _L1, _F2, _L2, _Coll); }
#line 81
};
#line 187 "/usr/vacpp/include/xlocinfo"
#pragma namemangling()

#pragma object_model(pop)
#line 196
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 90 "/usr/vacpp/include/xlocale"
namespace std {
#line 95
template <class _T>
struct _IsStandardFacet
        { enum { value = false }; };
#line 100
class  locale {
public:
        typedef int category;
        static const category collate  = (1 << (0));
        static const category ctype    = (1 << (1));
        static const category monetary = (1 << (2));
        static const category numeric  = (1 << (3));
        static const category time     = (1 << (4));
        static const category messages = (1 << (6));
        static const category all      = ((1 << ((6 + 1))) - 1);
        static const category none     = 0;
#line 113
        class  id {
        public:
                id(size_t _X = 0)
                        : _Id(_X) {}
                operator size_t()
                        {_Lockit _Lk(_Lockit::_Loc);
                        if (_Id == 0)
                                _Id = ++_Id_cnt;
                        return (_Id); }
        private:
                id(const id&);   
                id& operator=(const id&);        
                size_t _Id;
                static int _Id_cnt;
                };

        class _Locimp;
#line 132
        class facet {
                friend class locale;
                friend class _Locimp;
        public:
                static size_t _Getcat(const facet **_Ppf = 0)
                        {return ((size_t)(-1)); }
                void _Incref()
                        {
                        if (_Refs < (size_t)(-1))
                                ++_Refs; }
                facet *_Decref()
                        {
                        if (0 < _Refs && _Refs < (size_t)(-1))
                                --_Refs;
                        return (_Refs == 0 ? this : 0); }

                virtual ~facet()
                        {}
        protected:
                explicit facet(size_t _R = 0)
                        : _Refs(_R) {}
        private:
                facet(const facet&);     
                facet& operator=(const facet&);  
                size_t _Refs;
                };
#line 160
        class  _Locimp : public facet {
        protected:
                ~_Locimp();
        private:
                friend class locale;
                _Locimp(bool _Xp = false);
                _Locimp(const _Locimp&);
                void _Addfac(facet *, size_t);
                static _Locimp *_Makeloc(const _Locinfo&,
                        category, _Locimp *, const locale *);
                static void _Makewloc(const _Locinfo&,
                        category, _Locimp *, const locale *);
                static void _Makexloc(const _Locinfo&,
                        category, _Locimp *, const locale *);
                facet **_Fv;
                size_t _Nfv;
                category _Cat;
                bool _Xpar;
                string _Name;
                static _Locimp *_Clocptr, *_Global;
                };

        template<class _E, class _Tr, class _A>
                bool operator()(const basic_string<_E, _Tr, _A>&,
                        const basic_string<_E, _Tr, _A>&) const;
        template<class _F>
                locale combine(const locale& _X) const;
        template<class _F>
                locale(const locale& _X, _F *_Fac)
                        : _Ptr(new _Locimp(*(_X._Ptr)))
                {if ((_Fac != 0) && (_Ptr != 0))
                        {_Ptr->_Addfac(_Fac, _F::id);
                        if (_IsStandardFacet<_F>::value)
                                _Ptr->_Cat = 0, _Ptr->_Name = "*"; }}
        locale() throw ()
                {_Lockit _Lk(_Lockit::_Loc);
                _Ptr=_Init();
                if (_Ptr != 0)
                         _Ptr->_Incref(); }
        locale(_Uninitialized)
                : _Ptr(0)
                {}
        locale(const locale& _X) throw ()
                {_Lockit _Lk(_Lockit::_Loc);
                _Ptr=_X._Ptr;
                if (_Ptr != 0)
                         _Ptr->_Incref(); }
        locale(const locale&, const locale&, category);
        explicit locale(const char *, category = all);
        locale(const locale&, const char *, category);
        ~locale() throw ()
                {_Lockit _Lk(_Lockit::_Loc);
                if (_Ptr != 0)
                        delete _Ptr->_Decref(); }
        locale& operator=(const locale& _X) throw ()
                {_Lockit _Lk(_Lockit::_Loc);
                if ((_Ptr != 0) && (_Ptr != _X._Ptr))
                        {delete _Ptr->_Decref();
                        _Ptr = _X._Ptr;
                        _Ptr->_Incref(); }
                return (*this); }
        string name() const
                {return (_Ptr == 0 ? string() : _Ptr->_Name); }
        const facet *_Getfacet(size_t _Id) const;
        bool operator==(const locale& _X) const;
        bool operator!=(const locale& _X) const
                {return (!(*this == _X)); }
        static const locale& classic();
        static locale global(const locale&);
        static locale empty();
private:
        locale(_Locimp *_P)
                : _Ptr(_P) {}
        static _Locimp *_Init();        
        static void  _Tidy();    
        _Locimp *_Ptr;
        };
#line 239
template<class _F>
        class _Tidyfac {
public:
        typedef void (*PFV)();
        static _F *_Save(_F *_Fac)
                {_Lockit _Lk(_Lockit::_Loc);
                _Facsav = _Fac;
                _Facsav->_Incref();
                PFV _Tidy_rtn = &_Tidy;
                return (_Fac); }
        static void _Tidy()
                {_Lockit _Lk(_Lockit::_Loc);
                if (_Facsav != 0)
                        {delete _Facsav->_Decref();
                        _Facsav = 0; }}
private:
        static _F *_Facsav;
        };

template<class _F>
        _F *_Tidyfac<_F>::_Facsav = 0;
#line 265
template<class _F, bool _IsStdFac>
struct _UseFacet {
        static const _F& _Use(const locale & _L,
                              const locale::facet *& _Psave,
                              const locale::facet * _Pf)
                {if (_Pf == 0)
                        {if (_Psave != 0)
                                {_Pf = _Psave; }
                        else if (_F::_Getcat(&_Psave) != (size_t)(-1))
                                {_Pf = _Tidyfac<_F>::_Save((_F *)_Psave); }
                        else
                                {throw bad_cast(""); }}
                return static_cast<const _F&>(*_Pf);}
        };

template<class _F>
struct _UseFacet<_F, false> {
        static const _F& _Use(const locale& _L,
                              const locale::facet *&,
                              const locale::facet * _Pf)
                {if (_Pf == 0)
                        {throw bad_cast(""); }
                try
                        {return dynamic_cast<const _F&>(*_Pf); }
                catch (__non_rtti_object)
                        {}
                catch(...)
                        { throw; }
                return static_cast<const _F&>(*_Pf);}
        };

template<class _F> inline
        const _F& use_facet(const locale& _L)
                {static const locale::facet *_Psave = 0;
                const locale::facet *_Pf = _L._Getfacet(_F::id);
                typedef _UseFacet<_F, _IsStandardFacet<_F>::value> _UseFac;
                return _UseFac::_Use(_L, _Psave, _Pf); }
#line 305
template<class _E> inline
        char _Narrow(_E _C)  
        {return ((char)_C); }

template<> inline char _Narrow(wchar_t _C)
        {return ((char)wctob(_C)); }
#line 315
template<class _E> inline
        _E _Widen(char _Ch, _E *)  
        {return ((unsigned char)_Ch); }

template<> inline wchar_t _Widen(char _Ch, wchar_t *)
        {return (btowc(_Ch)); }
#line 324
template<class _E, class _II> inline
        int _Getloctxt(_II& _F, _II& _L, size_t _N,
                const _E *_S)
        {for (size_t _I = 0; _S[_I] != (_E)0; ++_I)
                if (_S[_I] == _S[0])
                        ++_N;
        string _Str(_N, '\0');
        int _Ans = -2;
        for (size_t _J = 1; ; ++_J, ++_F, _Ans = -1)
                {bool  _Pfx;
                size_t _I, _K;
                for (_I = 0, _K = 0, _Pfx = false; _K < _N; ++_K)
                        {for (; _S[_I] != (_E)0 && _S[_I] != _S[0]; ++_I)
                                ;
                        if (_Str[_K] != '\0')
                                _I += _Str[_K];
                        else if (_S[_I += _J] == _S[0] || _S[_I] == (_E)0)
                                {_Str[_K] = _J < 127 ? _J : 127;
                                _Ans = _K; }
                        else if (_F == _L || _S[_I] != *_F)
                                _Str[_K] = _J < 127 ? _J : 127;
                        else
                                _Pfx = true; }
                if (!_Pfx || _F == _L)
                        break; }
        return (_Ans); }
#line 354
template<class _E> inline
        _E *_Maklocstr(const char *_S, _E *)
        {size_t _L = strlen(_S) + 1;
        _E *_X = new _E[_L];
        for (_E *_P = _X; 0 < _L; --_L, ++_P, ++_S)
                if (_S != 0)
                        *_P = _Widen(*_S, (_E *)0);
                else
                        *_P = _Widen(0, (_E *)0);
        return (_X); }
#line 366
class  codecvt_base : public locale::facet {
public:
        enum _Result {ok, partial, error, noconv};
        typedef int result;
        codecvt_base(size_t _R = 0)
                : locale::facet(_R) {}
        bool always_noconv() const throw ()
                {return (do_always_noconv()); }
        int max_length() const throw ()
                {return (do_max_length()); }
        int encoding() const throw ()
                {return (do_encoding()); }
        ~codecvt_base() {}
protected:
        virtual bool do_always_noconv() const throw ()
                {return (true); }
        virtual int do_max_length() const throw ()
                {return (1); }
        virtual int do_encoding() const throw ()
                {return (1); }
        };
#line 391
template<class _E, class _To, class _St>
class codecvt : public codecvt_base {
public:
        typedef _E intern_type;
        typedef _To extern_type;
        typedef _St state_type;
        result in(_St& _State,
                const _To *_F1, const _To *_L1, const _To *& _Mid1,
                _E *_F2, _E *_L2, _E *& _Mid2) const
                {return (do_in(_State,
                        _F1, _L1, _Mid1, _F2, _L2, _Mid2)); }
        result out(_St& _State,
                const _E *_F1, const _E *_L1, const _E *& _Mid1,
                _To *_F2, _To *_L2, _To *& _Mid2) const
                {return (do_out(_State,
                        _F1, _L1, _Mid1, _F2, _L2, _Mid2)); }
        result unshift(_St& _State,
                _To *_F2, _To *_L2, _To *& _Mid2) const
                {return (do_unshift(_State,
                        _F2, _L2, _Mid2)); }
        int length(_St& _State, const _To *_F1,
                const _To *_L1, size_t _N2) const throw ()
                {return (do_length(_State, _F1, _L1, _N2)); }
        static locale::id id;

        explicit codecvt(size_t _R = 0)
                : codecvt_base(_R) {_Init(_Locinfo()); }
#line 422
        codecvt(const _Locinfo& _Lobj, size_t _R = 0)
                : codecvt_base(_R) {_Init(_Lobj); }
        static size_t _Getcat(const locale::facet **_Ppf = 0)
                {if (_Ppf != 0 && *_Ppf == 0)
                        *_Ppf = new codecvt<_E, _To, _St>;
                return (1); }
protected:
        virtual ~codecvt()
                {};
protected:
        void _Init(const _Locinfo& _Lobj)
                {_Cvt = _Lobj._Getcvt(); }
        virtual result do_in(_St& _State,
                const _To *_F1, const _To *, const _To *& _Mid1,
                _E *_F2, _E *, _E *& _Mid2) const
                {_Mid1 = _F1, _Mid2 = _F2;
                return (noconv); }
        virtual result do_out(_St& _State,
                const _E *_F1, const _E *, const _E *& _Mid1,
                _To *_F2, _To *, _To *& _Mid2) const
                {_Mid1 = _F1, _Mid2 = _F2;
                return (noconv); }
        virtual result do_unshift(_St& _State,
                _To *_F2, _To *_L2, _To *& _Mid2) const
                {_Mid2 = _F2;
                return (noconv); }
        virtual int do_length(_St& _State, const _To *_F1,
                const _To *_L1, size_t _N2) const throw ()
                {return (_N2 < (size_t)(_L1 - _F1)
                        ? _N2 : _L1 - _F1); }
private:
        _Locinfo::_Cvtvec _Cvt;
        };

template<class _E, class _To, class _St>
        locale::id codecvt<_E, _To, _St>::id;

__ExternStaticData template class codecvt<char , char , mbstate_t>;
__ExternStaticData template class codecvt<wchar_t , wchar_t , mbstate_t>;

template <>
struct _IsStandardFacet<codecvt<char, char, mbstate_t> >
        { enum { value = true }; };

template <>
struct _IsStandardFacet<codecvt<wchar_t, wchar_t, mbstate_t> >
        { enum { value = true }; };
#line 471
template<>
class  codecvt<wchar_t, char, mbstate_t>
        : public codecvt_base {
public:
        typedef wchar_t _E;
        typedef char _To;
        typedef mbstate_t _St;
        typedef _E intern_type;
        typedef _To extern_type;
        typedef _St state_type;
        result in(_St& _State,
                const _To *_F1, const _To *_L1, const _To *& _Mid1,
                _E *_F2, _E *_L2, _E *& _Mid2) const
                {return (do_in(_State,
                        _F1, _L1, _Mid1, _F2, _L2, _Mid2)); }
        result out(_St& _State,
                const _E *_F1, const _E *_L1, const _E *& _Mid1,
                _To *_F2, _To *_L2, _To *& _Mid2) const
                {return (do_out(_State,
                        _F1, _L1, _Mid1, _F2, _L2, _Mid2)); }
        result unshift(_St& _State,
                _To *_F2, _To *_L2, _To *& _Mid2) const
                {return (do_unshift(_State,
                        _F2, _L2, _Mid2)); }
        int length(_St& _State, const _To *_F1,
                const _To *_L1, size_t _N2) const throw ()
                {return (do_length(_State, _F1, _L1, _N2)); }
        static locale::id id;
        explicit codecvt(size_t _R = 0)
                : codecvt_base(_R) {_Init(_Locinfo()); }
        codecvt(const _Locinfo& _Lobj, size_t _R = 0)
                : codecvt_base(_R) {_Init(_Lobj); }
        static size_t _Getcat(const locale::facet **_Ppf = 0)
                {if (_Ppf != 0 && *_Ppf == 0)
                        *_Ppf = new codecvt<_E, _To, _St>;
                return (1); }
protected:
        virtual ~codecvt()
                {};
protected:
        void _Init(const _Locinfo& _Lobj)
                {_Cvt = _Lobj._Getcvt(); }
        virtual result do_in(_St& _State,
                const _To *_F1, const _To *_L1, const _To *& _Mid1,
                _E *_F2, _E *_L2, _E *& _Mid2) const
                {_Mid1 = _F1, _Mid2 = _F2;
                result _Ans = _Mid1 == _L1 ? ok : partial;
                int _N;
                while (_Mid1 != _L1 && _Mid2 != _L2)
                        {_N = _Mbrtowc(_Mid2, _Mid1, _L1 - _Mid1,
                                &_State, &_Cvt);
                        switch (_N)
                        {case -2:
                                _Mid1 = _L1;
                                return (_Ans);
                        case -1:
                                return (error);
                        case 0:
                                _N = strlen(_Mid1) + 1;
                        default:         
                                _Mid1 += _N, ++_Mid2, _Ans = ok; }}
                return (_Ans); }
        virtual result do_out(_St& _State,
                const _E *_F1, const _E *_L1, const _E *& _Mid1,
                _To *_F2, _To *_L2, _To *& _Mid2) const
                {_Mid1 = _F1, _Mid2 = _F2;
                result _Ans = _Mid1 == _L1 ? ok : partial;
                int _N;
                while (_Mid1 != _L1 && _Mid2 != _L2)
                        if (((__lc_charmap).obj->cm_mb_cur_max) <= _L2 - _Mid2)
                                if ((_N = _Wcrtomb(_Mid2, *_Mid1,
                                        &_State, &_Cvt)) <= 0)
                                        return (error);
                                else
                                        ++_Mid1, _Mid2 += _N, _Ans = ok;
                        else
                                {_To _Buf[4];
                                _St _Stsave = _State;
                                if ((_N = _Wcrtomb(_Buf, *_Mid1,
                                        &_State, &_Cvt)) <= 0)
                                        return (error);
                                else if (_L2 - _Mid2 < _N)
                                        {_State = _Stsave;
                                        return (_Ans); }
                                else
                                        {memcpy(_Mid2, _Buf, _N);
                                        ++_Mid1, _Mid2 += _N, _Ans = ok; }}
                return (_Ans); }
        virtual result do_unshift(_St& _State,
                _To *_F2, _To *_L2, _To *& _Mid2) const
                {_Mid2 = _F2;
                result _Ans = ok;
                int _N;
                _To _Buf[4];
                _St _Stsave = _State;
                if ((_N = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
                        _Ans = error;
                else if (_L2 - _Mid2 < --_N)
                        {_State = _Stsave;
                        _Ans = partial; }
                else if (0 < _N)
                        {memcpy(_Mid2, _Buf, _N);
                        _Mid2 += _N; }
                return (_Ans); }
        virtual int do_length(_St& _State, const _To *_F1,
                const _To *_L1, size_t _N2) const throw ()
                {int _N1;
                const _To *_Mid1;
                for (_N1 = 0, _Mid1 = _F1;
                        (size_t)_N1 < _N2 && _Mid1 != _L1; )
                        {int _N;
                        _E _Ch;
                        _N = _Mbrtowc(&_Ch, _Mid1, _L1 - _Mid1,
                                &_State, &_Cvt);
                        switch (_N)
                        {case -2:
                                return (_N1);
                        case -1:
                                return (_N1);
                        case 0:
                                _N = strlen(_Mid1) + 1;
                        default:         
                                _Mid1 += _N, ++_N1; }}
                return (_N1); }
        virtual bool do_always_noconv() const throw ()
                {return (false); }
        virtual int do_max_length() const throw ()
                {return (4); }
        virtual int do_encoding() const throw ()
                {return (0); }
private:
        _Locinfo::_Cvtvec _Cvt;
        };

__ExternStaticData template class codecvt<wchar_t , char , mbstate_t>;

template <>
struct _IsStandardFacet<codecvt<wchar_t, char, mbstate_t> >
        { enum { value = true }; };
#line 612
template<class _E, class _To, class _St>
        class codecvt_byname : public codecvt<_E, _To, _St> {
public:
        explicit codecvt_byname(const char *_S, size_t _R = 0)
                : codecvt<_E, _To, _St>(_Locinfo(_S), _R) {}
protected:
        virtual ~codecvt_byname()
                {}
        };
#line 623
struct ctype_base : public locale::facet {
        typedef short mask;      
#line 632
        enum _Mask {_Alnum = 0x02|0x40|0x80|0x100, _Alpha = 0x40|0x80|0x100,
                _Cntrl = 0x20, _Digit = 0x02, _Graph = 0x02|0x40|0x10|0x80|0x100,
                _Lower = 0x40, _Print = 0x02|0x40|0x10|0x04|0x80|0x100|0x01,
                _Punct = 0x10, _Space = 0x08|0x04|0x200, _Upper = 0x80,
                _Xdigit = 0x01};
        static const mask alnum = _Alnum;
        static const mask alpha = _Alpha;
        static const mask cntrl = _Cntrl;
        static const mask digit = _Digit;
        static const mask graph = _Graph;
        static const mask lower = _Lower;
        static const mask print = _Print;
        static const mask punct = _Punct;
        static const mask space = _Space;
        static const mask upper = _Upper;
        static const mask xdigit = _Xdigit;
#line 650
        ctype_base(size_t _R = 0)
                : locale::facet(_R) {}
        ~ctype_base() {}
        };
#line 656
template<class _E>
        class ctype : public ctype_base {
public:
        typedef _E char_type;
        bool is(mask _M, _E _C) const
                {return (do_is(_M, _C)); }
        const _E *is(const _E *_F, const _E *_L, mask *_V) const
                {return (do_is(_F, _L, _V)); }
        const _E *scan_is(mask _M, const _E *_F,
                const _E *_L) const
                {return (do_scan_is(_M, _F, _L)); }
        const _E *scan_not(mask _M, const _E *_F,
                const _E *_L) const
                {return (do_scan_not(_M, _F, _L)); }
        _E tolower(_E _C) const
                {return (do_tolower(_C)); }
        const _E *tolower(_E *_F, const _E *_L) const
                {return (do_tolower(_F, _L)); }
        _E toupper(_E _C) const
                {return (do_toupper(_C)); }
        const _E *toupper(_E *_F, const _E *_L) const
                {return (do_toupper(_F, _L)); }
        _E widen(char _X) const
                {return (do_widen(_X)); }
        const char *widen(const char *_F, const char *_L,
                _E *_V) const
                {return (do_widen(_F, _L, _V)); }
        char narrow(_E _C, char _D = '\0') const
                {return (do_narrow(_C, _D)); }
        const _E *narrow(const _E *_F, const _E *_L, char _D,
                char *_V) const
                {return (do_narrow(_F, _L, _D, _V)); }
        static locale::id id;

        explicit ctype(size_t _R = 0)
                : ctype_base(_R) {_Init(_Locinfo()); }
#line 696
        ctype(const _Locinfo& _Lobj, size_t _R = 0)
                : ctype_base(_R) {_Init(_Lobj); }
        static size_t _Getcat(const locale::facet **_Ppf = 0)
                {if (_Ppf != 0 && *_Ppf == 0)
                        *_Ppf = new ctype<_E>;
                return (1); }
protected:
        virtual ~ctype()
                {if (_Ctype._Delfl)
                        free((void *)_Ctype._Table); }
protected:
        void _Init(const _Locinfo& _Lobj)
                {_Ctype = _Lobj._Getctype(); }
        virtual bool do_is(mask _M, _E _C) const
                {return ((_Ctype._Table[(unsigned char)narrow(_C)]
                        & _M) != 0); }
        virtual const _E *do_is(const _E *_F, const _E *_L,
                mask *_V) const
                {for (; _F != _L; ++_F, ++_V)
                        *_V = _Ctype._Table[(unsigned char)narrow(*_F)];
                return (_F); }
        virtual const _E *do_scan_is(mask _M, const _E *_F,
                const _E *_L) const
                {for (; _F != _L && !is(_M, *_F); ++_F)
                        ;
                return (_F); }
        virtual const _E *do_scan_not(mask _M, const _E *_F,
                const _E *_L) const
                {for (; _F != _L && is(_M, *_F); ++_F)
                        ;
                return (_F); }
        virtual _E do_tolower(_E _C) const
                {return (widen((char)_Tolower((unsigned char)narrow(_C),
                        &_Ctype))); }
        virtual const _E *do_tolower(_E *_F, const _E *_L) const
                {for (; _F != _L; ++_F)
                        *_F = widen((char)_Tolower((unsigned char)narrow(*_F),
                                &_Ctype));
                return ((const _E *)_F); }
        virtual _E do_toupper(_E _C) const
                {return (widen((char)_Toupper((unsigned char)narrow(_C),
                        &_Ctype))); }
        virtual const _E *do_toupper(_E *_F, const _E *_L) const
                {for (; _F != _L; ++_F)
                        *_F = widen((char)_Toupper((unsigned char)narrow(*_F),
                        &_Ctype));
                return ((const _E *)_F); }
        virtual _E do_widen(char _X) const
                {return (_Widen(_X, (_E *)0)); }
        virtual const char *do_widen(const char *_F, const char *_L,
                _E *_V) const
                {for (; _F != _L; ++_F, ++_V)
                        *_V = _Widen(*_F, (_E *)0);
                return (_F); }
        virtual char do_narrow(_E _C, char) const
                {return (_Narrow(static_cast<_E>(_C))); }
        virtual const _E *do_narrow(const _E *_F, const _E *_L,
                char, char *_V) const
                {for (; _F != _L; ++_F, ++_V)
                        *_V = _Narrow(static_cast<_E>(*_F));
                return (_F); }
private:
        _Locinfo::_Ctypevec _Ctype;
        };

template<class _E>
        locale::id ctype<_E>::id;

__ExternStaticData template class ctype<wchar_t>;

template <>
struct _IsStandardFacet<ctype<wchar_t> >
        { enum { value = true }; };
#line 771
template<>
        bool ctype<wchar_t>::do_is(mask _M, wchar_t _C) const
                {return _DoIsW(_M, _C, &_Ctype); }
#line 777
template<>
class  ctype<char> : public ctype_base {
        typedef ctype<char> _Myt;
public:
        typedef char _E;
        typedef _E char_type;
        bool is(mask _M, _E _C) const

                {return _DoIs(_M, _C, &_Ctype); }
#line 789
        const _E *is(const _E *_F, const _E *_L, mask *_V) const
                {for (; _F != _L; ++_F, ++_V)
                        *_V = _Ctype._Table[(unsigned char)*_F];
                return (_F); }
        const _E *scan_is(mask _M, const _E *_F,
                const _E *_L) const
                {for (; _F != _L && !is(_M, *_F); ++_F)
                        ;
                return (_F); }
        const _E *scan_not(mask _M, const _E *_F,
                const _E *_L) const
                {for (; _F != _L && is(_M, *_F); ++_F)
                        ;
                return (_F); }
        _E tolower(_E _C) const
                {return (do_tolower(_C)); }
        const _E *tolower(_E *_F, const _E *_L) const
                {return (do_tolower(_F, _L)); }
        _E toupper(_E _C) const
                {return (do_toupper(_C)); }
        const _E *toupper(_E *_F, const _E *_L) const
                {return (do_toupper(_F, _L)); }
        _E widen(char _X) const
                {return (do_widen(_X)); }
        const _E *widen(const char *_F, const char *_L, _E *_V) const
                {return (do_widen(_F, _L, _V)); }
        _E narrow(_E _C, char _D = '\0') const
                {return (do_narrow(_C, _D)); }
        const _E *narrow(const _E *_F, const _E *_L, char _D,
                char *_V) const
                {return (do_narrow(_F, _L, _D, _V)); }
        static locale::id id;
        explicit ctype(const mask *_Tab = 0, bool _Df = false,
                size_t _R = 0)
                : ctype_base(_R)
                {_Init(_Locinfo());
                if (_Ctype._Delfl)
                        free((void *)_Ctype._Table), _Ctype._Delfl = false;
                if (_Tab == 0)
                        _Ctype._Table = _Cltab;
                else
                        _Ctype._Table = _Tab, _Ctype._Delfl = _Df; }
        ctype(const _Locinfo& _Lobj, size_t _R = 0)
                : ctype_base(_R) {_Init(_Lobj); }
        static size_t _Getcat(const locale::facet **_Ppf = 0)
                {if (_Ppf != 0 && *_Ppf == 0)
                        *_Ppf = new ctype<_E>;
                return (1); }
        static const size_t table_size;
protected:
        virtual ~ctype()
                {if (_Ctype._Delfl)
                        free((void *)_Ctype._Table); }
protected:
        void _Init(const _Locinfo& _Lobj)
                {_Ctype = _Lobj._Getctype();
                if (_Cltab == 0)
                        _Cltab = _Ctype._Table, _Ctype._Delfl = false; }
        virtual _E do_tolower(_E _C) const
                {return ((_E)_Tolower((unsigned char)_C, &_Ctype)); }
        virtual const _E *do_tolower(_E *_F, const _E *_L) const
                {for (; _F != _L; ++_F)
                        *_F = (_E)_Tolower((unsigned char)*_F, &_Ctype);
                return ((const _E *)_F); }
        virtual _E do_toupper(_E _C) const
                {return ((_E)_Toupper((unsigned char)_C, &_Ctype)); }
        virtual const _E *do_toupper(_E *_F, const _E *_L) const
                {for (; _F != _L; ++_F)
                        *_F = (_E)_Toupper((unsigned char)*_F, &_Ctype);
                return ((const _E *)_F); }
        virtual _E do_widen(char _X) const
                {return (_X); }
        virtual const _E *do_widen(const char *_F, const char *_L,
                _E *_V) const
                {memcpy(_V, _F, _L - _F);
                return (_L); }
        virtual _E do_narrow(_E _C, char _D) const
                {return (_C); }
        virtual const _E *do_narrow(const _E *_F, const _E *_L,
                char _D, char *_V) const
                {memcpy(_V, _F, _L - _F);
                return (_L); }
        const mask *table() const throw ()
                {return (_Ctype._Table); }
        static const mask *classic_table() throw ()
                {if (_Cltab == 0)
                        locale::classic();       
                return (_Cltab); }
private:
        _Locinfo::_Ctypevec _Ctype;
        static const mask *_Cltab;
        };

__ExternStaticData template class ctype<char>;

template <>
struct _IsStandardFacet<ctype<char> >
        { enum { value = true }; };
#line 889
template<class _E>
        class ctype_byname : public ctype<_E> {
public:
        explicit ctype_byname(const char *_S, size_t _R = 0)
                : ctype<_E>(_Locinfo(_S), _R) {}
protected:
        virtual ~ctype_byname()
                {}
        };
#line 904
};

#pragma namemangling()

#pragma object_model(pop)
#line 915
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 75 "/usr/vacpp/include/xiosbase"
namespace std {
#line 80
extern const int  _NSTDSTR;
#line 83
class  ios_base {
public:

        class failure : public runtime_error {
        public:
                explicit failure(const string &_S)
                        : runtime_error(_S) {}
                virtual ~failure()
                        {}
        protected:
                virtual void _Doraise() const
                        {throw (*this); }
        };

        enum _Fmtflags {_Skipws = 0x0001, _Unitbuf = 0x0002,
                _Uppercase = 0x0004, _Showbase = 0x0008,
                _Showpoint = 0x0010, _Showpos = 0x0020,
                _Left = 0x0040, _Right = 0x0080, _Internal = 0x0100,
                _Dec = 0x0200, _Oct = 0x0400, _Hex = 0x0800,
                _Scientific = 0x1000, _Fixed = 0x2000, _Boolalpha = 0x4000,
                _Adjustfield = 0x01c0, _Basefield = 0x0e00,
                _Floatfield = 0x3000, _Fmtmask = 0x7fff, _Fmtzero = 0};
        typedef int fmtflags;
        static const fmtflags skipws = _Skipws;
        static const fmtflags unitbuf = _Unitbuf;
        static const fmtflags uppercase = _Uppercase;
        static const fmtflags showbase = _Showbase;
        static const fmtflags showpoint = _Showpoint;
        static const fmtflags showpos = _Showpos;
        static const fmtflags left = _Left;
        static const fmtflags right = _Right;
        static const fmtflags internal = _Internal;
        static const fmtflags dec = _Dec;
        static const fmtflags oct = _Oct;
        static const fmtflags hex = _Hex;
        static const fmtflags scientific = _Scientific;
        static const fmtflags fixed = _Fixed;
        static const fmtflags boolalpha = _Boolalpha;
        static const fmtflags adjustfield = _Adjustfield;
        static const fmtflags basefield = _Basefield;
        static const fmtflags floatfield = _Floatfield;

        enum _Iostate {_Goodbit = 0x0, _Eofbit = 0x1,
                _Failbit = 0x2, _Badbit = 0x4, _Statmask = 0x7};
        typedef int iostate;
        static const iostate goodbit = _Goodbit;
        static const iostate eofbit = _Eofbit;
        static const iostate failbit = _Failbit;
        static const iostate badbit = _Badbit;

        enum _Openmode {_In = 0x01, _Out = 0x02, _Ate = 0x04,
                _App = 0x08, _Trunc = 0x10, _Binary = 0x20};
        typedef int openmode;
        static const openmode in = _In;
        static const openmode out = _Out;
        static const openmode ate = _Ate;
        static const openmode app = _App;
        static const openmode trunc = _Trunc;
        static const openmode binary = _Binary;

        enum seekdir {beg = 0, cur = 1, end = 2};
        enum event {erase_event, imbue_event, copyfmt_event};
        typedef void (*event_callback)(event, ios_base&, int);
        typedef short io_state, open_mode, seek_dir;
#line 149
        class  Init {
        public:
                Init();
                ~Init();
        private:
                static int _Init_cnt;
                };
        ios_base& operator=(const ios_base& _R)
                {if (this != &_R)
                        {_State = _R._State;
                        copyfmt(_R); }
                return (*this); }
        operator void *() const
                {return (fail() ? 0 : (void *)this); }
        bool operator!() const
                {return (fail()); }
        void clear(iostate = goodbit, bool = false);
        void clear(io_state _St)
                {clear((iostate)_St); }
        iostate rdstate() const
                {return (_State); }
        void setstate(iostate _St, bool _Ex = false)
                {if (_St != goodbit)
                        clear((iostate)((int)rdstate() | (int)_St), _Ex); }
        void setstate(io_state _St)
                {setstate((iostate)_St); }
        bool good() const
                {return (rdstate() == goodbit); }
        bool eof() const
                {return ((int)rdstate() & (int)eofbit); }
        bool fail() const
                {return (((int)rdstate()
                        & ((int)badbit | (int)failbit)) != 0); }
        bool bad() const
                {return (((int)rdstate() & (int)badbit) != 0); }
        iostate exceptions() const
                {return (_Except); }
        void exceptions(iostate _Ne)
                {_Except = (iostate)((int)_Ne & (int)_Statmask);
                clear(_State); }
        void exceptions(io_state _St)
                {exceptions((iostate)_St); }
        fmtflags flags() const
                {return (_Fmtfl); }
        fmtflags flags(fmtflags _Nf)
                {fmtflags _Of = _Fmtfl;
                _Fmtfl = (fmtflags)((int)_Nf & (int)_Fmtmask);
                return (_Of); }
        fmtflags setf(fmtflags _Nf)
                {ios_base::fmtflags _Of = _Fmtfl;
                _Fmtfl = (fmtflags)((int)_Fmtfl
                        | (int)_Nf & (int)_Fmtmask);
                return (_Of); }
        fmtflags setf(fmtflags _Nf, fmtflags _M)
                {ios_base::fmtflags _Of = _Fmtfl;
                _Fmtfl = (fmtflags)(((int)_Fmtfl & (int)~_M)
                        | ((int)_Nf & (int)_M & (int)_Fmtmask));
                return (_Of); }
        void unsetf(fmtflags _M)
                {_Fmtfl = (fmtflags)((int)_Fmtfl & (int)~_M); }
        streamsize precision() const
                {return (_Prec); }
        streamsize precision(int _Np)
                {streamsize _Op = _Prec;
                _Prec = _Np;
                return (_Op); }
        streamsize width() const
                {return (_Wide); }
        streamsize width(streamsize _Nw)
                {streamsize _Ow = _Wide;
                _Wide = _Nw;
                return (_Ow); }
        locale getloc() const
                {return (_Loc); }
        locale imbue(const locale&);
        static int xalloc()
                {return (_Index++); }
        long& iword(int _Idx)
                {return (_Findarr(_Idx)._Lo); }
        void *& pword(int _Idx)
                {return (_Findarr(_Idx)._Vp); }
        void register_callback(event_callback, int);
        ios_base& copyfmt(const ios_base&);
        virtual ~ios_base();
        static bool sync_with_stdio(bool _Sfl = true)
                {const bool _Osfl = _Sync;
                _Sync = _Sfl;
                return (_Osfl); }
protected:
        ios_base()
                : _Loc(_Noinit), _Stdstr(0), _Calls(0), _Arr(0) {}
        void _Addstd();
        void _Init();
private:

        struct _Iosarray {
        public:
                _Iosarray(int _Idx, _Iosarray *_Link)
                        : _Next(_Link), _Index(_Idx), _Lo(0), _Vp(0) {}
                _Iosarray *_Next;
                int _Index;
                long _Lo;
                void *_Vp;
                };

        struct _Fnarray {
                _Fnarray(int _Idx, event_callback _P, _Fnarray *_Link)
                        : _Next(_Link), _Index(_Idx), _Pfn(_P) {}
                _Fnarray *_Next;
                int _Index;
                event_callback _Pfn;
                };
        void _Callfns(event);
        _Iosarray& _Findarr(int);
        void _Tidy();
        iostate _State, _Except;
        fmtflags _Fmtfl;
        int _Prec, _Wide;
        _Iosarray *_Arr;
        _Fnarray *_Calls;
        locale _Loc;
        size_t _Stdstr;
        static int _Index;
        static bool _Sync;
        };
#line 283
};

#pragma namemangling()

#pragma object_model(pop)
#line 294
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 75 "/usr/vacpp/include/streambuf"
namespace std {
#line 80
template<class _E, class _Tr>
        class basic_streambuf {
        basic_streambuf(const basic_streambuf<_E, _Tr>&);        
        basic_streambuf<_E, _Tr>&
                operator=(const basic_streambuf<_E, _Tr>&);      
protected:
        basic_streambuf()
                : _Loc() {_Init(); }
        basic_streambuf(_Uninitialized)
                : _Loc(_Noinit) {}
public:
        typedef basic_streambuf<_E, _Tr> _Myt;
        typedef _E char_type;
        typedef _Tr traits_type;
        virtual ~basic_streambuf()
                { }
        typedef typename _Tr::int_type int_type;
        typedef typename _Tr::pos_type pos_type;
        typedef typename _Tr::off_type off_type;
        pos_type pubseekoff(off_type _O, ios_base::seekdir _W,
                ios_base::openmode _M = ios_base::in | ios_base::out)
                {return (seekoff(_O, _W, _M)); }
        pos_type pubseekoff(off_type _O, ios_base::seek_dir _W,
                ios_base::open_mode _M)
                {return (pubseekoff(_O, (ios_base::seekdir)_W,
                        (ios_base::openmode)_M)); }
        pos_type pubseekpos(pos_type _P,
                ios_base::openmode _M = ios_base::in | ios_base::out)
                {return (seekpos(_P, _M)); }
        pos_type pubseekpos(pos_type _P, ios_base::open_mode _M)
                {return (seekpos(_P, (ios_base::openmode)_M)); }
        _Myt *pubsetbuf(_E *_S, streamsize _N)
                {return (setbuf(_S, _N)); }
        locale pubimbue(const locale &_Ln)
                {locale _Lo = _Loc;
                imbue(_Ln);
                _Loc = _Ln;
                return (_Lo); }
        locale getloc()
                {return (_Loc); }
        streamsize in_avail()
                {return (gptr() != 0 && gptr() < egptr()
                        ? egptr() - gptr() : showmanyc()); }
        int pubsync()
                {return (sync()); }
        int_type sbumpc()
                {return (gptr() != 0 && gptr() < egptr()
                        ? _Tr::to_int_type(*_Gninc()) : uflow()); }
        int_type sgetc()
                {return (gptr() != 0 && gptr() < egptr()
                        ? _Tr::to_int_type(*gptr()) : underflow()); }
        streamsize sgetn(_E *_S, streamsize _N)
                {return (xsgetn(_S, _N)); }
        int_type snextc()
                {return (_Tr::eq_int_type(_Tr::eof(), sbumpc())
                        ? _Tr::eof() : sgetc()); }
        int_type sputbackc(_E _C)
                {return (gptr() != 0 && eback() < gptr()
                        && _Tr::eq(_C, gptr()[-1])
                        ? _Tr::to_int_type(*_Gndec())
                        : pbackfail(_Tr::to_int_type(_C))); }
        void stossc()
                {if (gptr() != 0 && gptr() < egptr())
                        _Gninc();
                else
                        uflow(); }
        int_type sungetc()
                {return (gptr() != 0 && eback() < gptr()
                        ? _Tr::to_int_type(*_Gndec()) : pbackfail()); }
        int_type sputc(_E _C)
                {return (pptr() != 0 && pptr() < epptr()
                        ? _Tr::to_int_type(*_Pninc() = _C)
                        : overflow(_Tr::to_int_type(_C))); }
        streamsize sputn(const _E *_S, streamsize _N)
                {return (xsputn(_S, _N)); }

        bool doflush() const
                {return 0 != *_IPcnt; }
#line 162
protected:
        _E *eback() const
                {return (*_IGbeg); }
        _E *gptr() const
                {return (*_IGnext); }
        _E *pbase() const
                {return (*_IPbeg); }
        _E *pptr() const
                {return (*_IPnext); }

        _E *egptr() const
                {return (*_IGnext + *_IGcnt); }
        void gbump(int _N)
                {*_IGcnt -= _N;
                *_IGnext += _N; }
        void setg(_E *_B, _E *_N, _E *_L)
                {*_IGbeg = _B, *_IGnext = _N, *_IGcnt = _L - _N; }
        _E *epptr() const
                {return (*_IPnext + *_IPcnt); }
        _E *_Gndec()
                {++*_IGcnt;
                return (--*_IGnext); }
        _E *_Gninc()
                {--*_IGcnt;
                return ((*_IGnext)++); }
        void pbump(int _N)
                {*_IPcnt -= _N;
                *_IPnext += _N; }
        void setp(_E *_B, _E *_L)
                {*_IPbeg = _B, *_IPnext = _B, *_IPcnt = _L - _B; }
        void setp(_E *_B, _E *_N, _E *_L)
                {*_IPbeg = _B, *_IPnext = _N, *_IPcnt = _L - _N; }
        _E *_Pninc()
                {--*_IPcnt;
                return ((*_IPnext)++); }
        void _Init()
                {_IGbeg = &_Gbeg, _IPbeg = &_Pbeg;
                _IGnext = &_Gnext, _IPnext = &_Pnext;
                _IGcnt = &_Gcnt, _IPcnt = &_Pcnt;
                setp(0, 0), setg(0, 0, 0); }
#line 209
        void _Init(_E **_Gb, _E **_Gn, int *_Gc,
                _E **_Pb, _E **_Pn, int *_Pc)
                {_IGbeg = _Gb, _IPbeg = _Pb;
                _IGnext = _Gn, _IPnext = _Pn;
                _IGcnt = _Gc, _IPcnt = _Pc; }
#line 248
        virtual int_type overflow(int_type = _Tr::eof())
                {return (_Tr::eof()); }
        virtual int_type pbackfail(int_type = _Tr::eof())
                {return (_Tr::eof()); }
        virtual streamsize showmanyc()
                {return (0); }
        virtual int_type underflow()
                {return (_Tr::eof()); }
        virtual int_type uflow()
                {return (_Tr::eq_int_type(_Tr::eof(), underflow())
                        ? _Tr::eof() : _Tr::to_int_type(*_Gninc())); }
        virtual streamsize xsgetn(_E * _S, streamsize _N)
                {int_type _C;
                streamsize _M, _Ns;
                for (_Ns = 0; 0 < _N; )
                        if (gptr() != 0 && 0 < (_M = egptr() - gptr()))
                                {if (_N < _M)
                                        _M = _N;
                                _Tr::copy(_S, gptr(), _M);
                                _S += _M, _Ns += _M, _N -= _M, gbump(_M); }
                        else if (_Tr::eq_int_type(_Tr::eof(), _C = uflow()))
                                break;
                        else
                                *_S++ = _Tr::to_char_type(_C), ++_Ns, --_N;
                return (_Ns); }
        virtual streamsize xsputn(const _E *_S, streamsize _N)
                {streamsize _M, _Ns;
                for (_Ns = 0; 0 < _N; )
                        if (pptr() != 0 && 0 < (_M = epptr() - pptr()))
                                {if (_N < _M)
                                        _M = _N;
                                _Tr::copy(pptr(), _S, _M);
                                _S += _M, _Ns += _M, _N -= _M, pbump(_M); }
                        else if (_Tr::eq_int_type(_Tr::eof(),
                                overflow(_Tr::to_int_type(*_S))))
                                break;
                        else
                                ++_S, ++_Ns, --_N;
                return (_Ns); }
        virtual pos_type seekoff(off_type, ios_base::seekdir,
                ios_base::openmode = ios_base::in | ios_base::out)
                {return (streampos(_BADOFF)); }
        virtual pos_type seekpos(pos_type,
                ios_base::openmode = ios_base::in | ios_base::out)
                {return (streampos(_BADOFF)); }
        virtual _Myt *setbuf(_E *, streamsize)
                {return (this); }
        virtual int sync()
                {return (0); }
        virtual void imbue(const locale& _Loc)
                {}
private:
#line 306
        _E *_Gbeg, *_Pbeg;
        _E **_IGbeg, **_IPbeg;
        _E *_Gnext, *_Pnext;
        _E **_IGnext, **_IPnext;
#line 312
        int _Gcnt, _Pcnt;
        int *_IGcnt, *_IPcnt;
#line 318
        locale _Loc;
        };
#line 326
};

#pragma namemangling()

#pragma object_model(pop)
#line 337
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 79 "/usr/vacpp/include/xlocnum"
namespace std {
#line 85
template<class _E>
        class numpunct : public locale::facet {
public:
        typedef basic_string<_E, char_traits<_E>, allocator<_E> >
                string_type;
        typedef _E char_type;
        static locale::id id;
        _E decimal_point() const
                {return (do_decimal_point()); }
        _E thousands_sep() const
                {return (do_thousands_sep()); }
        string grouping() const
                {return (do_grouping()); }
        string_type falsename() const
                {return (do_falsename()); }
        string_type truename() const
                {return (do_truename()); }
        explicit numpunct(size_t _R = 0)
                : locale::facet(_R) {_Init(_Locinfo()); }
        numpunct(const _Locinfo& _Lobj, size_t _R = 0)
                : locale::facet(_R) {_Init(_Lobj); }
        static size_t _Getcat(const locale::facet **_Ppf = 0)
                {if (_Ppf != 0 && *_Ppf == 0)
                        *_Ppf = new numpunct<_E>;
                return (3); }
protected:
        virtual ~numpunct()
                {delete[] _Gr;
                delete[] _Nf;
                delete[] _Nt; }
protected:
        void _Init(const _Locinfo& _Lobj)

                {const lconv *_P = _Lobj._Getnumpunct();
#line 122
                _Dp = _Widen(_P->decimal_point[0], (_E *)0);
                 if (!_GetCatName((1 << (3)), _Lobj._Getname().c_str())
                         .compare("C"))
                         {_Ks = _Widen(',', (_E *)0); }
                 else
                         {_Ks = _Widen(_P->thousands_sep[0], (_E *)0); }
                _Gr = _Maklocstr(_P->grouping, (char *)0);
                _Nf = _Maklocstr(_Lobj._Getfalse(), (_E *)0);
                _Nt = _Maklocstr(_Lobj._Gettrue(), (_E *)0); }
        virtual _E do_decimal_point() const
                {return (_Dp); }
        virtual _E do_thousands_sep() const
                {return (_Ks); }
        virtual string do_grouping() const
                {return (string(_Gr)); }
        virtual string_type do_falsename() const
                {return (string_type(_Nf)); }
        virtual string_type do_truename() const
                {return (string_type(_Nt)); }
private:
        char *_Gr;
        _E _Dp, _Ks, *_Nf, *_Nt;
        };

typedef numpunct<char> _Npc;
typedef numpunct<wchar_t> _Npwc;

__ExternStaticData template class numpunct<char>;
__ExternStaticData template class numpunct<wchar_t>;

template <>
struct _IsStandardFacet<numpunct<char> >
        { enum { value = true }; };

template <>
struct _IsStandardFacet<numpunct<wchar_t> >
        { enum { value = true }; };
#line 161
template<class _E>
        class numpunct_byname : public numpunct<_E> {
public:
        explicit numpunct_byname(const char *_S, size_t _R = 0)
                : numpunct<_E>(_Locinfo(_S), _R) {}
protected:
        virtual ~numpunct_byname()
                {}
        };

template<class _E>
        locale::id numpunct<_E>::id;
#line 177
template<class _E,
        class _II = istreambuf_iterator<_E, char_traits<_E> > >
        class num_get : public locale::facet {
public:
        typedef numpunct<_E> _Mypunct;
        typedef basic_string<_E, char_traits<_E>, allocator<_E> >
                _Mystr;
        static size_t _Getcat(const locale::facet **_Ppf = 0)
                {if (_Ppf != 0 && *_Ppf == 0)
                        *_Ppf = new num_get<_E, _II>;
                return (3); }
        static locale::id id;
protected:
        virtual ~num_get()
                {}
protected:
        void _Init(const _Locinfo& _Lobj)
                {}
public:
        explicit num_get(size_t _R = 0)
                : locale::facet(_R) {_Init(_Locinfo()); }
        num_get(const _Locinfo& _Lobj, size_t _R = 0)
                : locale::facet(_R) {_Init(_Lobj); }
        typedef _E char_type;
        typedef _II iter_type;
        _II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
                _Bool& _V) const
                {return (do_get(_F, _L, _X, _St, _V)); }
        _II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
                unsigned short& _V) const
                {return (do_get(_F, _L, _X, _St, _V)); }
        _II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
                unsigned int& _V) const
                {return (do_get(_F, _L, _X, _St, _V)); }
        _II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
                long& _V) const
                {return (do_get(_F, _L, _X, _St, _V)); }
        _II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
                unsigned long& _V) const
                {return (do_get(_F, _L, _X, _St, _V)); }

        _II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
                long long& _V) const
                {return (do_get(_F, _L, _X, _St, _V)); }
        _II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
                unsigned long long& _V) const
                {return (do_get(_F, _L, _X, _St, _V)); }

        _II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
                float& _V) const
                {return (do_get(_F, _L, _X, _St, _V)); }
        _II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
                double& _V) const
                {return (do_get(_F, _L, _X, _St, _V)); }
        _II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
                long double& _V) const
                {return (do_get(_F, _L, _X, _St, _V)); }
        _II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
                void *& _V) const
                {return (do_get(_F, _L, _X, _St, _V)); }
protected:
        virtual _II do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, _Bool& _V) const
                {int _Ans = -1;
                if (_X.flags() & ios_base::boolalpha)
                        {const _Mypunct& _Fac = use_facet<_Mypunct >(_X.getloc());
                        _Mystr _Str((typename _Mystr::size_type)1,
                                (char_type)0);
                        _Str += _Fac.falsename();
                        _Str += (char_type)0;
                        _Str += _Fac.truename();
                        _Ans = _Getloctxt(_F, _L, (size_t)2, _Str.c_str()); }
                else
                        {char _Ac[32], * _Ep;
                        errno = 0;
                        const unsigned long _Ulo = strtoul(_Ac, &_Ep,
                                _Getifld(_Ac, _F, _L, _X.flags(), _X.getloc(),
                                32));
                        if (_Ep != _Ac && errno == 0 && _Ulo <= 1)
                                _Ans = _Ulo; }
                if (_F == _L)
                        _St |= ios_base::eofbit;
                if (_Ans < 0)
                        _St |= ios_base::failbit;
                else
                        _V = _Ans != 0;
                return (_F); }
        virtual _II do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, unsigned short& _V) const
                {char _Ac[32], * _Ep;
                errno = 0;
                int _Base =
                        _Getifld(_Ac, _F, _L, _X.flags(), _X.getloc(),
                                 32);
                char *_S = _Ac[0] == '-' ? _Ac + 1 : _Ac;
                const unsigned long _Ans = strtoul(_S, &_Ep, _Base);
                if (_F == _L)
                        _St |= ios_base::eofbit;
                if (_Ep == _S || errno != 0 || (65535) < _Ans)
                        _St |= ios_base::failbit;
                else
                        _V = (unsigned short)(_Ac[0] == '-'
                                ? 0 -_Ans : _Ans);
                return (_F); }
        virtual _II do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, unsigned int& _V) const
                {char _Ac[32], * _Ep;
                errno = 0;
                int _Base =
                        _Getifld(_Ac, _F, _L, _X.flags(), _X.getloc(),
                                 32);
                char *_S = _Ac[0] == '-' ? _Ac + 1 : _Ac;
                const unsigned long _Ans = strtoul(_S, &_Ep, _Base);
                if (_F == _L)
                        _St |= ios_base::eofbit;
                if (_Ep == _S || errno != 0 || (4294967295U) < _Ans)
                        _St |= ios_base::failbit;
                else
                        _V = _Ac[0] == '-' ? 0 - _Ans : _Ans;
                return (_F); }
        virtual _II do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, long& _V) const
                {char _Ac[32], * _Ep;
                errno = 0;
                const long _Ans = strtol(_Ac, &_Ep,
                        _Getifld(_Ac, _F, _L, _X.flags(), _X.getloc(),
                                 32));
                if (_F == _L)
                        _St |= ios_base::eofbit;
                if (_Ep == _Ac || errno != 0)
                        _St |= ios_base::failbit;
                else
                        _V = _Ans;
                return (_F); }
        virtual _II do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, unsigned long& _V) const
                {char _Ac[32], * _Ep;
                errno = 0;
                const unsigned long _Ans = strtoul(_Ac, &_Ep,
                        _Getifld(_Ac, _F, _L, _X.flags(), _X.getloc(),
                                 32));
                if (_F == _L)
                        _St |= ios_base::eofbit;
                if (_Ep == _Ac || errno != 0)
                        _St |= ios_base::failbit;
                else
                        _V = _Ans;
                return (_F); }

         _II do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, long long& _V) const
                {char _Ac[64], * _Ep;
                errno = 0;
                const long long _Ans = strtoll(_Ac, &_Ep,
                        _Getifld(_Ac, _F, _L, _X.flags(), _X.getloc(),
                                 64));
                if (_F == _L)
                        _St |= ios_base::eofbit;
                if (_Ep == _Ac || errno != 0)
                        _St |= ios_base::failbit;
                else
                        _V = _Ans;
                return (_F); }
         _II do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, unsigned long long& _V) const
                {char _Ac[64], * _Ep;
                errno = 0;
                const unsigned long long _Ans = strtoull(_Ac, &_Ep,
                        _Getifld(_Ac, _F, _L, _X.flags(), _X.getloc(),
                        64));
                if (_F == _L)
                        _St |= ios_base::eofbit;
                if (_Ep == _Ac || errno != 0)
                        _St |= ios_base::failbit;
                else
                        _V = _Ans;
                return (_F); }

        virtual _II do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, float& _V) const
                {char _Ac[8 + 36 + 16], *_Ep;
                errno = 0;
                const float _Ans = _Stof(_Ac, &_Ep,
                        _Getffld(_Ac, _F, _L, _X.getloc()));
                if (_F == _L)
                        _St |= ios_base::eofbit;
                if (_Ep == _Ac || errno != 0)
                        _St |= ios_base::failbit;
                else
                        _V = _Ans;
                return (_F); }
        virtual _II do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, double& _V) const
                {char _Ac[8 + 36 + 16], *_Ep;
                errno = 0;
                const double _Ans = _Stod(_Ac, &_Ep,
                        _Getffld(_Ac, _F, _L, _X.getloc()));
                if (_F == _L)
                        _St |= ios_base::eofbit;
                if (_Ep == _Ac || errno != 0)
                        _St |= ios_base::failbit;
                else
                        _V = _Ans;
                return (_F); }
        virtual _II do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, long double& _V) const
                {char _Ac[8 + 36 + 16], *_Ep;
                errno = 0;
                const long double _Ans = _Stold(_Ac, &_Ep,
                        _Getffld(_Ac, _F, _L, _X.getloc()));
                if (_F == _L)
                        _St |= ios_base::eofbit;
                if (_Ep == _Ac || errno != 0)
                        _St |= ios_base::failbit;
                else
                        _V = _Ans;
                return (_F); }
        virtual _II do_get(_II _F, _II _L, ios_base& _X,
                ios_base::iostate& _St, void *& _V) const
                {union _Pvlo {
                        void *_Pv;
                        unsigned long _Lo[1 +
                                (sizeof (void *) - 1) / sizeof (unsigned long)];
                        } _U;
                const int _NL = sizeof (_U._Lo) / sizeof (unsigned long);
                for (int _I = 0; ; ++_F)
                        {char _Ac[32], * _Ep;
                        errno = 0;
                        _U._Lo[_I] = strtoul(_Ac, &_Ep,
                                _Getifld(_Ac, _F, _L,
                                        ios_base::hex, _X.getloc(),
                                        32));
                        if (_F == _L)
                                _St |= ios_base::eofbit;
                        if (_Ep == _Ac || errno != 0)
                                {_St |= ios_base::failbit;
                                break; }
                        if (_NL <= ++_I)
                                break;
                        if (_F == _L || *_F != _Widen(':', (_E *)0))
                                {_St |= ios_base::failbit;
                                break; }}
                if (!(_St & ios_base::failbit))
                        _V = _U._Pv;
                return (_F); }
private:
        static int _Getifld(char *_Ac, _II& _F, _II& _L,
                ios_base::fmtflags _Bfl, const locale& _Loc,
                unsigned int _MaxDigits)
                {const _E _E0 = _Widen('0', (_E *)0);
                const _Mypunct& _Fac = use_facet<_Mypunct >(_Loc);
                const string _Gr = _Fac.grouping();
                const _E _Ks = _Fac.thousands_sep();
                char *_P = _Ac;
                if (_F == _L)
                        ;
                else if (*_F == _Widen('+', (_E *)0))
                        *_P++ = '+', ++_F;
                else if (*_F == _Widen('-', (_E *)0))
                        *_P++ = '-', ++_F;
                _Bfl &= ios_base::basefield;
                int _Base = _Bfl == ios_base::oct ? 8
                        : _Bfl == ios_base::hex ? 16
                        : _Bfl == ios_base::_Fmtzero ? 0 : 10;
                bool _Sd = false, _Snz = false;
                if (_F != _L && *_F == _E0)
                        {_Sd = true, ++_F;
                        if (_F != _L && (*_F == _Widen('x', (_E *)0)
                                        || *_F == _Widen('X', (_E *)0))
                                && (_Base == 0 || _Base == 16))
                                _Base = 16, _Sd = false, ++_F;
                        else if (_Base == 0)
                                _Base = 8; }
                int _Dlen = _Base == 0 || _Base == 10 ? 10
                        : _Base == 8 ? 8 : 16 + 6;
                string _Grin((size_t)1, (char)_Sd);
                size_t _I = 0;
                for (char *const _Pe = &_Ac[_MaxDigits - 1];
                        _F != _L; ++_F)
                        if (memchr("0123456789abcdefABCDEF",
                                *_P = _Narrow(static_cast<_E>(*_F)), _Dlen) != 0)
                                {if ((_Snz || *_P != '0') && _P < _Pe)
                                        ++_P, _Snz = true;
                                _Sd = true;
                                if (_Grin[_I] != (255))
                                        ++_Grin[_I]; }
                        else if (_Grin[_I] == '\0' || _Ks == (_E)0
                                || *_F != _Ks || _Gr.length() == 0)
                                break;
                        else
                                _Grin.append((string::size_type)1, '\0'), ++_I;
                if (_I == 0)
                        ;
                else if ('\0' < _Grin[_I])
                        ++_I;
                else
                        _Sd = false;
                for (const char *_Pg = _Gr.c_str(); _Sd && 0 < _I; )
                        if (*_Pg == (255))
                                break;
                        else if (0 < --_I && *_Pg != _Grin[_I]
                                || 0 == _I && *_Pg < _Grin[_I])
                                _Sd = false;
                        else if ('\0' < _Pg[1])
                                ++_Pg;
                if (_Sd && !_Snz)
                        *_P++ = '0';
                else if (!_Sd)
                        _P = _Ac;
                *_P = '\0';
                return (_Base);
                }
        static int _Getffld(char *_Ac, _II& _F, _II &_L,
                const locale& _Loc)
                {const _E _E0 = _Widen('0', (_E *)0);
                const _Mypunct& _Fac = use_facet<_Mypunct >(_Loc);
                char *_P = _Ac;
                if (_F == _L)
                        ;
                else if (*_F == _Widen('+', (_E *)0))
                        *_P++ = '+', ++_F;
                else if (*_F == _Widen('-', (_E *)0))
                        *_P++ = '-', ++_F;
                bool _Sd = false;
                for (; _F != _L && *_F == _E0; _Sd = true, ++_F)
                        ;
                if (_Sd)
                        *_P++ = '0';
                int _Ns = 0;
                int _Pten = 0;
                for (; _F != _L
                        && (:: isdigit)(*_P = _Narrow(static_cast<_E>(*_F)));
                        _Sd = true, ++_F)
                        if (_Ns < 36)
                                ++_P, ++_Ns;
                        else
                                ++_Pten;
                if (_F != _L && *_F == _Fac.decimal_point())
                        *_P++ = localeconv()->decimal_point[0], ++_F;
                if (_Ns == 0)
                        {for (; _F != _L && *_F == _E0; _Sd = true, ++_F)
                                --_Pten;
                        if (_Pten < 0)
                                *_P++ = '0', ++_Pten; }
                for (; _F != _L
                        && (:: isdigit)(*_P = _Narrow(static_cast<_E>(*_F)));
                        _Sd = true, ++_F)
                        if (_Ns < 36)
                                ++_P, ++_Ns;
                if (_Sd && _F != _L
                        && (*_F == _Widen('e', (_E *)0)
                                || *_F == _Widen('E', (_E *)0)))
                        {*_P++ = 'e', ++_F;
                        _Sd = false, _Ns = 0;
                        if (_F == _L)
                                ;
                        else if (*_F == _Widen('+', (_E *)0))
                                *_P++ = '+', ++_F;
                        else if (*_F == _Widen('-', (_E *)0))
                                *_P++ = '-', ++_F;
                        for (; _F != _L && *_F == _E0; _Sd = true, ++_F)
                                ;
                        if (_Sd)
                                *_P++ = '0';
                        for (; _F != _L
                                && (:: isdigit)(*_P = _Narrow(static_cast<_E>(*_F)));
                                _Sd = true, ++_F)
                                if (_Ns < 8)
                                        ++_P, ++_Ns; }
                if (!_Sd)
                        _P = _Ac;
                *_P = '\0';
                return (_Pten);
                };
        };
template<class _E, class _II>
        locale::id num_get<_E, _II>::id;

__ExternStaticData template class num_get<char , istreambuf_iterator<char , char_traits<char> > >;
__ExternStaticData template class num_get<wchar_t , istreambuf_iterator<wchar_t , char_traits<wchar_t> > >;

template <>
struct _IsStandardFacet<num_get<char> >
        { enum { value = true }; };

template <>
struct _IsStandardFacet<num_get<wchar_t> >
        { enum { value = true }; };
#line 567
template<class _E,
        class _OI = ostreambuf_iterator<_E, char_traits<_E> > >
        class num_put : public locale::facet {
public:
        typedef numpunct<_E> _Mypunct;
        typedef basic_string<_E, char_traits<_E>, allocator<_E> >
                _Mystr;
        static size_t _Getcat(const locale::facet **_Ppf = 0)
                {if (_Ppf != 0 && *_Ppf == 0)
                        *_Ppf = new num_put<_E, _OI>;
                return (3); }
        static locale::id id;
protected:
        virtual ~num_put()
                {}
protected:
        void _Init(const _Locinfo& _Lobj)
                {}
public:
        explicit num_put(size_t _R = 0)
                : locale::facet(_R) {_Init(_Locinfo()); }
        num_put(const _Locinfo& _Lobj, size_t _R = 0)
                : locale::facet(_R) {_Init(_Lobj); }
        typedef _E char_type;
        typedef _OI iter_type;
        _OI put(_OI _F, ios_base& _X, _E _Fill,
                _Bool _V) const
                {return (do_put(_F, _X, _Fill, _V)); }
        _OI put(_OI _F, ios_base& _X, _E _Fill,
                long _V) const
                {return (do_put(_F, _X, _Fill, _V)); }
        _OI put(_OI _F, ios_base& _X, _E _Fill,
                unsigned long _V) const
                {return (do_put(_F, _X, _Fill, _V)); }

        _OI put(_OI _F, ios_base& _X, _E _Fill,
                long long _V) const
                {return (do_put(_F, _X, _Fill, _V)); }
        _OI put(_OI _F, ios_base& _X, _E _Fill,
                unsigned long long _V) const
                {return (do_put(_F, _X, _Fill, _V)); }

        _OI put(_OI _F, ios_base& _X, _E _Fill,
                double _V) const
                {return (do_put(_F, _X, _Fill, _V)); }
        _OI put(_OI _F, ios_base& _X, _E _Fill,
                long double _V) const
                {return (do_put(_F, _X, _Fill, _V)); }
        _OI put(_OI _F, ios_base& _X, _E _Fill,
                const void *_V) const
                {return (do_put(_F, _X, _Fill, _V)); }
protected:
        virtual _OI do_put(_OI _F, ios_base& _X, _E _Fill,
                _Bool _V) const
                {const _Mypunct& _Fac = use_facet<_Mypunct >(_X.getloc());
                _Mystr _Str;
                if (!(_X.flags() & ios_base::boolalpha))
		    {char _Buf[2 * 32], _Fmt[6];
                    return (_Iput(_F, _X, _Fill, _Buf,
                    sprintf(_Buf, _Ifmt(_Fmt, 'd', _X.flags()), _V?1L:0L)));}
		if (_V)
                        _Str = _Fac.truename();
                else
                        _Str = _Fac.falsename();
                size_t _M = _X.width() <= 0
                        || (size_t)_X.width() <= _Str.size()
                                ? 0 : (size_t)_X.width() - _Str.size();
                ios_base::fmtflags _Afl =
                        _X.flags() & ios_base::adjustfield;
                if (_Afl != ios_base::left)
                        _F = _Rep(_F, _Fill, _M), _M = 0;
                _F = _Put(_F, _Str.c_str(), _Str.size());
                _X.width(0);
                return (_Rep(_F, _Fill, _M)); }
        virtual _OI do_put(_OI _F, ios_base& _X, _E _Fill,
                long _V) const
                {char _Buf[2 * 32], _Fmt[6];
                return (_Iput(_F, _X, _Fill, _Buf,
                        sprintf(_Buf, _Ifmt(_Fmt, 'd', _X.flags()), _V))); }
        virtual _OI do_put(_OI _F, ios_base& _X, _E _Fill,
                unsigned long _V) const
                {char _Buf[2 * 32], _Fmt[6];
                return (_Iput(_F, _X, _Fill, _Buf,
                        sprintf(_Buf, _Ifmt(_Fmt, 'u', _X.flags()), _V))); }

         _OI do_put(_OI _F, ios_base& _X, _E _Fill,
                long long _V) const
                {char _Buf[2 * 64], _Fmt[7];
                return (_Iput(_F, _X, _Fill, _Buf,
                        sprintf(_Buf, _Lfmt(_Fmt, 'd', _X.flags()), _V))); }
         _OI do_put(_OI _F, ios_base& _X, _E _Fill,
                unsigned long long _V) const
                {char _Buf[2 * 64], _Fmt[7];
                return (_Iput(_F, _X, _Fill, _Buf,
                        sprintf(_Buf, _Lfmt(_Fmt, 'u', _X.flags()), _V))); }

        virtual _OI do_put(_OI _F, ios_base& _X, _E _Fill,
                double _V) const
                { return _DoPutFloat(_F, _X, _Fill, _V, 0); }
        virtual _OI do_put(_OI _F, ios_base& _X, _E _Fill,
                long double _V) const
                { return _DoPutFloat(_F, _X, _Fill, _V, 'L'); }
        virtual _OI do_put(_OI _F, ios_base& _X, _E _Fill,
                const void *_V) const
                {
                const int _NL = 1
                        + (sizeof (void *) - 1) / sizeof (unsigned long);
                char _Buf[(_NL + 1) * (32 + 1)];
                int _N = sprintf(_Buf, "%p", _V);
                size_t _M = _X.width() <= 0 || _X.width() <= _N
                        ? 0 : (size_t)_X.width() - _N;
                ios_base::fmtflags _Afl =
                        _X.flags() & ios_base::adjustfield;
                if (_Afl != ios_base::left)
                        _F = _Rep(_F, _Fill, _M), _M = 0;
                _F = _Putc(_F, _Buf, _N);
                _X.width(0);
                return (_Rep(_F, _Fill, _M)); }
        template <class _FltType>
        _OI _DoPutFloat(_OI _F, ios_base& _X, _E _Fill,
                _FltType _V, const char _Spec) const
                {const size_t _BufSize = 8 + 36 + 16;
                char _Buf[_BufSize], _Fmt[8];
                char * _BufPtr = _Buf;
                streamsize _Prec = _X.precision() <= 0
                        && !(_X.flags() & ios_base::fixed) ? 6
                        : _X.precision();
                int _Mpr = 36 < _Prec ? 36 : _Prec;
                _Ffmt(_Fmt, _Spec, _X.flags());
#line 701
                int _C = snprintf(_BufPtr, _BufSize, _Fmt, _Mpr, _V);
                if (_C >= _BufSize)
                        {_BufPtr = new char[_C + 1];
                     snprintf(_BufPtr, _C + 1, _Fmt, _Mpr, _V); }
                _OI _Ret(_Fput(_F, _X, _Fill, _BufPtr, _Prec - _Mpr, _C));
                if (_BufPtr != _Buf) {delete [] _BufPtr;}

                return _Ret; }
        static char *_Ffmt(char *_Fmt, char _Spec,
                ios_base::fmtflags _Fl)
                {char *_S = _Fmt;
                *_S++ = '%';
                if (_Fl & ios_base::showpos)
                        *_S++ = '+';
                if (_Fl & ios_base::showpoint)
                        *_S++ = '#';
                *_S++ = '.';
                *_S++ = '*';
                if (_Spec != 0)
                        *_S++ = _Spec;   
                ios_base::fmtflags _Ffl = _Fl & ios_base::floatfield;
                *_S++ = _Ffl == ios_base::fixed ? 'f'
                        : _Ffl == ios_base::scientific ? 'e' : 'g';
                *_S = '\0';
                return (_Fmt); }
        static _OI _Fput(_OI _F, ios_base& _X, _E _Fill,
                const char *_S, size_t _Nz, size_t _N)
                {size_t _M = _X.width() <= 0
                        || (size_t)_X.width() <= _N  + _Nz
                                ? 0 : (size_t)_X.width() - _N - _Nz;
                ios_base::fmtflags _Afl =
                        _X.flags() & ios_base::adjustfield;
                if (_Afl != ios_base::left && _Afl != ios_base::internal)
                        _F = _Rep(_F, _Fill, _M), _M = 0;
                else if (_Afl == ios_base::internal)
                        {if (0 < _N && (*_S == '+' || *_S == '-'))
                                _F = _Putc(_F, _S, 1), ++_S, --_N;
                        _F = _Rep(_F, _Fill, _M), _M = 0; }
                const char *_P = (const char *)memchr(_S,
                        localeconv()->decimal_point[0], _N);
                if (_P != 0)
                        {const _Mypunct& _Fac = use_facet<_Mypunct >(_X.getloc());
                        size_t _Nf = _P - _S + 1;
                        _F = _Putc(_F, _S, _Nf - 1);
                        _F = _Rep(_F, _Fac.decimal_point(), 1);
                        _S += _Nf, _N -= _Nf; }
                if ((_P = (const char *)memchr(_S, 'e', _N)) != 0)
                        {size_t _Nm = _P - _S + 1;
                        _F = _Putc(_F, _S, _Nm - 1);
                        _F = _Rep(_F, _Widen('0', (_E *)0), _Nz), _Nz = 0;
                        _F = _Putc(_F, _X.flags() & ios_base::uppercase
                                ? "E" : "e", 1);
                        _S += _Nm, _N -= _Nm; }
                _F = _Putc(_F, _S, _N);
                _F = _Rep(_F, _Widen('0', (_E *)0), _Nz);
                _X.width(0);
                return (_Rep(_F, _Fill, _M)); }
        static char *_Ifmt(char *_Fmt, char _Spec,
                ios_base::fmtflags _Fl)
                {char *_S = _Fmt;
                *_S++ = '%';
                if (_Fl & ios_base::showpos)
                        *_S++ = '+';
                if (_Fl & ios_base::showbase)
                        *_S++ = '#';
                *_S++ = 'l';
                ios_base::fmtflags _Bfl = _Fl & ios_base::basefield;
                *_S++ = _Bfl == ios_base::oct ? 'o'
                        : _Bfl != ios_base::hex ? _Spec  
                        : _Fl & ios_base::uppercase ? 'X' : 'x';
                *_S = '\0';
                return (_Fmt); }
        static _OI _Iput(_OI _F, ios_base& _X, _E _Fill,
                char *_S, size_t _N)
                {const size_t _Np = *_S == '+' || *_S == '-' ? 1
                        : *_S == '0' && (_S[1] == 'x' || _S[1] == 'X') ? 2
                        : 0;
                const _Mypunct& _Fac = use_facet<_Mypunct >(_X.getloc());
                const string _Gr = _Fac.grouping();
                const _E _Ks = _Fac.thousands_sep();
                bool _Grp = '\0' < *_Gr.c_str();
                if (_Grp)
                        {const char *_Pg = _Gr.c_str();
                        size_t _I = _N;
                        for (_Grp = false; *_Pg != (255) && '\0' < *_Pg
                                && (size_t)*_Pg < _I - _Np; _Grp = true)
                                {_I -= *_Pg;
                                memmove(&_S[_I + 1], &_S[_I], _N + 1 - _I);
                                _S[_I] = ',', ++_N;
                                if ('\0' < _Pg[1])
                                        ++_Pg; }}
                size_t _M = _X.width() <= 0
                        || (size_t)_X.width() <= _N
                                ? 0 : (size_t)_X.width() - _N;
                ios_base::fmtflags _Afl =
                        _X.flags() & ios_base::adjustfield;
                if (_Afl != ios_base::left && _Afl != ios_base::internal)
                        _F = _Rep(_F, _Fill, _M), _M = 0;
                else if (_Afl == ios_base::internal)
                        {_F = _Putc(_F, _S, _Np), _S += _Np, _N -= _Np;
                        _F = _Rep(_F, _Fill, _M), _M = 0; }
                if (!_Grp)
                        _F = _Putc(_F, _S, _N);
                else
                        for (; ; ++_S, --_N)
                                {size_t _Nd = strcspn(_S, ",");
                                _F = _Putc(_F, _S, _Nd);
                                _S += _Nd, _N -= _Nd;
                                if (_N == 0)
                                        break;
                                if (_Ks != (_E)0)
                                        _F = _Rep(_F, _Ks, 1); }
                _X.width(0);
                return (_Rep(_F, _Fill, _M)); }

        static char *_Lfmt(char *_Fmt, char _Spec,
                ios_base::fmtflags _Fl)
                {char *_S = _Fmt;
                *_S++ = '%';
                if (_Fl & ios_base::showpos)
                        *_S++ = '+';
                if (_Fl & ios_base::showbase)
                        *_S++ = '#';

                *_S++ = 'l';
                *_S++ = 'l';
#line 830
                ios_base::fmtflags _Bfl = _Fl & ios_base::basefield;
                *_S++ = _Bfl == ios_base::oct ? 'o'
                        : _Bfl != ios_base::hex ? _Spec  
                        : _Fl & ios_base::uppercase ? 'X' : 'x';
                *_S = '\0';
                return (_Fmt); }

        static _OI _Put(_OI _F, const _E *_S, size_t _N)
                {for (; 0 < _N; --_N, ++_F, ++_S)
                        *_F = *_S;
                return (_F); }
        static _OI _Putc(_OI _F, const char *_S, size_t _N)
                {for (; 0 < _N; --_N, ++_F, ++_S)
                        *_F = _Widen(*_S, (_E *)0);
                return (_F); }
        static _OI _Rep(_OI _F, _E _C, size_t _N)
                {for (; 0 < _N; --_N, ++_F)
                        *_F = _C;
                return (_F); }
        };
template<class _E, class _OI>
        locale::id num_put<_E, _OI>::id;

__ExternStaticData template class num_put<char , ostreambuf_iterator<char , char_traits<char> > >;
__ExternStaticData template class num_put<wchar_t , ostreambuf_iterator<wchar_t , char_traits<wchar_t> > >;

template <>
struct _IsStandardFacet<num_put<char> >
        { enum { value = true }; };

template <>
struct _IsStandardFacet<num_put<wchar_t> >
        { enum { value = true }; };
#line 870
};

#pragma namemangling()

#pragma object_model(pop)
#line 881
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 76 "/usr/vacpp/include/ios"
namespace std {
#line 81
template<class _E, class _Tr>
        class basic_ios : public ios_base {
public:
        typedef basic_ios<_E, _Tr> _Myt;
        typedef basic_ostream<_E, _Tr> _Myos;
        typedef basic_streambuf<_E, _Tr> _Mysb;
        typedef ctype<_E> _Ctype;
        explicit basic_ios(_Mysb *_S)
                {init(_S); }
        virtual ~basic_ios()
                {}
        typedef _E char_type;
        typedef _Tr traits_type;
        typedef typename _Tr::int_type int_type;
        typedef typename _Tr::pos_type pos_type;
        typedef typename _Tr::off_type off_type;
        void clear(iostate _St, bool _Ex)
                {ios_base::clear((iostate)(_Sb == 0
                        ? (int)_St | (int)badbit : (int)_St), _Ex); }
        void clear(io_state _St)
                {clear((iostate)_St, false); }
        void clear(iostate _St = goodbit)
                {clear(_St, false); }
        void setstate(iostate _St, bool _Ex)
                {if (_St != goodbit)
                        clear((iostate)((int)rdstate() | (int)_St), _Ex); }
        void setstate(io_state _St)
                {setstate((iostate)_St, false); }
        void setstate(iostate _St)
                {setstate(_St, false); }
        _Myt& copyfmt(const _Myt& _R)
                {_Tiestr = _R.tie();
                _Fillch = _R.fill();
                ios_base::copyfmt(_R);
                return (*this); }
        _Myos *tie() const
                {return (_Tiestr); }
        _Myos *tie(_Myos *_N)
                {_Myos *_O = _Tiestr;
                _Tiestr = _N;
                return (_O); }
        _Mysb *rdbuf() const
                {return (_Sb); }
        _Mysb *rdbuf(_Mysb *_N)
                {_Mysb *_O = _Sb;
                _Sb = _N;
                clear();
                return (_O); }
        locale imbue(const locale& _Ln)
                {if (rdbuf() != 0)
                        rdbuf()->pubimbue(_Ln);
                return (ios_base::imbue(_Ln)); }
        _E fill() const
                {return (_Fillch); }
        _E fill(_E _Nf)
                {_E _Of = _Fillch;
                _Fillch = _Nf;
                return (_Of); }
        char narrow(_E _C, char _D = '\0') const
                {const _Ctype& _Fac = use_facet<_Ctype >(getloc());
                return (_Fac.narrow(_C, _D)); }
        _E widen(char _C) const
                {const _Ctype& _Fac = use_facet<_Ctype >(getloc());
                return (_Fac.widen(_C)); }
protected:
        void init(_Mysb *_S = 0,
                bool _Isstd = false)
                {_Sb = _S;
                _Tiestr = 0;
                _Fillch = _Widen(' ', (_E *)0);
                _Init();
                if (_Sb == 0)
                        setstate(badbit);
                if (_Isstd)
                        _Addstd(); }
        basic_ios()
                {}
private:
        basic_ios(const _Myt&);  
        basic_ios& operator=(const _Myt&);       
        _Mysb *_Sb;
        _Myos *_Tiestr;
        _E _Fillch;
        };

inline ios_base& boolalpha(ios_base& _I)
        {_I.setf(ios_base::boolalpha);
        return (_I); }
inline ios_base& dec(ios_base& _I)
        {_I.setf(ios_base::dec, ios_base::basefield);
        return (_I); }
inline ios_base& fixed(ios_base& _I)
        {_I.setf(ios_base::fixed, ios_base::floatfield);
        return (_I); }
inline ios_base& hex(ios_base& _I)
        {_I.setf(ios_base::hex, ios_base::basefield);
        return (_I); }
inline ios_base& internal(ios_base& _I)
        {_I.setf(ios_base::internal, ios_base::adjustfield);
        return (_I); }
inline ios_base& left(ios_base& _I)
        {_I.setf(ios_base::left, ios_base::adjustfield);
        return (_I); }
inline ios_base& noboolalpha(ios_base& _I)
        {_I.unsetf(ios_base::boolalpha);
        return (_I); }
inline ios_base& noshowbase(ios_base& _I)
        {_I.unsetf(ios_base::showbase);
        return (_I); }
inline ios_base& noshowpoint(ios_base& _I)
        {_I.unsetf(ios_base::showpoint);
        return (_I); }
inline ios_base& noshowpos(ios_base& _I)
        {_I.unsetf(ios_base::showpos);
        return (_I); }
inline ios_base& noskipws(ios_base& _I)
        {_I.unsetf(ios_base::skipws);
        return (_I); }
inline ios_base& nounitbuf(ios_base& _I)
        {_I.unsetf(ios_base::unitbuf);
        return (_I); }
inline ios_base& nouppercase(ios_base& _I)
        {_I.unsetf(ios_base::uppercase);
        return (_I); }
inline ios_base& oct(ios_base& _I)
        {_I.setf(ios_base::oct, ios_base::basefield);
        return (_I); }
inline ios_base& right(ios_base& _I)
        {_I.setf(ios_base::right, ios_base::adjustfield);
        return (_I); }
inline ios_base& scientific(ios_base& _I)
        {_I.setf(ios_base::scientific, ios_base::floatfield);
        return (_I); }
inline ios_base& showbase(ios_base& _I)
        {_I.setf(ios_base::showbase);
        return (_I); }
inline ios_base& showpoint(ios_base& _I)
        {_I.setf(ios_base::showpoint);
        return (_I); }
inline ios_base& showpos(ios_base& _I)
        {_I.setf(ios_base::showpos);
        return (_I); }
inline ios_base& skipws(ios_base& _I)
        {_I.setf(ios_base::skipws);
        return (_I); }
inline ios_base& unitbuf(ios_base& _I)
        {_I.setf(ios_base::unitbuf);
        return (_I); }
inline ios_base& uppercase(ios_base& _I)
        {_I.setf(ios_base::uppercase);
        return (_I); }
#line 238
};

#pragma namemangling()

#pragma object_model(pop)
#line 249
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 77 "/usr/vacpp/include/ostream"
namespace std {
#line 94
template<class _E, class _Tr>
        class basic_ostream : virtual public basic_ios<_E, _Tr> {
public:
        typedef basic_ostream<_E, _Tr> _Myt;
        typedef basic_ios<_E, _Tr> _Myios;
        typedef basic_streambuf<_E, _Tr> _Mysb;
        typedef ostreambuf_iterator<_E, _Tr> _Iter;
        typedef num_put<_E, _Iter> _Nput;
        explicit basic_ostream(basic_streambuf<_E, _Tr> *_S,
                bool _Isstd = false)
                {_Myios::init(_S, _Isstd); }
        basic_ostream(_Uninitialized)
                {ios_base::_Addstd(); }
        virtual ~basic_ostream()
                {}

        typedef typename _Tr::int_type int_type;
        typedef typename _Tr::pos_type pos_type;
        typedef typename _Tr::off_type off_type;
        class sentry {
        public:
                explicit sentry(_Myt& _Os)
#line 119
                        : _Lk(_Lockit::_Str), _Ostr(_Os)

                        {if (_Os.good() && _Os.tie() != 0)
                                _Os.tie()->flush();
                        _Ok = _Os.good(); }
                ~sentry()
                        {if (!uncaught_exception())
                                _Ostr.osfx(); }
                operator bool() const
                        {return (_Ok); }
        private:
                sentry(const sentry&);   
                sentry& operator=(const sentry&);        
                bool _Ok;
                _Lockit _Lk;
                _Myt& _Ostr;
                };

        bool opfx()
                {if (ios_base::good() && _Myios::tie() != 0)
                        _Myios::tie()->flush();
                return (ios_base::good()); }
        void osfx()
                {if (ios_base::flags() & ios_base::unitbuf)
                        flush(); }
        _Myt& operator<<(_Myt& (*_F)(_Myt&))
                {return ((*_F)(*this)); }
        _Myt& operator<<(_Myios& (*_F)(_Myios&))
                {(*_F)(*(_Myios *)this);
                return (*this); }
#line 154
        _Myt& operator<<(ios_base& (*_F)(ios_base&))
                {(*_F)(*(ios_base *)this);
                return (*this); }
        _Myt& operator<<(_Bool _X);
        _Myt& operator<<(short _X);
        _Myt& operator<<(unsigned short _X);
        _Myt& operator<<(int _X);
        _Myt& operator<<(unsigned int _X);
        _Myt& operator<<(long _X);
        _Myt& operator<<(unsigned long _X);

        _Myt& operator<<(long long _X);
        _Myt& operator<<(unsigned long long _X);

        _Myt& operator<<(float _X);
        _Myt& operator<<(double _X);
        _Myt& operator<<(long double _X);
        _Myt& operator<<(const void *_X);
        _Myt& operator<<(_Mysb *_Pb);
        _Myt& put(_E _X);
        _Myt& write(const _E *_S, streamsize _N);
        _Myt& flush()
                {ios_base::iostate _St = ios_base::goodbit;
                if (!ios_base::fail()
                        && _Myios::rdbuf()->pubsync() == -1)
                        _St |= ios_base::badbit;
                _Myios::setstate(_St);
                return (*this); }
        _Myt& seekp(pos_type _P)
                {if (!ios_base::fail())
                        if (_Myios::rdbuf()->pubseekpos(_P, ios_base::out)
                            == streampos(_BADOFF))
                                _Myios::setstate(ios_base::failbit);
                return (*this); }
        _Myt& seekp(off_type _O, ios_base::seekdir _W)
                {if (!ios_base::fail())
                        if (_Myios::rdbuf()->pubseekoff(_O, _W, ios_base::out)
                            == streampos(_BADOFF))
                                _Myios::setstate(ios_base::failbit);
                return (*this); }
        pos_type tellp()
                {if (!ios_base::fail())
                        return (_Myios::rdbuf()->pubseekoff(0,
                                ios_base::cur, ios_base::out));
                else
                        return (pos_type(_BADOFF)); }
        };
#line 203
template<class _E, class _Tr>
        basic_ostream<_E, _Tr>& operator<<(
                basic_ostream<_E, _Tr>& _O, const char *_X);

template<class _E, class _Tr>
        basic_ostream<_E, _Tr>& operator<<(
                basic_ostream<_E, _Tr>& _O, char _C);

template<class _Tr>
        basic_ostream<char, _Tr>& operator<<(
                basic_ostream<char, _Tr>& _O,
                const char *_X);

template<class _Tr>
        basic_ostream<char, _Tr>& operator<<(
                basic_ostream<char, _Tr>& _O, char _C);

template<class _E, class _Tr>
        basic_ostream<_E, _Tr>& operator<<(
                basic_ostream<_E, _Tr>& _O, const _E *_X);

template<class _E, class _Tr>
        basic_ostream<_E, _Tr>& operator<<(
                basic_ostream<_E, _Tr>& _O, _E _C);

template<class _Tr> inline
        basic_ostream<char, _Tr>& operator<<(
                basic_ostream<char, _Tr>& _O, const signed char *_X)
        {return (_O << (const char *)_X); }
template<class _Tr> inline
        basic_ostream<char, _Tr>& operator<<(
                basic_ostream<char, _Tr>& _O, const signed char _C)
        {return (_O << (char)_C); }
template<class _Tr> inline
        basic_ostream<char, _Tr>& operator<<(
                basic_ostream<char, _Tr>& _O, const unsigned char *_X)
        {return (_O << (const char *)_X); }
template<class _Tr> inline
        basic_ostream<char, _Tr>& operator<<(
                basic_ostream<char, _Tr>& _O, const unsigned char _C)
        {return (_O << (char)_C); }
#line 246
template<class _E, class _Tr> inline
        basic_ostream<_E, _Tr>&
                endl(basic_ostream<_E, _Tr>& _O)
        {_O.put(_O.widen('\n'));
        _O.flush();
        return (_O); }
template<class _E, class _Tr> inline
        basic_ostream<_E, _Tr>&
                ends(basic_ostream<_E, _Tr>& _O)
        {_O.put(_E());
        return (_O); }
template<class _E, class _Tr> inline
        basic_ostream<_E, _Tr>&
                flush(basic_ostream<_E, _Tr>& _O)
        {_O.flush();
        return (_O); }
#line 268
};

#pragma implementation("ostream.t")
#line 31 "/usr/vacpp/include/ostream.t"
namespace std {
#line 37
template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(_Bool _X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok)
                {const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
                try {
                if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
                        _Myios::fill(), _X).failed())
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }
#line 54
template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(short _X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok)
                {const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
                ios_base::fmtflags _Bfl =
                        ios_base::flags() & ios_base::basefield;
                long _Y = (_Bfl == ios_base::oct
                        || _Bfl == ios_base::hex)
                        ? (long)(unsigned short)_X : (long)_X;
                try {
                if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
                        _Myios::fill(), _Y).failed())
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }
#line 76
template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(unsigned short _X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok)
                {const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
                try {
                if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
                        _Myios::fill(), (unsigned long)_X).failed())
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }
#line 93
template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(int _X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok)
                {const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
                ios_base::fmtflags _Bfl =
                        ios_base::flags() & ios_base::basefield;
                long _Y = (_Bfl == ios_base::oct
                        || _Bfl == ios_base::hex)
                        ? (long)(unsigned int)_X : (long)_X;
                try {
                if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
                        _Myios::fill(), _Y).failed())
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }
#line 115
template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(unsigned int _X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok)
                {const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
                try {
                if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
                        _Myios::fill(), (unsigned long)_X).failed())
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }

template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(long _X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok)
                {const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
                try {
                if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
                        _Myios::fill(), _X).failed())
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }
#line 148
template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(unsigned long _X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok)
                {const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
                try {
                if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
                        _Myios::fill(), _X).failed())
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }
#line 165
template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(long long _X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok)
                {const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
                try {
                if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
                        _Myios::fill(), _X).failed())
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }

template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(unsigned long long _X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok)
                {const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
                try {
                if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
                        _Myios::fill(), _X).failed())
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }
#line 198
template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(float _X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok)
                {const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
                try {
                if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
                        _Myios::fill(), (double)_X).failed())
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }

template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(double _X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok)
                {const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
                try {
                if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
                        _Myios::fill(), _X).failed())
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }

template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(long double _X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok)
                {const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
                try {
                if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
                        _Myios::fill(), _X).failed())
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }

template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(const void *_X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (_Ok)
                {const _Nput& _Fac = use_facet<_Nput >(ios_base::getloc());
                try {
                if (_Fac.put(_Iter(_Myios::rdbuf()), *this,
                        _Myios::fill(), _X).failed())
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }

template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::operator<<(_Mysb *_Pb)
        {ios_base::iostate _St = ios_base::goodbit;
        bool _Copied = false;
        const sentry _Ok(*this);
        if (_Ok && _Pb != 0)
                for (int_type _C = _Tr::eof(); ; _Copied = true)
                        {try {
                        _C = _Tr::eq_int_type(_Tr::eof(), _C)
                                ? _Pb->sgetc() : _Pb->snextc();
                        } catch (...) {
                                _Myios::setstate(ios_base::failbit);
                                throw;
                        }
                        if (_Tr::eq_int_type(_Tr::eof(),_C))
                                break;
                        try {
                                if (_Tr::eq_int_type(_Tr::eof(),
                                        _Myios::rdbuf()->sputc(
                                                _Tr::to_char_type(_C))))
                                        {_St |= ios_base::badbit;
                                        break; }
                        } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        ios_base::width(0);
        _Myios::setstate(!_Copied
                ? _St | ios_base::failbit : _St);
        return (*this); }

template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt& basic_ostream<_E, _Tr>::put(_E _X)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (!_Ok)
                _St |= ios_base::badbit;
        else
                {try {
                 if (_Tr::eq_int_type(_Tr::eof(),
                        _Myios::rdbuf()->sputc(_X)))
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }

template<class _E, class _Tr>
inline
typename basic_ostream<_E, _Tr>::_Myt&
basic_ostream<_E, _Tr>::write(const _E *_S, streamsize _N)
        {ios_base::iostate _St = ios_base::goodbit;
        const sentry _Ok(*this);
        if (!_Ok)
                _St |= ios_base::badbit;
        else
                {try {
                if (_Myios::rdbuf()->sputn(_S, _N) != _N)
                        _St |= ios_base::badbit;
                } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
        _Myios::setstate(_St);
        return (*this); }

template<class _E, class _Tr>
inline
basic_ostream<_E, _Tr>& operator<<(basic_ostream<_E, _Tr>& _O, const char *_X)
        {ios_base::iostate _St = ios_base::goodbit;
        size_t _N = strlen(_X);
        size_t _M = _O.width() <= 0
                || (size_t)_O.width() <= _N
                ? 0 : (size_t)_O.width() - _N;
        const typename basic_ostream<_E, _Tr>::sentry _Ok(_O);
        if (!_Ok)
                _St |= ios_base::badbit;
        else
                {try {
                const ctype<_E>& _Fac = use_facet<ctype<_E> >(_O.getloc());
                if ((_O.flags() & ios_base::adjustfield)
                        != ios_base::left)
                        for (; 0 < _M; --_M)
                                if (_Tr::eq_int_type(_Tr::eof(),
                                        _O.rdbuf()->sputc(_O.fill())))
                                        {_St |= ios_base::badbit;
                                        break; }
                for (; _St == ios_base::goodbit && 0 < _N; --_N, ++_X)
                        if (_Tr::eq_int_type(_Tr::eof(),
                                _O.rdbuf()->sputc(_Fac.widen(*_X))))
                                        _St |= ios_base::badbit;
                if (_St == ios_base::goodbit)
                        for (; 0 < _M; --_M)
                                if (_Tr::eq_int_type(_Tr::eof(),
                                        _O.rdbuf()->sputc(_O.fill())))
                                        {_St |= ios_base::badbit;
                                        break; }
                _O.width(0);
                } catch (...) { (_O).setstate(ios_base::badbit, true); } }
        _O.setstate(_St);
        return (_O); }
#line 369
template<class _E, class _Tr>
inline
basic_ostream<_E, _Tr>& operator<<(basic_ostream<_E, _Tr>& _O, char _C)
        {ios_base::iostate _St = ios_base::goodbit;
        const typename basic_ostream<_E, _Tr>::sentry _Ok(_O);
        if (_Ok)
                {const ctype<_E>& _Fac = use_facet<ctype<_E> >(_O.getloc());
                size_t _M = _O.width() <= 1 ? 0 : _O.width() - 1;
                try {
                if ((_O.flags() & ios_base::adjustfield)
                        != ios_base::left)
                        for (; _St == ios_base::goodbit && 0 < _M; --_M)
                                if (_Tr::eq_int_type(_Tr::eof(),
                                        _O.rdbuf()->sputc(_O.fill())))
                                        _St |= ios_base::badbit;
                if (_St == ios_base::goodbit
                        && _Tr::eq_int_type(_Tr::eof(),
                                _O.rdbuf()->sputc(_Fac.widen(_C))))
                        _St |= ios_base::badbit;
                for (; _St == ios_base::goodbit && 0 < _M; --_M)
                        if (_Tr::eq_int_type(_Tr::eof(),
                                _O.rdbuf()->sputc(_O.fill())))
                                _St |= ios_base::badbit;
                } catch (...) { (_O).setstate(ios_base::badbit, true); } }
        _O.width(0);
        _O.setstate(_St);
        return (_O); }

template<class _Tr>
inline
basic_ostream<char, _Tr>& operator<<(basic_ostream<char, _Tr>& _O,
                const char *_X)
        {typedef char _E;
        typedef basic_ostream<_E, _Tr> _Myos;
        ios_base::iostate _St = ios_base::goodbit;
        size_t _N = _Tr::length(_X);
        size_t _M = _O.width() <= 0
                || (size_t)_O.width() <= _N
                ? 0 : (size_t)_O.width() - _N;
        const typename _Myos::sentry _Ok(_O);
        if (!_Ok)
                _St |= ios_base::badbit;
        else
                {try {
                if ((_O.flags() & ios_base::adjustfield)
                        != ios_base::left)
                        for (; 0 < _M; --_M)
                                if (_Tr::eq_int_type(_Tr::eof(),
                                        _O.rdbuf()->sputc(_O.fill())))
                                        {_St |= ios_base::badbit;
                                        break; }
                if (_St == ios_base::goodbit
                        && (size_t)_O.rdbuf()->sputn(_X, _N) != _N)
                        _St |= ios_base::badbit;
                if (_St == ios_base::goodbit)
                        for (; 0 < _M; --_M)
                                if (_Tr::eq_int_type(_Tr::eof(),
                                        _O.rdbuf()->sputc(_O.fill())))
                                        {_St |= ios_base::badbit;
                                        break; }
                _O.width(0);
                } catch (...) { (_O).setstate(ios_base::badbit, true); } }
        _O.setstate(_St);
        return (_O); }
#line 443
template<class _Tr>
inline
basic_ostream<char, _Tr>& operator<<(basic_ostream<char, _Tr>& _O, char _C)
        {typedef char _E;
        typedef basic_ostream<_E, _Tr> _Myos;
        ios_base::iostate _St = ios_base::goodbit;
        const typename _Myos::sentry _Ok(_O);
        if (_Ok)
                {size_t _M = _O.width() <= 1 ? 0 : _O.width() - 1;
                try {
                if ((_O.flags() & ios_base::adjustfield)
                        != ios_base::left)
                        for (; _St == ios_base::goodbit && 0 < _M; --_M)
                                if (_Tr::eq_int_type(_Tr::eof(),
                                        _O.rdbuf()->sputc(_O.fill())))
                                        _St |= ios_base::badbit;
                if (_St == ios_base::goodbit
                        && _Tr::eq_int_type(_Tr::eof(),
                                _O.rdbuf()->sputc(_C)))
                        _St |= ios_base::badbit;
                for (; _St == ios_base::goodbit && 0 < _M; --_M)
                        if (_Tr::eq_int_type(_Tr::eof(),
                                _O.rdbuf()->sputc(_O.fill())))
                                _St |= ios_base::badbit;
                } catch (...) { (_O).setstate(ios_base::badbit, true); } }
        _O.width(0);
        _O.setstate(_St);
        return (_O); }

template<class _E, class _Tr>
inline
basic_ostream<_E, _Tr>& operator<<(basic_ostream<_E, _Tr>& _O, const _E *_X)
        {typedef basic_ostream<_E, _Tr> _Myos;
        ios_base::iostate _St = ios_base::goodbit;
        size_t _N = _Tr::length(_X);
        size_t _M = _O.width() <= 0
                || (size_t)_O.width() <= _N
                        ? 0 : (size_t)_O.width() - _N;
        const typename _Myos::sentry _Ok(_O);
        if (!_Ok)
                _St |= ios_base::badbit;
        else
                {try {
                if ((_O.flags() & ios_base::adjustfield)
                        != ios_base::left)
                        for (; 0 < _M; --_M)
                                if (_Tr::eq_int_type(_Tr::eof(),
                                        _O.rdbuf()->sputc(_O.fill())))
                                        {_St |= ios_base::badbit;
                                        break; }
                if (_St == ios_base::goodbit
                        && (size_t)_O.rdbuf()->sputn(_X, _N) != _N)
                        _St |= ios_base::badbit;
                if (_St == ios_base::goodbit)
                        for (; 0 < _M; --_M)
                                if (_Tr::eq_int_type(_Tr::eof(),
                                        _O.rdbuf()->sputc(_O.fill())))
                                        {_St |= ios_base::badbit;
                                        break; }
                _O.width(0);
                } catch (...) { (_O).setstate(ios_base::badbit, true); } }
        _O.setstate(_St);
        return (_O); }
#line 517
template<class _E, class _Tr>
inline
basic_ostream<_E, _Tr>& operator<<(basic_ostream<_E, _Tr>& _O, _E _C)
        {typedef basic_ostream<_E, _Tr> _Myos;
        ios_base::iostate _St = ios_base::goodbit;
        const typename _Myos::sentry _Ok(_O);
        if (_Ok)
                {size_t _M = _O.width() <= 1 ? 0 : _O.width() - 1;
                try {
                if ((_O.flags() & ios_base::adjustfield)
                        != ios_base::left)
                        for (; _St == ios_base::goodbit && 0 < _M; --_M)
                                if (_Tr::eq_int_type(_Tr::eof(),
                                        _O.rdbuf()->sputc(_O.fill())))
                                        _St |= ios_base::badbit;
                if (_St == ios_base::goodbit
                        && _Tr::eq_int_type(_Tr::eof(),
                                _O.rdbuf()->sputc(_C)))
                        _St |= ios_base::badbit;
                for (; _St == ios_base::goodbit && 0 < _M; --_M)
                        if (_Tr::eq_int_type(_Tr::eof(),
                                _O.rdbuf()->sputc(_O.fill())))
                                _St |= ios_base::badbit;
                } catch (...) { (_O).setstate(ios_base::badbit, true); } }
        _O.width(0);
        _O.setstate(_St);
        return (_O); }
#line 551
};
#line 276 "/usr/vacpp/include/ostream"
#pragma namemangling(pop)

#pragma object_model(pop)
#line 285
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 76 "/usr/vacpp/include/istream"
namespace std {
#line 86
template<class _E, class _Tr>
        class basic_istream : virtual public basic_ios<_E, _Tr> {
public:
        typedef basic_istream<_E, _Tr> _Myt;
        typedef basic_ios<_E, _Tr> _Myios;
        typedef basic_streambuf<_E, _Tr> _Mysb;
        typedef istreambuf_iterator<_E, _Tr> _Iter;
        typedef ctype<_E> _Ctype;
        typedef num_get<_E, _Iter> _Nget;
        explicit basic_istream(_Mysb *_S, bool _Isstd = false,
                bool _Noinit = false)
                : _Chcount(0)
                {if (!_Noinit)
                        _Myios::init(_S, _Isstd); }
        basic_istream(_Uninitialized)
                {ios_base::_Addstd(); }
        virtual ~basic_istream()
                {}
        typedef typename _Tr::int_type int_type;
        typedef typename _Tr::pos_type pos_type;
        typedef typename _Tr::off_type off_type;
        class sentry {
        public:
                explicit sentry(_Myt& _Is, bool _Noskip = false)
#line 113
                        : _Lk(_Lockit::_Str)

                        { _Ok = _Is._DoTie(_Noskip, -1); }
                explicit sentry(_Myt& _Is, bool _Noskip, streamsize _N)
#line 120
                        : _Lk(_Lockit::_Str)

                        { _Ok = _Is._DoTie(_Noskip, _N); }
                operator bool() const
                        {return (_Ok); }
        private:
                sentry(const sentry&);   
                sentry& operator=(const sentry&);        
                bool _Ok;
                _Lockit _Lk;
                };
        bool ipfx(bool _Noskip = false);
        void isfx()
                {}
        _Myt& operator>>(_Myt& (*_F)(_Myt&))
                {return ((*_F)(*this)); }
        _Myt& operator>>(_Myios& (*_F)(_Myios&))
                {(*_F)(*(_Myios *)this);
                return (*this); }
        _Myt& operator>>(ios_base& (*_F)(ios_base&))
                {(*_F)(*(ios_base *)this);
                return (*this); }
        _Myt& operator>>(_Bool& _X);
        _Myt& operator>>(short& _X);
        _Myt& operator>>(unsigned short& _X);
        _Myt& operator>>(int& _X);
        _Myt& operator>>(unsigned int& _X);
        _Myt& operator>>(long& _X);
        _Myt& operator>>(unsigned long& _X);

        _Myt& operator>>(long long& _X);
        _Myt& operator>>(unsigned long long& _X);

        _Myt& operator>>(float& _X);
        _Myt& operator>>(double& _X);
        _Myt& operator>>(long double& _X);
        _Myt& operator>>(void *& _X);
        _Myt& operator>>(_Mysb *_Pb);
        int_type get();
        _Myt& get(_E *_S, streamsize _N)
                {return (get(_S, _N, _Myios::widen('\n'))); }
        _Myt& get(_E *_S, streamsize _N, _E _D);
        _Myt& get(_E& _X)
                {int_type _C = get();
                if (!_Tr::eq_int_type(_Tr::eof(), _C))
                        _X = _Tr::to_char_type(_C);
                return (*this); }
        _Myt& get(_Mysb& _Sb)
                {return (get(_Sb, _Myios::widen('\n'))); }
        _Myt& get(_Mysb& _Sb, _E _D);
        _Myt& getline(_E *_S, streamsize _N)
                {return (getline(_S, _N, _Myios::widen('\n'))); }
        _Myt& getline(_E *_S, streamsize _N, _E _D);
        _Myt& ignore(streamsize _N = 1, int_type _Di = _Tr::eof());
        _Myt& read(_E *_S, streamsize _N);
        streamsize readsome(_E *_S, streamsize _N);
        int_type peek();
        _Myt& putback(_E _X);
        _Myt& unget();
        streamsize gcount() const
                {return (_Chcount); }
        int sync();
        _Myt& seekg(pos_type _P)
                 {if ((!ios_base::fail()) && (!ios_base::eof()))
                        if (_Myios::rdbuf()->pubseekpos(_P, ios_base::in)
                            == streampos(_BADOFF))
                            _Myios::setstate(ios_base::failbit);
                return (*this); }
        _Myt& seekg(off_type _O, ios_base::seekdir _W)
                 {if ((!ios_base::fail()) && (!ios_base::eof()))
                        if (_Myios::rdbuf()->pubseekoff(_O, _W, ios_base::in)
                            == streampos(_BADOFF))
                            _Myios::setstate(ios_base::failbit);
                return (*this); }
        pos_type tellg()
               {if ((!ios_base::fail()) && (!ios_base::eof()))
                        return (_Myios::rdbuf()->pubseekoff(0,
                                ios_base::cur, ios_base::in));
                else
                        return (pos_type(_BADOFF)); }
private:
        bool _DoTie(bool _Noskip, streamsize _N);
        streamsize _Chcount;
        };
#line 206
template<class _E, class _Tr>
        class basic_iostream : public basic_istream<_E, _Tr>,
                public basic_ostream<_E, _Tr> {
public:
        explicit basic_iostream(basic_streambuf<_E, _Tr> *_S)
                : basic_istream<_E, _Tr>(_S, false, true),
                        basic_ostream<_E, _Tr>(_S)
                {}
        virtual ~basic_iostream()
                {}
        };
#line 219
template<class _E, class _Tr>
        basic_istream<_E, _Tr>& operator>>(
                basic_istream<_E, _Tr>& _I, _E *_X);

template<class _E, class _Tr>
        basic_istream<_E, _Tr>& operator>>(
                basic_istream<_E, _Tr>& _I, _E& _X);

template<class _Tr> inline
        basic_istream<char, _Tr>& operator>>(
                basic_istream<char, _Tr>& _I, signed char *_X)
        {return (_I >> (char *)_X); }
template<class _Tr> inline
        basic_istream<char, _Tr>& operator>>(
                basic_istream<char, _Tr>& _I, signed char& _C)
        {return (_I >> (char&)_C); }
template<class _Tr> inline
        basic_istream<char, _Tr>& operator>>(
                basic_istream<char, _Tr>& _I, unsigned char *_X)
        {return (_I >> (char *)_X); }
template<class _Tr> inline
        basic_istream<char, _Tr>& operator>>(
                basic_istream<char, _Tr>& _I, unsigned char& _C)
        {return (_I >> (char&)_C); }
#line 245
template<class _E, class _Tr>
        basic_istream<_E, _Tr>&
                ws(basic_istream<_E, _Tr>& _I);
#line 254
};

#pragma implementation("istream.t")
#line 31 "/usr/vacpp/include/istream.t"
namespace std {
#line 36
template<class _E, class _Tr>
inline
bool basic_istream<_E, _Tr>::_DoTie(bool _Noskip, streamsize _N)
         {if (ios_base::good())
                 {if ((_Myios::tie() != 0) &&
                      (_Myios::rdbuf()->in_avail() < _N))
                          _Myios::tie()->flush(); }
                 return ipfx(_Noskip); }

template<class _E, class _Tr>
inline
bool basic_istream<_E, _Tr>::ipfx(bool _Noskip)
         {if (ios_base::good())
                 {if (!_Noskip && ios_base::flags() & ios_base::skipws)
                         {const _Ctype& _Fac =
                                 use_facet<_Ctype >(ios_base::getloc());
                         try {
                         int_type _C = _Myios::rdbuf()->sgetc();
                         for (; ; _C = _Myios::rdbuf()->snextc())
                                 if (_Tr::eq_int_type(_Tr::eof(), _C))
                                         {_Myios::setstate(ios_base::eofbit);
                                         break; }
                                 else if (!_Fac.is(_Ctype::space,
                                         _Tr::to_char_type(_C)))
                                         break;
                         } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
                 if (ios_base::good())
                         return (true); }
         _Myios::setstate(ios_base::failbit);
         return (false); }
#line 68
template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(_Bool& _X)
         {ios_base::iostate _St = ios_base::goodbit;
         const sentry _Ok(*this);
         if (_Ok)
                 {const _Nget& _Fac = use_facet<_Nget >(ios_base::getloc());
                 try {
                 _Fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
                         *this, _St, _X);
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }

template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(short& _X)
         {ios_base::iostate _St = ios_base::goodbit;
         const sentry _Ok(*this);
         if (_Ok)
                 {long _Y;
                 const _Nget& _Fac = use_facet<_Nget >(ios_base::getloc());
                 try {
                 _Fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
                         *this, _St, _Y);
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); }
                 if (_St & ios_base::failbit
                         || _Y < (-(32767) - 1) || (32767) < _Y)
                         _St |= ios_base::failbit;
                 else
                         _X = (short)_Y; }
         _Myios::setstate(_St);
         return (*this); }

template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(unsigned short& _X)
         {ios_base::iostate _St = ios_base::goodbit;
         const sentry _Ok(*this);
         if (_Ok)
                 {const _Nget& _Fac = use_facet<_Nget >(ios_base::getloc());
                 try {
                 _Fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
                         *this, _St, _X);
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }
#line 120
template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(int& _X)
         {ios_base::iostate _St = ios_base::goodbit;
         const sentry _Ok(*this);
         if (_Ok)
                 {long _Y;
                 const _Nget& _Fac = use_facet<_Nget >(ios_base::getloc());
                 try {
                 _Fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
                         *this, _St, _Y);
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); }
                 if (_St & ios_base::failbit
                         || _Y < (-(2147483647) - 1) || (2147483647) < _Y)
                         _St |= ios_base::failbit;
                 else
                         _X = _Y; }
         _Myios::setstate(_St);
         return (*this); }

template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(unsigned int& _X)
         {ios_base::iostate _St = ios_base::goodbit;
         const sentry _Ok(*this);
         if (_Ok)
                 {const _Nget& _Fac = use_facet<_Nget >(ios_base::getloc());
                 try {
                 _Fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
                         *this, _St, _X);
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }

template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(long& _X)
         {ios_base::iostate _St = ios_base::goodbit;
         const sentry _Ok(*this);
         if (_Ok)
                 {const _Nget& _Fac = use_facet<_Nget >(ios_base::getloc());
                 try {
                 _Fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
                         *this, _St, _X);
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }
#line 172
template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(unsigned long& _X)
         {ios_base::iostate _St = ios_base::goodbit;
         const sentry _Ok(*this);
         if (_Ok)
                 {const _Nget& _Fac = use_facet<_Nget >(ios_base::getloc());
                 try {
                 _Fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
                         *this, _St, _X);
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }
#line 189
template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(long long& _X)
         {ios_base::iostate _St = ios_base::goodbit;
         const sentry _Ok(*this);
         if (_Ok)
                 {const _Nget& _Fac = use_facet<_Nget >(ios_base::getloc());
                 try {
                 _Fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
                         *this, _St, _X);
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }

template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(unsigned long long& _X)
         {ios_base::iostate _St = ios_base::goodbit;
         const sentry _Ok(*this);
         if (_Ok)
                 {const _Nget& _Fac = use_facet<_Nget >(ios_base::getloc());
                 try {
                 _Fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
                         *this, _St, _X);
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }
#line 220
template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(float& _X)
         {ios_base::iostate _St = ios_base::goodbit;
         const sentry _Ok(*this);
         if (_Ok)
                 {const _Nget& _Fac = use_facet<_Nget >(ios_base::getloc());
                 try {
                 _Fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
                         *this, _St, _X);
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }

template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(double& _X)
         {ios_base::iostate _St = ios_base::goodbit;
         const sentry _Ok(*this);
         if (_Ok)
                 {const _Nget& _Fac = use_facet<_Nget >(ios_base::getloc());
                 try {
                 _Fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
                         *this, _St, _X);
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }

template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(long double& _X)
         {ios_base::iostate _St = ios_base::goodbit;
         const sentry _Ok(*this);
         if (_Ok)
                 {const _Nget& _Fac = use_facet<_Nget >(ios_base::getloc());
                 try {
                 _Fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
                         *this, _St, _X);
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }

template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(void *& _X)
         {ios_base::iostate _St = ios_base::goodbit;
         const sentry _Ok(*this);
         if (_Ok)
                 {const _Nget& _Fac = use_facet<_Nget >(ios_base::getloc());
                 try {
                 _Fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
                         *this, _St, _X);
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }
#line 281
template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::operator>>(_Mysb *_Pb)
         {ios_base::iostate _St = ios_base::goodbit;
         bool _Copied = false;
         const sentry _Ok(*this);
         if (_Ok && _Pb != 0)
                 {try {
                 int_type _C = _Myios::rdbuf()->sgetc();
                 for (; ; _C = _Myios::rdbuf()->snextc())
                         if (_Tr::eq_int_type(_Tr::eof(), _C))
                                 {_St |= ios_base::eofbit;
                                 break; }
                         else
                                 {try {
                                         if (_Tr::eq_int_type(_Tr::eof(),
                                                 _Pb->sputc(_Tr::to_char_type(_C))))
                                                 break;
                                 } catch (...) {
                                         break;
                                 }
                                 _Copied = true; }
                 } catch (...) {
                         _Myios::setstate(ios_base::badbit, true);
                         if (!_Copied &&
                             (_Myios::exceptions() & ios_base::failbit))
                         {_Myios::setstate(_St | ios_base::failbit);
                          throw; }
                 }
                 }
         _Myios::setstate(!_Copied
                 ? _St | ios_base::failbit : _St);
         return (*this); }
#line 317
template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::int_type basic_istream<_E, _Tr>::get()
         {int_type _C;
         ios_base::iostate _St = ios_base::goodbit;
         _Chcount = 0;
         const sentry _Ok(*this, true, 1);
         if (!_Ok)
                 _C = _Tr::eof();
         else
                 {try {
                 _C = _Myios::rdbuf()->sbumpc();
                 if (_Tr::eq_int_type(_Tr::eof(), _C))
                         _St |= ios_base::eofbit | ios_base::failbit;
                 else
                         ++_Chcount;
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (_C); }

template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::get(_E *_S, streamsize _N, _E _D)
         {ios_base::iostate _St = ios_base::goodbit;
         _Chcount = 0;
         const sentry _Ok(*this, true, _N);
         if (_Ok && 0 < _N)
                 {try {
                 int_type _C = _Myios::rdbuf()->sgetc();
                 for (; 0 < --_N; _C = _Myios::rdbuf()->snextc())
                         if (_Tr::eq_int_type(_Tr::eof(), _C))
                                 {_St |= ios_base::eofbit;
                                 break; }
                         else if (_Tr::to_char_type(_C) == _D)
                                 break;
                         else
                                 *_S++ = _Tr::to_char_type(_C), ++_Chcount;
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_Chcount == 0
                 ? _St | ios_base::failbit : _St);
         *_S = _E();
         return (*this); }
#line 362
template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::get(_Mysb& _Sb, _E _D)
         {ios_base::iostate _St = ios_base::goodbit;
         _Chcount = 0;
         const sentry _Ok(*this, true);
         if (_Ok)
                 {try {
                 int_type _C = _Myios::rdbuf()->sgetc();
                 for (; ; _C = _Myios::rdbuf()->snextc())
                         if (_Tr::eq_int_type(_Tr::eof(), _C))
                                 {_St |= ios_base::eofbit;
                                 break; }
                         else
                                 {try {
                                         _E _Ch = _Tr::to_char_type(_C);
                                         if (_Ch == _D
                                                 || _Tr::eq_int_type(_Tr::eof(),
                                                         _Sb.sputc(_Ch)))
                                                 break;
                                 } catch (...) {
                                         break;
                                 }
                                 ++_Chcount; }
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         if (_Chcount == 0)
                 _St |= ios_base::failbit;
         _Myios::setstate(_St);
         return (*this); }
#line 394
template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::getline(_E *_S, streamsize _N, _E _D)
         {ios_base::iostate _St = ios_base::goodbit;
         _Chcount = 0;
         const sentry _Ok(*this, true, _N);
         const streamsize _OriginalN = _N;
         if (_Ok)
                 {int_type _Di = _Tr::to_int_type(_D);
                 try {
                 int_type _C = _Myios::rdbuf()->sgetc();
                 for (; ; _C = _Myios::rdbuf()->snextc())
                         if (_Tr::eq_int_type(_Tr::eof(), _C))
                                 {_St |= ios_base::eofbit;
                                 break; }
                         else if (_C == _Di)
                                 {++_Chcount;
                                 _Myios::rdbuf()->sbumpc();
                                 break; }
                         else if (0 < _N)
                                 {if (--_N == 0)
                                         {_St |= ios_base::failbit;
                                         break; }
                                 else
                                         {++_Chcount;
                                         *_S++ = _Tr::to_char_type(_C); }}
                         else break;
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         if (0 < _OriginalN)
                 *_S = _E();
         _Myios::setstate(_Chcount == 0
                 ? _St | ios_base::failbit : _St);
         return (*this); }
#line 430
template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::ignore(streamsize _N, int_type _Di)
         {ios_base::iostate _St = ios_base::goodbit;
         _Chcount = 0;
         const sentry _Ok(*this, true, _N);
         if (_Ok && 0 < _N)
                 {try {
                 for (; ; )
                         {int_type _C;
                         if (_N != (2147483647) && --_N < 0)
                                 break;
                         else if (_Tr::eq_int_type(_Tr::eof(),
                                 _C = _Myios::rdbuf()->sbumpc()))
                                 {_St |= ios_base::eofbit;
                                 break; }
                         else
                                 {++_Chcount;
                                 if (_C == _Di)
                                         break; }}
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }

template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt&
basic_istream<_E, _Tr>::read(_E *_S, streamsize _N)
         {ios_base::iostate _St = ios_base::goodbit;
         _Chcount = 0;
         const sentry _Ok(*this, true, _N);
         if (_Ok)
                 {try {
                 const streamsize _M = _Myios::rdbuf()->sgetn(_S, _N);
                 _Chcount += _M;
                 if (_M != _N)
                         _St |= ios_base::eofbit | ios_base::failbit;
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }

template<class _E, class _Tr>
inline
streamsize basic_istream<_E, _Tr>::readsome(_E *_S, streamsize _N)
         {ios_base::iostate _St = ios_base::goodbit;
         _Chcount = 0;
         const sentry _Ok(*this, true, _N);
         int _M;
         if (_Myios::rdbuf() == 0)
                 _St |= ios_base::failbit;
         else if ((_M = _Myios::rdbuf()->in_avail()) < 0)
                 _St |= ios_base::eofbit;
         else if (0 < _M)
                 read(_S, _M < _N ? _M : _N);
         _Myios::setstate(_St);
         return (gcount()); }

template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::int_type basic_istream<_E, _Tr>::peek()
         {ios_base::iostate _St = ios_base::goodbit;
         _Chcount = 0;
         int_type _C;
         const sentry _Ok(*this, true, 1);
         if (!_Ok)
                 _C = _Tr::eof();
         else
                 {try {
                 if (_Tr::eq_int_type(_Tr::eof(),
                         _C = _Myios::rdbuf()->sgetc()))
                         _St |= ios_base::eofbit;
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (_C); }

template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt& basic_istream<_E, _Tr>::putback(_E _X)
         {ios_base::iostate _St = ios_base::goodbit;
         _Chcount = 0;
         const sentry _Ok(*this, true);
         if (_Ok)
                 {try {
                 if (_Tr::eq_int_type(_Tr::eof(),
                         _Myios::rdbuf()->sputbackc(_X)))
                         _St |= ios_base::badbit;
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }

template<class _E, class _Tr>
inline
typename basic_istream<_E, _Tr>::_Myt& basic_istream<_E, _Tr>::unget()
         {ios_base::iostate _St = ios_base::goodbit;
         _Chcount = 0;
         const sentry _Ok(*this, true);
         if (_Ok)
                 {try {
                 if (_Tr::eq_int_type(_Tr::eof(),
                         _Myios::rdbuf()->sungetc()))
                         _St |= ios_base::badbit;
                 } catch (...) { _Myios::setstate(ios_base::badbit, true); } }
         _Myios::setstate(_St);
         return (*this); }

template<class _E, class _Tr>
inline
int basic_istream<_E, _Tr>::sync()
         {ios_base::iostate _St = ios_base::goodbit;
         int _Ans;
         if (_Myios::rdbuf() == 0)
                 _Ans = -1;
         else if (_Myios::rdbuf()->pubsync() == -1)
                 _St |= ios_base::badbit, _Ans = -1;
         else
                 _Ans = 0;
         _Myios::setstate(_St);
         return (_Ans); }
#line 551
template<class _E, class _Tr>
inline
basic_istream<_E, _Tr>& operator>>(
                basic_istream<_E, _Tr>& _I, _E *_X)
        {typedef basic_istream<_E, _Tr> _Myis;
        typedef ctype<_E> _Ctype;
        ios_base::iostate _St = ios_base::goodbit;
        _E *_S = _X;
        const typename _Myis::sentry _Ok(_I);
        if (_Ok)
                {const _Ctype& _Fac = use_facet<_Ctype >(_I.getloc());
                try {
                int _N = 0 < _I.width() ? _I.width() : (2147483647);
                typename _Myis::int_type _C = _I.rdbuf()->sgetc();
                for (; 0 < --_N; _C = _I.rdbuf()->snextc())
                        if (_Tr::eq_int_type(_Tr::eof(), _C))
                                {_St |= ios_base::eofbit;
                                break; }
                        else if (_Fac.is(_Ctype::space,
                                _Tr::to_char_type(_C)))
                                break;
                        else
                                *_S++ = _Tr::to_char_type(_C);
                } catch (...) { (_I).setstate(ios_base::badbit, true); } }
        *_S = _E();
        _I.width(0);
        _I.setstate(_S == _X ? _St | ios_base::failbit : _St);
        return (_I); }
#line 591
template<class _E, class _Tr>
inline
basic_istream<_E, _Tr>& operator>>(
                basic_istream<_E, _Tr>& _I, _E& _X)
        {typedef basic_istream<_E, _Tr> _Myis;
        typename _Myis::int_type _C;
        ios_base::iostate _St = ios_base::goodbit;
        const typename _Myis::sentry _Ok(_I);
        if (_Ok)
                {try {
                _C = _I.rdbuf()->sbumpc();
                if (_Tr::eq_int_type(_Tr::eof(), _C))
                        _St |= ios_base::eofbit | ios_base::failbit;
                else
                        _X = _Tr::to_char_type(_C);
                } catch (...) { (_I).setstate(ios_base::badbit, true); } }
        _I.setstate(_St);
        return (_I); }

template<class _E, class _Tr>
inline
basic_istream<_E, _Tr>&
                ws(basic_istream<_E, _Tr>& _I)
        {typedef basic_istream<_E, _Tr> _Myis;
        typedef ctype<_E> _Ctype;
        ios_base::iostate _St = ios_base::goodbit;
        const typename _Myis::sentry _Ok(_I, true);
        if (_Ok)
                {const _Ctype& _Fac = use_facet<_Ctype >(_I.getloc());
                try {
                for (typename _Tr::int_type _C = _I.rdbuf()->sgetc(); ;
                        _C = _I.rdbuf()->snextc())
                        if (_Tr::eq_int_type(_Tr::eof(), _C))
                                {_St |= ios_base::eofbit;
                                break; }
                        else if (!_Fac.is(_Ctype::space,
                                _Tr::to_char_type(_C)))
                                break;
                } catch (...) { (_I).setstate(ios_base::badbit, true); } }
        _I.setstate(_St);
        return (_I); }
#line 642
};
#line 262 "/usr/vacpp/include/istream"
#pragma namemangling()

#pragma object_model(pop)
#line 271
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 76 "/usr/vacpp/include/iostream"
namespace std {
#line 81
extern istream  cin;
extern ostream  cout;
extern ostream  cerr, clog;

class  _Winit {
public:
        _Winit();
        ~_Winit();
private:
        static int _Init_cnt;
        };

extern wistream  wcin;
extern wostream  wcout, wcerr, wclog;
#line 101
};

#pragma namemangling()

#pragma object_model(pop)
#line 112
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 13 "/usr/vacpp/include/algorithm"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 40
#pragma object_model(compat)
#line 45
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/memory"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 40
#pragma object_model(compat)
#line 45
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/iterator"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 40
#pragma object_model(compat)
#line 45
  #pragma namemangling(v7)
#line 69
namespace std {

template<class _C>
        class back_insert_iterator
                : public _Outit {
public:
        typedef _C container_type;
        typedef typename _C::reference reference;
        explicit back_insert_iterator(_C& _X)
                : container(&_X) {}
        back_insert_iterator<_C>& operator=(
                typename _C::const_reference _V)
                {container->push_back(_V);
                return (*this); }
        back_insert_iterator<_C>& operator*()
                {return (*this); }
        back_insert_iterator<_C>& operator++()
                {return (*this); }
        back_insert_iterator<_C> operator++(int)
                {return (*this); }
protected:
        _C *container;
        };
template<class _C> inline
        back_insert_iterator<_C> back_inserter(_C& _X)
        {return (back_insert_iterator<_C>(_X)); }
#line 97
template<class _C>
        class front_insert_iterator
                : public _Outit {
public:
        typedef _C container_type;
        typedef typename _C::reference reference;
        explicit front_insert_iterator(_C& _X)
                : container(&_X) {}
        front_insert_iterator<_C>& operator=(
                typename _C::const_reference _V)
                {container->push_front(_V);
                return (*this); }
        front_insert_iterator<_C>& operator*()
                {return (*this); }
        front_insert_iterator<_C>& operator++()
                {return (*this); }
        front_insert_iterator<_C> operator++(int)
                {return (*this); }
protected:
        _C *container;
        };
template<class _C> inline
        front_insert_iterator<_C> front_inserter(_C& _X)
        {return (front_insert_iterator<_C>(_X)); }
#line 123
template<class _C>
        class insert_iterator
                : public _Outit {
public:
        typedef _C container_type;
        typedef typename _C::reference reference;
        insert_iterator(_C& _X, typename _C::iterator _I)
                : container(&_X), iter(_I) {}
        insert_iterator<_C>& operator=(
                typename _C::const_reference _V)
                {iter = container->insert(iter, _V);
                ++iter;
                return (*this); }
        insert_iterator<_C>& operator*()
                {return (*this); }
        insert_iterator<_C>& operator++()
                {return (*this); }
        insert_iterator<_C>& operator++(int)
                {return (*this); }
protected:
        _C *container;
        typename _C::iterator iter;
        };
template<class _C, class _XI> inline
        insert_iterator<_C> inserter(_C& _X, _XI _I)
        {return (insert_iterator<_C>(_X, _C::iterator(_I))); }
#line 151
template<class _Ty, class _E = char,
        class _Tr = char_traits<_E>,
        class _Dist = ptrdiff_t>
        class istream_iterator
                : public iterator<input_iterator_tag, _Ty, _Dist,
                        _Ty *, _Ty&> {
public:
        typedef istream_iterator<_Ty, _E, _Tr, _Dist> _Myt;
        typedef _E char_type;
        typedef _Tr traits_type;
        typedef basic_istream<_E, _Tr> istream_type;
        istream_iterator()
                : _Istr(0) {}
        istream_iterator(istream_type& _I)
                : _Istr(&_I) {_Getval(); }
        istream_iterator(const _Myt & _I)
		: _Istr(_I._Istr), _Val(_I._Val) {}
        const _Ty& operator*() const
                {return (_Val); }
        const _Ty *operator->() const
                {return (&**this); }
        _Myt& operator++()
                {_Getval();
                return (*this); }
        _Myt operator++(int)
                {_Myt _Tmp = *this;
                _Getval();
                return (_Tmp); }
        bool _Equal(const _Myt& _X) const
                {return (_Istr == _X._Istr); }
protected:
        void _Getval()
                {if (_Istr != 0 && !(*_Istr >> _Val))
                        _Istr = 0; }
        istream_type *_Istr;
        _Ty _Val;
        };
#line 190
template<class _Ty, class _E, class _Tr, class _Dist> inline
        bool operator==(
                const istream_iterator<_Ty, _E, _Tr, _Dist>& _X,
                const istream_iterator<_Ty, _E, _Tr, _Dist>& _Y)
        {return (_X._Equal(_Y)); }
template<class _Ty, class _E, class _Tr, class _Dist> inline
        bool operator!=(
                const istream_iterator<_Ty, _E, _Tr, _Dist>& _X,
                const istream_iterator<_Ty, _E, _Tr, _Dist>& _Y)
        {return (!(_X == _Y)); }
#line 202
template<class _Ty, class _E = char,
        class _Tr = char_traits<_E> >
        class ostream_iterator
                : public _Outit {
public:
        typedef _E char_type;
        typedef _Tr traits_type;
        typedef basic_ostream<_E, _Tr> ostream_type;
        typedef ostream_iterator<_Ty, _E, _Tr> _Myt;
        ostream_iterator(ostream_type& _O)
                : _Ostr(&_O), _Delim(0) {}
        ostream_iterator(ostream_type& _O,
                const _E *_D)
                : _Ostr(&_O), _Delim(_D) {}
        ostream_iterator(const _Myt & _O)
		: _Ostr(_O._Ostr), _Delim(_O._Delim) {}
        ostream_iterator<_Ty, _E, _Tr>& operator=(const _Ty& _X)
                {*_Ostr << _X;
                if (_Delim != 0)
                        *_Ostr << _Delim;
                return (*this); }
        ostream_iterator<_Ty, _E, _Tr>& operator*()
                {return (*this); }
        ostream_iterator<_Ty, _E, _Tr>& operator++()
                {return (*this); }
        ostream_iterator<_Ty, _E, _Tr>& operator++(int)
                {return (*this); }
protected:
        const _E *_Delim;
        ostream_type *_Ostr;
        };
#line 235
template<class _It> inline
        typename iterator_traits<_It>::value_type *_Val_type(_It)
        {return (0); }
#line 240
template<class _II, class _D> inline
        void _Advance(_II& _I, _D _N, input_iterator_tag)
        {for (; 0 < _N; --_N)
                ++_I; }
template<class _FI, class _D> inline
        void _Advance(_FI& _I, _D _N, forward_iterator_tag)
        {for (; 0 < _N; --_N)
                ++_I; }
template<class _BI, class _D> inline
        void _Advance(_BI& _I, _D _N, bidirectional_iterator_tag)
        {for (; 0 < _N; --_N)
                ++_I;
        for (; _N < 0; ++_N)
                --_I; }
template<class _RI, class _D> inline
        void _Advance(_RI& _I, _D _N, random_access_iterator_tag)
        {_I += _N; }
template<class _II, class _D> inline
        void advance(_II& _I, _D _N)
        {_Advance(_I, _N, _Iter_cat(_I)); }
#line 262
template<class _It> inline
        typename iterator_traits<_It>::difference_type
                *_Dist_type(_It)
        {return (0); }
};

#pragma namemangling()

#pragma object_model(pop)
#line 277
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 70 "/usr/vacpp/include/memory"
namespace std {

template<class _Ty> inline
        pair<_Ty  *, ptrdiff_t>
                get_temporary_buffer(ptrdiff_t _N)
        {_Ty  *_P;
        for (_P = 0; 0 < _N; _N /= 2)
                if ((_P = (_Ty  *)operator new(
                        (size_t)_N * sizeof (_Ty),
#line 82
                        nothrow)) != 0)
                        break;
        return (pair<_Ty  *, ptrdiff_t>(_P, _N)); }
#line 87
template<class _Ty> inline
        void return_temporary_buffer(_Ty *_P)
        {operator delete(_P); }
#line 92
template<class _II, class _FI, class _Ty>
        _FI _Uninit_copy(_II _F, _II _L, _FI _X, _Ty *);
template<class _II, class _FI> inline
        _FI uninitialized_copy(_II _F, _II _L, _FI _X)
        {return (_Uninit_copy(_F, _L, _X, _Val_type(_F))); }
#line 99
template<class _FI, class _Tval, class _Ty>
        void _Uninit_fill(_FI _F, _FI _L, const _Tval& _V, _Ty *);
template<class _FI, class _Tval> inline
        void uninitialized_fill(_FI _F, _FI _L, const _Tval& _V)
        {_Uninit_fill(_F, _L, _V, _Val_type(_F)); }
#line 106
template<class _FI, class _S, class _Tval, class _Ty>
        void _Uninit_fill_n(_FI _F, _S _N, const _Tval& _V,
                _Ty *);
template<class _FI, class _S, class _Tval> inline
        void uninitialized_fill_n(_FI _F, _S _N, const _Tval& _V)
        {_Uninit_fill_n(_F, _N, _V, _Val_type(_F)); }
#line 114
template<class _OI, class _Ty>
        class raw_storage_iterator
                : public _Outit {
public:
        typedef _OI iter_type;
        typedef _Ty element_type;
        explicit raw_storage_iterator(_OI _X)
                : _Next(_X) {}
        raw_storage_iterator<_OI, _Ty>& operator*()
                {return (*this); }
        raw_storage_iterator<_OI, _Ty>& operator=(const _Ty& _X)
                {_Construct(&*_Next, _X);
                return (*this); }
        raw_storage_iterator<_OI, _Ty>& operator++()
                {++_Next;
                return (*this); }
        raw_storage_iterator<_OI, _Ty> operator++(int)
                {raw_storage_iterator<_OI, _Ty> _Ans = *this;
                ++_Next;
                return (_Ans); }
private:
        _OI _Next;
        };
#line 139
template<class _Ty>
        class _Temp_iterator
                : public _Outit {
public:
        typedef _Ty  *_Pty;
        _Temp_iterator(ptrdiff_t _N = 0)
                {pair<_Pty, ptrdiff_t> _Pair =
                        get_temporary_buffer<_Ty>(_N);
                _Buf._Begin = _Pair.first;
                _Buf._Cur = _Pair.first;
                _Buf._Hiwater = _Pair.first;
                _Buf._Len = _Pair.second;
                _Pb = &_Buf; }
        _Temp_iterator(const _Temp_iterator<_Ty>& _X)
                {_Buf._Begin = 0;
                _Buf._Cur = 0;
                _Buf._Hiwater = 0;
                _Buf._Len = 0;
                *this = _X; }
        ~_Temp_iterator()
                {if (_Buf._Begin != 0)
                        {for (_Pty _F = _Buf._Begin;
                                _F != _Buf._Hiwater; ++_F)
                                _Destroy(&*_F);
                        return_temporary_buffer(_Buf._Begin); }}
        _Temp_iterator<_Ty>& operator=(const _Temp_iterator<_Ty>& _X)
                {_Pb = _X._Pb;
                return (*this); }
        _Temp_iterator<_Ty>& operator=(const _Ty& _V)
                {if (_Pb->_Cur < _Pb->_Hiwater)
                        *_Pb->_Cur++ = _V;
                else
                        {_Construct(&*_Pb->_Cur, _V);
                        _Pb->_Hiwater = ++_Pb->_Cur; }
                return (*this); }
        _Temp_iterator<_Ty>& operator*()
                {return (*this); }
        _Temp_iterator<_Ty>& operator++()
                {return (*this); }
        _Temp_iterator<_Ty>& operator++(int)
                {return (*this); }
        _Temp_iterator<_Ty>& _Init()
                {_Pb->_Cur = _Pb->_Begin;
                return (*this); }
        _Pty _First() const
                {return (_Pb->_Begin); }
        _Pty _Last() const
                {return (_Pb->_Cur); }
        ptrdiff_t _Maxlen() const
                {return (_Pb->_Len); }
private:
        struct _Bufpar {
                _Pty _Begin;
                _Pty _Cur;
                _Pty _Hiwater;
                ptrdiff_t _Len;
                } _Buf, *_Pb;
        };
#line 200
class _AutoPtrBase {};
template <class _Ty> class auto_ptr;

template<class _U>
        class auto_ptr_ref {
public:
        auto_ptr_ref(auto_ptr<_U>& _Y)
                        : _Ptr(&_Y) {}
        template <class _V>
        auto_ptr_ref(auto_ptr<_V>& _Y, int = 0)
                        : _Ptr(&_Y) {}
        auto_ptr<_U> _Ref()
                {return * static_cast<auto_ptr<_U> *>(_Ptr); }
private:
        _AutoPtrBase * _Ptr;
        };
#line 218
template<class _Ty>
        class auto_ptr : public _AutoPtrBase {
public:
        typedef _Ty element_type;
        explicit auto_ptr(_Ty *_P = 0) throw ()
                : _Ptr(_P) {}
        auto_ptr(auto_ptr<_Ty>& _Y) throw ()
                : _Ptr(_Y.release()) {}
        auto_ptr(auto_ptr_ref<_Ty> _Y) throw ()
                : _Ptr(_Y._Ref().release()) {}
        auto_ptr& operator=(auto_ptr_ref<_Ty> _Y) throw ()
                {reset(_Y._Ref().release());
                return (*this); }
        template<class _U>
                operator auto_ptr<_U>() throw ()
                {return (auto_ptr<_U>(*this)); }
        template<class _U>
                operator auto_ptr_ref<_U>() throw ()
                {return (auto_ptr_ref<_U>(*this, 0)); }
        template<class _U>
                auto_ptr<_Ty>& operator=(auto_ptr<_U>& _Y) throw ()
                {reset(_Y.release());
                return (*this); }
        template<class _U>
                auto_ptr(auto_ptr<_U>& _Y) throw ()
                : _Ptr(_Y.release()) {}
        auto_ptr<_Ty>& operator=(auto_ptr<_Ty>& _Y) throw ()
                {reset(_Y.release());
                return (*this); }
        ~auto_ptr()
                {delete _Ptr; }
        _Ty& operator*() const throw ()
                {return (*get()); }
        _Ty *operator->() const throw ()
                {return (get()); }
        _Ty *get() const throw ()
                {return (_Ptr); }
        _Ty *release() throw ()
                {_Ty *_Tmp = _Ptr;
                _Ptr = 0;
                return (_Tmp); }
        void reset(_Ty* _P = 0)
                {if (_P != _Ptr)
                        delete _Ptr;
                _Ptr = _P; }
private:
        _Ty *_Ptr;
        };
};

#pragma implementation("memory.t")
#line 31 "/usr/vacpp/include/memory.t"
namespace std {

template<class _II, class _FI, class _Ty>
inline
_FI _Uninit_copy(_II _F, _II _L, _FI _X, _Ty *)
        {_FI _Xs = _X;
        try {
        for (; _F != _L; ++_X, ++_F)
                _Construct(&*_X, _Ty(*_F));
        } catch (...) {
        for (; _Xs != _X; ++_Xs)
                _Destroy(&*_Xs);
        throw;
        }
        return (_X); }

template<class _FI, class _Tval, class _Ty>
inline
void _Uninit_fill(_FI _F, _FI _L, const _Tval& _V, _Ty *)
        {_FI _Fs = _F;
        try {
        for (; _F != _L; ++_F)
                _Construct(&*_F, _Ty(_V));
        } catch (...) {
        for (; _Fs != _F; ++_Fs)
                _Destroy(&*_Fs);
        throw;
        } }

template<class _FI, class _S, class _Tval, class _Ty>
inline
void _Uninit_fill_n(_FI _F, _S _N, const _Tval& _V,
                _Ty *)
        {_FI _Fs = _F;
        try {
        for (; 0 < _N; --_N, ++_F)
                _Construct(&*_F, _Ty(_V));
        } catch (...) {
        for (; _Fs != _F; ++_Fs)
                _Destroy(&*_Fs);
        throw;
        } }

};
#line 274 "/usr/vacpp/include/memory"
#pragma namemangling()

#pragma object_model (pop)
#line 283
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 69 "/usr/vacpp/include/algorithm"
namespace std {
#line 75
   static const int _CHUNK_SIZE = 7;
   static const int _SORT_MAX = 16;
#line 80
template<class _II, class _Fn> inline
        _Fn for_each(_II _F, _II _L, _Fn _Op)
        {for (; _F != _L; ++_F)
                _Op(*_F);
        return (_Op); }
#line 87
template<class _II, class _Ty> inline
        _II find(_II _F, _II _L, const _Ty& _V)
        {for (; _F != _L; ++_F)
                if (*_F == _V)
                        break;
        return (_F); }
#line 95
template<class _II, class _Pr> inline
        _II find_if(_II _F, _II _L, _Pr _P)
        {for (; _F != _L; ++_F)
                if (_P(*_F))
                        break;
        return (_F); }
#line 103
template<class _FI> inline
        _FI adjacent_find(_FI _F, _FI _L)
        {for (_FI _Fb; (_Fb = _F) != _L && ++_F != _L; )
                if (*_Fb == *_F)
                        return (_Fb);
        return (_L); }
#line 111
template<class _FI, class _Pr> inline
        _FI adjacent_find(_FI _F, _FI _L, _Pr _P)
        {for (_FI _Fb; (_Fb = _F) != _L && ++_F != _L; )
                if (_P(*_Fb, *_F))
                        return (_Fb);
        return (_L); }
#line 119
template<class _II, class _Ty> inline
        typename iterator_traits<_II>::difference_type count(_II _F, _II _L, const _Ty& _V)
        {typename iterator_traits<_II>::difference_type _N = 0;
        for (; _F != _L; ++_F)
                if (*_F == _V)
                        ++_N;
        return (_N); }
#line 128
template<class _II, class _Pr> inline
        typename iterator_traits<_II>::difference_type count_if(_II _F, _II _L, _Pr _P)
        {typename iterator_traits<_II>::difference_type _N = 0;
        for (; _F != _L; ++_F)
                if (_P(*_F))
                        ++_N;
        return (_N); }
#line 137
template<class _FI1, class _FI2, class _Pd1, class _Pd2>
        _FI1 _Search(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2,
                _Pd1 *, _Pd2 *);
template<class _FI1, class _FI2> inline
        _FI1 search(_FI1 _F1, _FI1 _L1,
                _FI2 _F2, _FI2 _L2)
        {return (_Search(_F1, _L1, _F2, _L2,
                _Dist_type(_F1), _Dist_type(_F2))); }
#line 147
template<class _FI1, class _FI2, class _Pd1, class _Pd2,
        class _Pr>
        _FI1 _Search(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2,
                _Pr _P, _Pd1 *, _Pd2 *);
template<class _FI1, class _FI2, class _Pr> inline
        _FI1 search(_FI1 _F1, _FI1 _L1,
                _FI2 _F2, _FI2 _L2, _Pr _P)
        {return (_Search(_F1, _L1, _F2, _L2, _P,
                _Dist_type(_F1), _Dist_type(_F2))); }
#line 158
template<class _FI1, class _Pd2, class _Ty, class _Pd1>
        _FI1 _Search_n(_FI1 _F1, _FI1 _L1,
                _Pd2 _N, const _Ty& _V, _Pd1 *);
template<class _FI1, class _Pd2, class _Ty> inline
        _FI1 search_n(_FI1 _F1, _FI1 _L1, _Pd2 _N, const _Ty& _V)
        {return (_Search_n(_F1, _L1, _N, _V, _Dist_type(_F1))); }
#line 166
template<class _FI1, class _Pd2,
        class _Ty, class _Pd1, class _Pr>
        _FI1 _Search_n(_FI1 _F1, _FI1 _L1,
                _Pd2 _N, const _Ty& _V, _Pr _P, _Pd1 *);
template<class _FI1, class _Pd2, class _Ty, class _Pr> inline
        _FI1 search_n(_FI1 _F1, _FI1 _L1,
                _Pd2 _N, const _Ty& _V, _Pr _P)
        {return (_Search_n(_F1, _L1,
                _N, _V, _P, _Dist_type(_F1))); }
#line 177
template<class _FI1, class _FI2, class _Pd1, class _Pd2>
        _FI1 _Find_end(_FI1 _F1, _FI1 _L1,
                _FI2 _F2, _FI2 _L2, _Pd1 *, _Pd2 *);
template<class _FI1, class _FI2> inline
        _FI1 find_end(_FI1 _F1, _FI1 _L1,
                _FI2 _F2, _FI2 _L2)
        {return (_Find_end(_F1, _L1, _F2, _L2,
                _Dist_type(_F1), _Dist_type(_F2))); }
#line 187
template<class _FI1, class _FI2, class _Pd1, class _Pd2,
        class _Pr>
        _FI1 _Find_end(_FI1 _F1, _FI1 _L1,
                _FI2 _F2, _FI2 _L2, _Pr _P, _Pd1 *, _Pd2 *);
template<class _FI1, class _FI2, class _Pr> inline
        _FI1 find_end(_FI1 _F1, _FI1 _L1,
                _FI2 _F2, _FI2 _L2, _Pr _P)
        {return (_Find_end(_F1, _L1, _F2, _L2, _P,
                _Dist_type(_F1), _Dist_type(_F2))); }
#line 198
template<class _FI1, class _FI2> inline
        _FI1 find_first_of(_FI1 _F1, _FI1 _L1,
                _FI2 _F2, _FI2 _L2)
        {for (; _F1 != _L1; ++_F1)
                for (_FI2 _X2 = _F2; _X2 != _L2; ++_X2)
                        if (*_F1 == *_X2)
                                return (_F1);
        return (_F1); }
#line 208
template<class _FI1, class _FI2, class _Pr> inline
        _FI1 find_first_of(_FI1 _F1, _FI1 _L1,
                _FI2 _F2, _FI2 _L2, _Pr _P)
        {for (; _F1 != _L1; ++_F1)
                for (_FI2 _X2 = _F2; _X2 != _L2; ++_X2)
                        if (_P(*_F1, *_X2))
                                return (_F1);
        return (_F1); }
#line 218
template<class _FI1, class _FI2, class _Ty> inline
        void _Iter_swap(_FI1 _X, _FI2 _Y, _Ty *)
        {_Ty _Tmp = *_X;
        *_X = *_Y, *_Y = _Tmp; }
template<class _FI1, class _FI2> inline
        void iter_swap(_FI1 _X, _FI2 _Y)
        {_Iter_swap(_X, _Y, _Val_type(_X)); }
#line 227
template<class _FI1, class _FI2> inline
        _FI2 swap_ranges(_FI1 _F, _FI1 _L, _FI2 _X)
        {for (; _F != _L; ++_F, ++_X)
                iter_swap(_F, _X);
        return (_X); }
#line 234
template<class _II, class _OI, class _Uop> inline
        _OI transform(_II _F, _II _L, _OI _X, _Uop _U)
        {for (; _F != _L; ++_F, ++_X)
                *_X = _U(*_F);
        return (_X); }
#line 241
template<class _II1, class _II2, class _OI, class _Bop> inline
        _OI transform(_II1 _F1, _II1 _L1, _II2 _F2, _OI _X, _Bop _B)
        {for (; _F1 != _L1; ++_F1, ++_F2, ++_X)
                *_X = _B(*_F1, *_F2);
        return (_X); }
#line 248
template<class _FI, class _Ty> inline
        void replace(_FI _F, _FI _L, const _Ty& _Vo, const _Ty& _Vn)
        {for (; _F != _L; ++_F)
                if (*_F == _Vo)
                        *_F = _Vn; }
#line 255
template<class _FI, class _Pr, class _Ty> inline
        void replace_if(_FI _F, _FI _L, _Pr _P, const _Ty& _V)
        {for (; _F != _L; ++_F)
                if (_P(*_F))
                        *_F = _V; }
#line 262
template<class _II, class _OI, class _Ty> inline
        _OI replace_copy(_II _F, _II _L, _OI _X,
                const _Ty& _Vo, const _Ty& _Vn)
        {for (; _F != _L; ++_F, ++_X)
                *_X = *_F == _Vo ? _Vn : *_F;
                return (_X); }
#line 270
template<class _II, class _OI, class _Pr, class _Ty> inline
        _OI replace_copy_if(_II _F, _II _L, _OI _X,
                _Pr _P, const _Ty& _V)
        {for (; _F != _L; ++_F, ++_X)
                *_X = _P(*_F) ? _V : *_F;
                return (_X); }
#line 278
template<class _FI, class _Gen> inline
        void generate(_FI _F, _FI _L, _Gen _G)
        {for (; _F != _L; ++_F)
                *_F = _G(); }
#line 284
template<class _OI, class _Pd, class _Gen> inline
        void generate_n(_OI _F, _Pd _N, _Gen _G)
        {for (; 0 < _N; --_N, ++_F)
                *_F = _G(); }
#line 290
template<class _FI, class _Ty> inline
        _FI remove(_FI _F, _FI _L, const _Ty& _V)
        {_F = find(_F, _L, _V);
        if (_F == _L)
                return (_F);
        else
                {_FI _Fb = _F;
                return (remove_copy(++_F, _L, _Fb, _V)); }}
#line 300
template<class _FI, class _Pr> inline
        _FI remove_if(_FI _F, _FI _L, _Pr _P)
        {_F = find_if(_F, _L, _P);
        if (_F == _L)
                return (_F);
        else
                {_FI _Fb = _F;
                return (remove_copy_if(++_F, _L, _Fb, _P)); }}
#line 310
template<class _II, class _OI, class _Ty> inline
        _OI remove_copy(_II _F, _II _L, _OI _X, const _Ty& _V)
        {for (; _F != _L; ++_F)
                if (!(*_F == _V))
                        *_X++ = *_F;
        return (_X); }
#line 318
template<class _II, class _OI, class _Pr> inline
        _OI remove_copy_if(_II _F, _II _L, _OI _X, _Pr _P)
        {for (; _F != _L; ++_F)
                if (!_P(*_F))
                        *_X++ = *_F;
        return (_X); }
#line 326
template<class _FI> inline
        _FI unique(_FI _F, _FI _L)
        {_F = adjacent_find(_F, _L);
        return (unique_copy(_F, _L, _F)); }
#line 332
template<class _FI, class _Pr> inline
        _FI unique(_FI _F, _FI _L, _Pr _P)
        {_F = adjacent_find(_F, _L, _P);
        return (unique_copy(_F, _L, _F, _P)); }
#line 338
template<class _II, class _OI, class _Ty> inline
        _OI _Unique_copy(_II _F, _II _L, _OI _X, _Ty *)
        {_Ty _V = *_F;
        for (*_X++ = _V; ++_F != _L; )
                if (!(_V == *_F))
                        _V = *_F, *_X++ = _V;
        return (_X); }
template<class _FI, class _OI> inline
        _OI _Unique_copy(_FI _F, _FI _L, _OI _X,
                forward_iterator_tag)
        {_FI _Fb = _F;
        for (*_X++ = *_Fb; ++_F != _L; )
                if (!(*_Fb == *_F))
                        _Fb = _F, *_X++ = *_Fb;
        return (_X); }
template<class _BI, class _OI> inline
        _OI _Unique_copy(_BI _F, _BI _L, _OI _X,
                bidirectional_iterator_tag)
        {return (_Unique_copy(_F, _L, _X, forward_iterator_tag())); }
template<class _RI, class _OI> inline
        _OI _Unique_copy(_RI _F, _RI _L, _OI _X,
                random_access_iterator_tag)
        {return (_Unique_copy(_F, _L, _X, forward_iterator_tag())); }
template<class _II, class _OI> inline
        _OI _Unique_copy(_II _F, _II _L, _OI _X,
                input_iterator_tag)
        {return (_Unique_copy(_F, _L, _X, _Val_type(_F))); }
template<class _II, class _OI> inline
        _OI unique_copy(_II _F, _II _L, _OI _X)
        {return (_F == _L ? _X :
                _Unique_copy(_F, _L, _X, _Iter_cat(_F))); }
#line 371
template<class _II, class _OI, class _Ty, class _Pr> inline
        _OI _Unique_copy(_II _F, _II _L, _OI _X, _Pr _P, _Ty *)
        {_Ty _V = *_F;
        for (*_X++ = _V; ++_F != _L; )
                if (!_P(_V, *_F))
                        _V = *_F, *_X++ = _V;
        return (_X); }
template<class _FI, class _OI, class _Pr> inline
        _OI _Unique_copy(_FI _F, _FI _L, _OI _X, _Pr _P,
                forward_iterator_tag)
        {_FI _Fb = _F;
        for (*_X++ = *_Fb; ++_F != _L; )
                if (!_P(*_Fb, *_F))
                        _Fb = _F, *_X++ = *_Fb;
        return (_X); }
template<class _BI, class _OI, class _Pr> inline
        _OI _Unique_copy(_BI _F, _BI _L, _OI _X, _Pr _P,
                bidirectional_iterator_tag)
        {return (_Unique_copy(_F, _L, _X, _P,
                forward_iterator_tag())); }
template<class _RI, class _OI, class _Pr> inline
        _OI _Unique_copy(_RI _F, _RI _L, _OI _X, _Pr _P,
                random_access_iterator_tag)
        {return (_Unique_copy(_F, _L, _X, _P,
                forward_iterator_tag())); }
template<class _II, class _OI, class _Pr> inline
        _OI _Unique_copy(_II _F, _II _L, _OI _X, _Pr _P,
                input_iterator_tag)
        {return (_Unique_copy(_F, _L, _X, _P, _Val_type(_F))); }
template<class _II, class _OI, class _Pr> inline
        _OI unique_copy(_II _F, _II _L, _OI _X, _Pr _P)
        {return (_F == _L ? _X :
                _Unique_copy(_F, _L, _X, _P, _Iter_cat(_F))); }
#line 406
template<class _BI> inline
        void _Reverse(_BI _F, _BI _L, bidirectional_iterator_tag)
        {for (; _F != _L && _F != --_L; ++_F)
                iter_swap(_F, _L); }
template<class _RI> inline
        void _Reverse(_RI _F, _RI _L, random_access_iterator_tag)
        {for (; _F < _L; ++_F)
                iter_swap(_F, --_L); }
template<class _BI> inline
        void reverse(_BI _F, _BI _L)
        {_Reverse(_F, _L, _Iter_cat(_F)); }
#line 419
template<class _BI, class _OI> inline
        _OI reverse_copy(_BI _F, _BI _L, _OI _X)
        {for (; _F != _L; ++_X)
                *_X = *--_L;
        return (_X); }
#line 426
template<class _RI, class _Pd, class _Ty>
        void _Rotate(_RI _F, _RI _M, _RI _L, _Pd *, _Ty *);
template<class _FI> inline
        void _Rotate(_FI _F, _FI _M, _FI _L,
                forward_iterator_tag)
        {for (_FI _X = _M; ; )
                {iter_swap(_F, _X);
                if (++_F == _M)
                        if (++_X == _L)
                                break;
                        else
                                _M = _X;
                else if (++_X == _L)
                        _X = _M; }}
template<class _BI> inline
        void _Rotate(_BI _F, _BI _M, _BI _L,
                bidirectional_iterator_tag)
        {reverse(_F, _M);
        reverse(_M, _L);
        reverse(_F, _L); }
template<class _RI> inline
        void _Rotate(_RI _F, _RI _M, _RI _L,
                        random_access_iterator_tag)
        {_Rotate(_F, _M, _L, _Dist_type(_F), _Val_type(_F)); }
template<class _FI> inline
        void rotate(_FI _F, _FI _M, _FI _L)
        {if (_F != _M && _M != _L)
                _Rotate(_F, _M, _L, _Iter_cat(_F)); }
#line 456
template<class _FI, class _OI> inline
        _OI rotate_copy(_FI _F, _FI _M, _FI _L, _OI _X)
        {_X = copy(_M, _L, _X);
        return (copy(_F, _M, _X)); }
#line 462
template<class _RI, class _Pd>
        void _Random_shuffle(_RI _F, _RI _L, _Pd *);
template<class _RI> inline
        void random_shuffle(_RI _F, _RI _L)
        {if (_F != _L)
                _Random_shuffle(_F, _L, _Dist_type(_F)); }
#line 470
template<class _RI, class _Pf, class _Pd> inline
        void _Random_shuffle(_RI _F, _RI _L, _Pf& _R, _Pd *)
        {_RI _X = _F;
        for (unsigned long _D = 2; ++_X != _L; ++_D)
                iter_swap(_X, _F + _Pd(_R(_D))); }
template<class _RI, class _Pf> inline
        void random_shuffle(_RI _F, _RI _L, _Pf& _R)
        {if (_F != _L)
                _Random_shuffle(_F, _L, _R, _Dist_type(_F)); }
#line 481
template<class _BI, class _Pr>
        _BI partition(_BI _F, _BI _L, _Pr _P);
#line 485
template<class _BI, class _Pr, class _Pd, class _Ty>
        _BI _Stable_partition(_BI _F, _BI _L, _Pr _P, _Pd _N,
                _Temp_iterator<_Ty>& _Xb);
template<class _BI, class _Pr, class _Pd, class _Ty> inline
        _BI _Stable_partition(_BI _F, _BI _L, _Pr _P, _Pd *, _Ty *)
        {_Pd _N = 0;
        _Distance(_F, _L, _N);
        _Temp_iterator<_Ty> _Xb(_N);
        return (_Stable_partition(_F, _L, _P, _N, _Xb)); }
template<class _BI, class _Pr> inline
        _BI stable_partition(_BI _F, _BI _L, _Pr _P)
        {return (_F == _L ? _F : _Stable_partition(_F, _L, _P,
                _Dist_type(_F), _Val_type(_F))); }
#line 500
template<class _BI, class _Ty>
        void _Insertion_sort_1(_BI _F, _BI _L, _Ty *);
template<class _BI> inline
        void _Insertion_sort(_BI _F, _BI _L)
        {_Insertion_sort_1(_F, _L, _Val_type(_F)); }
template<class _RI, class _Ty>
        _RI _Unguarded_partition(_RI _F, _RI _L, _Ty *);
template<class _RI, class _Pd>
        void _Sort(_RI _F, _RI _L, _Pd _Ideal);
template<class _BI, class _Ty> inline
        void _Unguarded_insert(_BI _L, _Ty _V)
        {for (_BI _M = _L; _V < *--_M; _L = _M)
                *_L = *_M;
        *_L = _V; }
template<class _RI, class _Ty>
        void _Sort_end(_RI _F, _RI _L, _Ty *)
        {for (; _F != _L; ++_F)
                _Unguarded_insert(_F, _Ty(*_F)); }
template<class _RI> inline
        void sort(_RI _F, _RI _L)
        {if (_L - _F <= _SORT_MAX)
                _Insertion_sort(_F, _L);
        else
                {_Sort(_F, _L, _L - _F);
                _Insertion_sort(_F, _F + _SORT_MAX);
                _Sort_end(_F + _SORT_MAX, _L, _Val_type(_F)); }}
#line 528
template<class _BI, class _Ty, class _Pr>
        void _Insertion_sort_1(_BI _F, _BI _L, _Pr _P, _Ty *);
template<class _BI, class _Pr> inline
        void _Insertion_sort(_BI _F, _BI _L, _Pr _P)
        {_Insertion_sort_1(_F, _L, _P, _Val_type(_F)); }
template<class _RI, class _Pr, class _Ty>
        _RI _Unguarded_partition(_RI _F, _RI _L, _Pr _P, _Ty *);
template<class _RI, class _Pd, class _Pr>
        void _Sort(_RI _F, _RI _L, _Pd _Ideal, _Pr _P);
template<class _BI, class _Ty, class _Pr> inline
        void _Unguarded_insert(_BI _L, _Ty _V, _Pr _P)
        {for (_BI _M = _L; _P(_V, *--_M); _L = _M)
                *_L = *_M;
        *_L = _V; }
template<class _RI, class _Pr, class _Ty>
        void _Sort_end(_RI _F, _RI _L, _Pr _P, _Ty *)
        {for (; _F != _L; ++_F)
                _Unguarded_insert(_F, _Ty(*_F), _P); }
template<class _RI, class _Pr> inline
        void sort(_RI _F, _RI _L, _Pr _P)
        {if (_L - _F <= _SORT_MAX)
                _Insertion_sort(_F, _L, _P);
        else
                {_Sort(_F, _L, _L - _F, _P);
                _Insertion_sort(_F, _F + _SORT_MAX, _P);
                _Sort_end(_F + _SORT_MAX, _L, _P, _Val_type(_F)); }}
#line 556
template<class _BI, class _Pd, class _Ty>
        void _Stable_sort(_BI _F, _BI _L, _Pd _N,
                _Temp_iterator<_Ty>& _Xb);
template<class _BI, class _Pd, class _Ty> inline
        void _Stable_sort(_BI _F, _BI _L, _Pd *, _Ty *)
        {_Pd _N = 0;
        _Distance(_F, _L, _N);
        _Temp_iterator<_Ty> _Xb(_N);
        _Stable_sort(_F, _L, _N, _Xb); }
template<class _BI, class _Pd, class _Ty>
        void _Buffered_merge_sort(_BI _F, _BI _L, _Pd _N,
                _Temp_iterator<_Ty>& _Xb);
template<class _BI, class _OI, class _Pd>
        void _Chunked_merge(_BI _F, _BI _L, _OI _X, _Pd _D, _Pd _N);
template<class _BI> inline
        void stable_sort(_BI _F, _BI _L)
        {if (_F != _L)
                _Stable_sort(_F, _L, _Dist_type(_F), _Val_type(_F)); }
#line 576
template<class _BI, class _Pd, class _Ty, class _Pr>
        void _Stable_sort(_BI _F, _BI _L, _Pd _N,
                _Temp_iterator<_Ty>& _Xb, _Pr _P);
template<class _BI, class _Pd, class _Ty, class _Pr> inline
        void _Stable_sort(_BI _F, _BI _L, _Pd *, _Ty *, _Pr _P)
        {_Pd _N = 0;
        _Distance(_F, _L, _N);
        _Temp_iterator<_Ty> _Xb(_N);
        _Stable_sort(_F, _L, _N, _Xb, _P); }
template<class _BI, class _Pd, class _Ty, class _Pr>
        void _Buffered_merge_sort(_BI _F, _BI _L, _Pd _N,
                _Temp_iterator<_Ty>& _Xb, _Pr _P);
template<class _BI, class _OI, class _Pd, class _Pr>
        void _Chunked_merge(_BI _F, _BI _L, _OI _X,
                _Pd _D, _Pd _N, _Pr _P);
template<class _BI, class _Pr> inline
        void stable_sort(_BI _F, _BI _L, _Pr _P)
        {if (_F != _L)
                _Stable_sort(_F, _L,
                        _Dist_type(_F), _Val_type(_F), _P); }
#line 598
template<class _RI, class _Ty> inline
        void _Partial_sort(_RI _F, _RI _M, _RI _L, _Ty *)
        {make_heap(_F, _M);
        for (_RI _I = _M; _I < _L; ++_I)
                if (*_I < *_F)
                        _Pop_heap(_F, _M, _I, _Ty(*_I), _Dist_type(_F));
        sort_heap(_F, _M); }
template<class _RI> inline
        void partial_sort(_RI _F, _RI _M, _RI _L)
        {_Partial_sort(_F, _M, _L, _Val_type(_F)); }
#line 610
template<class _RI, class _Ty, class _Pr> inline
        void _Partial_sort(_RI _F, _RI _M, _RI _L, _Pr _P, _Ty *)
        {make_heap(_F, _M, _P);
        for (_RI _I = _M; _I < _L; ++_I)
                if (_P(*_I, *_F))
                        _Pop_heap(_F, _M, _I, _Ty(*_I), _P, _Dist_type(_F));
        sort_heap(_F, _M, _P); }
template<class _RI, class _Pr> inline
        void partial_sort(_RI _F, _RI _M, _RI _L, _Pr _P)
        {_Partial_sort(_F, _M, _L, _P, _Val_type(_F)); }
#line 622
template<class _II, class _RI, class _Pd, class _Ty>
        _RI _Partial_sort_copy(_II _F1, _II _L1, _RI _F2, _RI _L2,
                _Pd *, _Ty *);
template<class _II, class _RI> inline
        _RI partial_sort_copy(_II _F1, _II _L1, _RI _F2, _RI _L2)
        {return (_Partial_sort_copy(_F1, _L1, _F2, _L2,
                _Dist_type(_F2), _Val_type(_F1))); }
#line 631
template<class _II, class _RI, class _Pd,
        class _Ty, class _Pr>
        _RI _Partial_sort_copy(_II _F1, _II _L1, _RI _F2, _RI _L2,
                _Pr _P, _Pd *, _Ty *);
template<class _II, class _RI, class _Pr> inline
        _RI partial_sort_copy(_II _F1, _II _L1, _RI _F2, _RI _L2,
                _Pr _P)
        {return (_Partial_sort_copy(_F1, _L1, _F2, _L2, _P,
                _Dist_type(_F2), _Val_type(_F1))); }
#line 642
template<class _RI>
        void nth_element(_RI _F, _RI _Nth, _RI _L);
#line 646
template<class _RI, class _Pr>
        void nth_element(_RI _F, _RI _Nth, _RI _L, _Pr _P);
#line 650
template<class _FI, class _Ty, class _Pd>
        _FI _Lower_bound(_FI _F, _FI _L, const _Ty& _V, _Pd *);
template<class _FI, class _Ty> inline
        _FI lower_bound(_FI _F, _FI _L, const _Ty& _V)
        {return (_Lower_bound(_F, _L, _V, _Dist_type(_F))); }
#line 657
template<class _FI, class _Ty, class _Pd, class _Pr>
        _FI _Lower_bound(_FI _F, _FI _L, const _Ty& _V, _Pr _P, _Pd *);
template<class _FI, class _Ty, class _Pr> inline
        _FI lower_bound(_FI _F, _FI _L, const _Ty& _V, _Pr _P)
        {return (_Lower_bound(_F, _L, _V, _P, _Dist_type(_F))); }
#line 664
template<class _FI, class _Ty, class _Pd>
        _FI _Upper_bound(_FI _F, _FI _L, const _Ty& _V, _Pd *);
template<class _FI, class _Ty> inline
        _FI upper_bound(_FI _F, _FI _L, const _Ty& _V)
        {return (_Upper_bound(_F, _L, _V, _Dist_type(_F))); }
#line 671
template<class _FI, class _Ty, class _Pd, class _Pr>
        _FI _Upper_bound(_FI _F, _FI _L, const _Ty& _V, _Pr _P, _Pd *);
template<class _FI, class _Ty, class _Pr> inline
        _FI upper_bound(_FI _F, _FI _L, const _Ty& _V, _Pr _P)
        {return (_Upper_bound(_F, _L, _V, _P, _Dist_type(_F))); }
#line 678
template<class _FI, class _Ty, class _Pd>
        pair<_FI, _FI> _Equal_range(_FI _F, _FI _L,
                const _Ty& _V, _Pd *);
template<class _FI, class _Ty> inline
        pair<_FI, _FI> equal_range(_FI _F, _FI _L, const _Ty& _V)
        {return (_Equal_range(_F, _L, _V, _Dist_type(_F))); }
#line 686
template<class _FI, class _Ty, class _Pd, class _Pr>
        pair<_FI, _FI> _Equal_range(_FI _F, _FI _L, const _Ty& _V,
                _Pr _P, _Pd *);
template<class _FI, class _Ty, class _Pr> inline
        pair<_FI, _FI> equal_range(_FI _F, _FI _L, const _Ty& _V,
                _Pr _P)
        {return (_Equal_range(_F, _L, _V, _P, _Dist_type(_F))); }
#line 695
template<class _FI, class _Ty> inline
        bool binary_search(_FI _F, _FI _L, const _Ty& _V)
        {_FI _I = lower_bound(_F, _L, _V);
        return (_I != _L && !(_V < *_I)); }
#line 701
template<class _FI, class _Ty, class _Pr> inline
        bool binary_search(_FI _F, _FI _L, const _Ty& _V, _Pr _P)
        {_FI _I = lower_bound(_F, _L, _V, _P);
        return (_I != _L && !_P(_V, *_I)); }
#line 707
template<class _II1, class _II2, class _OI>
        _OI merge(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2, _OI _X);
#line 711
template<class _II1, class _II2, class _OI, class _Pr>
        _OI merge(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2, _OI _X,
                _Pr _P);
#line 716
template<class _BI, class _Pd, class _Ty>
        void _Inplace_merge(_BI _F, _BI _M, _BI _L, _Pd *, _Ty *);
template<class _BI, class _Pd, class _Ty>
        void _Buffered_merge(_BI _F, _BI _M, _BI _L,
                _Pd _D1, _Pd _D2, _Temp_iterator<_Ty>& _Xb);
template<class _BI1, class _BI2, class _BI3>
        _BI3 _Merge_backward(_BI1 _F1, _BI1 _L1,
                _BI2 _F2, _BI2 _L2, _BI3 _X);
template<class _BI, class _Pd, class _Ty>
        _BI _Buffered_rotate(_BI _F, _BI _M, _BI _L,
                _Pd _D1, _Pd _D2, _Temp_iterator<_Ty>& _Xb);
template<class _BI> inline
        void inplace_merge(_BI _F, _BI _M, _BI _L)
        {if (_F != _L)
                _Inplace_merge(_F, _M, _L,
                        _Dist_type(_F), _Val_type(_F)); }
#line 734
template<class _BI, class _Pd, class _Ty, class _Pr>
        void _Inplace_merge(_BI _F, _BI _M, _BI _L, _Pr _P,
                _Pd *, _Ty *);
template<class _BI, class _Pd, class _Ty, class _Pr>
        void _Buffered_merge(_BI _F, _BI _M, _BI _L,
                _Pd _D1, _Pd _D2, _Temp_iterator<_Ty>& _Xb, _Pr _P);
template<class _BI1, class _BI2, class _BI3, class _Pr>
        _BI3 _Merge_backward(_BI1 _F1, _BI1 _L1,
                _BI2 _F2, _BI2 _L2, _BI3 _X, _Pr _P);
template<class _BI, class _Pr> inline
        void inplace_merge(_BI _F, _BI _M, _BI _L, _Pr _P)
        {if (_F != _L)
                _Inplace_merge(_F, _M, _L, _P,
                        _Dist_type(_F), _Val_type(_F)); }
#line 750
template<class _II1, class _II2>
        bool includes(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2);
#line 754
template<class _II1, class _II2, class _Pr>
        bool includes(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2, _Pr _P);
#line 758
template<class _II1, class _II2, class _OI>
        _OI set_union(_II1 _F1, _II1 _L1,
                _II2 _F2, _II2 _L2, _OI _X);
#line 763
template<class _II1, class _II2, class _OI, class _Pr>
        _OI set_union(_II1 _F1, _II1 _L1,
                _II2 _F2, _II2 _L2, _OI _X, _Pr _P);
#line 768
template<class _II1, class _II2, class _OI>
        _OI set_intersection(_II1 _F1, _II1 _L1,
                _II2 _F2, _II2 _L2, _OI _X);
#line 773
template<class _II1, class _II2, class _OI, class _Pr>
        _OI set_intersection(_II1 _F1, _II1 _L1,
                _II2 _F2, _II2 _L2, _OI _X, _Pr _P);
#line 778
template<class _II1, class _II2, class _OI>
        _OI set_difference(_II1 _F1, _II1 _L1,
                _II2 _F2, _II2 _L2,     _OI _X);
#line 783
template<class _II1, class _II2, class _OI, class _Pr>
        _OI set_difference(_II1 _F1, _II1 _L1,
                _II2 _F2, _II2 _L2, _OI _X, _Pr _P);
#line 788
template<class _II1, class _II2, class _OI>
        _OI set_symmetric_difference(_II1 _F1, _II1 _L1,
                _II2 _F2, _II2 _L2, _OI _X);
#line 793
template<class _II1, class _II2, class _OI, class _Pr>
        _OI set_symmetric_difference(_II1 _F1, _II1 _L1,
                _II2 _F2, _II2 _L2, _OI _X, _Pr _P);
#line 798
template<class _RI, class _Pd, class _Ty> inline
        void _Push_heap(_RI _F, _Pd _H, _Pd _J, _Ty _V)
        {for (_Pd _I = (_H - 1) / 2; _J < _H && *(_F + _I) < _V;
                _I = (_H - 1) / 2)
                *(_F + _H) = *(_F + _I), _H = _I;
        *(_F + _H) = _V; }
template<class _RI, class _Pd, class _Ty> inline
        void _Push_heap_0(_RI _F, _RI _L, _Pd *, _Ty *)
        {_Push_heap(_F, _Pd(_L - _F - 1), _Pd(0), _Ty(*(_L - 1))); }
template<class _RI> inline
        void push_heap(_RI _F, _RI _L)
        {_Push_heap_0(_F, _L, _Dist_type(_F), _Val_type(_F)); }
#line 812
template<class _RI, class _Pd, class _Ty, class _Pr> inline
        void _Push_heap(_RI _F, _Pd _H, _Pd _J, _Ty _V, _Pr _P)
        {for (_Pd _I = (_H - 1) / 2; _J < _H && _P(*(_F + _I), _V);
                _I = (_H - 1) / 2)
                *(_F + _H) = *(_F + _I), _H = _I;
        *(_F + _H) = _V; }
template<class _RI, class _Pd, class _Ty, class _Pr> inline
        void _Push_heap_0(_RI _F, _RI _L, _Pr _P, _Pd *, _Ty *)
        {_Push_heap(_F, _Pd(_L - _F - 1), _Pd(0),
                _Ty(*(_L - 1)), _P); }
template<class _RI, class _Pr> inline
        void push_heap(_RI _F, _RI _L, _Pr _P)
        {_Push_heap_0(_F, _L, _P,
                _Dist_type(_F), _Val_type(_F)); }
#line 828
template<class _RI, class _Pd, class _Ty>
        void _Adjust_heap(_RI _F, _Pd _H, _Pd _N, _Ty _V);
template<class _RI, class _Pd, class _Ty> inline
        void _Pop_heap(_RI _F, _RI _L, _RI _X, _Ty _V, _Pd *)
        {*_X = *_F;
        _Adjust_heap(_F, _Pd(0), _Pd(_L - _F), _V); }
template<class _RI, class _Ty> inline
        void _Pop_heap_0(_RI _F, _RI _L, _Ty *)
        {_Pop_heap(_F, _L - 1, _L - 1, _Ty(*(_L - 1)),
                _Dist_type(_F)); }
template<class _RI> inline
        void pop_heap(_RI _F, _RI _L)
        {_Pop_heap_0(_F, _L, _Val_type(_F)); }
#line 843
template<class _RI, class _Pd, class _Ty, class _Pr>
        void _Adjust_heap(_RI _F, _Pd _H, _Pd _N, _Ty _V, _Pr _P);
template<class _RI, class _Pd, class _Ty, class _Pr> inline
        void _Pop_heap(_RI _F, _RI _L, _RI _X, _Ty _V, _Pr _P, _Pd *)
        {*_X = *_F;
        _Adjust_heap(_F, _Pd(0), _Pd(_L - _F), _V, _P); }
template<class _RI, class _Ty, class _Pr> inline
        void _Pop_heap_0(_RI _F, _RI _L, _Pr _P, _Ty *)
        {_Pop_heap(_F, _L - 1, _L - 1, _Ty(*(_L - 1)), _P,
                _Dist_type(_F)); }
template<class _RI, class _Pr> inline
        void pop_heap(_RI _F, _RI _L, _Pr _P)
        {_Pop_heap_0(_F, _L, _P, _Val_type(_F)); }
#line 858
template<class _RI, class _Pd, class _Ty> inline
        void _Make_heap(_RI _F, _RI _L, _Pd *, _Ty *)
        {_Pd _N = _L - _F;
        for (_Pd _H = _N / 2; 0 < _H; )
                --_H, _Adjust_heap(_F, _H, _N, _Ty(*(_F + _H))); }
template<class _RI> inline
        void make_heap(_RI _F, _RI _L)
        {if (2 <= _L - _F)
                _Make_heap(_F, _L, _Dist_type(_F), _Val_type(_F)); }
#line 869
template<class _RI, class _Pd, class _Ty, class _Pr> inline
        void _Make_heap(_RI _F, _RI _L, _Pr _P, _Pd *, _Ty *)
        {_Pd _N = _L - _F;
        for (_Pd _H = _N / 2; 0 < _H; )
                --_H, _Adjust_heap(_F, _H, _N, _Ty(*(_F + _H)), _P); }
template<class _RI, class _Pr> inline
        void make_heap(_RI _F, _RI _L, _Pr _P)
        {if (2 <= _L - _F)
                _Make_heap(_F, _L, _P,
                        _Dist_type(_F), _Val_type(_F)); }
#line 881
template<class _RI> inline
        void sort_heap(_RI _F, _RI _L)
        {for (; 1 < _L - _F; --_L)
                pop_heap(_F, _L); }
#line 887
template<class _RI, class _Pr> inline
        void sort_heap(_RI _F, _RI _L, _Pr _P)
        {for (; 1 < _L - _F; --_L)
                pop_heap(_F, _L, _P); }
#line 893
template<class _FI>
        _FI max_element(_FI _F, _FI _L);
#line 897
template<class _FI, class _Pr>
        _FI max_element(_FI _F, _FI _L, _Pr _P);
#line 901
template<class _FI>
        _FI min_element(_FI _F, _FI _L);
#line 905
template<class _FI, class _Pr>
        _FI min_element(_FI _F, _FI _L, _Pr _P);
#line 909
template<class _BI>
        bool next_permutation(_BI _F, _BI _L);
#line 913
template<class _BI, class _Pr>
        bool next_permutation(_BI _F, _BI _L, _Pr _P);
#line 917
template<class _BI>
        bool prev_permutation(_BI _F, _BI _L);
#line 921
template<class _BI, class _Pr>
        bool prev_permutation(_BI _F, _BI _L, _Pr _P);
};

#pragma implementation("algorithm.t")
#line 31 "/usr/vacpp/include/algorithm.t"
namespace std {

template<class _FI1, class _FI2, class _Pd1, class _Pd2>
        inline
        _FI1 _Search(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2,
                _Pd1 *, _Pd2 *)
        {_Pd1 _D1 = 0;
        _Distance(_F1, _L1, _D1);
        _Pd2 _D2 = 0;
        _Distance(_F2, _L2, _D2);
        for (; _D2 <= _D1; ++_F1, --_D1)
                {_FI1 _X1 = _F1;
                for (_FI2 _X2 = _F2; ; ++_X1, ++_X2)
                        if (_X2 == _L2)
                                return (_F1);
                        else if (!(*_X1 == *_X2))
                                break; }
        return (_L1); }

template<class _FI1, class _FI2, class _Pd1, class _Pd2,
        class _Pr>
        inline
        _FI1 _Search(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2,
                _Pr _P, _Pd1 *, _Pd2 *)
        {_Pd1 _D1 = 0;
        _Distance(_F1, _L1, _D1);
        _Pd2 _D2 = 0;
        _Distance(_F2, _L2, _D2);
        for (; _D2 <= _D1; ++_F1, --_D1)
                {_FI1 _X1 = _F1;
                for (_FI2 _X2 = _F2; ; ++_X1, ++_X2)
                        if (_X2 == _L2)
                                return (_F1);
                        else if (!_P(*_X1, *_X2))
                                break; }
        return (_L1); }

template<class _FI1, class _Pd2, class _Ty, class _Pd1>
        inline
        _FI1 _Search_n(_FI1 _F1, _FI1 _L1, _Pd2 _N, const _Ty& _V, _Pd1 *)
        {_Pd1 _D1 = 0;
        _Distance(_F1, _L1, _D1);
        for (; _N <= _D1; ++_F1, --_D1)
                {_FI1 _X1 = _F1;
                for (_Pd2 _D2 = _N; ; ++_X1, --_D2)
                        if (_D2 == 0)
                                return (_F1);
                        else if (!(*_X1 == _V))
                                break; }
        return (_L1); }

template<class _FI1, class _Pd2,
        class _Ty, class _Pd1, class _Pr>
        inline
        _FI1 _Search_n(_FI1 _F1, _FI1 _L1,
                _Pd2 _N, const _Ty& _V, _Pr _P, _Pd1 *)
        {_Pd1 _D1 = 0;
        _Distance(_F1, _L1, _D1);
        for (; _N <= _D1; ++_F1, --_D1)
                {_FI1 _X1 = _F1;
                for (_Pd2 _D2 = _N; ; ++_X1, --_D2)
                        if (_D2 == 0)
                                return (_F1);
                        else if (!_P(*_X1, _V))
                                break; }
        return (_L1); }

template<class _FI1, class _FI2, class _Pd1, class _Pd2>
        inline
        _FI1 _Find_end(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2, _Pd1 *, _Pd2 *)
        {_Pd1 _D1 = 0;
        _Distance(_F1, _L1, _D1);
        _Pd2 _D2 = 0;
        _Distance(_F2, _L2, _D2);
        _FI1 _Ans = _L1;
        if (0 < _D2)
                for (; _D2 <= _D1; ++_F1, --_D1)
                        {_FI1 _X1 = _F1;
                        for (_FI2 _X2 = _F2; ; ++_X1)
                                if (!(*_X1 == *_X2))
                                        break;
                                else if (++_X2 == _L2)
                                        {_Ans = _F1;
                                        break; }}
        return (_Ans); }

template<class _FI1, class _FI2, class _Pd1, class _Pd2,
        class _Pr>
        inline
        _FI1 _Find_end(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2,
                _Pr _P, _Pd1 *, _Pd2 *)
        {_Pd1 _D1 = 0;
        _Distance(_F1, _L1, _D1);
        _Pd2 _D2 = 0;
        _Distance(_F2, _L2, _D2);
        _FI1 _Ans = _L1;
        if (0 < _D2)
                for (; _D2 <= _D1; ++_F1, --_D1)
                        {_FI1 _X1 = _F1;
                        for (_FI2 _X2 = _F2; ; ++_X1)
                                if (!_P(*_X1, *_X2))
                                        break;
                                else if (++_X2 == _L2)
                                        {_Ans = _F1;
                                        break; }}
        return (_Ans); }

template<class _RI, class _Pd, class _Ty>
        inline
        void _Rotate(_RI _F, _RI _M, _RI _L, _Pd *, _Ty *)
        {_Pd _D = _M - _F;
        _Pd _N = _L - _F;
        for (_Pd _I = _D; _I != 0; )
                {_Pd _J = _N % _I;
                _N = _I, _I = _J; }
        if (_N < _L - _F)
                for (; 0 < _N; --_N)
                        {_RI _X = _F + _N;
                        _RI _Y = _X;
                        _Ty _V = *_X;
                        _RI _Z = _Y + _D == _L ? _F : _Y + _D;
                        while (_Z != _X)
                                {*_Y = *_Z;
                                _Y = _Z;
                                _Z = _D < _L - _Z ? _Z + _D
                                        : _F + (_D - (_L - _Z)); }
                        *_Y = _V; }}

template<class _RI, class _Pd>
        inline
        void _Random_shuffle(_RI _F, _RI _L, _Pd *)
        {const int _RBITS = 15;
        const int _RMAX = (1U << _RBITS) - 1;
        _RI _X = _F;
        for (unsigned long _D = 2; ++_X != _L; ++_D)
                {unsigned long _Rm = _RMAX;
                unsigned long _Rn = rand() & _RMAX;
                for (; _Rm < _D && _Rm != ~0UL;
                        _Rm = _Rm << _RBITS | _RMAX)
                        _Rn = _Rn << _RBITS | _RMAX;
                iter_swap(_X, _F + _Pd(_Rn % _D)); }}

template<class _BI, class _Pr>
        inline
        _BI partition(_BI _F, _BI _L, _Pr _P)
        {for (; ; ++_F)
                {for (; _F != _L && _P(*_F); ++_F)
                        ;
                if (_F == _L)
                        break;
                for (; _F != --_L && !_P(*_L); )
                        ;
                if (_F == _L)
                        break;
                iter_swap(_F, _L); }
        return (_F); }

template<class _BI, class _Pr, class _Pd, class _Ty>
        inline
        _BI _Stable_partition(_BI _F, _BI _L, _Pr _P, _Pd _N,
                 _Temp_iterator<_Ty>& _Xb)
        {if (_N == 1)
                return (_P(*_F) ? _L : _F);
        else if (_N <= _Xb._Maxlen())
                {_BI _X = _F;
                for (_Xb._Init(); _F != _L; ++_F)
                        if (_P(*_F))
                                *_X++ = *_F;
                        else
                                *_Xb++ = *_F;
                copy(_Xb._First(), _Xb._Last(), _X);
                return (_X); }
        else
                {_BI _M = _F;
                advance(_M, _N / 2);
                _BI _Lp = _Stable_partition(_F, _M, _P, _N / 2, _Xb);
                _BI _Rp = _Stable_partition(_M, _L, _P, _N - _N / 2, _Xb);
                _Pd _D1 = 0;
                _Distance(_Lp, _M, _D1);
                _Pd _D2 = 0;
                _Distance(_M, _Rp, _D2);
                return (_Buffered_rotate(_Lp, _M, _Rp, _D1, _D2, _Xb)); }}

template<class _RI, class _Pd>
        inline
        void _Sort(_RI _F, _RI _L, _Pd _Ideal)
        {for (; _SORT_MAX < _L - _F; )
                if (_Ideal == 0)
                        {make_heap(_F, _L);
                        sort_heap(_F, _L);
                        break; }
                else
                        {_RI _M = _Unguarded_partition(_F, _L,
                                _Val_type(_F));
                        _Sort(_F, _M, _Ideal /= 2);
                        _F = _M; }}

template<class _RI, class _Ty>
        inline
        _RI _Unguarded_partition(_RI _F, _RI _L, _Ty *)
        {_RI _M = _F + (_L - _F) / 2;
        if (*_M < *_F)
                iter_swap(_F, _M);
        if (*(_L - 1) < *_M)
                iter_swap(_M, _L - 1);
        if (*_M < *_F)
                iter_swap(_F, _M);
        for (_Ty _Piv = *_M; ; ++_F)
                {for (; *_F < _Piv; ++_F)
                        ;
                for (; _Piv < *--_L; )
                        ;
                if (_L <= _F)
                        return (_F);
                iter_swap(_F, _L); }}

template<class _BI, class _Ty>
        inline
        void _Insertion_sort_1(_BI _F, _BI _L, _Ty *)
        {if (_F != _L)
                for (_BI _M = _F; ++_M != _L; )
                        {_Ty _V = *_M;
                        if (!(_V < *_F))
                                _Unguarded_insert(_M, _V);
                        else
                                {_BI _Mp1 = _M;
                                copy_backward(_F, _M, ++_Mp1);
                                *_F = _V; }}}

template<class _RI, class _Pd, class _Pr>
        inline
        void _Sort(_RI _F, _RI _L, _Pd _Ideal, _Pr _P)
        {for (; _SORT_MAX < _L - _F; )
                if (_Ideal == 0)
                        {make_heap(_F, _L, _P);
                        sort_heap(_F, _L, _P);
                        break; }
                else
                        {_RI _M = _Unguarded_partition(_F, _L, _P,
                                _Val_type(_F));
                        _Sort(_F, _M, _Ideal /= 2, _P);
                        _F = _M; }}

template<class _RI, class _Pr, class _Ty>
        inline
        _RI _Unguarded_partition(_RI _F, _RI _L, _Pr _P, _Ty *)
        {_RI _M = _F + (_L - _F) / 2;
        if (_P(*_M, *_F))
                iter_swap(_F, _M);
        if (_P(*(_L - 1), *_M))
                iter_swap(_M, _L - 1);
        if (_P(*_M, *_F))
                iter_swap(_F, _M);
        for (_Ty _Piv = *_M; ; ++_F)
                {for (; _P(*_F, _Piv); ++_F)
                        ;
                for (; _P(_Piv, *--_L); )
                        ;
                if (_L <= _F)
                        return (_F);
                iter_swap(_F, _L); }}

template<class _BI, class _Ty, class _Pr>
        inline
        void _Insertion_sort_1(_BI _F, _BI _L, _Pr _P, _Ty *)
        {if (_F != _L)
                for (_BI _M = _F; ++_M != _L; )
                        {_Ty _V = *_M;
                        if (!_P(_V, *_F))
                                _Unguarded_insert(_M, _V, _P);
                        else
                                {_BI _Mp1 = _M;
                                copy_backward(_F, _M, ++_Mp1);
                                *_F = _V; }}}

template<class _BI, class _Pd, class _Ty>
        inline
        void _Stable_sort(_BI _F, _BI _L, _Pd _N, _Temp_iterator<_Ty>& _Xb)
        {if (_N <= _SORT_MAX)
                _Insertion_sort(_F, _L);
        else
                {_Pd _N2 = (_N + 1) / 2;
                _BI _M = _F;
                advance(_M, _N2);
                if (_N2 <= _Xb._Maxlen())
                        {_Buffered_merge_sort(_F, _M, _N2, _Xb);
                        _Buffered_merge_sort(_M, _L, _N - _N2, _Xb); }
                else
                        {_Stable_sort(_F, _M, _N2, _Xb);
                        _Stable_sort(_M, _L, _N - _N2, _Xb); }
                _Buffered_merge(_F, _M, _L, _N2, _N - _N2, _Xb); }}

template<class _BI, class _Pd, class _Ty>
        inline
        void _Buffered_merge_sort(_BI _F, _BI _L, _Pd _N,
                _Temp_iterator<_Ty>& _Xb)
        {_BI _M = _F;
        for (_Pd _I = _N; _CHUNK_SIZE <= _I; _I -= _CHUNK_SIZE)
                {_BI _Mn = _M;
                advance(_Mn, (int)_CHUNK_SIZE);
                _Insertion_sort(_M, _Mn);
                _M = _Mn; }
        _Insertion_sort(_M, _L);
        for (_Pd _D = _CHUNK_SIZE; _D < _N; _D *= 2)
                {_Chunked_merge(_F, _L, _Xb._Init(), _D, _N);
                _Chunked_merge(_Xb._First(), _Xb._Last(), _F,
                        _D *= 2, _N); }}

template<class _BI, class _OI, class _Pd>
        inline
        void _Chunked_merge(_BI _F, _BI _L, _OI _X, _Pd _D, _Pd _N)
        {_Pd _D2 = _D * 2;
        for (; _D2 <= _N; _N -= _D2)
                {_BI _F1 = _F;
                advance(_F1, _D);
                _BI _F2 = _F1;
                advance(_F2, _D);
                _X = merge(_F, _F1, _F1, _F2, _X);
                _F = _F2; }
        if (_N <= _D)
                copy(_F, _L, _X);
        else
                {_BI _F1 = _F;
                advance(_F1, _D);
                merge(_F, _F1, _F1, _L, _X); }}

template<class _BI, class _Pd, class _Ty, class _Pr>
        inline
        void _Stable_sort(_BI _F, _BI _L, _Pd _N,
                _Temp_iterator<_Ty>& _Xb, _Pr _P)
        {if (_N <= _SORT_MAX)
                _Insertion_sort(_F, _L, _P);
        else
                {_Pd _N2 = (_N + 1) / 2;
                _BI _M = _F;
                advance(_M, _N2);
                if (_N2 <= _Xb._Maxlen())
                        {_Buffered_merge_sort(_F, _M, _N2, _Xb, _P);
                        _Buffered_merge_sort(_M, _L, _N - _N2, _Xb, _P); }
                else
                        {_Stable_sort(_F, _M, _N2, _Xb, _P);
                        _Stable_sort(_M, _L, _N - _N2, _Xb, _P); }
                _Buffered_merge(_F, _M, _L, _N2, _N - _N2, _Xb, _P); }}

template<class _BI, class _Pd, class _Ty, class _Pr>
        inline
        void _Buffered_merge_sort(_BI _F, _BI _L, _Pd _N,
                _Temp_iterator<_Ty>& _Xb, _Pr _P)
        {_BI _M = _F;
        for (_Pd _I = _N; _CHUNK_SIZE <= _I; _I -= _CHUNK_SIZE)
                {_BI _Mn = _M;
                advance(_Mn, (int)_CHUNK_SIZE);
                _Insertion_sort(_M, _Mn, _P);
                _M = _Mn; }
        _Insertion_sort(_M, _L, _P);
        for (_Pd _D = _CHUNK_SIZE; _D < _N; _D *= 2)
                {_Chunked_merge(_F, _L, _Xb._Init(), _D, _N, _P);
                _Chunked_merge(_Xb._First(), _Xb._Last(), _F,
                        _D *= 2, _N, _P); }}

template<class _BI, class _OI, class _Pd, class _Pr>
        inline
        void _Chunked_merge(_BI _F, _BI _L, _OI _X, _Pd _D, _Pd _N, _Pr _P)
        {_Pd _D2 = _D * 2;
        for (; _D2 <= _N; _N -= _D2)
                {_BI _F1 = _F;
                advance(_F1, _D);
                _BI _F2 = _F1;
                advance(_F2, _D);
                _X = merge(_F, _F1, _F1, _F2, _X, _P);
                _F = _F2; }
        if (_N <= _D)
                copy(_F, _L, _X);
        else
                {_BI _F1 = _F;
                advance(_F1, _D);
                merge(_F, _F1, _F1, _L, _X, _P); }}

template<class _II, class _RI, class _Pd, class _Ty>
        inline
        _RI _Partial_sort_copy(_II _F1, _II _L1, _RI _F2, _RI _L2,
                _Pd *, _Ty *)
        {_RI _X = _F2;
        if (_X != _L2)
                {for (; _F1 != _L1 && _X != _L2; ++_F1, ++_X)
                        *_X = *_F1;
                make_heap(_F2, _X);
                for (; _F1 != _L1; ++_F1)
                        if (*_F1 < *_F2)
                                _Adjust_heap(_F2, _Pd(0), _Pd(_X - _F2),
                                        _Ty(*_F1));
                sort_heap(_F2, _X); }
        return (_X); }

template<class _II, class _RI, class _Pd,
        class _Ty, class _Pr>
        inline
        _RI _Partial_sort_copy(_II _F1, _II _L1, _RI _F2, _RI _L2,
                _Pr _P, _Pd *, _Ty *)
        {_RI _X = _F2;
        if (_X != _L2)
                {for (; _F1 != _L1 && _X != _L2; ++_F1, ++_X)
                        *_X = *_F1;
                make_heap(_F2, _X, _P);
                for (; _F1 != _L1; ++_F1)
                        if (_P(*_F1, *_F2))
                                _Adjust_heap(_F2, _Pd(0), _Pd(_X - _F2),
                                        _Ty(*_F1), _P);
                sort_heap(_F2, _X, _P); }
        return (_X); }

template<class _RI>
        inline
        void nth_element(_RI _F, _RI _Nth, _RI _L)
        {for (; _SORT_MAX < _L - _F; )
                {_RI _M = _Unguarded_partition(_F, _L,
                        _Val_type(_F));
                if (_M <= _Nth)
                        _F = _M;
                else
                        _L = _M; }
        _Insertion_sort(_F, _L); }

template<class _RI, class _Pr>
        inline
        void nth_element(_RI _F, _RI _Nth, _RI _L, _Pr _P)
        {for (; _SORT_MAX < _L - _F; )
                {_RI _M = _Unguarded_partition(_F, _L, _P,
                        _Val_type(_F));
                if (_M <= _Nth)
                        _F = _M;
                else
                        _L = _M; }
        _Insertion_sort(_F, _L, _P); }

template<class _FI, class _Ty, class _Pd>
        inline
        _FI _Lower_bound(_FI _F, _FI _L, const _Ty& _V, _Pd *)
        {_Pd _N = 0;
        _Distance(_F, _L, _N);
        for (; 0 < _N; )
                {_Pd _N2 = _N / 2;
                _FI _M = _F;
                advance(_M, _N2);
                if (*_M < _V)
                        _F = ++_M, _N -= _N2 + 1;
                else
                        _N = _N2; }
        return (_F); }

template<class _FI, class _Ty, class _Pd, class _Pr>
        inline
        _FI _Lower_bound(_FI _F, _FI _L, const _Ty& _V, _Pr _P, _Pd *)
        {_Pd _N = 0;
        _Distance(_F, _L, _N);
        for (; 0 < _N; )
                {_Pd _N2 = _N / 2;
                _FI _M = _F;
                advance(_M, _N2);
                if (_P(*_M, _V))
                        _F = ++_M, _N -= _N2 + 1;
                else
                        _N = _N2; }
        return (_F); }

template<class _FI, class _Ty, class _Pd>
        inline
        _FI _Upper_bound(_FI _F, _FI _L, const _Ty& _V, _Pd *)
        {_Pd _N = 0;
        _Distance(_F, _L, _N);
        for (; 0 < _N; )
                {_Pd _N2 = _N / 2;
                _FI _M = _F;
                advance(_M, _N2);
                if (!(_V < *_M))
                        _F = ++_M, _N -= _N2 + 1;
                else
                        _N = _N2; }
        return (_F); }

template<class _FI, class _Ty, class _Pd, class _Pr>
        inline
        _FI _Upper_bound(_FI _F, _FI _L, const _Ty& _V, _Pr _P, _Pd *)
        {_Pd _N = 0;
        _Distance(_F, _L, _N);
        for (; 0 < _N; )
                {_Pd _N2 = _N / 2;
                _FI _M = _F;
                advance(_M, _N2);
                if (!_P(_V, *_M))
                        _F = ++_M, _N -= _N2 + 1;
                else
                        _N = _N2; }
        return (_F); }

template<class _FI, class _Ty, class _Pd>
        inline
        pair<_FI, _FI> _Equal_range(_FI _F, _FI _L, const _Ty& _V, _Pd *)
        {_Pd _N = 0;
        _Distance(_F, _L, _N);
        for (; 0 < _N; )
                {_Pd _N2 = _N / 2;
                _FI _M = _F;
                advance(_M, _N2);
                if (*_M < _V)
                        _F = ++_M, _N -= _N2 + 1;
                else if (_V < *_M)
                        _N = _N2;
                else
                        {_FI _F2 = lower_bound(_F, _M, _V);
                        advance(_F, _N);
                        _FI _L2 = upper_bound(++_M, _F, _V);
                        return (pair<_FI, _FI>(_F2, _L2)); }}
        return (pair<_FI, _FI>(_F, _F)); }

template<class _FI, class _Ty, class _Pd, class _Pr>
        inline
        pair<_FI, _FI> _Equal_range(_FI _F, _FI _L, const _Ty& _V,
                _Pr _P, _Pd *)
        {_Pd _N = 0;
        _Distance(_F, _L, _N);
        for (; 0 < _N; )
                {_Pd _N2 = _N / 2;
                _FI _M = _F;
                advance(_M, _N2);
                if (_P(*_M, _V))
                        _F = ++_M, _N -= _N2 + 1;
                else if (_P(_V, *_M))
                        _N = _N2;
                else
                        {_FI _F2 = lower_bound(_F, _M, _V, _P);
                        advance(_F, _N);
                        _FI _L2 = upper_bound(++_M, _F, _V, _P);
                        return (pair<_FI, _FI>(_F2, _L2)); }}
        return (pair<_FI, _FI>(_F, _F)); }

template<class _II1, class _II2, class _OI>
        inline
        _OI merge(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2, _OI _X)
        {for (; _F1 != _L1 && _F2 != _L2; ++_X)
                if (*_F2 < *_F1)
                        *_X = *_F2, ++_F2;
                else
                        *_X = *_F1, ++_F1;
        _X = copy(_F1, _L1, _X);
        return (copy(_F2, _L2, _X)); }

template<class _II1, class _II2, class _OI, class _Pr>
        inline
        _OI merge(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2, _OI _X, _Pr _P)
        {for (; _F1 != _L1 && _F2 != _L2; ++_X)
                if (_P(*_F2, *_F1))
                        *_X = *_F2, ++_F2;
                else
                        *_X = *_F1, ++_F1;
        _X = copy(_F1, _L1, _X);
        return (copy(_F2, _L2, _X)); }

template<class _BI, class _Pd, class _Ty>
        inline
        void _Inplace_merge(_BI _F, _BI _M, _BI _L, _Pd *, _Ty *)
        {_Pd _D1 = 0;
        _Distance(_F, _M, _D1);
        _Pd _D2 = 0;
        _Distance(_M, _L, _D2);
        _Temp_iterator<_Ty> _Xb(_D1 < _D2 ? _D1 : _D2);
        _Buffered_merge(_F, _M, _L, _D1, _D2, _Xb); }

template<class _BI, class _Pd, class _Ty>
        inline
        void _Buffered_merge(_BI _F, _BI _M, _BI _L,
                _Pd _D1, _Pd _D2, _Temp_iterator<_Ty>& _Xb)
        {if (_D1 == 0 || _D2 == 0)
                ;
        else if (_D1 + _D2 == 2)
                {if (*_M < *_F)
                        iter_swap(_F, _M); }
        else if (_D1 <= _D2 && _D1 <= _Xb._Maxlen())
                {copy(_F, _M, _Xb._Init());
                merge(_Xb._First(), _Xb._Last(), _M, _L, _F); }
        else if (_D2 <= _Xb._Maxlen())
                {copy(_M, _L, _Xb._Init());
                _Merge_backward(_F, _M, _Xb._First(), _Xb._Last(), _L); }
        else
                {_BI _Fn, _Ln;
                _Pd _D1n, _D2n;
                if (_D2 < _D1)
                        {_D1n = _D1 / 2, _D2n = 0;
                        _Fn = _F;
                        advance(_Fn, _D1n);
                        _Ln = lower_bound(_M, _L, *_Fn);
                        _Distance(_M, _Ln, _D2n); }
                else
                        {_D1n = 0, _D2n = _D2 / 2;
                        _Ln = _M;
                        advance(_Ln, _D2n);
                        _Fn = upper_bound(_F, _M, *_Ln);
                        _Distance(_F, _Fn, _D1n); }
                _BI _Mn = _Buffered_rotate(_Fn, _M, _Ln,
                        _D1 - _D1n, _D2n, _Xb);
                _Buffered_merge(_F, _Fn, _Mn, _D1n, _D2n, _Xb);
                _Buffered_merge(_Mn, _Ln, _L,
                        _D1 - _D1n, _D2 - _D2n, _Xb); }}

template<class _BI1, class _BI2, class _BI3>
        inline
        _BI3 _Merge_backward(_BI1 _F1, _BI1 _L1, _BI2 _F2, _BI2 _L2, _BI3 _X)
        {for (; ; )
                if (_F1 == _L1)
                        return (copy_backward(_F2, _L2, _X));
                else if (_F2 == _L2)
                        return (copy_backward(_F1, _L1, _X));
                else if (*--_L2 < *--_L1)
                        *--_X = *_L1, ++_L2;
                else
                        *--_X = *_L2, ++_L1; }

template<class _BI, class _Pd, class _Ty>
        inline
        _BI _Buffered_rotate(_BI _F, _BI _M, _BI _L,
                _Pd _D1, _Pd _D2, _Temp_iterator<_Ty>& _Xb)
        {if (_D1 <= _D2 && _D1 <= _Xb._Maxlen())
                {copy(_F, _M, _Xb._Init());
                copy(_M, _L, _F);
                return (copy_backward(_Xb._First(), _Xb._Last(), _L)); }
        else if (_D2 <= _Xb._Maxlen())
                {copy(_M, _L, _Xb._Init());
                copy_backward(_F, _M, _L);
                return (copy(_Xb._First(), _Xb._Last(), _F)); }
        else
                {rotate(_F, _M, _L);
                advance(_F, _D2);
                return (_F); }}

template<class _BI, class _Pd, class _Ty, class _Pr>
        inline
        void _Inplace_merge(_BI _F, _BI _M, _BI _L, _Pr _P, _Pd *, _Ty *)
        {_Pd _D1 = 0;
        _Distance(_F, _M, _D1);
        _Pd _D2 = 0;
        _Distance(_M, _L, _D2);
        _Temp_iterator<_Ty> _Xb(_D1 < _D2 ? _D1 : _D2);
        _Buffered_merge(_F, _M, _L, _D1, _D2, _Xb, _P); }

template<class _BI, class _Pd, class _Ty, class _Pr>
        inline
        void _Buffered_merge(_BI _F, _BI _M, _BI _L,
                _Pd _D1, _Pd _D2, _Temp_iterator<_Ty>& _Xb, _Pr _P)
        {if (_D1 == 0 || _D2 == 0)
                ;
        else if (_D1 + _D2 == 2)
                {if (_P(*_M, *_F))
                        iter_swap(_F, _M); }
        else if (_D1 <= _D2 && _D1 <= _Xb._Maxlen())
                {copy(_F, _M, _Xb._Init());
                merge(_Xb._First(), _Xb._Last(), _M, _L, _F, _P); }
        else if (_D2 <= _Xb._Maxlen())
                {copy(_M, _L, _Xb._Init());
                _Merge_backward(_F, _M, _Xb._First(), _Xb._Last(),
                        _L, _P); }
        else
                {_BI _Fn, _Ln;
                _Pd _D1n, _D2n;
                if (_D2 < _D1)
                        {_D1n = _D1 / 2, _D2n = 0;
                        _Fn = _F;
                        advance(_Fn, _D1n);
                        _Ln = lower_bound(_M, _L, *_Fn, _P);
                        _Distance(_M, _Ln, _D2n); }
                else
                        {_D1n = 0, _D2n = _D2 / 2;
                        _Ln = _M;
                        advance(_Ln, _D2n);
                        _Fn = upper_bound(_F, _M, *_Ln, _P);
                        _Distance(_F, _Fn, _D1n); }
                _BI _Mn = _Buffered_rotate(_Fn, _M, _Ln,
                        _D1 - _D1n, _D2n, _Xb);
                _Buffered_merge(_F, _Fn, _Mn, _D1n, _D2n, _Xb, _P);
                _Buffered_merge(_Mn, _Ln, _L,
                        _D1 - _D1n, _D2 - _D2n, _Xb, _P); }}

template<class _BI1, class _BI2, class _BI3, class _Pr>
        inline
        _BI3 _Merge_backward(_BI1 _F1, _BI1 _L1,
                _BI2 _F2, _BI2 _L2, _BI3 _X, _Pr _P)
        {for (; ; )
                if (_F1 == _L1)
                        return (copy_backward(_F2, _L2, _X));
                else if (_F2 == _L2)
                        return (copy_backward(_F1, _L1, _X));
                else if (_P(*--_L2, *--_L1))
                        *--_X = *_L1, ++_L2;
                else
                        *--_X = *_L2, ++_L1; }

template<class _II1, class _II2>
        inline
        bool includes(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2)
        {for (; _F1 != _L1 && _F2 != _L2; )
                if (*_F2 < *_F1)
                        return (false);
                else if (*_F1 < *_F2)
                        ++_F1;
                else
                        ++_F1, ++_F2;
        return (_F2 == _L2); }

template<class _II1, class _II2, class _Pr>
        inline
        bool includes(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2, _Pr _P)
        {for (; _F1 != _L1 && _F2 != _L2; )
                if (_P(*_F2, *_F1))
                        return (false);
                else if (_P(*_F1, *_F2))
                        ++_F1;
                else
                        ++_F1, ++_F2;
        return (_F2 == _L2); }

template<class _II1, class _II2, class _OI>
        inline
        _OI set_union(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2, _OI _X)
        {for (; _F1 != _L1 && _F2 != _L2; )
                if (*_F1 < *_F2)
                        *_X++ = *_F1, ++_F1;
                else if (*_F2 < *_F1)
                        *_X++ = *_F2, ++_F2;
                else
                        *_X++ = *_F1, ++_F1, ++_F2;
        _X = copy(_F1, _L1, _X);
        return (copy(_F2, _L2, _X)); }

template<class _II1, class _II2, class _OI, class _Pr>
        inline
        _OI set_union(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2, _OI _X, _Pr _P)
        {for (; _F1 != _L1 && _F2 != _L2; )
                if (_P(*_F1, *_F2))
                        *_X++ = *_F1, ++_F1;
                else if (_P(*_F2, *_F1))
                        *_X++ = *_F2, ++_F2;
                else
                        *_X++ = *_F1, ++_F1, ++_F2;
        _X = copy(_F1, _L1, _X);
        return (copy(_F2, _L2, _X)); }

template<class _II1, class _II2, class _OI>
        inline
        _OI set_intersection(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2, _OI _X)
        {for (; _F1 != _L1 && _F2 != _L2; )
                if (*_F1 < *_F2)
                        ++_F1;
                else if (*_F2 < *_F1)
                        ++_F2;
                else
                        *_X++ = *_F1++, ++_F2;
        return (_X); }

template<class _II1, class _II2, class _OI, class _Pr>
        inline
        _OI set_intersection(_II1 _F1, _II1 _L1,
                _II2 _F2, _II2 _L2, _OI _X, _Pr _P)
        {for (; _F1 != _L1 && _F2 != _L2; )
                if (_P(*_F1, *_F2))
                        ++_F1;
                else if (_P(*_F2, *_F1))
                        ++_F2;
                else
                        *_X++ = *_F1++, ++_F2;
        return (_X); }

template<class _II1, class _II2, class _OI>
        inline
        _OI set_difference(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2, _OI _X)
        {for (; _F1 != _L1 && _F2 != _L2; )
                if (*_F1 < *_F2)
                        *_X++ = *_F1, ++_F1;
                else if (*_F2 < *_F1)
                        ++_F2;
                else
                        ++_F1, ++_F2;
        return (copy(_F1, _L1, _X)); }

template<class _II1, class _II2, class _OI, class _Pr>
        inline
        _OI set_difference(_II1 _F1, _II1 _L1,
                _II2 _F2, _II2 _L2, _OI _X, _Pr _P)
        {for (; _F1 != _L1 && _F2 != _L2; )
                if (_P(*_F1, *_F2))
                        *_X++ = *_F1, ++_F1;
                else if (_P(*_F2, *_F1))
                        ++_F2;
                else
                        ++_F1, ++_F2;
        return (copy(_F1, _L1, _X)); }

template<class _II1, class _II2, class _OI>
        inline
        _OI set_symmetric_difference(_II1 _F1, _II1 _L1,
                _II2 _F2, _II2 _L2, _OI _X)
        {for (; _F1 != _L1 && _F2 != _L2; )
                if (*_F1 < *_F2)
                        *_X++ = *_F1, ++_F1;
                else if (*_F2 < *_F1)
                        *_X++ = *_F2, ++_F2;
                else
                        ++_F1, ++_F2;
        _X = copy(_F1, _L1, _X);
        return (copy(_F2, _L2, _X)); }

template<class _II1, class _II2, class _OI, class _Pr>
        inline
        _OI set_symmetric_difference(_II1 _F1, _II1 _L1,
                _II2 _F2, _II2 _L2, _OI _X, _Pr _P)
        {for (; _F1 != _L1 && _F2 != _L2; )
                if (_P(*_F1, *_F2))
                        *_X++ = *_F1, ++_F1;
                else if (_P(*_F2, *_F1))
                        *_X++ = *_F2, ++_F2;
                else
                        ++_F1, ++_F2;
        _X = copy(_F1, _L1, _X);
        return (copy(_F2, _L2, _X)); }

template<class _RI, class _Pd, class _Ty>
        inline
        void _Adjust_heap(_RI _F, _Pd _H, _Pd _N, _Ty _V)
        {_Pd _J = _H;
        _Pd _K = 2 * _H + 2;
        for (; _K < _N; _K = 2 * _K + 2)
                {if (*(_F + _K) < *(_F + (_K - 1)))
                        --_K;
                *(_F + _H) = *(_F + _K), _H = _K; }
        if (_K == _N)
                *(_F + _H) = *(_F + (_K - 1)), _H = _K - 1;
        _Push_heap(_F, _H, _J, _V); }

template<class _RI, class _Pd, class _Ty, class _Pr>
        inline
        void _Adjust_heap(_RI _F, _Pd _H, _Pd _N, _Ty _V, _Pr _P)
        {_Pd _J = _H;
        _Pd _K = 2 * _H + 2;
        for (; _K < _N; _K = 2 * _K + 2)
                {if (_P(*(_F + _K), *(_F + (_K - 1))))
                        --_K;
                *(_F + _H) = *(_F + _K), _H = _K; }
        if (_K == _N)
                *(_F + _H) = *(_F + (_K - 1)), _H = _K - 1;
        _Push_heap(_F, _H, _J, _V, _P); }

template<class _FI>
        inline
        _FI max_element(_FI _F, _FI _L)
        {_FI _X = _F;
        if (_F != _L)
                for (; ++_F != _L; )
                        if (*_X < *_F)
                                _X = _F;
        return (_X); }

template<class _FI, class _Pr>
        inline
        _FI max_element(_FI _F, _FI _L, _Pr _P)
        {_FI _X = _F;
        if (_F != _L)
                for (; ++_F != _L; )
                        if (_P(*_X, *_F))
                                _X = _F;
        return (_X); }

template<class _FI>
        inline
        _FI min_element(_FI _F, _FI _L)
        {_FI _X = _F;
        if (_F != _L)
                for (; ++_F != _L; )
                        if (*_F < *_X)
                                _X = _F;
        return (_X); }

template<class _FI, class _Pr>
        inline
        _FI min_element(_FI _F, _FI _L, _Pr _P)
        {_FI _X = _F;
        if (_F != _L)
                for (; ++_F != _L; )
                        if (_P(*_F, *_X))
                                _X = _F;
        return (_X); }

template<class _BI>
        inline
        bool next_permutation(_BI _F, _BI _L)
        {_BI _I = _L;
        if (_F == _L || _F == --_I)
                return (false);
        for (; ; )
                {_BI _Ip = _I;
                if (*--_I < *_Ip)
                        {_BI _J = _L;
                        for (; !(*_I < *--_J); )
                                ;
                        iter_swap(_I, _J);
                        reverse(_Ip, _L);
                        return (true); }
                if (_I == _F)
                        {reverse(_F, _L);
                        return (false); }}}

template<class _BI, class _Pr>
        inline
        bool next_permutation(_BI _F, _BI _L, _Pr _P)
        {_BI _I = _L;
        if (_F == _L || _F == --_I)
                return (false);
        for (; ; )
                {_BI _Ip = _I;
                if (_P(*--_I, *_Ip))
                        {_BI _J = _L;
                        for (; !_P(*_I, *--_J); )
                                ;
                        iter_swap(_I, _J);
                        reverse(_Ip, _L);
                        return (true); }
                if (_I == _F)
                        {reverse(_F, _L);
                        return (false); }}}

template<class _BI>
        inline
        bool prev_permutation(_BI _F, _BI _L)
        {_BI _I = _L;
        if (_F == _L || _F == --_I)
                return (false);
        for (; ; )
                {_BI _Ip = _I;
                if (!(*--_I < *_Ip))
                        {_BI _J = _L;
                        for (; *_I < *--_J; )
                                ;
                        iter_swap(_I, _J);
                        reverse(_Ip, _L);
                        return (true); }
                if (_I == _F)
                        {reverse(_F, _L);
                        return (false); }}}

template<class _BI, class _Pr>
        inline
        bool prev_permutation(_BI _F, _BI _L, _Pr _P)
        {_BI _I = _L;
        if (_F == _L || _F == --_I)
                return (false);
        for (; ; )
                {_BI _Ip = _I;
                if (!_P(*--_I, *_Ip))
                        {_BI _J = _L;
                        for (; _P(*_I, *--_J); )
                                ;
                        iter_swap(_I, _J);
                        reverse(_Ip, _L);
                        return (true); }
                if (_I == _F)
                        {reverse(_F, _L);
                        return (false); }}}

};
#line 931 "/usr/vacpp/include/algorithm"
#pragma namemangling()

#pragma object_model(pop)
#line 940
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 13 "/usr/vacpp/include/string"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 46
#pragma object_model(compat)
#line 51
#pragma namemangling(v5)
#line 77
namespace std {
#line 82
template<class _E, class _Tr, class _A> inline
        basic_string<_E, _Tr, _A> operator+(
                const basic_string<_E, _Tr, _A>& _L,
                const basic_string<_E, _Tr, _A>& _R)
        {return (basic_string<_E, _Tr, _A>(_L) += _R); }
template<class _E, class _Tr, class _A> inline
        basic_string<_E, _Tr, _A> operator+(const _E *_L,
                const basic_string<_E, _Tr, _A>& _R)
        {return (basic_string<_E, _Tr, _A>(_L) += _R); }
template<class _E, class _Tr, class _A> inline
        basic_string<_E, _Tr, _A> operator+(
                const _E _L, const basic_string<_E, _Tr, _A>& _R)
        {return (basic_string<_E, _Tr, _A>(1, _L) += _R); }
template<class _E, class _Tr, class _A> inline
        basic_string<_E, _Tr, _A> operator+(
                const basic_string<_E, _Tr, _A>& _L,
                const _E *_R)
        {return (basic_string<_E, _Tr, _A>(_L) += _R); }
template<class _E, class _Tr, class _A> inline
        basic_string<_E, _Tr, _A> operator+(
                const basic_string<_E, _Tr, _A>& _L, const _E _R)
        {return (basic_string<_E, _Tr, _A>(_L) += _R); }

template<class _E, class _Tr, class _A> inline
        bool operator==(const basic_string<_E, _Tr, _A>& _L,
                const basic_string<_E, _Tr, _A>& _R)
        {return (_L.compare(_R) == 0); }
template<class _E, class _Tr, class _A> inline
        bool operator==(const _E * _L,
                const basic_string<_E, _Tr, _A>& _R)
        {return (_R.compare(_L) == 0); }
template<class _E, class _Tr, class _A> inline
        bool operator==(const basic_string<_E, _Tr, _A>& _L,
                const _E *_R)
        {return (_L.compare(_R) == 0); }

template<class _E, class _Tr, class _A> inline
        bool operator!=(const basic_string<_E, _Tr, _A>& _L,
                const basic_string<_E, _Tr, _A>& _R)
        {return (!(_L == _R)); }
template<class _E, class _Tr, class _A> inline
        bool operator!=(const _E *_L,
                const basic_string<_E, _Tr, _A>& _R)
        {return (!(_L == _R)); }
template<class _E, class _Tr, class _A> inline
        bool operator!=(const basic_string<_E, _Tr, _A>& _L,
                const _E *_R)
        {return (!(_L == _R)); }

template<class _E, class _Tr, class _A> inline
        bool operator<(const basic_string<_E, _Tr, _A>& _L,
                const basic_string<_E, _Tr, _A>& _R)
        {return (_L.compare(_R) < 0); }
template<class _E, class _Tr, class _A> inline
        bool operator<(const _E * _L,
                const basic_string<_E, _Tr, _A>& _R)
        {return (_R.compare(_L) > 0); }
template<class _E, class _Tr, class _A> inline
        bool operator<(const basic_string<_E, _Tr, _A>& _L,
                const _E *_R)
        {return (_L.compare(_R) < 0); }

template<class _E, class _Tr, class _A> inline
        bool operator>(const basic_string<_E, _Tr, _A>& _L,
                const basic_string<_E, _Tr, _A>& _R)
        {return (_R < _L); }
template<class _E, class _Tr, class _A> inline
        bool operator>(const _E * _L,
                const basic_string<_E, _Tr, _A>& _R)
        {return (_R < _L); }
template<class _E, class _Tr, class _A> inline
        bool operator>(const basic_string<_E, _Tr, _A>& _L,
                const _E *_R)
        {return (_R < _L); }

template<class _E, class _Tr, class _A> inline
        bool operator<=(const basic_string<_E, _Tr, _A>& _L,
                const basic_string<_E, _Tr, _A>& _R)
        {return (!(_R < _L)); }
template<class _E, class _Tr, class _A> inline
        bool operator<=(const _E * _L,
                const basic_string<_E, _Tr, _A>& _R)
        {return (!(_R < _L)); }
template<class _E, class _Tr, class _A> inline
        bool operator<=(const basic_string<_E, _Tr, _A>& _L,
                const _E *_R)
        {return (!(_R < _L)); }

template<class _E, class _Tr, class _A> inline
        bool operator>=(const basic_string<_E, _Tr, _A>& _L,
                const basic_string<_E, _Tr, _A>& _R)
        {return (!(_L < _R)); }
template<class _E, class _Tr, class _A> inline
        bool operator>=(const _E * _L,
                const basic_string<_E, _Tr, _A>& _R)
        {return (!(_L < _R)); }
template<class _E, class _Tr, class _A> inline
        bool operator>=(const basic_string<_E, _Tr, _A>& _L,
                const _E *_R)
        {return (!(_L < _R)); }
#line 184
template<class _E, class _Tr, class _A>
        basic_istream<_E, _Tr>& operator>>(
                basic_istream<_E, _Tr>& _I,
                basic_string<_E, _Tr, _A>& _X);

template<class _E, class _Tr, class _A> inline
        basic_istream<_E, _Tr>& getline(basic_istream<_E, _Tr>& _I,
                basic_string<_E, _Tr, _A>& _X)
        {return (getline(_I, _X, _I.widen('\n'))); }
template<class _E, class _Tr, class _A>
        basic_istream<_E, _Tr>& getline(basic_istream<_E, _Tr>& _I,
                basic_string<_E, _Tr, _A>& _X, const _E _D);

template<class _E, class _Tr, class _A>
        basic_ostream<_E, _Tr>& operator<<(
                basic_ostream<_E, _Tr>& _O,
                const basic_string<_E, _Tr, _A>& _X);
#line 219
};

#pragma implementation("string.t")
#line 31 "/usr/vacpp/include/string.t"
namespace std {
#line 36
template<class _E, class _Tr, class _A>
inline
basic_istream<_E, _Tr>& operator>>(
                basic_istream<_E, _Tr>& _I,
                basic_string<_E, _Tr, _A>& _X)
        {typedef ctype<_E> _Ctype;
        typedef basic_istream<_E, _Tr> _Myis;
        typedef basic_string<_E, _Tr, _A> _Mystr;
        typedef typename _Mystr::size_type _Mysizt;
        ios_base::iostate _St = ios_base::goodbit;
        bool _Chg = false;
        const typename _Myis::sentry _Ok(_I);
        if (_Ok)
                {const _Ctype& _Fac = use_facet<_Ctype >(_I.getloc());
                _X.erase();
                try {
                _Mysizt _N = 0 < _I.width()
                        && (_Mysizt)_I.width() < _X.max_size()
                                ? (_Mysizt)_I.width() : _X.max_size();
                typename _Tr::int_type _C = _I.rdbuf()->sgetc();
                for (; 0 < --_N; _C = _I.rdbuf()->snextc())
                        if(_Tr::eq_int_type(_Tr::eof(), _C))
                                {_St |= ios_base::eofbit;
                                break; }
                        else if (_Fac.is(_Ctype::space,
                                _Tr::to_char_type(_C)))
                                break;
                        else
                                {_X.append(1, _Tr::to_char_type(_C));
                                _Chg = true; }
                } catch (...) { (_I).setstate(ios_base::badbit, true); }; }
        _I.width(0);
        if (!_Chg)
                _St |= ios_base::failbit;
        _I.setstate(_St);
        return (_I); }

template<class _E, class _Tr, class _A>
inline
basic_istream<_E, _Tr>& getline(basic_istream<_E, _Tr>& _I,
                basic_string<_E, _Tr, _A>& _X, const _E _D)
        {typedef basic_istream<_E, _Tr> _Myis;
        ios_base::iostate _St = ios_base::goodbit;
        bool _Chg = false;
        const typename _Myis::sentry _Ok(_I, true);
        if (_Ok)
                {try {
                _X.erase();
                typename _Tr::int_type _C = _I.rdbuf()->sgetc();
                for (; ; _C = _I.rdbuf()->snextc())
                        if (_Tr::eq_int_type(_Tr::eof(), _C))
                                {_St |= ios_base::eofbit;
                                break; }
                        else if (_Tr::eq(_C, _D))
                                {_Chg = true;
                                _I.rdbuf()->sbumpc();
                                break; }
                        else if (_X.max_size() <= _X.size())
                                {_St |= ios_base::failbit;
                                break; }
                        else
                                _X += _Tr::to_char_type(_C), _Chg = true;
                } catch (...) { (_I).setstate(ios_base::badbit, true); }; }
        if (!_Chg)
                _St |= ios_base::failbit;
        _I.setstate(_St);
        return (_I); }

template<class _E, class _Tr, class _A>
inline
basic_ostream<_E, _Tr>& operator<<(
                basic_ostream<_E, _Tr>& _O,
                const basic_string<_E, _Tr, _A>& _X)
        {typedef basic_ostream<_E, _Tr> _Myos;
        typedef basic_string<_E, _Tr, _A> _Mystr;
        typedef typename _Mystr::size_type _Mysizt;
        ios_base::iostate _St = ios_base::goodbit;
        _Mysizt _N = _X.size();
        _Mysizt _M = _O.width() <= 0
                || (_Mysizt)_O.width() <= _N
                        ? 0 : (_Mysizt)_O.width() - _N;
        const typename _Myos::sentry _Ok(_O);
        if (!_Ok)
                _St |= ios_base::badbit;
        else
                {try {
                if ((_O.flags() & ios_base::adjustfield)
                        != ios_base::left)
                        for (; 0 < _M; --_M)
                                if (_Tr::eq_int_type(_Tr::eof(),
                                        _O.rdbuf()->sputc(_O.fill())))
                                        {_St |= ios_base::badbit;
                                        break; }
                if (_St == ios_base::goodbit)
                        for (_Mysizt _I = 0; _I < _N; ++_I)
                                if (_Tr::eq_int_type(_Tr::eof(),
                                        _O.rdbuf()->sputc(_X[_I])))
                                        {_St |= ios_base::badbit;
                                        break; }
                if (_St == ios_base::goodbit)
                        for (; 0 < _M; --_M)
                                if (_Tr::eq_int_type(_Tr::eof(),
                                        _O.rdbuf()->sputc(_O.fill())))
                                        {_St |= ios_base::badbit;
                                        break; }
                _O.width(0);
                } catch (...) { (_O).setstate(ios_base::badbit, true); } }
        _O.setstate(_St);
        return (_O); }
#line 159
};
#line 227 "/usr/vacpp/include/string"
#pragma namemangling(pop)
#line 230
#pragma object_model (pop)
#line 237
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 13 "/usr/vacpp/include/vector"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 40
#pragma object_model(compat)
#line 45
  #pragma namemangling(v7)
#line 70
namespace std {
#line 73
template<class _Ty, class _A>
        class _Vector_val {
protected:
        _Vector_val(_A _Al = _A())
                : _Alval(_Al) {}
        typedef typename _A::template
                rebind<_Ty>::other _Alty;
        _Alty _Alval;
        };
#line 84
template<class _Ty, class _Ax = allocator<_Ty> >
        class vector : public _Vector_val<_Ty, _Ax> {
public:
        typedef vector<_Ty, _Ax> _Myt;
        typedef _Vector_val<_Ty, _Ax> _Mybase;
        typedef typename _Mybase::_Alty _A;
        typedef _A allocator_type;
        typedef typename _A::size_type size_type;
        typedef typename _A::difference_type difference_type;
        typedef typename _A::pointer _Tptr;
        typedef typename _A::const_pointer _Ctptr;
        typedef _Tptr pointer;
        typedef _Ctptr const_pointer;
        typedef typename _A::reference reference;
        typedef typename _A::const_reference const_reference;
        typedef typename _A::value_type value_type;
#line 104
        typedef _Ptrit<value_type, difference_type, _Tptr,
                reference, _Tptr, reference> iterator;
        typedef _Ptrit<value_type, difference_type, _Ctptr,
                const_reference, _Tptr, reference> const_iterator;

        typedef typename std::reverse_iterator<iterator>
                reverse_iterator;
        typedef typename std::reverse_iterator<const_iterator>
                const_reverse_iterator;
        vector()
                : _Mybase()
                {_Buy(0); }
        explicit vector(const _A& _Al)
                : _Mybase(_Al)
                {_Buy(0); }
        explicit vector(size_type _N)
                : _Mybase()
                {if (_Buy(_N))
                        _Last = _Ufill(_First, _N, _Ty()); }
        vector(size_type _N, const _Ty& _V)
                : _Mybase()
                {if (_Buy(_N))
                        _Last = _Ufill(_First, _N, _V); }
        vector(size_type _N, const _Ty& _V, const _A& _Al)
                : _Mybase(_Al)
                {if (_Buy(_N))
                        _Last = _Ufill(_First, _N, _V); }
        vector(const _Myt& _X)
                : _Mybase(_X._Alval)
                {if (_Buy(_X.size()))
                        _Last = _Ucopy(_X.begin(), _X.end(), _First); }
        template<class _It>
                vector(_It _F, _It _L)
                : _Mybase()
                {_Construct(_F, _L, _Iter_cat(_F)); }
        template<class _It>
                vector(_It _F, _It _L, const _A& _Al)
                : _Mybase(_Al)
                {_Construct(_F, _L, _Iter_cat(_F)); }
        template<class _It>
                void _Construct(_It _F, _It _L, _Int_iterator_tag)
                {size_type _N = (size_type)_F;
                if (_Buy(_N))
                        _Last = _Ufill(_First, _N, (_Ty)_L); }
        template<class _It>
                void _Construct(_It _F, _It _L, input_iterator_tag)
                {_Buy(0);
                insert(begin(), _F, _L); }
        ~vector()
                {_Clear(); }
        _Myt& operator=(const _Myt& _X)
                {if (this == &_X)
                        ;
                else if (_X.size() == 0)
                        {_Clear(); }
                else if (_X.size() <= size())
                        {pointer _Q = copy(_X.begin(), _X.end(), _First);
                        _Destroy(_Q, _Last);
                        _Last = _First + _X.size(); }
                else if (_X.size() <= capacity())
                        {const_iterator _S = _X.begin() + size();
                        copy(_X.begin(), _S, _First);
                        _Last = _Ucopy(_S, _X.end(), _Last); }
                else
                        {_Destroy(_First, _Last);
                        _Mybase::_Alval.deallocate(_First,
                                _End - _First);
                        if (_Buy(_X.size()))
                                _Last = _Ucopy(_X.begin(), _X.end(), _First); }
                return (*this); }
        void reserve(size_type _N);
        size_type capacity() const
                {return (_First == 0 ? 0 : _End - _First); }
        iterator begin()
                {return (iterator(_First)); }
        const_iterator begin() const
                {return (const_iterator(_First)); }
        iterator end()
                {return (iterator(_Last)); }
        const_iterator end() const
                {return (const_iterator(_Last)); }
        reverse_iterator rbegin()
                {return (reverse_iterator(end())); }
        const_reverse_iterator rbegin() const
                {return (const_reverse_iterator(end())); }
        reverse_iterator rend()
                {return (reverse_iterator(begin())); }
        const_reverse_iterator rend() const
                {return (const_reverse_iterator(begin())); }
        void resize(size_type _N)
                {resize(_N, _Ty()); }
        void resize(size_type _N, _Ty _X)
                {if (size() < _N)
                        insert(end(), _N - size(), _X);
                else if (_N < size())
                        erase(begin() + _N, end()); }
        size_type size() const
                {return (_First == 0 ? 0 : _Last - _First); }
        size_type max_size() const
                {return (_Mybase::_Alval.max_size()); }
        bool empty() const
                {return (size() == 0); }
        _A get_allocator() const
                {return (_Mybase::_Alval); }
        const_reference at(size_type _P) const
                {if (size() <= _P)
                        _Xran();
                return (*(begin() + _P)); }
        reference at(size_type _P)
                {if (size() <= _P)
                        _Xran();
                return (*(begin() + _P)); }
        const_reference operator[](size_type _P) const
                {return (*(begin() + _P)); }
        reference operator[](size_type _P)
                {return (*(begin() + _P)); }
        reference front()
                {return (*begin()); }
        const_reference front() const
                {return (*begin()); }
        reference back()
                {return (*(end() - 1)); }
        const_reference back() const
                {return (*(end() - 1)); }
        void push_back(const _Ty& _X)
                {if (_Last < _End)
                        {_Mybase::_Alval.construct(_Last, _X);
                        _Last += 1;
                        }
                else
                        {insert(end(), _X); }}
        void pop_back()
                {erase(end() - 1); }
        template<class _It>
                void assign(_It _F, _It _L)
                {_Assign(_F, _L, _Iter_cat(_F)); }
        template<class _It>
                void _Assign(_It _F, _It _L, _Int_iterator_tag)
                {assign((size_type)_F, (_Ty)_L); }
        template<class _It>
                void _Assign(_It _F, _It _L, input_iterator_tag)
                {erase(begin(), end());
                insert(begin(), _F, _L); }
        void assign(size_type _N, const _Ty& _X)
                {_Ty _Tx = _X;
                erase(begin(), end());
                insert(begin(), _N, _Tx); }
        iterator insert(iterator _P, const _Ty& _X)
                {size_type _Off = size() == 0 ? 0 : _P - begin();
                insert(_P, (size_type)1, _X);
                return (begin() + _Off); }
        void insert(iterator _P, size_type _M, const _Ty& _X);
        template<class _It>
                void insert(iterator _P, _It _F, _It _L)
                {_Insert(_P, _F, _L, _Iter_cat(_F)); }
        template<class _It>
                void _Insert(iterator _P, _It _F, _It _L,
                        _Int_iterator_tag)
                {insert(_P, (size_type)_F, (_Ty)_L); }
        template<class _It>
                void _Insert(iterator _P, _It _F, _It _L,
                        input_iterator_tag)
                {for (; _F != _L; ++_F, ++_P)
                        _P = insert(_P, *_F); }
        template<class _It>
                void _Insert(iterator _P, _It _F, _It _L,
                        forward_iterator_tag);
        iterator erase(iterator _P)
                {copy(_P + 1, end(), _P);
                _Destroy(_Last - 1, _Last);
                --_Last;
                return (_P); }
        iterator erase(iterator _F, iterator _L)
                {if (_F != _L)
                        {pointer _S = copy(_L, end(), _GetRawPtr(_F));
                        _Destroy(_S, _Last);
                        _Last = _S; }
                return (_F); }
        void clear()
                {erase(begin(), end()); }
        void swap(_Myt& _X)
                {if (_Mybase::_Alval == _X._Alval)
                        {std::swap(_First, _X._First);
                        std::swap(_Last, _X._Last);
                        std::swap(_End, _X._End); }
                else
                        {_Myt _Ts = *this; *this = _X, _X = _Ts; }}
protected:
        bool _Buy(size_type _N)
                {_First = 0, _Last = 0, _End = 0;
                if (_N == 0)
                        return (false);
                else
                        {_First = _Mybase::_Alval.allocate(_N,
                                (void *)0);
                        _Last = _First;
                        _End = _First + _N;
                        return (true); }}
        void _Clear()
                {if (_First != 0)
                        {_Destroy(_First, _Last);
                        _Mybase::_Alval.deallocate(_First,
                                _End - _First); }
                _First = 0, _Last = 0, _End = 0; }
        void _Destroy(pointer _F, pointer _L)
                {for (; _F != _L; ++_F)
                        _Mybase::_Alval.destroy(_F); }
        template<class _It>
        pointer _Ucopy(_It _F, _It _L, pointer _Q);
        pointer _Ufill(pointer _Q, size_type _N, const _Ty &_X);
        void _Xlen() const
                {throw length_error(""); }
        void _Xran() const
                {throw out_of_range(""); }
        pointer _First, _Last, _End;
        };

template<class _Ty, class _Ax> inline
bool _VectorEq(const vector<_Ty, _Ax>& _X, const vector<_Ty, _Ax>& _Y)
        {return (_X.size() == _Y.size() &&
               equal(_Y.begin(), _Y.end(), _X.begin())); }
template<class _Ty, class _Ax> inline
bool _VectorLt(const vector<_Ty, _Ax>& _X, const vector<_Ty, _Ax>& _Y)
        {return (lexicographical_compare(_X.begin(), _X.end(),
                _Y.begin(), _Y.end())); }
#line 331
typedef unsigned char _Vbase;
const int _VBITS = 8 * sizeof (_Vbase);  

template<class _A>
        class vector<_Bool, _A> {
public:
        typedef typename _A::size_type size_type;
        typedef typename _A::difference_type _Dift;
        typedef typename std::vector<_Vbase,
                typename _A::template rebind<_Vbase>::other>
                        _Vbtype;
        typedef typename std::vector<_Bool, _A> _Myt;
        typedef _Dift difference_type;
        typedef _Bool _Ty;
        typedef _A allocator_type;

        class reference {
        public:
                reference()
                        : _Mask(0), _Ptr(0) {}
                reference(size_t _Off, _Vbase *_P)
                        : _Mask((_Vbase)1 << _Off), _Ptr(_P) {}
                reference& operator=(const reference& _X)
                        {return (*this = bool(_X)); }
                reference& operator=(bool _V)
                        {if (_V)
                                *_Ptr |= _Mask;
                        else
                                *_Ptr &= ~_Mask;
                        return (*this); }
                void flip()
                        {*_Ptr ^= _Mask; }
                bool operator~() const
                        {return (!bool(*this)); }
                operator bool() const
                        {return ((*_Ptr & _Mask) != 0); }
        protected:
                _Vbase _Mask, *_Ptr;
                };
        typedef reference _Reft;
        typedef bool const_reference;
        typedef bool value_type;
#line 375
        class const_iterator;
        class iterator
                : public _Ranit<_Bool, _Dift, _Reft *, _Reft> {
        public:
                typedef _Ranit<_Bool, _Dift, _Reft *, _Reft> _Mybase;
                typedef typename _Mybase::iterator_category
                        iterator_category;
                typedef typename _Mybase::value_type value_type;
                typedef typename _Mybase::difference_type
                        difference_type;
                typedef typename _Mybase::pointer pointer;
                typedef typename _Mybase::reference reference;
                friend class const_iterator;
                iterator()
                        : _Off(0), _Ptr(0) {}
                iterator(size_t _O, typename _Vbtype::iterator _P)
                        : _Off(_O), _Ptr(_GetRawPtr(_P)) {}
                reference operator*() const
                        {return (_Reft(_Off, _Ptr)); }
                iterator& operator++()
                        {_Inc();
                        return (*this); }
                iterator operator++(int)
                        {iterator _Tmp = *this;
                        _Inc();
                        return (_Tmp); }
                iterator& operator--()
                        {_Dec();
                        return (*this); }
                iterator operator--(int)
                        {iterator _Tmp = *this;
                        _Dec();
                        return (_Tmp); }
                iterator& operator+=(difference_type _N)
                        {if (_N < 0)
                                *this -= -_N;
                        else
                                {_Off += _N;
                                _Ptr += _Off / _VBITS;
                                _Off %= _VBITS; }
                        return (*this); }
                iterator& operator-=(difference_type _N)
                        {if (_N < 0)
                                *this += -_N;
                        else
                                {difference_type _Mod = _N % _VBITS;
                                _Ptr -= _N / _VBITS;
                                if (_Off < _Mod)
                                        {_Ptr -= 1;
                                        _Off = _VBITS - _Mod; }
                                else
                                        {_Off -= _Mod; } }
                        return (*this); }
                iterator operator+(difference_type _N) const
                        {iterator _Tmp = *this;
                        return (_Tmp += _N); }
                iterator operator-(difference_type _N) const
                        {iterator _Tmp = *this;
                        return (_Tmp -= _N); }
                difference_type operator-(const iterator _X) const
                        {return (_VBITS * (_Ptr - _X._Ptr)
                                + (difference_type)_Off
                                - (difference_type)_X._Off); }
                difference_type operator-(const const_iterator _X) const
                        {return (_VBITS * (_Ptr - _X._Ptr)
                                + (difference_type)_Off
                                - (difference_type)_X._Off); }
                reference operator[](difference_type _N) const
                        {return (*(*this + _N)); }
                bool operator==(const iterator& _X) const
                        {return (_Ptr == _X._Ptr && _Off == _X._Off); }
                bool operator==(const const_iterator& _X) const
                        {return (_Ptr == _X._Ptr && _Off == _X._Off); }
                bool operator!=(const iterator& _X) const
                        {return (!(*this == _X)); }
                bool operator!=(const const_iterator& _X) const
                        {return (!(*this == _X)); }
                bool operator<(const iterator& _X) const
                        {return (_Ptr < _X._Ptr
                                || _Ptr == _X._Ptr && _Off < _X._Off); }
                bool operator<(const const_iterator& _X) const
                        {return (_Ptr < _X._Ptr
                                || _Ptr == _X._Ptr && _Off < _X._Off); }
                bool operator>(const iterator& _X) const
                        {return (_X < *this); }
                bool operator>(const const_iterator& _X) const
                        {return (_X < *this); }
                bool operator<=(const iterator& _X) const
                        {return (!(_X < *this)); }
                bool operator<=(const const_iterator& _X) const
                        {return (!(_X < *this)); }
                bool operator>=(const iterator& _X) const
                        {return (!(*this < _X)); }
                bool operator>=(const const_iterator& _X) const
                        {return (!(*this < _X)); }
        protected:
                void _Dec()
                        {if (_Off != 0)
                                --_Off;
                        else
                                _Off = _VBITS - 1, --_Ptr; }
                void _Inc()
                        {if (_Off < _VBITS - 1)
                                ++_Off;
                        else
                                _Off = 0, ++_Ptr; }
                size_t _Off;
                _Vbase *_Ptr;
                };
        typedef iterator _Myit;
#line 494
        class const_iterator : public _Ranit<_Bool, _Dift,
                const_reference *, const_reference> {

        public:
                typedef _Ranit<_Bool, _Dift,
                        const_reference *, const_reference> _Mybase;
                typedef typename _Mybase::iterator_category
                        iterator_category;
                typedef typename _Mybase::value_type value_type;
                typedef typename _Mybase::difference_type
                        difference_type;
                typedef typename _Mybase::pointer pointer;
                typedef typename _Mybase::reference reference;
                friend class iterator;
                const_iterator()
                        : _Off(0), _Ptr(0) {}
                const_iterator(size_t _O,
                        typename _Vbtype::const_iterator _P)
                        : _Off(_O), _Ptr(_GetRawPtr(_P)) {}
                const_iterator(const _Myit& _X)
                        : _Off(_X._Off), _Ptr(_X._Ptr) {}
                const_reference operator*() const
                        {return (_Reft(_Off, (_Vbase *)_Ptr)); }
                const_iterator& operator++()
                        {_Inc();
                        return (*this); }
                const_iterator operator++(int)
                        {const_iterator _Tmp = *this;
                        _Inc();
                        return (_Tmp); }
                const_iterator& operator--()
                        {_Dec();
                        return (*this); }
                const_iterator operator--(int)
                        {const_iterator _Tmp = *this;
                        _Dec();
                        return (_Tmp); }
                const_iterator& operator+=(difference_type _N)
                        {if (_N < 0)
                                *this -= -_N;
                        else
                                {_Off += _N;
                                _Ptr += _Off / _VBITS;
                                _Off %= _VBITS; }
                        return (*this); }
                const_iterator& operator-=(difference_type _N)
                        {if (_N < 0)
                                *this += -_N;
                        else
                                {difference_type _Mod = _N % _VBITS;
                                _Ptr -= _N / _VBITS;
                                if (_Off < _Mod)
                                        {_Ptr -= 1;
                                        _Off = _VBITS - _Mod; }
                                else
                                        {_Off -= _Mod; } }
                        return (*this); }
                const_iterator operator+(difference_type _N) const
                        {const_iterator _Tmp = *this;
                        return (_Tmp += _N); }
                const_iterator operator-(difference_type _N) const
                        {const_iterator _Tmp = *this;
                        return (_Tmp -= _N); }
                difference_type operator-(const const_iterator _X) const
                        {return (_VBITS * (_Ptr - _X._Ptr)
                                + (difference_type)_Off
                                - (difference_type)_X._Off); }
                const_reference operator[](difference_type _N) const
                        {return (*(*this + _N)); }
                bool operator==(const const_iterator& _X) const
                        {return (_Ptr == _X._Ptr && _Off == _X._Off); }
                bool operator!=(const const_iterator& _X) const
                        {return (!(*this == _X)); }
                bool operator<(const const_iterator& _X) const
                        {return (_Ptr < _X._Ptr
                                || _Ptr == _X._Ptr && _Off < _X._Off); }
                bool operator>(const const_iterator& _X) const
                        {return (_X < *this); }
                bool operator<=(const const_iterator& _X) const
                        {return (!(_X < *this)); }
                bool operator>=(const const_iterator& _X) const
                        {return (!(*this < _X)); }
        protected:
                void _Dec()
                        {if (_Off != 0)
                                --_Off;
                        else
                                _Off = _VBITS - 1, --_Ptr; }
                void _Inc()
                        {if (_Off < _VBITS - 1)
                                ++_Off;
                        else
                                _Off = 0, ++_Ptr; }
                size_t _Off;
                const _Vbase *_Ptr;
                };

        typedef iterator pointer;
        typedef const_iterator const_pointer;
        typedef typename std::reverse_iterator<iterator>
                reverse_iterator;
        typedef typename std::reverse_iterator<const_iterator>
                const_reverse_iterator;

        vector()
                : _Size(0), _Vec() {}
        explicit vector(const _A& _Al)
                : _Size(0), _Vec(_Al) {}
        explicit vector(size_type _N, const bool _V = false)
                : _Size(0), _Vec(_Nw(_N), _V ? -1 : 0)
                {_Trim(_N); }
        vector(size_type _N, const bool _V, const _A& _Al)
                : _Size(0), _Vec(_Nw(_N), _V ? -1 : 0, _Al)
                {_Trim(_N); }
        template<class _It>
                vector(_It _F, _It _L)
                : _Size(0), _Vec()
                {_BConstruct(_F, _L, _Iter_cat(_F)); }
        template<class _It>
                vector(_It _F, _It _L, const _A& _Al)
                : _Size(0), _Vec(_Al)
                {_BConstruct(_F, _L, _Iter_cat(_F)); }
        template<class _It>
                void _BConstruct(_It _F, _It _L, _Int_iterator_tag)
                {size_type _N = (size_type)_F;
                _Vec.assign(_N, (_Ty)_L ? -1 : 0);
                _Trim(_N); }
        template<class _It>
                void _BConstruct(_It _F, _It _L, input_iterator_tag)
                {insert(begin(), _F, _L); }
        ~vector()
                {_Size = 0; }
        void reserve(size_type _N)
                {_Vec.reserve(_Nw(_N)); }
        size_type capacity() const
                {return (_Vec.capacity() * _VBITS); }
        iterator begin()
                {return (iterator(0, _Vec.begin())); }
        const_iterator begin() const
                {return (const_iterator(0, _Vec.begin())); }
        iterator end()
                {iterator _Tmp = begin();
                if (0 < _Size)
                        _Tmp += _Size;
                return (_Tmp); }
        const_iterator end() const
                {const_iterator _Tmp = begin();
                if (0 < _Size)
                        _Tmp += _Size;
                return (_Tmp); }
        reverse_iterator rbegin()
                {return (reverse_iterator(end())); }
        const_reverse_iterator rbegin() const
                {return (const_reverse_iterator(end())); }
        reverse_iterator rend()
                {return (reverse_iterator(begin())); }
        const_reverse_iterator rend() const
                {return (const_reverse_iterator(begin())); }
        void resize(size_type _N, bool _X = false)
                {if (size() < _N)
                        insert(end(), _N - size(), _X);
                else if (_N < size())
                        erase(begin() + _N, end()); }
        size_type size() const
                {return (_Size); }
        size_type max_size() const
                {return (_Vec.max_size() * _VBITS); }
        bool empty() const
                {return (size() == 0); }
        _A get_allocator() const
                {return (_Vec.get_allocator()); }
        const_reference at(size_type _P) const
                {if (size() <= _P)
                        _Xran();
                return (*(begin() + _P)); }
        reference at(size_type _P)
                {if (size() <= _P)
                        _Xran();
                return (*(begin() + _P)); }
        const_reference operator[](size_type _P) const
                {return (*(begin() + _P)); }
        reference operator[](size_type _P)
                {return (*(begin() + _P)); }
        reference front()
                {return (*begin()); }
        const_reference front() const
                {return (*begin()); }
        reference back()
                {return (*(end() - 1)); }
        const_reference back() const
                {return (*(end() - 1)); }
        void push_back(const bool _X)
                {insert(end(), _X); }
        void pop_back()
                {erase(end() - 1); }
        template<class _It>
                void assign(_It _F, _It _L)
                {_Assign(_F, _L, _Iter_cat(_F)); }
        template<class _It>
                void _Assign(_It _F, _It _L, _Int_iterator_tag)
                {assign((size_type)_F, (_Ty)_L); }
        template<class _It>
                void _Assign(_It _F, _It _L, input_iterator_tag)
                {erase(begin(), end());
                insert(begin(), _F, _L); }
        void assign(size_type _N, const _Ty& _X)
                {_Ty _Tx = _X;
                erase(begin(), end());
                insert(begin(), _N, _Tx); }
        iterator insert(iterator _P, const bool _X)
                {size_type _Off = _P - begin();
                insert(_P, (size_type)1, _X);
                return (begin() + _Off); }
        void insert(iterator _P, size_type _M, const bool _X);
        template<class _It>
                void insert(iterator _P, _It _F, _It _L)
                {_Insert(_P, _F, _L, _Iter_cat(_F)); }
        template<class _It>
                void _Insert(iterator _P, _It _F, _It _L,
                        _Int_iterator_tag)
                {insert(_P, (size_type)_F, (_Ty)_L); }
        template<class _It>
                void _Insert(iterator _P, _It _F, _It _L,
                        input_iterator_tag)
                {size_type _Off = _P - begin();
                for (; _F != _L; ++_F, ++_Off)
                        insert(begin() + _Off, *_F); }
        template<class _It>
                void _Insert(iterator _P, _It _F, _It _L,
                        forward_iterator_tag);
        iterator erase(iterator _P)
                {copy(_P + 1, end(), _P);
                _Trim(_Size - 1);
                return (_P); }
        iterator erase(iterator _F, iterator _L)
                {iterator _S = copy(_L, end(), _F);
                _Trim(_S - begin());
                return (_F); }
        void clear()
                {erase(begin(), end()); }
        void flip()
                {for (typename _Vbtype::iterator _S = _Vec.begin();
                        _S != _Vec.end(); ++_S)
                        *_S = ~*_S;
                _Trim(_Size); }
        bool _Eq(const _Myt& _X) const
                {return (_Size == _X._Size && _Vec == _X._Vec); }
        void swap(_Myt& _X)
                {std::swap(_Size, _X._Size);
                _Vec.swap(_X._Vec); }
        static void swap(reference _X, reference _Y)
                {bool _V = _X;
                _X = _Y;
                _Y = _V; }
protected:
        static size_type _Nw(size_type _N)
                {return ((_N + _VBITS - 1) / _VBITS); }
        void _Trim(size_type _N)
                {if (size() < _N && max_size() <= _N)
                        _Xlen();
                size_type _M = _Nw(_N);
                if (_M < _Vec.size())
                        _Vec.erase(_Vec.begin() + _M, _Vec.end());
                _Size = _N;
                _N %= _VBITS;
                if (0 < _N)
                        _Vec[_M - 1] &= ((_Vbase)1 << _N) - 1; }
        void _Xlen() const
                {throw out_of_range(""); }
        void _Xran() const
                {throw out_of_range(""); }
        size_type _Size;
        _Vbtype _Vec;
        };

template<class _Ax> inline
bool _VectorEq(const vector<_Bool, _Ax>& _X, const vector<_Bool, _Ax>& _Y)
        {return (_X._Eq(_Y)); }

typedef vector<bool, allocator<bool> > _Bvector;
#line 776
template<class _Ty, class _A> inline
        bool operator==(const vector<_Ty, _A>& _X,
                const vector<_Ty, _A>& _Y)
        {return (_VectorEq(_X, _Y)); }
template<class _Ty, class _A> inline
        bool operator!=(const vector<_Ty, _A>& _X,
                const vector<_Ty, _A>& _Y)
        {return (!(_X == _Y)); }
template<class _Ty, class _A> inline
        bool operator<(const vector<_Ty, _A>& _X,
                const vector<_Ty, _A>& _Y)
        {return (_VectorLt(_X, _Y)); }
template<class _Ty, class _A> inline
        bool operator>(const vector<_Ty, _A>& _X,
                const vector<_Ty, _A>& _Y)
        {return (_Y < _X); }
template<class _Ty, class _A> inline
        bool operator<=(const vector<_Ty, _A>& _X,
                const vector<_Ty, _A>& _Y)
        {return (!(_Y < _X)); }
template<class _Ty, class _A> inline
        bool operator>=(const vector<_Ty, _A>& _X,
                const vector<_Ty, _A>& _Y)
        {return (!(_X < _Y)); }
template<class _Ty, class _A> inline
        void swap(vector<_Ty, _A>& _X, vector<_Ty, _A>& _Y)
        {_X.swap(_Y); }

};

#pragma implementation("vector.t")
#line 33 "/usr/vacpp/include/vector.t"
namespace std {
template<class _Ty, class _Ax>
inline
void vector<_Ty, _Ax>::reserve(size_type _N)
        {if (max_size() < _N)
                _Xlen();
        else if (capacity() < _N)
                {pointer _Q = _Mybase::_Alval.allocate(_N,
                        (void *)0);
                try {
                _Ucopy(begin(), end(), _Q);
                } catch (...) {
                _Mybase::_Alval.deallocate(_Q, _N);
                throw;
                }
                if (_First != 0)
                        {_Destroy(_First, _Last);
                        _Mybase::_Alval.deallocate(_First,
                                _End - _First); }
                _End = _Q + _N;
                _Last = _Q + size();
                _First = _Q; }}
#line 57
template<class _Ty, class _Ax>
inline
void vector<_Ty, _Ax>::insert(iterator _P, size_type _M, const _Ty& _X)
        {_Ty _Tx = _X;
        size_type _N = capacity();
        if (_M == 0)
                ;
        else if (max_size() - size() < _M)
                _Xlen();
        else if (_N < size() + _M)
                {_N = max_size() - _N / 2 < _N
                        ? 0 : _N + _N / 2;
                if (_N < size() + _M)
                        _N = size() + _M;
                pointer _S = _Mybase::_Alval.allocate(_N,
                        (void *)0);
                pointer _Q;
                try {
                _Q = _Ucopy(begin(), _P, _S);
                _Q = _Ufill(_Q, _M, _Tx);
                _Ucopy(_P, end(), _Q);
                } catch (...) {
                _Destroy(_S, _Q);
                _Mybase::_Alval.deallocate(_S, _N);
                throw;
                }
                if (_First != 0)
                        {_Destroy(_First, _Last);
                        _Mybase::_Alval.deallocate(_First,
                                _End - _First); }
                _End = _S + _N;
                _Last = _S + size() + _M;
                _First = _S; }
        else if ((size_type)(end() - _P) < _M)
                {_Ucopy(_P, end(), _GetRawPtr(_P) + _M);
                try {
                _Ufill(_Last, _M - (end() - _P), _Tx);
                } catch (...) {
                _Destroy(_GetRawPtr(_P) + _M, _Last + _M);
                throw;
                }
                _Last += _M;
                fill(_P, end() - _M, _Tx); }
        else
                {iterator _Oend = end();
                _Last = _Ucopy(_Oend - _M, _Oend, _Last);
                copy_backward(_P, _Oend - _M, _Oend);
                fill(_P, _P + _M, _Tx); }}
#line 107
template<class _Ty, class _Ax> template<class _It>
inline
void vector<_Ty, _Ax>::_Insert(iterator _P, _It _F, _It _L, forward_iterator_tag)
        {size_type _M = 0;
        _Distance(_F, _L, _M);
        size_type _N = capacity();
        if (_M == 0)
                ;
        else if (max_size() - size() < _M)
                _Xlen();
        else if (_N < size() + _M)
                {_N = max_size() - _N / 2 < _N
                        ? 0 : _N + _N / 2;
                if (_N < size() + _M)
                        _N = size() + _M;
                pointer _S = _Mybase::_Alval.allocate(_N,
                        (void *)0);
                pointer _Q;
                try {
                _Q = _Ucopy(begin(), _P, _S);
                _Q = _Ucopy(_F, _L, _Q);
                _Ucopy(_P, end(), _Q);
                } catch (...) {
                _Destroy(_S, _Q);
                _Mybase::_Alval.deallocate(_S, _N);
                throw;
                }
                if (_First != 0)
                        {_Destroy(_First, _Last);
                        _Mybase::_Alval.deallocate(_First,
                                _End - _First); }
                _End = _S + _N;
                _Last = _S + size() + _M;
                _First = _S; }
        else if ((size_type)(end() - _P) < _M)
                {_Ucopy(_P, end(), _GetRawPtr(_P) + _M);
                _It _Mid = _F;
                advance(_Mid, end() - _P);
                try {
                _Ucopy(_Mid, _L, _Last);
                } catch (...) {
                _Destroy(_GetRawPtr(_P) + _M, _Last + _M);
                throw;
                }
                _Last += _M;
                copy(_F, _Mid, _P); }
        else if (0 < _M)
                {iterator _Oend = end();
                _Last = _Ucopy(_Oend - _M, _Oend, _Last);
                copy_backward(_P, _Oend - _M, _Oend);
                copy(_F, _L, _P); }}
#line 160
template<class _Ty, class _Ax> template<class _It>
inline
typename vector<_Ty, _Ax>::pointer vector<_Ty, _Ax>::_Ucopy(_It _F, _It _L, pointer _Q)
        {pointer _Qs = _Q;
        try {
        for (; _F != _L; ++_Q, ++_F)
                _Mybase::_Alval.construct(_Q, *_F);
        } catch (...) {
        _Destroy(_Qs, _Q);
        throw;
        }
        return (_Q); }

template <class _Ty, class _Szt, class _Ptr, bool>
        struct _UfillHelper {
        static inline bool help(_Ptr _Q, _Szt _N, const _Ty &_X)
                {return false; }
        };

template <class _Ty, class _Szt, class _Ptr>
        struct _UfillHelper<_Ty, _Szt, _Ptr, true> {
        static inline bool help(_Ptr _Q, _Szt _N, const _Ty &_X)
                {if ((sizeof(_Ty) == 1) || (_X == 0))
                        {memset((void *) _Q, _X,  _N * sizeof(_Ty));
                        return true; }
                return false; }
        };

template<class _Ty, class _Ax>
inline
typename vector<_Ty, _Ax>::pointer vector<_Ty, _Ax>::_Ufill(pointer _Q, size_type _N, const _Ty &_X)
        {
        typedef _UfillHelper<_Ty, size_type, pointer,
                             std::_Is_integral_aux<_Ty>::value > _UFH;

        if (_UFH::help(_Q, _N, _X))
                {return (_Q + _N); }
        else
                {pointer _Qs = _Q;
                try {
                for (; 0 < _N; --_N, ++_Q)
                        _Mybase::_Alval.construct(_Q, _X);
                } catch (...) {
                _Destroy(_Qs, _Q);
                throw;
                }
                return (_Q); }
        }

template<class _A>
inline
void vector<_Bool, _A>::insert(iterator _P, size_type _M, const bool _X)
        {if (_M == 0)
                ;
        else if (max_size() - size() < _M)
                _Xlen();
        else
                {if (size() == 0)
                        {_Vec.resize(_Nw(size() + _M), 0);
                        _P = begin(); }
                else
                        {size_type _Off = _P - begin();
                        _Vec.resize(_Nw(size() + _M), 0);
                        _P = begin() + _Off;
                        copy_backward(_P, end(), end() + _M); }
                fill(_P, _P + _M, _X);
                _Size += _M; }}
#line 229
template<class _A> template<class _It>
inline
void vector<_Bool, _A>::_Insert(iterator _P, _It _F, _It _L, forward_iterator_tag)
        {size_type _M = 0;
        _Distance(_F, _L, _M);
        if (_M == 0)
                ;
        else if (max_size() - size() < _M)
                _Xlen();
        else
                {if (size() == 0)
                        {_Vec.resize(_Nw(size() + _M), 0);
                        _P = begin(); }
                else
                        {size_type _Off = _P - begin();
                        _Vec.resize(_Nw(size() + _M), 0);
                        _P = begin() + _Off;
                        copy_backward(_P, end(), end() + _M); }
                copy(_F, _L, _P);
                _Size += _M; }}

};
#line 812 "/usr/vacpp/include/vector"
#pragma namemangling()

#pragma object_model(pop)
#line 821
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
extern "C" {
}
extern "C" {
#line 40 "/usr/include/sys/ipc.h"
extern "C" {
#line 50
struct ipc_perm {
	uid_t		uid;		 
	gid_t		gid;		 
	uid_t		cuid;		 
	gid_t		cgid;		 
	mode_t		mode;		 
	unsigned short	seq;		 
	key_t		key;		 
};
#line 80
key_t	ftok(const char *, int);
#line 109
}
}
extern "C" {
#line 35 "/usr/include/sys/shm.h"
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 36 "/usr/include/sys/param.h"
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 220 "/usr/include/sys/machine.h"
struct dscr_properties {
#line 223
	unsigned int	 version;
	unsigned int  number_of_streams;	 
	long long	platform_default_pd;	 
	long long	os_default_pd;		 
	long long dscr_res[5];			 
};
#line 236
int dscr_ctl(int op, void *buf_p, int size);
}
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 215 "/usr/include/sys/param.h"
}
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 47 "/usr/include/jfs/fsdefs.h"
struct jfsinfo
{
	unsigned short	agsize;
	unsigned short	iagsize;
	struct 
	{
                unsigned _spare         : 20;
		unsigned _fperpage	:  4;	 
		unsigned _bigexp	:  4;	 
		unsigned _comptype	:  4;	 
	} _jfsvars;
        vmidx_t         logsidx;
};
#line 68
typedef struct
{

	unsigned nbit	:1;	 
	unsigned nfrags	:3;	 
	unsigned addr	:28;	 
#line 79
} frag_t;
}
extern "C" {
}
extern "C" {
#line 101 "/usr/include/jfs/filsys.h"
struct  superblock
{       
	char    s_magic[4];      
	char    s_flag[4];       
	int	s_agsize;	 
	int	s_logserial;	 
	daddr32_t s_fsize;       
	short	s_bsize;	 
	short	s_spare;	 
	char    s_fname[6];      
	char    s_fpack[6];      
	dev32_t	s_logdev;	 
#line 115
	char    s_fmod;          
	char    s_ronly;         
	time32_t s_time;         
#line 120
	int	s_version;	 
	int	s_fragsize;	 
	int	s_iagsize;	 
	int	s_compress;	 
	int	s_bigexp;	 
	int	s_mntflag;	 
	int	s_info;		 
	time32_t s_mount_ts;	 
	time32_t s_dirty_ts;	 
	time32_t s_unmnt_ts;	 
	uint	s_pevlist;	 
};
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 43 "/usr/include/sys/vnode.h"
extern "C" {
}
extern "C" {
}
extern "C" {
#line 72 "/usr/include/sys/lock_def.h"
typedef	int32long64_t 	simple_lock_data;
#line 102
typedef int32long64_t  complex_lock_status;

struct complex_lock_data {
                complex_lock_status   status;
                short   	      flags;
                short   	      recursion_depth;
#line 116
		long		      reserved;
#line 119
};
#line 127
struct lock_data_instrumented {

		union {
			simple_lock_data		s_lock;
			struct complex_lock_data 	c_lock;
			struct lock_data_instrumented	*lock_next;
		} lock_control_word;
#line 137
		unsigned int    li_flags;        
#line 140
		union	{			 
			int 	name;
			struct  {
				short	_id;
				short	occurrence;
			} _lock_id;
		} _lockname;
		int	reserved[4];		 
#line 169
	};
#line 193
union _simple_lock{
	simple_lock_data		_slock;
	struct lock_data_instrumented	*_slockp;
};	
#line 199
union _complex_lock{
	struct complex_lock_data	_clock;
	struct lock_data_instrumented	*_clockp;
};	

typedef	union _simple_lock	Simple_lock;
typedef union _complex_lock	Complex_lock;
#line 208
typedef  Simple_lock	*simple_lock_t;
typedef  Complex_lock	*complex_lock_t;
#line 212
typedef int32long64_t	lock_t;
#line 287
void simple_lock(simple_lock_t);
void simple_lock_hot(simple_lock_t);
void simple_unlock(simple_lock_t);
void simple_unlock_mem(simple_lock_t);
void simple_unlock_hot(simple_lock_t);
boolean_t simple_lock_try(simple_lock_t);
#line 296
int disable_lock(int,simple_lock_t);
void unlock_enable(int,simple_lock_t);
void unlock_enable_mem(int,simple_lock_t);
#line 301
void lock_init(complex_lock_t , boolean_t);
void lock_write(complex_lock_t);
void lock_read(complex_lock_t);
void lock_done(complex_lock_t);
void lock_done_mem(complex_lock_t);
#line 308
boolean_t lock_read_to_write(complex_lock_t);
void lock_write_to_read(complex_lock_t);
#line 312
boolean_t lock_try_write(complex_lock_t);
boolean_t lock_try_read(complex_lock_t);
boolean_t lock_try_read_to_write(complex_lock_t);
#line 317
void lock_set_recursive(complex_lock_t);
void lock_clear_recursive(complex_lock_t);
int lock_islocked(complex_lock_t);
#line 323
int lockl(lock_t *,int);
void unlockl(lock_t *);                
boolean_t lockl_mine(lock_t *);	
#line 334
void simple_lock_init(simple_lock_t);
}
extern "C" {
#line 57 "/usr/include/sys/lockl.h"
extern lock_t kernel_lock;	 
}
extern "C" {
}
extern "C" {
#line 46 "/usr/include/sys/uio.h"
extern "C" {
}
extern "C" {
}
extern "C" {
#line 59
struct iovec {
#line 63
	void *iov_base;	 

	size_t	iov_len;	 
};
#line 72
extern ssize_t	readv(int, const struct iovec *, int);
extern ssize_t 	writev(int, const struct iovec *, int);
#line 85
extern ssize_t	readvx(int, const struct iovec *, int, long);
extern ssize_t 	writevx(int, const struct iovec *, int, long);
extern ssize_t	preadv(int, const struct iovec *, int, offset_t);
extern ssize_t 	pwritev(int, const struct iovec *, int, offset_t);
}
extern "C" {
#line 87 "/usr/include/sys/xmem.h"
struct xmem_phys {
	int		total;
	int		used;
	unsigned int	s_vpn;
	rpn_t 		*rpn;
};
#line 190
struct xmem {
	union {
		struct {
			short	version;
			short	flag;	 
		} s;
		int	_aspace_id;
	} _u;
#line 202
	union {
	    vmhandle_t	_subspace_id;	 
	    uint	_prexflags;	 
	} u1;
#line 209
	union {
	    vmhandle_t	_subspace_id2;	 
	    struct xmem *_orig_xmem;	 
	} u2;
#line 216
	char	*uaddr;		 
#line 232
};
#line 247
extern struct xmem *xmem_global;
#line 262
int xmem_compare_and_swap_32(int *location,int *original,int newval,
			     struct xmem *dp);

int xmem_compare_and_swap_64(long long *location,long long *original,
			     long long newval,struct xmem *dp);
#line 272
int xmattach();				 
#line 283
int xmattach64(unsigned long long vaddr, int count, struct xmem *dp,
int segflag);
#line 291
long xmattach_remio();
#line 303
int xmemin();				 
#line 314
int xmemout();				 
#line 324
int xmdetach();				 
#line 346
int xmemdma();				 
#line 352
int xmemacc();				 
#line 381
unsigned long long xmemdma64();		 
}
extern "C" {
#line 93 "/usr/include/sys/uio.h"
struct uio {
	struct	iovec *uio_iov;	 
	struct	xmem  *uio_xmem; 
	int32long64_t  uio_iovcnt; 
	int32long64_t  uio_iovdcnt; 

	offset_t uio_offset;	 
#line 108
	int32long64_t uio_resid;	 
	short	uio_segflg;	 
	long	uio_fmode;	 
};
typedef struct uio uio_t;
#line 118
struct pinu_block {
	struct pinu_block *next;	 
	int		seg_num;	 
	int		pincount;	 
	struct xmem	xd;		 
};
#line 131
enum	uio_rw { UIO_READ, UIO_WRITE, UIO_READ_NO_MOVE, UIO_WRITE_NO_MOVE,
		 UIO_PWRITE };
#line 339
}
}
extern "C" {
}
extern "C" {
#line 31 "/usr/include/sys/rset.h"
typedef struct subrange subrange_t;
#line 34
typedef void * rsethandle_t;
#line 37
typedef int rstype_t;
#line 50
typedef union {
	pid_t at_pid;            
	tid_t at_tid;            
	int at_shmid;		 
	int at_fd;		 
	rsethandle_t at_rset;	 
        subrange_t *at_subrange;   
#line 61
} rsid_t;
#line 64
struct subrange {
           off64_t su_offset;            
           size64_t su_length;           
#line 70
           rstype_t su_rstype;           

	   uint_t su_policy;             
           rsid_t su_rsid;               

           off64_t su_rsoffset;          
           size64_t su_rslength;         
};
#line 80
typedef struct attachinfo { 
           rstype_t at_rstype;		 
           rsid_t at_rsid;		 
           uint_t at_policy;		 
           int pad0;			 
           struct attachinfo *next_resource;  
} attachinfo_t; 
#line 92
typedef struct mmap_struct {
        uint64_t mm_addr;
        size64_t mm_len;
        off64_t  mm_pos;
        int      mm_prot;
        int      mm_flags;
        int      mm_fd;
} mmap_struct_t;
#line 136
typedef int rsinfo_t;
#line 209
typedef struct rs_attributes {
        uid_t owner; gid_t group; uint_t mode;
} rs_attributes_t;
#line 278
extern int rs_numrads(rsethandle_t rseth,
                    uint_t sdl,
                    uint_t flags);

extern int rs_getrad(rsethandle_t rseth_in,
                    rsethandle_t rseth_out,
                    uint_t sdl,
                    uint_t index,
                    uint_t flags);

extern int rs_getinfo(rsethandle_t rseth,
                    rsinfo_t info_type,
                    uint_t flags);

extern rsethandle_t rs_alloc(uint_t flags);

extern void rs_free(rsethandle_t rseth);

extern int rs_init(rsethandle_t rseth,
                    uint_t flags);

extern int rs_op(uint_t command,
                    rsethandle_t rseth1,
                    rsethandle_t rseth2,
                    uint_t flags,
                    uint_t id);
#line 306
extern int rs_registername(rsethandle_t rseth,
                    char *name_space,
                    char *name,
                    uint_t mode,
                    uint_t command);

extern int rs_getnameattr(char *name_space,
                    char *name,
                    rs_attributes_t *attr);

extern int rs_setnameattr(char *name_space,
                    char *name,
                    uint_t command,
                    rs_attributes_t *attr);

extern int rs_discardname(char *name_space,
                    char *name);

extern int rs_getnamedrset(char *name_space,
                    char *name,
                    rsethandle_t rseth);
#line 329
extern pid_t ra_fork(rstype_t rstype_resource,
                    rsid_t rsid_resource,
                    uint_t flags);

extern int ra_execl(rstype_t, rsid_t, uint_t, const char *, ...);
extern int ra_execle(rstype_t, rsid_t, uint_t, const char *, ...);
extern int ra_execlp(rstype_t, rsid_t, uint_t, const char *, const char *, ...);
extern int ra_execv(rstype_t, rsid_t, uint_t, const char *, char *const[]);
extern int ra_execve(rstype_t, rsid_t, uint_t, const char *, char *const[],
                     char *const[]);
extern int ra_execvp(rstype_t, rsid_t, uint_t, const char *, char *const[]);
extern int ra_exect(rstype_t, rsid_t, uint_t, char *, char *[], char *[]);

extern int ra_attachrset(rstype_t rstype_work_component,
                    rsid_t rsid_work_component,
                    rsethandle_t rseth,
                    uint_t flags);

extern int ra_detachrset(rstype_t rstype_work_component,
                    rsid_t rsid_work_component,
                    uint_t flags);

extern int ra_getrset(rstype_t rstype_work_component,
                    rsid_t rsid_work_component,
                    uint_t flags,
                    rsethandle_t rseth);

extern int ra_shmget(key_t key, size_t size, int shmflg, rstype_t rstype,
		     rsid_t rsid, uint_t policy);
extern int ra_shmgetv(key_t key, size_t size, int shmflg, int rangecnt,
		      subrange_t *user_subranges);

extern void * ra_mmap( void *addr, size_t len, int prot, int flags,
		       int fildes, off64_t off, rstype_t rstype,
		       rsid_t rsid, uint policy );
extern void * ra_mmapv( void *addr, size_t len, int prot, int flags,
		        int fildes, off64_t off, int rangecnt,
			subrange_t *user_subranges );
#line 370
extern int rs_getpartition(pid_t pid,
                    rsethandle_t rseth);

extern int rs_setpartition(pid_t pid,
                    rsethandle_t rseth,
                    uint_t flags);

extern int rs_getassociativity(uint_t type,
		    uint_t id,
		    uint_t *associativity_array,
		    uint_t associativity_array_size);

extern attachinfo_t *ra_get_attachinfo(rstype_t rstype,
                    rsid_t rsid,
                    off64_t offset,
                    size64_t length,
                    uint_t flags);    

extern int ra_free_attachinfo(attachinfo_t *info);
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 176 "/usr/include/sys/vmount.h"
struct vmount {
	uint	vmt_revision;	 
	uint	vmt_length;	 

	fsid64_t  vmt_fsid;	 
#line 184
	int	vmt_vfsnumber;	 
	uint	vmt_time;	 
	uint	vmt_timepad;	 
	int	vmt_flags;	 

	int	vmt_gfstype;	 
	struct vmt_data {
		short vmt_off;	 
		short vmt_size;	 
	} vmt_data[5 + 1];
#line 198
};
#line 234
int vmount(struct vmount *, int);
int uvmount(int, int);
int mntctl(int, size_t, char *);
int fscntl(int, int, caddr_t, size_t);
}
extern "C" {
#line 85 "/usr/include/sys/acl.h"
typedef union _acl_type_t {   
	char		acl_type[8];  
	uint64_t	u64;			 
} acl_type_t;

int __fstatxacl(int fd, uint64_t ctl_flags, acl_type_t *acl_type,
		void *acl, size_t *acl_sz, mode_t *mode_info);
int __statxacl(char *path, uint64_t ctl_flags, acl_type_t *acl_type,
		void *acl, size_t *acl_sz, mode_t *mode_info);
int __fchxacl(int fd, uint64_t ctl_flags, acl_type_t acl_type,
		void *acl, size_t acl_sz, mode_t mode_info);
int __chxacl(char *path, uint64_t ctl_flags, acl_type_t acl_type,
		void *acl, size_t acl_sz, mode_t mode_info);
#line 120
int __aclxcntl(char *path, int cmd, caddr_t arg, size_t *argsize);
#line 149
typedef struct _acl_type_info_t {
	acl_type_t	acl_type;	

	char 		acl_type_info[1];	
#line 155
} acl_type_info_t;
#line 159
typedef	struct   _acl_types_list_t  {
	uint32_t	num_entries;	 
	uint32_t	pad;		

	acl_type_t	entries[16];	 
} acl_types_list_t ;
#line 193
extern int aclx_get(char *, uint64_t, acl_type_t *, void *, size_t *, mode_t *);
extern int aclx_fget(int, uint64_t, acl_type_t *, void *, size_t *, mode_t *);
extern int aclx_put(char *, uint64_t, acl_type_t, void *, size_t, mode_t);
extern int aclx_fput(int, uint64_t, acl_type_t, void *, size_t, mode_t);
extern int aclx_scan(FILE *, void *, size_t *, acl_type_t, FILE *);
extern int aclx_scanStr(char *, void *, size_t *, acl_type_t);
extern int aclx_print(FILE *, void *, size_t, acl_type_t, char *, int);
extern int aclx_printStr(char *, size_t *, void *, size_t, acl_type_t, char *, int);
extern int aclx_gettypes(char *, acl_types_list_t *, size_t *);
extern int aclx_convert(void *, size_t, acl_type_t, void *, size_t *,
		acl_type_t, char *);
extern int aclx_gettypeinfo(char *, acl_type_t, void *, size_t *);
#line 217
typedef union _nfs4_acewhoid_t {
	uid_t	uid;	 
	gid_t	gid;	 
	int32_t	special_whoid;	 
#line 236
	int32_t id;
} nfs4_acewhoid_t;
#line 249
typedef uint32_t nfs4_acetype;
typedef uint32_t nfs4_aceflag;
typedef uint32_t nfs4_acemask;
#line 259
typedef struct _nfs4_ace_int_t { 
	int32_t		entryLen;
#line 264
	uint32_t	flags;	 
#line 269
	nfs4_acewhoid_t	aceWho;	 
#line 273
	nfs4_acetype	aceType;	 
#line 281
	nfs4_aceflag	aceFlags;	 
#line 295
	nfs4_acemask	aceMask;	 
#line 320
	char		aceWhoString[1]; 
#line 325
} nfs4_ace_int_t; 

typedef struct _nfs4_acl_int_t { 
	int32_t		aclLength;	 
	uint32_t	aclVersion;	 

	int32_t		aclEntryN;	 
	nfs4_ace_int_t	aclEntry[1];	 
} nfs4_acl_int_t; 
#line 343
typedef	struct   _nfs4_acl_type_info_t  {
	uint32_t	version;  	 

	uint32_t	acl_support;	 
#line 352
} nfs4_acl_type_info_t ;
#line 362
struct	ace_id
{
	unsigned short	id_len;		 
	unsigned short	id_type;	 
#line 369
	int	id_data[1];		 

};
#line 385
struct	acl_entry
{
	unsigned short	ace_len;	 
	unsigned 	ace_type : 2;	 

	unsigned 	ace_access : 14;     
#line 393
	struct	ace_id	ace_id[1];          
#line 398
};
#line 409
struct	acl
{
	unsigned int	acl_len;
	unsigned int	acl_mode;
#line 415
	ushort	acl_rsvd;
	ushort	u_access;
	ushort	g_access;
	ushort	o_access;
	struct	acl_entry	acl_ext[1];
};
#line 430
	extern int chacl(char *, struct acl *, int);
	extern int fchacl(int, struct acl *, int);
	extern int statacl(char *, int, struct acl *, int);
	extern int fstatacl(int, int, struct acl *, int);

	extern int __chaclx (char *, void *, size_t, unsigned int);
	extern int __fchaclx (int, void *, size_t, unsigned int);
	extern int __stataclx (char *, int, void *, size_t, unsigned int);
	extern int __fstataclx (int, int, void *, size_t, unsigned int);
#line 452
typedef	struct acl		aixc_acl_t;
typedef	struct acl_entry	aixc_ace_t;
typedef	struct ace_id		aixc_acewhoid_t;
}
extern "C" {
#line 57 "/usr/include/sys/vnode.h"
struct vfs;
struct gnode;
struct vnodeops;
struct filock;
struct ucred;
struct vattr;
struct buf;
struct eflock;
extern int audit_flag;
#line 74
struct vnode {
        ushort	v_flag;		 
	ushort	v_flag2;	 
        ulong32int64_t v_count;	 
	int	v_vfsgen;	 
	Simple_lock v_lock;      
        struct vfs *v_vfsp;	 
        struct vfs *v_mvfsp;	 

	struct gnode *v_gnode;	 
	struct vnode *v_next;	 
	struct vnode *v_vfsnext;  
	struct vnode *v_vfsprev;  
	union v_data {
		void *		_v_socket;	  
		struct vnode *	_v_pfsvnode;	  
	} _v_data;
	char *	v_audit; 	  
};
typedef struct vnode vnode_t;
#line 151
struct gn_vfsdata {
	struct gn_vfsdata *gnv_next;	 
	struct gnode	*gnv_gnode;	 
	int	gn_gfstype;		 

};
#line 163
enum vtype { VNON, VREG, VDIR, VBLK, VCHR, VLNK, VSOCK, VBAD, VFIFO, VMPC };

typedef enum vtype vtype_t;
#line 171
struct gnode {
	enum vtype gn_type;		 
	short	gn_flags;		 
	vmid_t	gn_seg;			 
	long32int64_t	gn_mwrcnt;	 
	long32int64_t	gn_mrdcnt;	 
	long32int64_t	gn_rdcnt;	 
	long32int64_t	gn_wrcnt;	 
	long32int64_t	gn_excnt;	 
	long32int64_t	gn_rshcnt;	 
	struct vnodeops *gn_ops;
	struct vnode *gn_vnode;	 
	dev_t	gn_rdev;	 
	chan_t	gn_chan;	 

	Simple_lock	gn_reclk_lock;   
	int		gn_reclk_event;  
	struct filock  *gn_filocks;      

	caddr_t	gn_data;	 
};
#line 224
struct vnodeops {

	int	(*vn_link)(struct vnode *, struct vnode *, char *,
			struct ucred *);
	int	(*vn_mkdir)(struct vnode *, char *, int32long64_t,
			struct ucred *);
	int	(*vn_mknod)(struct vnode *, caddr_t, int32long64_t,
			dev_t, struct ucred *);
	int	(*vn_remove)(struct vnode *, struct vnode *, char *,
			struct ucred *);
	int	(*vn_rename)(struct vnode *, struct vnode *, caddr_t, 
			struct vnode *,struct vnode *,caddr_t,struct ucred *);
	int	(*vn_rmdir)(struct vnode *, struct vnode *, char *,
			struct ucred *);

	int	(*vn_lookup)(struct vnode *, struct vnode **, char *,
			int32long64_t, struct vattr *, struct ucred *);
	int	(*vn_fid)(struct vnode *, struct fileid *, struct ucred *);

	int	(*vn_open)(struct vnode *, int32long64_t, ext_t, caddr_t *,
			struct ucred *);
	int	(*vn_create)(struct vnode *, struct vnode **, int32long64_t,
			caddr_t, int32long64_t, caddr_t *, struct ucred *);
	int	(*vn_hold)(struct vnode *);
	int	(*vn_rele)(struct vnode *);
	int	(*vn_close)(struct vnode *, int32long64_t, caddr_t,
			struct ucred *);
	int	(*vn_map)(struct vnode *, caddr_t, uint32long64_t,
			uint32long64_t, uint32long64_t, struct ucred *);
	int	(*vn_unmap)(struct vnode *, int32long64_t, struct ucred *);

	int	(*vn_access)(struct vnode *, int32long64_t, int32long64_t,
			struct ucred *);
	int	(*vn_getattr)(struct vnode *, struct vattr *, struct ucred *);
	int	(*vn_setattr)(struct vnode *, int32long64_t, int32long64_t,
			int32long64_t, int32long64_t, struct ucred *);

	int	(*vn_fclear)(struct vnode *, int32long64_t, offset_t, offset_t, 
			caddr_t, struct ucred *);
	int	(*vn_fsync)(struct vnode *, int32long64_t, int32long64_t,
			struct ucred *);
	int	(*vn_ftrunc)(struct vnode *, int32long64_t, offset_t, caddr_t,
			struct ucred *);
	int	(*vn_rdwr)(struct vnode *, enum uio_rw, int32long64_t,
			struct uio *, ext_t, caddr_t, struct vattr *,
			struct ucred *);
	int	(*vn_lockctl)(struct vnode *, offset_t, struct eflock *,
			int32long64_t, int (*)(), ulong *, struct ucred *);

	int	(*vn_ioctl)(struct vnode *, int32long64_t, caddr_t, size_t,
			ext_t, struct ucred *);
	int	(*vn_readlink)(struct vnode *, struct uio *, struct ucred *);
	int	(*vn_select)(struct vnode *, int32long64_t, ushort, ushort *,
			void (*)(), caddr_t, struct ucred *);
	int	(*vn_symlink)(struct vnode *, char *, char *, struct ucred *);
	int	(*vn_readdir)(struct vnode *, struct uio *, struct ucred *);

	int	(*vn_strategy)(struct vnode *, struct buf *, struct ucred *);

	int	(*vn_revoke)(struct vnode *, int32long64_t, int32long64_t,
			struct vattr *, struct ucred *);
	int	(*vn_getacl)(struct vnode *, struct uio *, struct ucred *);
	int	(*vn_setacl)(struct vnode *, struct uio *, struct ucred *);
	int	(*vn_getpcl)(struct vnode *, struct uio *, struct ucred *);
	int	(*vn_setpcl)(struct vnode *, struct uio *, struct ucred *);
	int	(*vn_seek)(struct vnode *, offset_t *, struct ucred *);
#line 292
	int	(*vn_fsync_range)(struct vnode *, int32long64_t, int32long64_t,
			offset_t, offset_t, struct ucred *);
	int	(*vn_create_attr)(struct vnode *, struct vnode **,
			int32long64_t, char *, struct vattr *, int32long64_t,
			caddr_t *, struct ucred *);
	int	(*vn_finfo)(struct vnode *, int32long64_t, void *,
			size_t, struct ucred *);
	int	(*vn_map_lloff)(struct vnode *, caddr_t, offset_t, offset_t,
			uint32long64_t, uint32long64_t, struct ucred *);
	int	(*vn_readdir_eofp)(struct vnode *, struct uio *, int *,
			struct ucred *);
	int	(*vn_rdwr_attr)(struct vnode *, enum uio_rw, int32long64_t,
			struct uio *, ext_t , caddr_t, struct vattr *,
			struct vattr *, struct ucred *);
	int	(*vn_memcntl)(struct vnode *,int, void *, struct ucred *);
	int	(*vn_getea)(struct vnode *, const char *, struct uio *,
			       struct ucred *);
	int	(*vn_setea)(struct vnode *, const char*, struct uio *, 
			       int flags, struct ucred *);
	int	(*vn_listea)(struct vnode *, struct uio *, struct ucred *);
	int	(*vn_removeea)(struct vnode *, const char *, struct ucred *);
	int	(*vn_statea)(struct vnode *, const char *, struct vattr *,
				struct ucred *);
	int	(*vn_getxacl)(struct vnode *, uint64_t, acl_type_t *, struct uio *, size_t *, mode_t *, struct ucred *);
	int	(*vn_setxacl)(struct vnode *, uint64_t, acl_type_t, struct uio *, mode_t,  struct ucred *);
	int	(*vn_spareE)();
	int	(*vn_spareF)();
#line 323
	int     (*pagerBackRange)(struct gnode *, offset_t, caddr_t, size_t *,
			size_t *, uint *);
	int64_t	(*pagerGetFileSize)(struct gnode *);
	void	(*pagerReadAhead)(struct gnode *, vpn_t, vpn_t *,
			vpn_t *, vpn_t *, boolean_t);
	void	(*pagerReadWriteBehind)(struct gnode *, int64_t, int64_t, uint);
	void    (*pagerEndCopy)(struct gnode *, offset_t, size_t, size_t, uint);

};
typedef struct vnodeops vnodeops_t;
#line 974
extern enum vtype iftovt_tab[];		 
extern int   vttoif_tab[];
#line 990
}
}
extern "C" {
}
extern "C" {
#line 41 "/usr/include/sys/cred.h"
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 36 "/usr/include/sys/priv.h"
struct priv
{
	unsigned int	pv_priv[2];   
};
typedef struct priv	priv_t;
}
extern "C" {
#line 57 "/usr/include/sys/pcl.h"
struct pce_id
{
	unsigned short	id_len;		 
	unsigned short	id_type;	 
#line 63
	int	id_data[1];	 
};
#line 75
struct	pcl_entry
{
	unsigned int	pce_len;	 
	priv_t	pce_privs;		 
#line 83
	struct pce_id	pce_id[1];
};
#line 115
struct	pcl
{
	unsigned int	pcl_len;
	unsigned int	pcl_mode;
	priv_t	pcl_default;
	struct	pcl_entry	pcl_ext[1];
};
}
extern "C" {
#line 121 "/usr/include/sys/priv.h"
	extern int chpriv(char *, struct pcl *, int);
	extern int fchpriv(int, struct pcl *, int);
	extern int statpriv(char *, int, struct pcl *, int);
	extern int fstatpriv(int, int, struct pcl *, int);
	extern int privcheck(int);
	extern int getpriv(int, priv_t *, int);
	extern int setpriv(int, priv_t *, int);
}
extern "C" {
}
extern "C" {
#line 32 "/usr/include/sys/capabilities.h"
typedef unsigned int cap_flag_t;
#line 41
struct __cap_t {
	uint64_t cap_effective;
	uint64_t cap_inheritable;
	uint64_t cap_permitted;
};
typedef void * cap_t;
cap_t cap_init();
#line 57
typedef unsigned int cap_flag_value_t;
#line 65
typedef int cap_value_t;
}
extern "C" {
#line 75 "/usr/include/sys/cred.h"
typedef struct groupset {
	union {
		struct {
			gid_t	un_groups[((32 * sizeof (gid_t) - sizeof (void *)) / sizeof (gid_t))];
			struct groupset *un_next;
		} un_struct;
		gid_t	un_groups[32];
	} gs_union;
} groupset_t;
#line 135
struct ucred {
	int	cr_ref;			 

	uid_t   cr_ruid;		 
	uid_t   cr_uid;			 
	uid_t   cr_suid;		 
	uid_t   cr_luid;		 
	uid_t   cr_acctid;		 

	gid_t   cr_gid;			 
	gid_t   cr_rgid;		 
	gid_t   cr_sgid;		 

	short	cr_ngrps;		 
#line 151
	short	cr_caps;		 
#line 155
	groupset_t cr_groupset;		 
#line 161
	priv_t	cr_mpriv;
#line 167
	priv_t	cr_ipriv;
#line 173
	priv_t	cr_epriv;
#line 179
	priv_t	cr_bpriv;

	int    cr_pag;                  
};

typedef struct ucred    cred_t;
#line 192
struct ucred_43 {
	int	ocr_ref;		 
	uid_t   ocr_ruid;		 
	uid_t   ocr_uid;		 
	uid_t   ocr_suid;		 
	uid_t   ocr_luid;		 
	uid_t   ocr_acctid;		 
	gid_t   ocr_gid;		 
	gid_t   ocr_rgid;		 
	gid_t   ocr_sgid;		 
	short	ocr_ngrps;		 
	gid_t	ocr_groups[32];  
	priv_t	ocr_mpriv;		 
	priv_t	ocr_ipriv;		 
	priv_t	ocr_epriv;		 
	priv_t	ocr_bpriv;		 
	int	ocr_pag;		 
};
typedef struct ucred_43 cred_43_t;
#line 239
typedef struct ucred_ext {
#line 245
	uid_t   crx_ruid;		 
	uid_t   crx_uid;		 
	uid_t   crx_suid;		 
	uid_t   crx_luid;		 
	uid_t   crx_acctid;		 
#line 255
	gid_t   crx_gid;		 
	gid_t   crx_rgid;		 
	gid_t   crx_sgid;		 
#line 265
	int	crx_ngrps;		 
	gid_t   crx_groups[128];  
#line 272
	int	crx_reserved_1;
#line 278
	struct	__cap_t crx_caps;	  
#line 284
	priv_t	crx_mpriv;		 
	priv_t	crx_ipriv;		 
	priv_t	crx_epriv;		 
	priv_t	crx_bpriv;		 
#line 293
	int	crx_npags;		 
	char	crx_pagids[16];  
	int	crx_pags[16];  
#line 301
	int	crx_pad[256-173];	 
} cred_ext_t;
#line 322
void crlock(void);
void crunlock(void);
void credlock(void);
void credunlock(void);
void crfree(struct ucred *);
struct ucred *crref(void);
struct ucred *crxref(struct ucred * volatile *);
struct ucred *crget(void);
struct ucred *crcopy(struct ucred *);
struct ucred *crdup(struct ucred *);
void crset(struct ucred *);
void crhold(struct ucred *);
void crexport(struct ucred *, struct ucred_ext *);
struct ucred *crimport(int, void *);
#line 365
int kcred_getgroups (struct ucred *, int, gid_t *);
int kcred_setgroups (struct ucred *, int, gid_t *);
int kcred_getpriv (struct ucred *, int, priv_t *);
int kcred_setpriv (struct ucred *, int, priv_t *);
void kcred_getcap (struct ucred *, struct __cap_t *);
void kcred_setcap (struct ucred *, struct __cap_t *);
int kcred_getpag (struct ucred *, int, int *);
int kcred_getpag64 (struct ucred *, int, uint64_t *);
int kcred_setpag (struct ucred *, int, int);
int kcred_setpag64 (struct ucred *, int, uint64_t);
int kcred_genpagvalue (struct ucred *, int, uint64_t *, int);
#line 381
int groupmember (gid_t);
int groupmember_cr (gid_t, struct ucred *);
#line 392
int get_pag(int which, int *pag);
int get_pag64(int which, uint64_t *pag);
int set_pag(int which, int pag);
int set_pag64(int which, uint64_t pag);

struct pag_list {
	int pag;
	int active;
	int spare[2];
};

int validate_pag(int which, struct pag_list pag[], int npag);

struct pag_list64 {
	uint64_t pag;
	int active;
	int spare[2];
};

int validate_pag64(int which, struct pag_list64 pag[], int npag);
#line 418
}
}
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 81 "/usr/include/sys/buf.h"
extern "C" {
}
extern "C" {
}
extern "C" {
#line 40 "/usr/include/sys/ras_base.h"
enum ras_type
{
	RAS_TYPE_CHILD = 0x0,

	RAS_TYPE_OTHER = 0x4f544852,			 

	RAS_TYPE_DEVICE = 0x44450000,			 
	RAS_TYPE_DEVICE_BUS = 0x44454255,		 
	RAS_TYPE_DEVICE_CRYPT = 0x44454352,		 
	RAS_TYPE_DEVICE_PARALLEL = 0x44455041,		 
	RAS_TYPE_DEVICE_PLANAR = 0x4445504c,		 
	RAS_TYPE_DEVICE_SERIAL = 0x44455345,		 
	RAS_TYPE_DEVICE_USB = 0x44455553,		 

	RAS_TYPE_FILESYSTEM = 0x46490000,		 
	RAS_TYPE_FILESYSTEM_DISTRIBUTED = 0x46494449,	 
	RAS_TYPE_FILESYSTEM_LOCAL = 0x46494c4f,		 
	RAS_TYPE_FILESYSTEM_NETWORK = 0x46494e45,	 
	RAS_TYPE_FILESYSTEM_PSEUDO = 0x46495053,	 

	RAS_TYPE_NETWORK = 0x4e450000,			 
	RAS_TYPE_NETWORK_API = 0x4e454150,		 
	RAS_TYPE_NETWORK_ATM = 0x4e454154,		 
	RAS_TYPE_NETWORK_ETHERNET = 0x4e454554,		 
	RAS_TYPE_NETWORK_FDDI = 0x4e454644,		 
	RAS_TYPE_NETWORK_IB = 0x4e454942,		 
	RAS_TYPE_NETWORK_DLC = 0x4e45444c,		 
	RAS_TYPE_NETWORK_PROTOCOL = 0x4e455052,		 
	RAS_TYPE_NETWORK_MEMORY = 0x4e454d45,		 
	RAS_TYPE_NETWORK_SERIAL = 0x4e455345,		 
	RAS_TYPE_NETWORK_TOKENRING = 0x4e45544f,	 
	RAS_TYPE_NETWORK_X25 = 0x4e453235,		 
	RAS_TYPE_NETWORK_VASI = 0x4e455641,		 
	RAS_TYPE_NETWORK_MOVER = 0x4e454d4f,		 
	RAS_TYPE_NETWORK_SEA = 0x4e455365,		 

	RAS_TYPE_SERVICES = 0x53450000,			 
	RAS_TYPE_SERVICES_BASE = 0x53454241,		 
	RAS_TYPE_SERVICES_CHARACTER = 0x53454348,	 
	RAS_TYPE_SERVICES_PERF = 0x53455045,		 
	RAS_TYPE_SERVICES_RAS = 0x53455241,		 
	RAS_TYPE_SERVICES_SECURITY = 0x53455345,	 
	RAS_TYPE_SERVICES_ARM = 0x53454152,		 

	RAS_TYPE_STORAGE = 0x53540000,			 
	RAS_TYPE_STORAGE_ARRAY = 0x53544152,		 
	RAS_TYPE_STORAGE_CDROM = 0x53544344,		 
	RAS_TYPE_STORAGE_DISK = 0x53544449,		 
	RAS_TYPE_STORAGE_DRIVER = 0x53544452,		 
	RAS_TYPE_STORAGE_IDE = 0x53544944,		 
	RAS_TYPE_STORAGE_ISCSI = 0x53544953,		 
	RAS_TYPE_STORAGE_FC = 0x53544643,		 
	RAS_TYPE_STORAGE_FLOPPY = 0x5354464c,		 
	RAS_TYPE_STORAGE_RAID = 0x53545241,		 
	RAS_TYPE_STORAGE_SAS = 0x53545341,		 
	RAS_TYPE_STORAGE_SATA = 0x53545361,		 
	RAS_TYPE_STORAGE_SCSI = 0x53545343,		 
	RAS_TYPE_STORAGE_SSA = 0x53545353,		 
	RAS_TYPE_STORAGE_TAPE = 0x53545441,		 

	RAS_TYPE_UI = 0x55490000,			 
	RAS_TYPE_UI_GRAPHICS = 0x55494752,		 
	RAS_TYPE_UI_KEYBOARD = 0x55494b45,		 
	RAS_TYPE_UI_LFT = 0x55494c46,			 
	RAS_TYPE_UI_MOUSE = 0x55494d4f,			 
	RAS_TYPE_UI_TABLET = 0x55495441,		 

	RAS_TYPE_LAST = 0x0E0F0E0F			 
};
#line 150
typedef enum ras_type ras_type_t;

struct ras_type_entry
{
	ras_type_t rast_type;
	const char *rast_string;
};

typedef struct ras_type_entry ras_type_entry_t;

extern const ras_type_entry_t ras_type_lookup[];
}
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 65 "/usr/include/sys/ras.h"
typedef unsigned char		eye_catch1b_t;
typedef unsigned short		eye_catch2b_t;
typedef unsigned int		eye_catch4b_t;
typedef unsigned long long	eye_catch8b_t;
#line 72
typedef unsigned long		eye_catch_t;
#line 83
typedef long	kerrno_t;
#line 88
typedef void *ras_block_t;
#line 181
enum ras_domain
{
	RASD_TRACE=1,
	RASD_ERROR,
	RASD_DUMP,
	RASD_LAST
};
#line 191
typedef enum ras_domain ras_domain_t;

struct CoMpIlE_aSsErT__toomanydomains { char v[(RASD_LAST < 0x10) ? 1 : -1]; };
#line 216
typedef unsigned long long ras_cmd_t;
#line 256
struct CoMpIlE_aSsErT__baddomain { char v[(( (( (ras_cmd_t)0x52 << ( (sizeof(ras_cmd_t)-1) * 8 ) ) | ((ras_cmd_t)(0x1) << 8) | ((ras_cmd_t)(0x100)) ) | ( ( ((((ras_cmd_t)(0x1)) << 8) & ( ( (ras_cmd_t)0xFF ) << ( (sizeof(ras_cmd_t)-1) * 8 ) )) || (((ras_cmd_t)(0x1)) == 0) || (((ras_cmd_t)(0x100)) & ~( (ras_cmd_t)0xFF )) ) ? -1LL : 0) ) == -1LL) ? 1 : -1]; };
struct CoMpIlE_aSsErT__badcmd { char v[(( (( (ras_cmd_t)0x52 << ( (sizeof(ras_cmd_t)-1) * 8 ) ) | ((ras_cmd_t)(-1) << 8) | ((ras_cmd_t)(0x1)) ) | ( ( ((((ras_cmd_t)(-1)) << 8) & ( ( (ras_cmd_t)0xFF ) << ( (sizeof(ras_cmd_t)-1) * 8 ) )) || (((ras_cmd_t)(-1)) == 0) || (((ras_cmd_t)(0x1)) & ~( (ras_cmd_t)0xFF )) ) ? -1LL : 0) ) == -1LL) ? 1 : -1]; };
#line 278
struct CoMpIlE_aSsErT__RAS_COMMAND_RASC_LOGICAL_ALIAS { char v[(( (( (ras_cmd_t)0x52 << ( (sizeof(ras_cmd_t)-1) * 8 ) ) | ((ras_cmd_t)(0x1) << 8) | ((ras_cmd_t)(0x10)) ) | ( ( ((((ras_cmd_t)(0x1)) << 8) & ( ( (ras_cmd_t)0xFF ) << ( (sizeof(ras_cmd_t)-1) * 8 ) )) || (((ras_cmd_t)(0x1)) == 0) || (((ras_cmd_t)(0x10)) & ~( (ras_cmd_t)0xFF )) ) ? -1LL : 0) ) == 0x5200000000000110ull) ? 1 : -1]; };
#line 281
struct CoMpIlE_aSsErT__RAS_COMMAND_RASC_BLOCK_TO_FULL_PATH { char v[(( (( (ras_cmd_t)0x52 << ( (sizeof(ras_cmd_t)-1) * 8 ) ) | ((ras_cmd_t)(0x2) << 8) | ((ras_cmd_t)(0x10)) ) | ( ( ((((ras_cmd_t)(0x2)) << 8) & ( ( (ras_cmd_t)0xFF ) << ( (sizeof(ras_cmd_t)-1) * 8 ) )) || (((ras_cmd_t)(0x2)) == 0) || (((ras_cmd_t)(0x10)) & ~( (ras_cmd_t)0xFF )) ) ? -1LL : 0) ) == 0x5200000000000210ull) ? 1 : -1]; };
#line 284
struct CoMpIlE_aSsErT__RAS_COMMAND_RASC_STAT_COMPONENT { char v[(( (( (ras_cmd_t)0x52 << ( (sizeof(ras_cmd_t)-1) * 8 ) ) | ((ras_cmd_t)(0x3) << 8) | ((ras_cmd_t)(0x10)) ) | ( ( ((((ras_cmd_t)(0x3)) << 8) & ( ( (ras_cmd_t)0xFF ) << ( (sizeof(ras_cmd_t)-1) * 8 ) )) || (((ras_cmd_t)(0x3)) == 0) || (((ras_cmd_t)(0x10)) & ~( (ras_cmd_t)0xFF )) ) ? -1LL : 0) ) == 0x5200000000000310ull) ? 1 : -1]; };
#line 288
struct CoMpIlE_aSsErT__RAS_COMMAND_RASC_ALIAS_TO_FULL_PATH { char v[(( (( (ras_cmd_t)0x52 << ( (sizeof(ras_cmd_t)-1) * 8 ) ) | ((ras_cmd_t)(0x1) << 8) | ((ras_cmd_t)(0x20)) ) | ( ( ((((ras_cmd_t)(0x1)) << 8) & ( ( (ras_cmd_t)0xFF ) << ( (sizeof(ras_cmd_t)-1) * 8 ) )) || (((ras_cmd_t)(0x1)) == 0) || (((ras_cmd_t)(0x20)) & ~( (ras_cmd_t)0xFF )) ) ? -1LL : 0) ) == 0x5200000000000120ull) ? 1 : -1]; };
#line 291
struct CoMpIlE_aSsErT__RAS_COMMAND_RASC_LIST_COMPONENTS { char v[(( (( (ras_cmd_t)0x52 << ( (sizeof(ras_cmd_t)-1) * 8 ) ) | ((ras_cmd_t)(0x2) << 8) | ((ras_cmd_t)(0x20)) ) | ( ( ((((ras_cmd_t)(0x2)) << 8) & ( ( (ras_cmd_t)0xFF ) << ( (sizeof(ras_cmd_t)-1) * 8 ) )) || (((ras_cmd_t)(0x2)) == 0) || (((ras_cmd_t)(0x20)) & ~( (ras_cmd_t)0xFF )) ) ? -1LL : 0) ) == 0x5200000000000220ull) ? 1 : -1]; };
#line 294
struct CoMpIlE_aSsErT__RAS_COMMAND_RASC_LIST_ALIASES { char v[(( (( (ras_cmd_t)0x52 << ( (sizeof(ras_cmd_t)-1) * 8 ) ) | ((ras_cmd_t)(0x3) << 8) | ((ras_cmd_t)(0x20)) ) | ( ( ((((ras_cmd_t)(0x3)) << 8) & ( ( (ras_cmd_t)0xFF ) << ( (sizeof(ras_cmd_t)-1) * 8 ) )) || (((ras_cmd_t)(0x3)) == 0) || (((ras_cmd_t)(0x20)) & ~( (ras_cmd_t)0xFF )) ) ? -1LL : 0) ) == 0x5200000000000320ull) ? 1 : -1]; };
#line 303
typedef int ras_stat_domain_t[32];

struct ras_stat
{
	int rstat_eyec;
	int rstat_flags;

	char rstat_name[64];
	char rstat_desc[256];

	ras_type_t rstat_typesubtype;

	int rstat_reserved[8];

	ras_stat_domain_t rstat_domain[(RASD_LAST - 1)];
};

typedef struct ras_stat ras_stat_t; 
#line 349
struct ras_pathent
{
	int rpent_eyec;  
	int rpent_flags;
	ras_type_t rpent_typesubtype;
	int rpent_reserved[7];
	char rpent_name[64];
	char rpent_desc[256];
};

typedef struct ras_pathent ras_pathent_t;
#line 362
struct CoMpIlE_aSsErT__rpent_eyec { char v[(__offsetof(ras_pathent_t, rpent_eyec) == 0) ? 1 : -1]; };
#line 370
struct ras_arg
{
	eye_catch8b_t		arg_eyec;	 
	unsigned long long	argptr;		 
	long long		argsize;	 

};

typedef struct ras_arg ras_arg_t;
#line 479
int rascntl(
	char *path,
	ras_cmd_t cmd,
	void *arg,
	int argsize);
}
extern "C" {
#line 90 "/usr/include/sys/buf.h"
struct vnode;
#line 93
struct buf {				 
	__long64_t b_flags;		 

	struct	buf *b_forw;		 
	struct	buf *b_back;		 
	struct	buf *av_forw;		 
	struct	buf *av_back;		 

	void	(*b_iodone)();		 
	struct	vnode *b_vp;		 
	dev_t	b_dev;			 
	daddr_t b_blkno;		 

	union {
	    caddr_t  b_addr;		 
	} b_un;

	__ulong64_t  b_bcount;		 

	char	     b_error;		 
	__ulong64_t  b_resid;		 
	__long64_t   b_work;		 
	int	     b_options; 	 
	tid_t	     b_event;		 
	struct timestruc_t b_start;	 
	struct	     xmem b_xmemd;	 
};
#line 180
struct bufx {				 
	__long64_t b_flags;		 

	struct	bufx *b_forw;		 
	struct	bufx *b_back;		 
	struct	bufx *av_forw;		 
	struct	bufx *av_back;		 

	void	(*b_iodone)();		 
	struct	vnode *b_vp;		 
	dev_t	b_dev;			 
	daddr_t b_blkno;		 

	union {
	    caddr_t  b_addr;		 
	} b_un;

	__ulong64_t  b_bcount;		 

	char	    b_error;		 
	char	    b_pad[3];		 
#line 204
	__ulong64_t  b_resid;		 
	__long64_t   b_work;		 
	int	    b_options;		 
#line 210
	tid_t	    b_event;		 
	struct timestruc_t b_start;	 
	struct xmem b_xmemd;		 
	int	    bx_version;		 
	eye_catch4b_t bx_eyecatcher;	 
	__long64_t   bx_flags;		 
#line 218
	__ulong64_t bx_error_detail;	 
	__ulong64_t bx_work2;		 
	ushort    bx_io_priority;	 
	ushort    bx_io_cache_hint;	 
	int	    bx_resvd1;		 
	__ulong64_t bx_resvd2[7];	 
	__ulong64_t bx_resvd3;		 
#line 231
};
#line 373
}
}
extern "C" {
#line 243 "/usr/include/sys/vmuser.h"
extern int ps_not_defined;
#line 251
struct vmm_client_info {
	uint     magic;		 
	unsigned async    : 1;	 
	unsigned pgahead  : 1;	 
	unsigned combehind: 1;	 
	unsigned max_xfer : 3;	 

	unsigned ncgather : 1;	 
	unsigned rbr      : 1;	 
	unsigned rsvd_bits: 24;	 
	short	numclust;	 
	short	maxpgahead;	 
	int     maxrandwrt;	 
	int     wrb_cluster;	 
	int     wrb_randcnt;	 

	int     maxpout;         
	int     minpout;         
};
}
extern "C" {
}
extern "C" {
#line 55 "/usr/include/sys/fs/quota_common.h"
extern char *qfname;
extern char *qfextension[];
extern char *quotagroup;
#line 65
typedef struct {
	uint64_t  bhard;	 
	uint64_t  bsoft;	 
	uint64_t  ihard;	 
	uint64_t  isoft;	 
	uint64_t  bused;	 
	uint64_t  iused;	 
	time64_t  btime;	 
	time64_t  itime;	 
} quota64_t;			 
#line 119
int quotactl(char *, int, int, caddr_t);
}
extern "C" {
#line 64 "/usr/include/jfs/quota.h"
struct	dqblk {
	u_long	dqb_bhardlimit;	 
	u_long	dqb_bsoftlimit;	 
	u_long	dqb_curblocks;	 
	u_long	dqb_ihardlimit;	 
	u_long	dqb_isoftlimit;	 
	u_long	dqb_curinodes;	 
	time_t	dqb_btime;	 
	time_t	dqb_itime;	 
};
}
extern "C" {
#line 39 "/usr/include/jfs/jfsmount.h"
struct	jfsmount {
	dev_t	jm_dev;			 
	struct	vnode *jm_quotas[2];  
	struct	ucred *jm_cred[2];  
	time_t	jm_btime[2];	 
	time_t	jm_itime[2];	 
	char	jm_qflags[2];	 
};
}
extern "C" {
#line 44 "/usr/include/jfs/ino.h"
struct inode;
#line 49
struct idblock
{
	uint  id_vaddr;   
	uint  id_raddr;   
};

struct dinode
{

	uint	di_gen;
#line 62
	mode_t	di_mode;
#line 65
	ushort	di_nlink;
#line 68
	ushort	di_pel;
#line 73
	uid_t	di_uid;
#line 76
	gid_t	di_gid;
#line 79
	soff_t	di_size_lo;
#line 83
	uint	di_nblocks;
#line 87
	struct timestruc_t    di_mtime_ts;
#line 94
	struct timestruc_t    di_atime_ts;
#line 101
	struct timestruc_t    di_ctime_ts;
#line 112
	int	di_acl;		 
#line 115
	uint	di_attr;
#line 120
	uint	di_rsrvd[4];
	soff_t	di_size_hi;	 
#line 130
	union	di_info
	{

		char	d_private[48];
#line 136
		struct regdir
		{

			uint	_di_rdaddr[8];  
			struct idblock _di_indblk;

			union
			{

				struct
				{
					uint	_di_offset;
					uint	_di_flags;
#line 153
				} _di_privinfo;
				priv_t	_di_priv;

				struct
				{
					uint	_di_aclf;
					uint	_di_acld;
				} _di_aclinfo;
			} _di_sec;
		} _di_file;
#line 175
		struct
		{
			dev32_t	_di_rdev;	 
		} _di_dev;
#line 187
		union
		{
			char	_s_private[48];
			struct	regdir	_s_symfile;
		} _di_sym;
#line 195
	} _di_info;
};
#line 203
struct  jfsmntinfo
{
	uint	_diodone;
	uint	_diofail;
	uint	_mntflag;
	uint	_sbinfo;	 
	time32_t _mount_ts;
	time32_t _dirty_ts;
};

struct mountnode
{
	struct	inode	*_iplog;	 
	struct	inode	*_ipinode;	 
	struct	inode	*_ipind;	 
	struct	inode	*_ipinomap;	 
	struct	inode	*_ipdmap;	 
	struct	inode	*_ipsuper;	 
	struct	inode	*_ipinodex;	 
	struct  jfsmount *_jmpmnt;	 
	struct  jfsinfo _jfs_info;	 
	struct	jfsmntinfo *_jfsmnt;
	pdtx_t	_pdtx;			 
	int	*_indfree;		 
	void	*_kdm_fset;		 
};
#line 259
struct lognode
{
	int	_logptr;	 
	int	_logsize;	 
	int	_logend;	 
	int	_logsync;	 
	int	_nextsync;	 
	int	_logxor;	 

	int	_llogeor;	 

	int	_llogxor;	 

	struct ilogx *_logx;	 
	struct gnode *_logdgp;	 
	Simple_lock   _loglock;	 
	pdtx_t	_logpdtx;	 
	uint	_logwaitcount;	 
	uint	_logwaittime;	 
	Simple_lock	_lilistlock;  
	struct inode	*_lforw;      
};
}
extern "C" {
#line 30 "/usr/include/jfs/inode.h"
struct	inode
{
	struct inode	*i_forw;	 
	struct inode	*i_back;	 
	struct inode	*i_next;         
	struct inode	*i_prev;         
	struct gnode	i_gnode;	 
	ino32_t		i_number;        
	dev_t		i_dev;           
	struct inode	*i_ipmnt;	 
	short		i_flag;		 
	short		i_locks;	 
	char		i_bigexp;	 
	char		i_compress;	 
	short		i_cflag;         
	int		i_count;	 
	unsigned int	i_syncsn;	 
	struct movedfrag *i_movedfrag;	 
	tid_t		i_openevent;	 
	int		i_id;		 
	struct hinode	*i_hip;		 
	Simple_lock	i_nodelock;	 
	struct dquot	*i_dquot[2];  
	union {
		struct dinode	 _i_dinode;
		struct mountnode _i_mountnode;
		struct lognode	 _i_lognode;
	} i_node;
	int		i_cluster;	 
	offset_t	i_size;		 
	int		i_rcluster;	 
	int		i_diocnt;	 
	int		i_nondio;	 	
	int		i_gets;		 
	vmid_t		i_indsid;	 
	uint		i_indidx;	 
	struct acl	*i_aclp;	 
	Complex_lock	i_rwlock;	 
	Simple_lock	i_simplelock;	 
	void		*i_kdmvp;	 
	uint		i_change;	 
	struct inode	*i_logforw;	 
	struct inode	*i_logback;	 
	int		i_did;		 
};
#line 207
struct hinode
{
	struct	inode	*hi_forw;
	struct	inode 	*hi_back;
	int32long64_t	hi_timestamp;
	Simple_lock	hi_lock;
};
#line 219
struct icachelist {
        union
	{
		void	*_x1;
		int	_x2;
	}		ic_freecnt_un;   
        union
	{
		void	*_x1;
		int	_x2;
	}		ic_minfree_un;   
        struct inode    *ic_next;        
        struct inode    *ic_prev;        
	int		ic_gets;	 
	int		ic_activates;	 
	int		ic_inodes;	 
        Simple_lock     ic_lock;         
};
#line 241
extern int nhino;
extern struct hinode *hinode;
extern struct icachelist *cinode;
}
extern "C" {
}
extern "C" {
#line 37 "/usr/include/sys/seg.h"
struct shmid_ds;
#line 196
extern uint 		g_adspaceval;
#line 230
struct segstate {
	ushort	segflag;			 
#line 237
	ushort  num_segs;			 
#line 240
	union {
		uint             mfileno;	 
		uint             attr;           
		esid_t           nsegs;	         
#line 247
		__ptr32          shmptr;	 
#line 257
		vmhandle_t      srval;	         

	} u_ptrs;
};
#line 335
struct segnode {
	snidx_t	sfwd;		 
	snidx_t sbwd;		 
	esid_t	base;		 
	esid_t	last;		 
	short	nvalid;		 
	short	flags;		 
	struct segstate segst[16];   
};
#line 400
struct uadnode {
	esid_t		uad_base;	 
	int		uad_level;	 
#line 407
	adspace_t	uad_adsp;	

};
#line 480
struct vmh_is_big_enough {
	char v[sizeof(vmhandle_t) >= sizeof(unidx_t) ? 1 : -1];
};
#line 522
struct asalloc {
	void        *origin;	 
	vmnodeidx_t  freeind;	 
	vmnodeidx_t  nextind;	 
	vmnodeidx_t  maxind;	 
	vmnodeidx_t  hint;	 
	int	     size;	 

};
}
extern "C" {
#line 81 "/usr/include/sys/shm.h"
typedef unsigned long	shmatt_t;
#line 86
struct shmid_ds {
	struct ipc_perm	shm_perm;	 
	size_t		shm_segsz;	 
	pid_t		shm_lpid;	 
	pid_t		shm_cpid;	 
	shmatt_t	shm_nattch;	 

	shmatt_t	shm_cnattch;	 
#line 97
	time_t		shm_atime;	 
	time_t		shm_dtime;	 
	time_t		shm_ctime;	 

	__ulong32_t	shm_handle;	 
	int		shm_extshm;	 
	int64_t         shm_pagesize;    
	uint64_t        shm_lba;	 
	int64_t         shm_reserved0;
	int64_t         shm_reserved1;
#line 115
};
#line 124
extern int   shmget(key_t, size_t, int);
extern void *shmat(int, const void *, int);
extern int   shmdt(const void *);
extern int   shmctl(int, int, struct shmid_ds *);
#line 138
extern int disclaim(char *, unsigned int, unsigned int);
extern int disclaim64(void *, size_t, unsigned long);
}
extern "C" {
}
extern "C" {
#line 168
struct	shminfo {
	unsigned long long shmmax;	 
	int		shmmin,	 
			shmmni;	 
};
#line 176
}
}
#line 16 "/usr/vacpp/include/sys/shm.h"
  extern "C" int disclaim (char *, unsigned int, unsigned int);
#line 1 "/usr/vacpp/include/sys/sem.h"
struct sem;
extern "C" {
#line 45 "/usr/include/sys/sem.h"
extern "C" {
#line 76
struct sem {
	unsigned short	semval;		 

	unsigned short  flags;		 
#line 83
	pid_t		sempid;		 
	unsigned short	semncnt;	 
	unsigned short	semzcnt;	 

	tid_t		semnwait;	 
	tid_t		semzwait;	 
#line 93
};
#line 99
struct sembuf {
	unsigned short	sem_num;	 
	short		sem_op;		 
	short		sem_flg;	 
};
#line 112
struct semid_ds {
	struct ipc_perm	sem_perm;	 
#line 116
	__ptr32		sem_base;	 
#line 127
	unsigned short	sem_nsems;	 
	time_t		sem_otime;	 
	time_t		sem_ctime;	 
};
#line 139
extern int semget(key_t, int, int);
extern int semop(int, struct sembuf *, size_t);
extern int semctl(int, int, int, ...);
#line 167
struct sem_undo {
	struct sem_undo	*un_np;	 
	short		un_cnt;	 
	struct undo {
		short	un_aoe;	 
		ushort	un_num;	 
		int	un_id;	 
	}	un_ent[1];	 
};
#line 182
struct	seminfo	{
	int	semmni,		 
		semmsl,		 
		semopm,		 
		semume,		 
		semusz,		 
		semvmx,		 
		semaem;		 
};
#line 200
struct timespec;
extern int semtimedop(int, struct sembuf *, size_t, struct timespec *);
#line 207
}
}
#line 43 "LoggDis.h"
using namespace std;
#line 48
struct Log_Menu
{
    int Index;           
    int iNum;
    char ChName[100];   

    Log_Menu()
    {
        Index = 0;
        iNum = 0;
        memset(ChName,0,sizeof(ChName));
    }
};

class DisplayLogg
{
public:
    static void DisInit();
    static void Loggstartwin();
    static void LoggLoadGeneralInfo();
    static void LoggLoadEmptyMenu();
    static void LoggloadAll(vector<string> &m_vInfo);

    static void LoggProcessMain(int flag,char* sParam);
    static void LoggRebuildProblemProc();
    static void LoggRebuildProcess();
    static void LoggStartProblemProc();
    static void LoggInitProcessInfo(int flag,char *sParam);
    static void LoggTimeBreak_Process(int signo);
    static void LoggTimeBreak_ProblemProc(int signo);

private:
    static int INTERVAL;
    static int iLoggPageSize;
    static int Logg_ProblemProcSelectedRow;
    static int Logg_ProblemProcStartRow;
    static int Logg_Main2SelectedRow;
    static int Logg_Main2StartRow ;
    static int iDisParamCnt;
    static int NOW_USED;
    static Log_Menu* Logg_pMenuInfo;
    static Log_Menu* Logg_pMenuInfoAll;
    static vector<string> m_vConverInfo;

public:
    static vector<string> m_vAppInfo;
    static vector<string> m_vProInfo;
    static vector<string> m_vAlarmInfo;
    static vector<string> m_vParamInfo;
    static vector<string> m_vSystemInfo;
    static vector<string> m_vSysOperInfo;

    static vector<string> m_vLevFatal;
    static vector<string> m_vLevError;
    static vector<string> m_vLevWarn;
    static vector<string> m_vLevInfo;
    static vector<string> m_vLevDebug;     
#line 107
    static vector<string> m_vClaError;
    static vector<string> m_vClaWarn;      
    static vector<string> m_vClaInfo; 
#line 112
    static vector<string> m_vTypeBusi;
    static vector<string> m_vTypeParam;
    static vector<string> m_vTypeSystem ;
    static vector<string> m_vTypeStart;
    static vector<string> m_vTypeOracle;   
#line 119
	static vector<string> m_vCodeInfo;

};
#line 13 "/cbilling/app/petri/src/threelogapi/ThreeLogGroupDefine.h"
enum
{
	LOG_LEVEL_FATAL       =1,
	LOG_LEVEL_ERROR       =2,
	LOG_LEVEL_WARNING     =3,
	LOG_LEVEL_INFO        =4,
	LOG_LEVEL_DEBUG       =5
};
#line 24
enum
{
	LOG_CLASS_ERROR     =1,
	LOG_CLASS_WARNING   =2,
	LOG_CLASS_INFO      =3
};
#line 35
enum
{
    LOG_TYPE_BUSI        =1,
    LOG_TYPE_PARAM       =2,
    LOG_TYPE_SYSTEM      =3,
    LOG_TYPE_PROC        =4,
    LOG_TYPE_DATEDB      =5
};
#line 46
enum
{
    INACTIVE=1,                                  
    CURRENT,                                     
    ACTIVE                                       
};
#line 54
enum
{
    UNDOWN=1,                                    
    ALLDOWN,                                     
    NEEDDOWN,                                    
    FILEDOWN                                     
};

enum
{
		LOG_ACTION_INS    =1,
	  LOG_ACTION_UPD    =2,
	  LOG_ACTION_DEL    =3
};
#line 70
enum
{
    GROUPCREAT              =1,                  
    GROUPFREE               =2,                  
    GROUPFILEADD            =3,                  
    GROUPDELETE             =4,                  
    GROUPPRINTF             =5,                  
    GROUPQUIT               =6,                  
    GROUPSET                =7,                  
    GROUPBAK                =8,                  
    GROUPOUT                =9,                  
    FILETEST                =10,                 
    PIGEONHOLE              =11,                 
    GROUPHELP               =12,                 
    GROUPADD                =13,                 
    GROUPSTAT               =14,                 
    GROUPPARAM              =15,                 
    GROUPMODULE             =16,                 
    GROUPPROCESS            =17,                 
    GROUPINFOLV             =18,                 
    GROUPCLASS              =19,                 
    GROUPTYPE               =20,                 
    GROUPCODE               =21,                 
    GROUPRESET              =23,                 
    GROUPTEST               =99                  
};
#line 13 "/usr/vacpp/include/map"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 40
#pragma object_model(compat)
#line 45
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/xtree"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 40
#pragma object_model(compat)
#line 45
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/functional"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 40
#pragma object_model(compat)
#line 45
  #pragma namemangling(v7)
#line 72
namespace std {

template<class _A, class _R>
        struct unary_function {
        typedef _A argument_type;
        typedef _R result_type;
        };
#line 81
template<class _A1, class _A2, class _R>
        struct binary_function {
        typedef _A1 first_argument_type;
        typedef _A2 second_argument_type;
        typedef _R result_type;
        };
#line 89
template<class _Ty>
        struct plus : binary_function<_Ty, _Ty, _Ty> {
        _Ty operator()(const _Ty& _X, const _Ty& _Y) const
                {return (_X + _Y); }
        };
#line 96
template<class _Ty>
        struct minus : binary_function<_Ty, _Ty, _Ty> {
        _Ty operator()(const _Ty& _X, const _Ty& _Y) const
                {return (_X - _Y); }
        };
#line 103
template<class _Ty>
        struct multiplies : binary_function<_Ty, _Ty, _Ty> {
        _Ty operator()(const _Ty& _X, const _Ty& _Y) const
                {return (_X * _Y); }
        };
#line 110
template<class _Ty>
        struct divides : binary_function<_Ty, _Ty, _Ty> {
        _Ty operator()(const _Ty& _X, const _Ty& _Y) const
                {return (_X / _Y); }
        };
#line 117
template<class _Ty>
        struct modulus : binary_function<_Ty, _Ty, _Ty> {
        _Ty operator()(const _Ty& _X, const _Ty& _Y) const
                {return (_X % _Y); }
        };
#line 124
template<class _Ty>
        struct negate : unary_function<_Ty, _Ty> {
        _Ty operator()(const _Ty& _X) const
                {return (-_X); }
        };
#line 131
template<class _Ty>
        struct equal_to : binary_function<_Ty, _Ty, bool> {
        bool operator()(const _Ty& _X, const _Ty& _Y) const
                {return (_X == _Y); }
        };
#line 138
template<class _Ty>
        struct not_equal_to : binary_function<_Ty, _Ty, bool> {
        bool operator()(const _Ty& _X, const _Ty& _Y) const
                {return (_X != _Y); }
        };
#line 145
template<class _Ty>
        struct greater : binary_function<_Ty, _Ty, bool> {
        bool operator()(const _Ty& _X, const _Ty& _Y) const
                {return (_X > _Y); }
        };
#line 152
template<class _Ty>
        struct less : binary_function<_Ty, _Ty, bool> {
        bool operator()(const _Ty& _X, const _Ty& _Y) const
                {return (_X < _Y); }
        };
#line 159
template<class _Ty>
        struct greater_equal : binary_function<_Ty, _Ty, bool> {
        bool operator()(const _Ty& _X, const _Ty& _Y) const
                {return (_X >= _Y); }
        };
#line 166
template<class _Ty>
        struct less_equal : binary_function<_Ty, _Ty, bool> {
        bool operator()(const _Ty& _X, const _Ty& _Y) const
                {return (_X <= _Y); }
        };
#line 173
template<class _Ty>
        struct logical_and : binary_function<_Ty, _Ty, bool> {
        bool operator()(const _Ty& _X, const _Ty& _Y) const
                {return (_X && _Y); }
        };
#line 180
template<class _Ty>
        struct logical_or : binary_function<_Ty, _Ty, bool> {
        bool operator()(const _Ty& _X, const _Ty& _Y) const
                {return (_X || _Y); }
        };
#line 187
template<class _Ty>
        struct logical_not : unary_function<_Ty, bool> {
        bool operator()(const _Ty& _X) const
                {return (!_X); }
        };
#line 194
template<class _Ufn>
        class unary_negate
        : public unary_function<typename _Ufn::argument_type, bool> {
public:
        explicit unary_negate(const _Ufn& _X)
                : _Fn(_X) {}
        bool operator()(const typename _Ufn::argument_type& _X) const
                {return (!_Fn(_X)); }
protected:
        _Ufn _Fn;
        };
#line 207
template<class _Ufn> inline
        unary_negate<_Ufn> not1(const _Ufn& _X)
                {return (unary_negate<_Ufn>(_X)); }
#line 212
template<class _Bfn>
        class binary_negate
        : public binary_function<typename _Bfn::first_argument_type,
                typename _Bfn::second_argument_type, bool> {
public:
        explicit binary_negate(const _Bfn& _X)
                : _Fn(_X) {}
        bool operator()(const typename _Bfn::first_argument_type& _X,
                const typename _Bfn::second_argument_type& _Y) const
                {return (!_Fn(_X, _Y)); }
protected:
        _Bfn _Fn;
        };
#line 227
template<class _Bfn> inline
        binary_negate<_Bfn> not2(const _Bfn& _X)
                {return (binary_negate<_Bfn>(_X)); }

template<class _Bfn>
        class binder1st
        : public unary_function<typename _Bfn::second_argument_type,
                typename _Bfn::result_type> {
public:
        typedef unary_function<typename _Bfn::second_argument_type,
                typename _Bfn::result_type> _Base;
        typedef typename _Base::argument_type argument_type;
        typedef typename _Base::result_type result_type;
        binder1st(const _Bfn& _X,
                const typename _Bfn::first_argument_type& _Y)
                : op(_X), value(_Y) {}
        result_type operator()(const argument_type& _X) const
                {return (op(value, _X)); }
protected:
        _Bfn op;
        typename _Bfn::first_argument_type value;
        };
#line 251
template<class _Bfn, class _Ty> inline
        binder1st<_Bfn> bind1st(const _Bfn& _X, const _Ty& _Y)
                {typename _Bfn::first_argument_type _Arg(_Y);
                return (binder1st<_Bfn>(_X, _Arg)); }
#line 257
template<class _Bfn>
        class binder2nd
        : public unary_function<typename _Bfn::first_argument_type,
                typename _Bfn::result_type> {
public:
        typedef unary_function<typename _Bfn::first_argument_type,
                typename _Bfn::result_type> _Base;
        typedef typename _Base::argument_type argument_type;
        typedef typename _Base::result_type result_type;
        binder2nd(const _Bfn& _X,
                const typename _Bfn::second_argument_type& _Y)
                : op(_X), value(_Y) {}
        result_type operator()(const argument_type& _X) const
                {return (op(_X, value)); }
protected:
        _Bfn op;
        typename _Bfn::second_argument_type value;
        };
#line 277
template<class _Bfn, class _Ty> inline
        binder2nd<_Bfn> bind2nd(const _Bfn& _X, const _Ty& _Y)
                {typename _Bfn::second_argument_type _Arg(_Y);
                return (binder2nd<_Bfn>(_X, _Arg)); }

template<class _A, class _R>
        class pointer_to_unary_function
                : public unary_function<_A, _R> {
public:
        explicit pointer_to_unary_function(_R (*_X)(_A))
                : _Fn(_X) {}
        _R operator()(_A _X) const
                {return (_Fn(_X)); }
protected:
        _R (*_Fn)(_A);
        };
#line 295
template<class _A1, class _A2, class _R>
        class pointer_to_binary_function
                : public binary_function<_A1, _A2, _R> {
public:
        explicit pointer_to_binary_function(
                _R (*_X)(_A1, _A2))
                : _Fn(_X) {}
        _R operator()(_A1 _X, _A2 _Y) const
                {return (_Fn(_X, _Y)); }
protected:
        _R (*_Fn)(_A1, _A2);
        };
#line 309
template<class _A, class _R> inline
        pointer_to_unary_function<_A, _R>
                ptr_fun(_R (*_X)(_A))
                {return (pointer_to_unary_function<_A, _R>(_X)); }
template<class _A1, class _A2, class _R> inline
        pointer_to_binary_function<_A1, _A2, _R>
                ptr_fun(_R (*_X)(_A1, _A2))
                {return (pointer_to_binary_function<_A1, _A2, _R>(_X)); }

template<class _R, class _Ty>
        class mem_fun_t : public unary_function<_Ty *, _R> {
public:
        explicit mem_fun_t(_R (_Ty::*_Pm)())
                : _Ptr(_Pm) {}
        _R operator()(_Ty *_P) const
                {return ((_P->*_Ptr)()); }
private:
        _R (_Ty::*_Ptr)();
        };
#line 330
template<class _R, class _Ty, class _A>
        class mem_fun1_t : public binary_function<_Ty *, _A, _R> {
public:
        explicit mem_fun1_t(_R (_Ty::*_Pm)(_A))
                : _Ptr(_Pm) {}
        _R operator()(_Ty *_P, _A _Arg) const
                {return ((_P->*_Ptr)(_Arg)); }
private:
        _R (_Ty::*_Ptr)(_A);
        };
#line 342
template<class _R, class _Ty>
        class const_mem_fun_t
                : public unary_function<const _Ty *, _R> {
public:
        explicit const_mem_fun_t(_R (_Ty::*_Pm)() const)
                : _Ptr(_Pm) {}
        _R operator()(const _Ty *_P) const
                {return ((_P->*_Ptr)()); }
private:
        _R (_Ty::*_Ptr)() const;
        };
#line 355
template<class _R, class _Ty, class _A>
        class const_mem_fun1_t
                : public binary_function<const _Ty *, _A, _R> {
public:
        explicit const_mem_fun1_t(_R (_Ty::*_Pm)(_A) const)
                : _Ptr(_Pm) {}
        _R operator()(const _Ty *_P, _A _Arg) const
                {return ((_P->*_Ptr)(_Arg)); }
private:
        _R (_Ty::*_Ptr)(_A) const;
        };
#line 368
template<class _R, class _Ty> inline
        mem_fun_t<_R, _Ty> mem_fun(_R (_Ty::*_Pm)())
        {return (mem_fun_t<_R, _Ty>(_Pm)); }
template<class _R, class _Ty, class _A> inline
        mem_fun1_t<_R, _Ty, _A> mem_fun(_R (_Ty::*_Pm)(_A))
        {return (mem_fun1_t<_R, _Ty, _A>(_Pm)); }
template<class _R, class _Ty> inline
        const_mem_fun_t<_R, _Ty>
                mem_fun(_R (_Ty::*_Pm)() const)
        {return (const_mem_fun_t<_R, _Ty>(_Pm)); }
template<class _R, class _Ty, class _A> inline
        const_mem_fun1_t<_R, _Ty, _A>
                mem_fun(_R (_Ty::*_Pm)(_A) const)
        {return (const_mem_fun1_t<_R, _Ty, _A>(_Pm)); }
#line 384
template<class _R, class _Ty>
        class mem_fun_ref_t : public unary_function<_Ty, _R> {
public:
        explicit mem_fun_ref_t(_R (_Ty::*_Pm)())
                : _Ptr(_Pm) {}
        _R operator()(_Ty& _X) const
                {return ((_X.*_Ptr)()); }
private:
        _R (_Ty::*_Ptr)();
        };
#line 396
template<class _R, class _Ty, class _A>
        class mem_fun1_ref_t : public binary_function<_Ty, _A, _R> {
public:
        explicit mem_fun1_ref_t(_R (_Ty::*_Pm)(_A))
                : _Ptr(_Pm) {}
        _R operator()(_Ty& _X, _A _Arg) const
                {return ((_X.*_Ptr)(_Arg)); }
private:
        _R (_Ty::*_Ptr)(_A);
        };
#line 408
template<class _R, class _Ty>
        class const_mem_fun_ref_t
                : public unary_function<_Ty, _R> {
public:
        explicit const_mem_fun_ref_t(_R (_Ty::*_Pm)() const)
                : _Ptr(_Pm) {}
        _R operator()(const _Ty& _X) const
                {return ((_X.*_Ptr)()); }
private:
        _R (_Ty::*_Ptr)() const;
        };
#line 421
template<class _R, class _Ty, class _A>
        class const_mem_fun1_ref_t
                : public binary_function<_Ty, _A, _R> {
public:
        explicit const_mem_fun1_ref_t(_R (_Ty::*_Pm)(_A) const)
                : _Ptr(_Pm) {}
        _R operator()(const _Ty& _X, _A _Arg) const
                {return ((_X.*_Ptr)(_Arg)); }
private:
        _R (_Ty::*_Ptr)(_A) const;
        };
#line 434
template<class _R, class _Ty> inline
        mem_fun_ref_t<_R, _Ty> mem_fun_ref(_R (_Ty::*_Pm)())
        {return (mem_fun_ref_t<_R, _Ty>(_Pm)); }
template<class _R, class _Ty, class _A> inline
        mem_fun1_ref_t<_R, _Ty, _A>
                mem_fun_ref(_R (_Ty::*_Pm)(_A))
        {return (mem_fun1_ref_t<_R, _Ty, _A>(_Pm)); }
template<class _R, class _Ty> inline
        const_mem_fun_ref_t<_R, _Ty>
                mem_fun_ref(_R (_Ty::*_Pm)() const)
        {return (const_mem_fun_ref_t<_R, _Ty>(_Pm)); }
template<class _R, class _Ty, class _A> inline
        const_mem_fun1_ref_t<_R, _Ty, _A>
                mem_fun_ref(_R (_Ty::*_Pm)(_A) const)
        {return (const_mem_fun1_ref_t<_R, _Ty, _A>(_Pm)); }
#line 651
};

#pragma namemangling()

#pragma object_model(pop)
#line 662
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 71 "/usr/vacpp/include/xtree"
namespace std {
#line 74
template<class _Tr>
        class _Tree_nod : public _Tr {
protected:
        typedef typename _Tr::allocator_type allocator_type;
        typedef typename _Tr::key_compare key_compare;
        typedef typename _Tr::value_type value_type;
        struct _Node;
        typedef typename allocator_type::template
                rebind<_Node>::other::pointer _Genptr;
        friend struct _Node;
        struct _Node {
                _Genptr _Left, _Parent, _Right;
                value_type _Value;
                char _Color, _Isnil;
                };
        _Tree_nod(const key_compare& _Parg,
                allocator_type _Al)
                : _Tr(_Parg), _Alnod(_Al) {}
        typename allocator_type::template
                rebind<_Node>::other
                _Alnod;
        };
#line 98
template<class _Tr>
        class _Tree_ptr : public _Tree_nod<_Tr> {
protected:
        typedef typename _Tree_nod<_Tr>::_Node _Node;
        typedef typename _Tr::allocator_type allocator_type;
        typedef typename _Tr::key_compare key_compare;
        typedef typename allocator_type::template
                rebind<_Node>::other::pointer _Nodeptr;
        _Tree_ptr(const key_compare& _Parg,
                allocator_type _Al)
                : _Tree_nod<_Tr>(_Parg, _Al), _Alptr(_Al) {}
        typename allocator_type::template
                rebind<_Nodeptr>::other
                _Alptr;
        };
#line 115
template<class _Tr>
        class _Tree_val : public _Tree_ptr<_Tr> {
protected:
        typedef typename _Tr::allocator_type allocator_type;
        typedef typename _Tr::key_compare key_compare;
        _Tree_val(const key_compare& _Parg,
                allocator_type _Al)
                : _Tree_ptr<_Tr>(_Parg, _Al), _Alval(_Al) {}
        allocator_type _Alval;
        };
#line 127
template<class _Tr>
        class _Tree
                : public _Tree_val<_Tr> {
public:
        typedef _Tree<_Tr> _Myt;
        typedef _Tree_val<_Tr> _Mybase;
        typedef typename _Tr::_Kfn _Kfn;
        typedef typename _Tr::key_type key_type;
        typedef typename _Tr::key_compare key_compare;
        typedef typename _Tr::value_compare value_compare;
        typedef typename _Tr::value_type value_type;
        typedef typename _Tr::allocator_type allocator_type;
protected:
        typedef typename _Tree_nod<_Tr>::_Genptr _Genptr;
        typedef typename _Tree_nod<_Tr>::_Node _Node;
        enum _Redbl {_Red, _Black};
        typedef typename allocator_type::template rebind<_Node>::other::pointer _Nodeptr;
        typedef typename allocator_type::template rebind<_Nodeptr>::other::reference _Nodepref;
        typedef typename allocator_type::template rebind<key_type>::other::const_reference _Keyref;
        typedef typename allocator_type::template rebind<char>::other::reference _Charref;
        typedef typename allocator_type::template rebind<value_type>::other::reference _Vref;

        static _Charref _Color(_Nodeptr _P)
                {return ((_Charref)(*_P)._Color); }
        static _Charref _Isnil(_Nodeptr _P)
                {return ((_Charref)(*_P)._Isnil); }
        static _Keyref _Key(_Nodeptr _P)
                {return (_Kfn()(_Value(_P))); }
        static _Nodepref _Left(_Nodeptr _P)
                {return ((_Nodepref)(*_P)._Left); }
        static _Nodepref _Parent(_Nodeptr _P)
                {return ((_Nodepref)(*_P)._Parent); }
        static _Nodepref _Right(_Nodeptr _P)
                {return ((_Nodepref)(*_P)._Right); }
        static _Vref _Value(_Nodeptr _P)
                {return ((_Vref)(*_P)._Value); }
public:
        typedef typename allocator_type::size_type size_type;
        typedef typename allocator_type::difference_type _Dift;
        typedef _Dift difference_type;
        typedef typename allocator_type::template rebind<value_type>::other::pointer _Tptr;
        typedef typename allocator_type::template rebind<value_type>::other::const_pointer _Ctptr;
        typedef typename allocator_type::template rebind<value_type>::other::reference _Reft;
        typedef _Tptr pointer;
        typedef _Ctptr const_pointer;
        typedef _Reft reference;
        typedef typename allocator_type::template rebind<value_type>::other::const_reference
                const_reference;

        typedef _Tree_ptr<_Tr> _My_Tree_ptr;
        typedef _Tree_nod<_Tr> _My_Tree_nod;
#line 180
        class iterator;
        friend class iterator;
        class const_iterator;
        class iterator : public _Bidit<value_type, _Dift,
                _Tptr, _Reft> {
        public:
                typedef _Bidit<value_type, _Dift,
                        _Tptr, _Reft> _Mybase;
                typedef typename _Mybase::iterator_category
                        iterator_category;

                typedef typename _Mybase::difference_type
                        difference_type;
                typedef typename _Mybase::pointer pointer;
                typedef typename _Mybase::reference reference;
                iterator()
                        : _Ptr(0) {}
                iterator(_Nodeptr _P)
                        : _Ptr(_P) {}
                reference operator*() const
                        {return (_Value(_Ptr)); }
                _Tptr operator->() const
                        {return (&**this); }
                iterator& operator++()
                        {_Inc();
                        return (*this); }
                iterator operator++(int)
                        {iterator _Tmp = *this;
                        ++*this;
                        return (_Tmp); }
                iterator& operator--()
                        {_Dec();
                        return (*this); }
                iterator operator--(int)
                        {iterator _Tmp = *this;
                        --*this;
                        return (_Tmp); }
                bool operator==(const iterator& _X) const
                        {return (_Ptr == _X._Ptr); }
                bool operator==(const const_iterator& _X) const
                        {return (_Ptr == _X._Ptr); }
                bool operator!=(const iterator& _X) const
                        {return (!(*this == _X)); }
                bool operator!=(const const_iterator& _X) const
                        {return (!(*this == _X)); }
                void _Dec();
                void _Inc();
                _Nodeptr _Mynode() const
                        {return (_Ptr); }
        protected:
                _Nodeptr _Ptr;
                };
#line 234
        class const_iterator;
        friend class const_iterator;
        class const_iterator : public _Bidit<value_type, _Dift,
                _Ctptr, const_reference> {
        public:
                typedef _Bidit<value_type, _Dift,
                        _Ctptr, const_reference> _Mybase;
                typedef typename _Mybase::iterator_category
                        iterator_category;

                typedef typename _Mybase::difference_type
                        difference_type;
                typedef typename _Mybase::pointer pointer;
                typedef typename _Mybase::reference reference;
                friend class iterator;
                const_iterator()
                        : _Ptr(0) {}
                const_iterator(_Nodeptr _P)
                        : _Ptr(_P) {}
                const_iterator(const iterator& _X)
                        : _Ptr(_X._Mynode()) {}
                const_reference operator*() const
                        {return (_Value(_Ptr)); }
                _Ctptr operator->() const
                        {return (&**this); }
                const_iterator& operator++()
                        {_Inc();
                        return (*this); }
                const_iterator operator++(int)
                        {const_iterator _Tmp = *this;
                        ++*this;
                        return (_Tmp); }
                const_iterator& operator--()
                        {_Dec();
                        return (*this); }
                const_iterator operator--(int)
                        {const_iterator _Tmp = *this;
                        --*this;
                        return (_Tmp); }
                bool operator==(const const_iterator& _X) const
                        {return (_Ptr == _X._Ptr); }
                bool operator!=(const const_iterator& _X) const
                        {return (!(*this == _X)); }
                void _Dec();
                void _Inc();
                _Nodeptr _Mynode() const
                        {return (_Ptr); }
        protected:
                _Nodeptr _Ptr;
                };

        typedef std::reverse_iterator<iterator>
                reverse_iterator;
        typedef std::reverse_iterator<const_iterator>
                const_reverse_iterator;
        typedef pair<iterator, bool> _Pairib;
        typedef pair<iterator, iterator> _Pairii;
        typedef pair<const_iterator, const_iterator> _Paircc;

        explicit _Tree(const key_compare& _Parg,
                const allocator_type& _Al)
                : _Mybase(_Parg, _Al)
                {_Init(); }
        _Tree(const value_type *_F, const value_type *_L,
                const key_compare& _Parg, const allocator_type& _Al)
                : _Mybase(_Parg, _Al)
                {_Init();
                insert(_F, _L); }
        _Tree(const _Myt& _X)
                : _Mybase(_X.key_comp(), _X.get_allocator())
                {_Init();
                _Copy(_X); }
        ~_Tree()
                {erase(begin(), end());
                _Freenode(_Head);
                _Head = 0, _Size = 0; }
        _Myt& operator=(const _Myt& _X)
                {if (this != &_X)
                        {erase(begin(), end());
                        _Tr::comp = _X.comp;
                        _Copy(_X); }
                return (*this); }
        iterator begin()
                {return (iterator(_Lmost())); }
        const_iterator begin() const
                {return (const_iterator(_Lmost())); }
        iterator end()
                {return (iterator(_Head)); }
        const_iterator end() const
                {return (const_iterator(_Head)); }
        reverse_iterator rbegin()
                {return (reverse_iterator(end())); }
        const_reverse_iterator rbegin() const
                {return (const_reverse_iterator(end())); }
        reverse_iterator rend()
                {return (reverse_iterator(begin())); }
        const_reverse_iterator rend() const
                {return (const_reverse_iterator(begin())); }
        size_type size() const
                {return (_Size); }
        size_type max_size() const
                {return (_Mybase::_Alval.max_size()); }
        bool empty() const
                {return (size() == 0); }
        allocator_type get_allocator() const
                {return (_Mybase::_Alval); }
        key_compare key_comp() const
                {return (_Tr::comp); }
        value_compare value_comp() const
                {return (value_compare(key_comp())); }
        _Pairib insert(const value_type& _V);
        iterator insert(iterator _P, const value_type& _V);
        template<class _It>
                void insert(_It _F, _It _L)
                {for (; _F != _L; ++_F)
                        insert(*_F); }
        iterator erase(iterator _P);
        iterator erase(iterator _F, iterator _L);
        size_type erase(const key_type& _X)
                {_Pairii _P = equal_range(_X);
                size_type _N = 0;
                _Distance(_P.first, _P.second, _N);
                erase(_P.first, _P.second);
                return (_N); }
        void erase(const key_type *_F, const key_type *_L)
                {while (_F != _L)
                        erase(*_F++); }
        void clear()
                {erase(begin(), end()); }
        iterator find(const key_type& _Kv)
                {iterator _P = lower_bound(_Kv);
                return (_P == end()
                        || _Tr::comp(_Kv, _Key(_P._Mynode()))
                                ? end() : _P); }
        const_iterator find(const key_type& _Kv) const
                {const_iterator _P = lower_bound(_Kv);
                return (_P == end()
                        || _Tr::comp(_Kv, _Key(_P._Mynode()))
                                ? end() : _P); }
        size_type count(const key_type& _Kv) const
                {_Paircc _Ans = equal_range(_Kv);
                size_type _N = 0;
                _Distance(_Ans.first, _Ans.second, _N);
                return (_N); }
        iterator lower_bound(const key_type& _Kv)
                {return (iterator(_Lbound(_Kv))); }
        const_iterator lower_bound(const key_type& _Kv) const
                {return (const_iterator(_Lbound(_Kv))); }
        iterator upper_bound(const key_type& _Kv)
                {return (iterator(_Ubound(_Kv))); }
        const_iterator upper_bound(const key_type& _Kv) const
                {return (const_iterator(_Ubound(_Kv))); }
        _Pairii equal_range(const key_type& _Kv)
                {return (_Pairii(lower_bound(_Kv), upper_bound(_Kv))); }
        _Paircc equal_range(const key_type& _Kv) const
                {return (_Paircc(lower_bound(_Kv), upper_bound(_Kv))); }
        void swap(_Myt& _X);
protected:
        void _Copy(const _Myt& _X);
        _Nodeptr _Copy(_Nodeptr _X, _Nodeptr _P);
        void _Erase(_Nodeptr _X)
                {for (_Nodeptr _Y = _X; !_Isnil(_Y); _X = _Y)
                        {_Erase(_Right(_Y));
                        _Y = _Left(_Y);
                        _Destval(&_Value(_X));
                        _Freenode(_X); }}
        void _Init()
                {_Head = _Buynode(0, _Black);
                _Isnil(_Head) = true;
                _Root() = _Head;
                _Lmost() = _Head, _Rmost() = _Head;
                _Size = 0; }
        iterator _Insert(bool _Addleft, _Nodeptr _Y,
                const value_type& _V);
        _Nodeptr _Lbound(const key_type& _Kv) const;
        _Nodeptr& _Lmost()
                {return (_Left(_Head)); }
        _Nodeptr& _Lmost() const
                {return (_Left(_Head)); }
        void _Lrotate(_Nodeptr _X);
        static _Nodeptr _Max(_Nodeptr _P)
                {while (!_Isnil(_Right(_P)))
                        _P = _Right(_P);
                return (_P); }
        static _Nodeptr _Min(_Nodeptr _P)
                {while (!_Isnil(_Left(_P)))
                        _P = _Left(_P);
                return (_P); }
        _Nodeptr& _Rmost()
                {return (_Right(_Head)); }
        _Nodeptr& _Rmost() const
                {return (_Right(_Head)); }
        _Nodeptr& _Root()
                {return (_Parent(_Head)); }
        _Nodeptr& _Root() const
                {return (_Parent(_Head)); }
        void _Rrotate(_Nodeptr _X);
        _Nodeptr _Ubound(const key_type& _Kv) const;
        _Nodeptr _Buynode(_Nodeptr _Parg, char _Carg);
        void _Consval(_Tptr _P, const value_type& _V)
                {_Mybase::_Alval.construct(_P, _V); }
        void _Destval(_Tptr _P)
                {_Mybase::_Alval.destroy(_P); }
        void _Freenode(_Nodeptr _S)
                {_My_Tree_ptr::_Alptr.destroy(&_Parent(_S));
                _My_Tree_ptr::_Alptr.destroy(&_Right(_S));
                _My_Tree_ptr::_Alptr.destroy(&_Left(_S));
                _My_Tree_nod::_Alnod.deallocate(_S, 1); }
        _Nodeptr _Head;
        size_type _Size;
        };
#line 447
template<class _Tr> inline
        void swap(_Tree<_Tr>& _X, _Tree<_Tr>& _Y)
        {_X.swap(_Y); }

template<class _Tr> inline
        bool operator==(const _Tree<_Tr>& _X, const _Tree<_Tr>& _Y)
        {return (_X.size() == _Y.size()
                && equal(_X.begin(), _X.end(), _Y.begin())); }
template<class _Tr> inline
        bool operator!=(const _Tree<_Tr>& _X, const _Tree<_Tr>& _Y)
        {return (!(_X == _Y)); }
template<class _Tr> inline
        bool operator<(const _Tree<_Tr>& _X, const _Tree<_Tr>& _Y)
        {return (lexicographical_compare(_X.begin(), _X.end(),
                _Y.begin(), _Y.end())); }
template<class _Tr> inline
        bool operator>(const _Tree<_Tr>& _X, const _Tree<_Tr>& _Y)
        {return (_Y < _X); }
template<class _Tr> inline
        bool operator<=(const _Tree<_Tr>& _X, const _Tree<_Tr>& _Y)
        {return (!(_Y < _X)); }
template<class _Tr> inline
        bool operator>=(const _Tree<_Tr>& _X, const _Tree<_Tr>& _Y)
        {return (!(_X < _Y)); }
};

#pragma implementation("xtree.t")
#line 31 "/usr/vacpp/include/xtree.t"
namespace std {
template<class _Tr>
inline
void _Tree<_Tr>::iterator::_Dec()
        {if (_Isnil(_Ptr))
                _Ptr = _Right(_Ptr);
        else if (!_Isnil(_Left(_Ptr)))
                _Ptr = _Max(_Left(_Ptr));
        else
                {_Nodeptr _P;
                while (!_Isnil(_P = _Parent(_Ptr))
                        && _Ptr == _Left(_P))
                        _Ptr = _P;
                if (!_Isnil(_P))
                        _Ptr = _P; }}

template<class _Tr>
inline
void _Tree<_Tr>::iterator::_Inc()
        {if (_Isnil(_Ptr))
                ;
        else if (!_Isnil(_Right(_Ptr)))
                _Ptr = _Min(_Right(_Ptr));
        else
                {_Nodeptr _P;
                while (!_Isnil(_P = _Parent(_Ptr))
                        && _Ptr == _Right(_P))
                        _Ptr = _P;
                _Ptr = _P; }}

template<class _Tr>
inline
void _Tree<_Tr>::const_iterator::_Dec()
        {if (_Isnil(_Ptr))
                _Ptr = _Right(_Ptr);
        else if (!_Isnil(_Left(_Ptr)))
                _Ptr = _Max(_Left(_Ptr));
        else
                {_Nodeptr _P;
                while (!_Isnil(_P = _Parent(_Ptr))
                        && _Ptr == _Left(_P))
                        _Ptr = _P;
                if (!_Isnil(_P))
                        _Ptr = _P; }}

template<class _Tr>
inline
void _Tree<_Tr>::const_iterator::_Inc()
        {if (_Isnil(_Ptr))
                ;
        else if (!_Isnil(_Right(_Ptr)))
                _Ptr = _Min(_Right(_Ptr));
        else
                {_Nodeptr _P;
                while (!_Isnil(_P = _Parent(_Ptr))
                        && _Ptr == _Right(_P))
                        _Ptr = _P;
                _Ptr = _P; }}
#line 91
template<class _Tr>
inline
typename _Tree<_Tr>::_Pairib _Tree<_Tr>::insert(const value_type& _V)
        {_Nodeptr _X = _Root();
        _Nodeptr _Y = _Head;
        bool _Addleft = true;
        while (!_Isnil(_X))
                {_Y = _X;
                _Addleft = _Tr::comp(_Kfn()(_V), _Key(_X));
                _X = _Addleft ? _Left(_X) : _Right(_X); }
        if (_Tr::_Multi)
                return (_Pairib(_Insert(_Addleft, _Y, _V), true));
        else
                {iterator _P = iterator(_Y);
                if (!_Addleft)
                        ;
                else if (_P == begin())
                        return (_Pairib(_Insert(true, _Y, _V), true));
                else
                        --_P;
                if (_Tr::comp(_Key(_P._Mynode()), _Kfn()(_V)))
                        return (_Pairib(_Insert(_Addleft, _Y, _V), true));
                else
                        return (_Pairib(_P, false)); }}

template<class _Tr>
inline
typename _Tree<_Tr>::iterator _Tree<_Tr>::insert(iterator _P,
                const value_type& _V)
        {if (size() == 0)
                return (_Insert(true, _Head, _V));
        else if (_P == begin())
                {if (_Tr::comp(_Kfn()(_V), _Key(_P._Mynode())))
                        return (_Insert(true, _P._Mynode(), _V)); }
        else if (_P == end())
                {if (_Tr::comp(_Key(_Rmost()), _Kfn()(_V)))
                        return (_Insert(false, _Rmost(), _V)); }
        else
                {iterator _Pb = _P;
                if (_Tr::comp(_Key((--_Pb)._Mynode()), _Kfn()(_V))
                        && _Tr::comp(_Kfn()(_V), _Key(_P._Mynode())))
                        if (_Isnil(_Right(_Pb._Mynode())))
                                return (_Insert(false, _Pb._Mynode(), _V));
                        else
                                return (_Insert(true, _P._Mynode(), _V)); }
        return (insert(_V).first); }

template<class _Tr>
inline
typename _Tree<_Tr>::iterator _Tree<_Tr>::erase(iterator _P)
        {if (_Isnil(_P._Mynode()))
                throw out_of_range("");
        _Nodeptr _X, _Xpar;
        _Nodeptr _Y = (_P++)._Mynode();
        _Nodeptr _Z = _Y;
        if (_Isnil(_Left(_Y)))
                _X = _Right(_Y);
        else if (_Isnil(_Right(_Y)))
                _X = _Left(_Y);
        else
                _Y = _Min(_Right(_Y)), _X = _Right(_Y);
        if (_Y == _Z)
                {_Xpar = _Parent(_Z);
                if (!_Isnil(_X))
                        _Parent(_X) = _Xpar;
                if (_Root() == _Z)
                        _Root() = _X;
                else if (_Left(_Xpar) == _Z)
                        _Left(_Xpar) = _X;
                else
                        _Right(_Xpar) = _X;
                if (_Lmost() != _Z)
                        ;
                else if (_Isnil(_Right(_Z)))
                        _Lmost() = _Xpar;
                else
                        _Lmost() = _Min(_X);
                if (_Rmost() != _Z)
                        ;
                else if (_Isnil(_Left(_Z)))
                        _Rmost() = _Xpar;
                else
                        _Rmost() = _Max(_X); }
        else
                {_Parent(_Left(_Z)) = _Y;
                _Left(_Y) = _Left(_Z);
                if (_Y == _Right(_Z))
                        _Xpar = _Y;
                else
                        {_Xpar = _Parent(_Y);
                        if (!_Isnil(_X))
                                _Parent(_X) = _Xpar;
                        _Left(_Xpar) = _X;
                        _Right(_Y) = _Right(_Z);
                        _Parent(_Right(_Z)) = _Y; }
                if (_Root() == _Z)
                        _Root() = _Y;
                else if (_Left(_Parent(_Z)) == _Z)
                        _Left(_Parent(_Z)) = _Y;
                else
                        _Right(_Parent(_Z)) = _Y;
                _Parent(_Y) = _Parent(_Z);
                std::swap(_Color(_Y), _Color(_Z)); }
        if (_Color(_Z) == _Black)
                {for (; _X != _Root() && _Color(_X) == _Black;
                        _Xpar = _Parent(_X))
                        if (_X == _Left(_Xpar))
                                {_Nodeptr _W = _Right(_Xpar);
                                if (_Color(_W) == _Red)
                                        {_Color(_W) = _Black;
                                        _Color(_Xpar) = _Red;
                                        _Lrotate(_Xpar);
                                        _W = _Right(_Xpar); }
                                if (_Isnil(_W))
                                        _X = _Xpar;      
                                else if (_Color(_Left(_W)) == _Black
                                        && _Color(_Right(_W)) == _Black)
                                        {_Color(_W) = _Red;
                                        _X = _Xpar; }
                                else
                                        {if (_Color(_Right(_W)) == _Black)
                                                {_Color(_Left(_W)) = _Black;
                                                _Color(_W) = _Red;
                                                _Rrotate(_W);
                                                _W = _Right(_Xpar); }
                                        _Color(_W) = _Color(_Xpar);
                                        _Color(_Xpar) = _Black;
                                        _Color(_Right(_W)) = _Black;
                                        _Lrotate(_Xpar);
                                        break; }}
                        else
                                {_Nodeptr _W = _Left(_Xpar);
                                if (_Color(_W) == _Red)
                                        {_Color(_W) = _Black;
                                        _Color(_Xpar) = _Red;
                                        _Rrotate(_Xpar);
                                        _W = _Left(_Xpar); }
                                if (_Isnil(_W))
                                        _X = _Xpar;      
                                else if (_Color(_Right(_W)) == _Black
                                        && _Color(_Left(_W)) == _Black)
                                        {_Color(_W) = _Red;
                                        _X = _Xpar; }
                                else
                                        {if (_Color(_Left(_W)) == _Black)
                                                {_Color(_Right(_W)) = _Black;
                                                _Color(_W) = _Red;
                                                _Lrotate(_W);
                                                _W = _Left(_Xpar); }
                                        _Color(_W) = _Color(_Xpar);
                                        _Color(_Xpar) = _Black;
                                        _Color(_Left(_W)) = _Black;
                                        _Rrotate(_Xpar);
                                        break; }}
                _Color(_X) = _Black; }
        _Destval(&_Value(_Z));
        _Freenode(_Z);
        if (0 < _Size)
                --_Size;
        return (_P); }

template<class _Tr>
inline
typename _Tree<_Tr>::iterator _Tree<_Tr>::erase(iterator _F, iterator _L)
        {if (size() == 0 || _F != begin() || _L != end())
                {while (_F != _L)
                        erase(_F++);
                return (_F); }
        else
                {_Erase(_Root());
                _Root() = _Head, _Size = 0;
                _Lmost() = _Head, _Rmost() = _Head;
                return (begin()); }}
#line 266
template<class _Tr>
inline
void _Tree<_Tr>::swap(_Myt& _X)
        {if (get_allocator() == _X.get_allocator())
                {std::swap(_Tr::comp, _X.comp);
                std::swap(_Head, _X._Head);
                std::swap(_Size, _X._Size); }
        else
                {_Myt _Ts = *this; *this = _X, _X = _Ts; }}

template<class _Tr>
inline
void _Tree<_Tr>::_Copy(const _Myt& _X)
        {_Root() = _Copy(_X._Root(), _Head);
        _Size = _X.size();
        if (!_Isnil(_Root()))
                {_Lmost() = _Min(_Root());
                _Rmost() = _Max(_Root()); }
        else
                _Lmost() = _Head, _Rmost() = _Head; }

template<class _Tr>
inline
typename _Tree<_Tr>::_Nodeptr _Tree<_Tr>::_Copy(_Nodeptr _X, _Nodeptr _P)
        {_Nodeptr _R = _Head;
        if (!_Isnil(_X))
                {_Nodeptr _Y = _Buynode(_P, _Color(_X));
                try {
                _Consval(&_Value(_Y), _Value(_X));
                } catch (...) {
                _Freenode(_Y);
                _Erase(_R);
                throw;
                }
                _Left(_Y) = _Head, _Right(_Y) = _Head;
                if (_Isnil(_R))
                        _R = _Y;
                try {
                _Left(_Y) = _Copy(_Left(_X), _Y);
                _Right(_Y) = _Copy(_Right(_X), _Y);
                } catch (...) {
                _Erase(_R);
                throw;
                } }
        return (_R); }

template<class _Tr>
inline
typename _Tree<_Tr>::iterator _Tree<_Tr>::_Insert(bool _Addleft,
                _Nodeptr _Y, const value_type& _V)
        {if (max_size() - 1 <= _Size)
                throw length_error("");
        _Nodeptr _Z = _Buynode(_Y, _Red);
        _Left(_Z) = _Head, _Right(_Z) = _Head;
        try {
        _Consval(&_Value(_Z), _V);
        } catch (...) {
        _Freenode(_Z);
        throw;
        }
        ++_Size;
        if (_Y == _Head)
                {_Root() = _Z;
                _Lmost() = _Z, _Rmost() = _Z; }
        else if (_Addleft)
                {_Left(_Y) = _Z;
                if (_Y == _Lmost())
                        _Lmost() = _Z; }
        else
                {_Right(_Y) = _Z;
                if (_Y == _Rmost())
                        _Rmost() = _Z; }
        for (_Nodeptr _X = _Z; _Color(_Parent(_X)) == _Red; )
                if (_Parent(_X) == _Left(_Parent(_Parent(_X))))
                        {_Y = _Right(_Parent(_Parent(_X)));
                        if (_Color(_Y) == _Red)
                                {_Color(_Parent(_X)) = _Black;
                                _Color(_Y) = _Black;
                                _Color(_Parent(_Parent(_X))) = _Red;
                                _X = _Parent(_Parent(_X)); }
                        else
                                {if (_X == _Right(_Parent(_X)))
                                        {_X = _Parent(_X);
                                        _Lrotate(_X); }
                                _Color(_Parent(_X)) = _Black;
                                _Color(_Parent(_Parent(_X))) = _Red;
                                _Rrotate(_Parent(_Parent(_X))); }}
                else
                        {_Y = _Left(_Parent(_Parent(_X)));
                        if (_Color(_Y) == _Red)
                                {_Color(_Parent(_X)) = _Black;
                                _Color(_Y) = _Black;
                                _Color(_Parent(_Parent(_X))) = _Red;
                                _X = _Parent(_Parent(_X)); }
                        else
                                {if (_X == _Left(_Parent(_X)))
                                        {_X = _Parent(_X);
                                        _Rrotate(_X); }
                                _Color(_Parent(_X)) = _Black;
                                _Color(_Parent(_Parent(_X))) = _Red;
                                _Lrotate(_Parent(_Parent(_X))); }}
        _Color(_Root()) = _Black;
        return (iterator(_Z)); }

template<class _Tr>
inline
typename _Tree<_Tr>::_Nodeptr _Tree<_Tr>::_Lbound(const key_type& _Kv) const
        {_Nodeptr _X = _Root();
        _Nodeptr _Y = _Head;
        while (!_Isnil(_X))
                if (_Tr::comp(_Key(_X), _Kv))
                        _X = _Right(_X);
                else
                        _Y = _X, _X = _Left(_X);
        return (_Y); }

template<class _Tr>
inline
void _Tree<_Tr>::_Lrotate(_Nodeptr _X)
        {_Nodeptr _Y = _Right(_X);
        _Right(_X) = _Left(_Y);
        if (!_Isnil(_Left(_Y)))
                _Parent(_Left(_Y)) = _X;
        _Parent(_Y) = _Parent(_X);
        if (_X == _Root())
                _Root() = _Y;
        else if (_X == _Left(_Parent(_X)))
                _Left(_Parent(_X)) = _Y;
        else
                _Right(_Parent(_X)) = _Y;
        _Left(_Y) = _X;
        _Parent(_X) = _Y; }

template<class _Tr>
inline
void _Tree<_Tr>::_Rrotate(_Nodeptr _X)
        {_Nodeptr _Y = _Left(_X);
        _Left(_X) = _Right(_Y);
        if (!_Isnil(_Right(_Y)))
                _Parent(_Right(_Y)) = _X;
        _Parent(_Y) = _Parent(_X);
        if (_X == _Root())
                _Root() = _Y;
        else if (_X == _Right(_Parent(_X)))
                _Right(_Parent(_X)) = _Y;
        else
                _Left(_Parent(_X)) = _Y;
        _Right(_Y) = _X;
        _Parent(_X) = _Y; }

template<class _Tr>
inline
typename _Tree<_Tr>::_Nodeptr _Tree<_Tr>::_Ubound(const key_type& _Kv) const
        {_Nodeptr _X = _Root();
        _Nodeptr _Y = _Head;
        while (!_Isnil(_X))
                if (_Tr::comp(_Kv, _Key(_X)))
                        _Y = _X, _X = _Left(_X);
                else
                        _X = _Right(_X);
        return (_Y); }

template<class _Tr>
inline
typename _Tree<_Tr>::_Nodeptr _Tree<_Tr>::_Buynode(_Nodeptr _Parg, char _Carg)
        {_Nodeptr _S = _My_Tree_nod::_Alnod.allocate(1, (void *)0);
        _My_Tree_ptr::_Alptr.construct(&_Left(_S), 0);
        _My_Tree_ptr::_Alptr.construct(&_Right(_S), 0);
        _My_Tree_ptr::_Alptr.construct(&_Parent(_S), _Parg);
        _Color(_S) = _Carg;
        _Isnil(_S) = false;
        return (_S); }

};
#line 479 "/usr/vacpp/include/xtree"
#pragma namemangling()

#pragma object_model(pop)
#line 488
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 69 "/usr/vacpp/include/map"
namespace std {

template<class _K, class _Ty, class _Pr, class _Ax, bool _Mfl>
        class _Tmap_traits {
public:
        typedef _K key_type;
        typedef pair<const _K, _Ty> value_type;
        typedef _Pr key_compare;
        typedef typename _Ax::template rebind<value_type>::other
                allocator_type;
        enum {_Multi = _Mfl};
        _Tmap_traits()
                : comp()
                {}
        _Tmap_traits(_Pr _Parg)
                : comp(_Parg)
                {}
        class value_compare
                : public binary_function<value_type, value_type, bool> {
                friend class _Tmap_traits<_K, _Ty, _Pr, _Ax, _Mfl>;
        public:
                bool operator()(const value_type& _X,
                        const value_type& _Y) const
                        {return (comp(_X.first, _Y.first)); }
                value_compare(key_compare _Pred)
                        : comp(_Pred) {}
        protected:
                key_compare comp;
                };
        struct _Kfn {
                const _K& operator()(const value_type& _X) const
                        {return (_X.first); }
                };
        _Pr comp;
        };
#line 106
template<class _K, class _Ty,
        class _Pr = less<_K>,
        class _A = allocator<pair<const _K, _Ty> > >
        class map
                : public _Tree<_Tmap_traits<_K, _Ty, _Pr, _A, false> > {
public:
        typedef map<_K, _Ty, _Pr, _A> _Myt;
        typedef _Tree<_Tmap_traits<_K, _Ty, _Pr, _A, false> >
                _Mybase;
        typedef _K key_type;
        typedef _Ty mapped_type;
        typedef _Ty referent_type;
        typedef _Pr key_compare;
        typedef typename _Mybase::value_compare value_compare;
        typedef typename _Mybase::allocator_type allocator_type;
        typedef typename _Mybase::size_type size_type;
        typedef typename _Mybase::difference_type difference_type;
        typedef typename _Mybase::pointer pointer;
        typedef typename _Mybase::const_pointer const_pointer;
        typedef typename _Mybase::reference reference;
        typedef typename _Mybase::const_reference const_reference;
        typedef typename _Mybase::iterator iterator;
        typedef typename _Mybase::const_iterator const_iterator;
        typedef typename _Mybase::reverse_iterator reverse_iterator;
        typedef typename _Mybase::const_reverse_iterator
                const_reverse_iterator;
        typedef typename _Mybase::value_type value_type;
        map()
                : _Mybase(key_compare(), allocator_type()) {}
        explicit map(const key_compare& _Pred)
                : _Mybase(_Pred, allocator_type()) {}
        map(const key_compare& _Pred, const allocator_type& _Al)
                : _Mybase(_Pred, _Al) {}
        template<class _It>
                map(_It _F, _It _L)
                : _Mybase(key_compare(), allocator_type())
                {for (; _F != _L; ++_F)
                        insert(*_F); }
        template<class _It>
                map(_It _F, _It _L, const key_compare& _Pred)
                : _Mybase(_Pred, allocator_type())
                {for (; _F != _L; ++_F)
                        insert(*_F); }
        template<class _It>
                map(_It _F, _It _L, const key_compare& _Pred,
                const allocator_type& _Al)
                : _Mybase(_Pred, _Al)
                {for (; _F != _L; ++_F)
                        insert(*_F); }
        mapped_type& operator[](const key_type& _Kv)
                {iterator _P =
                        _Mybase::insert(value_type(_Kv, mapped_type())).first;
                return ((*_P).second); }
        };
#line 162
template<class _K, class _Ty,
        class _Pr = less<_K>,
        class _A = allocator<pair<const _K, _Ty> > >
        class multimap
                : public _Tree<_Tmap_traits<_K, _Ty, _Pr, _A, true> > {
public:
        typedef multimap<_K, _Ty, _Pr, _A> _Myt;
        typedef _Tree<_Tmap_traits<_K, _Ty, _Pr, _A, true> >
                _Mybase;
        typedef _K key_type;
        typedef _Ty mapped_type;
        typedef _Ty referent_type;       
        typedef _Pr key_compare;
        typedef typename _Mybase::value_compare value_compare;
        typedef typename _Mybase::allocator_type allocator_type;
        typedef typename _Mybase::size_type size_type;
        typedef typename _Mybase::difference_type difference_type;
        typedef typename _Mybase::pointer pointer;
        typedef typename _Mybase::const_pointer const_pointer;
        typedef typename _Mybase::reference reference;
        typedef typename _Mybase::const_reference const_reference;
        typedef typename _Mybase::iterator iterator;
        typedef typename _Mybase::const_iterator const_iterator;
        typedef typename _Mybase::reverse_iterator reverse_iterator;
        typedef typename _Mybase::const_reverse_iterator
                const_reverse_iterator;
        typedef typename _Mybase::value_type value_type;
        multimap()
                : _Mybase(key_compare(), allocator_type()) {}
        explicit multimap(const key_compare& _Pred)
                : _Mybase(_Pred, allocator_type()) {}
        multimap(const key_compare& _Pred, const allocator_type& _Al)
                : _Mybase(_Pred, _Al) {}
        template<class _It>
                multimap(_It _F, _It _L)
                : _Mybase(key_compare(), allocator_type())
                {for (; _F != _L; ++_F)
                        insert(*_F); }
        template<class _It>
                multimap(_It _F, _It _L, const key_compare& _Pred)
                : _Mybase(_Pred, allocator_type())
                {for (; _F != _L; ++_F)
                        insert(*_F); }
        template<class _It>
                multimap(_It _F, _It _L, const key_compare& _Pred,
                const allocator_type& _Al)
                : _Mybase(_Pred, _Al)
                {for (; _F != _L; ++_F)
                        insert(*_F); }
        iterator insert(const value_type& _X)
                {return (_Mybase::insert(_X).first); }
        iterator insert(iterator _P, const value_type& _X)
                {return (_Mybase::insert(_P, _X)); }
        template<class _It>
                void insert(_It _F, _It _L)
                {for (; _F != _L; ++_F)
                        insert(*_F); }
        };
};

#pragma namemangling()

#pragma object_model(pop)
#line 231
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 26 "/usr/vacpp/include/math.h"
# pragma info(none)

#   pragma report(level, E)

# pragma info(restore)
#line 35
extern "C++" {
#line 44
extern "C" {
      inline double acos(double);
      inline double acosh(double);
      inline double asin(double);
      inline double asinh(double);
      inline double atan(double);
      inline double atanh(double);
      inline double atan2(double, double);
      inline double cbrt(double);
      inline double cos(double);
      inline double cosh(double);
      inline double exp(double);
      inline double expm1(double);
      inline double fabs(double);
      inline double log(double);
      inline double log10(double);
      inline double log1p(double);
      inline double pow(double, double);
      inline double sin(double);
      inline double sinh(double);
      inline double sqrt(double);
      inline double tan(double);
      inline double tanh(double);

      inline float floorf(float);
      inline double floor(double);
      inline long double floorl(long double);
      inline float ceilf(float);
      inline double ceil(double);
      inline long double ceill(long double);
};
#line 77
extern "C" {
      inline double copysign(double, double);
};
#line 84
}

extern "C++" {
#line 90
extern "C" {
#line 99
}

inline double abs(double);
extern "C" {
extern double ceil(double);
extern double cosh(double);
extern double floor(double);
extern double fmod(double, double);
extern double frexp(double, int *);
extern double ldexp(double, int);
extern double modf(double, double *);
extern double pow(double, double);
extern double sinh(double);
extern double sqrt(double);
extern double tanh(double);
};

inline float abs(float _X) { return (_X < 0.0) ? -_X : _X; }

inline float acos(float _X) { 
	double _Ans = acos( (double)_X );
	if (abs(_Ans)<1.1754943508222875e-38F) {
		errno = 34;
		return (float)0.0;
	}
	return (float)_Ans;	
}

inline float asin(float _X)
{
   double _Ans = asin( (double)_X );
   if (abs(_Ans)<1.1754943508222875e-38F) {
	  errno = 34;
	  return (float)0.0;
   }
   return (float)_Ans;
}

inline float atan(float _X)
{
   double _Ans;
   _Ans = atan( (double)_X );
   if (abs(_Ans)<1.1754943508222875e-38F) {
	  errno = 34;
	  return (float)0.0;
   }
   return (float)_Ans;
}

inline float atan2(float _X, float _Y)
{
   double _Ans;
   _Ans = atan2( (double)_X, (double)_Y );
   if (abs(_Ans)<1.1754943508222875e-38F) {
	  errno = 34;
	  return (float)0.0;
   }
   return (float)_Ans;
}

inline float ceil(float _X) { return (float)ceil( (double)_X ); }
inline float cos(float _X) { return (float)cos( (double)_X ); }
inline float cosh(float _X)
{
   double _Ans;
   _Ans = cosh( (double)_X );
   if (_Ans>3.4028234663852886e+38F) {
	  errno = 34;
	  return (*((double *) (_DBLINF)));
   }
   return (float)_Ans;
}

inline float exp(float _X)
{
   double _Ans;
   _Ans = exp( (double)_X );
   if (abs(_Ans)>3.4028234663852886e+38F) {
	  errno = 34;
	  return (*((double *) (_DBLINF)));
   } else {
	  if (abs(_Ans)<1.1754943508222875e-38F) {
		 errno = 34;
		 return 0.0;
	  }
   }
   return (float)_Ans;
}

inline float fabs(float _X) { return (_X<0.0) ? -_X : _X; }
inline float floor(float _X) { return (float)floor( (double)_X ); }
inline float fmod(float _X, float _Y) { return (float)fmod( (double)_X, (double)_Y ); }
inline float frexp(float _X, int* _Y) { return (float)frexp( (double)_X, _Y ); }

inline float ldexp(float _X, int _Y)
{
   double _Ans;
   _Ans = ldexp( (double)_X, _Y );
   if (fabs(_Ans)>3.4028234663852886e+38F) {
	  errno = 34;
	  if (_Ans>0.0) {
		 return (*((double *) (_DBLINF)));
	  } else {
		 return -(*((double *) (_DBLINF)));
	  }
   } else {
	  if (fabs(_Ans)<1.1754943508222875e-38F) {
		 errno = 34;
		 return 0.0;
	  }
   }
   return (float)_Ans;
}
inline float log(float _X) { return (float)log( (double)_X ); }
inline float log10(float _X) { return (float)log10( (double)_X ); }

inline float modf(float _X, float* _Y) { 
   double _Tmp = 0;
   double _Ret = 0;
   _Ret = modf((double)_X, &_Tmp);
   *_Y =  _Tmp;
   return _Ret;
}

inline float pow(float _X, float _Y) { 
   double _Ans;
   _Ans = pow( (double)_X, (double)_Y );
   if (fabs(_Ans)>3.4028234663852886e+38F) {
	  errno = 34;
	  if (_Ans>0.0)
			return (*((double *) (_DBLINF)));
		else
			return -(*((double *) (_DBLINF)));
	} else {
		if (fabs(_Ans)<1.1754943508222875e-38F) {
			errno = 34;
			return 0.0;
		}
	}
	return (float)_Ans;
}

inline float pow(float _X, int _Y) { 
   double _Ans;
   _Ans = pow( (double)_X, (double)_Y );
   if (fabs(_Ans)>3.4028234663852886e+38F) {
	  errno = 34;
	  if (_Ans>0.0)
		 return (*((double *) (_DBLINF)));
	  else
		 return -(*((double *) (_DBLINF)));
   } else {
	  if (fabs(_Ans)<1.1754943508222875e-38F) {
		 errno = 34;
		 return 0.0;
	  }
   }
   return (float)_Ans;
}

inline float sin (float _X) { return (float)sin( (double)_X ); }	

inline float sinh (float _X) { 
   double _Ans;
   if (_X==0.0) {
	  return (float)0.0;
   }
   _Ans = sinh( (double)_X );
   if (_Ans>3.4028234663852886e+38F) {
	  errno = 34;
	  return (*((double *) (_DBLINF)));
   } else if (_Ans<-3.4028234663852886e+38F) {
	  errno = 34;
	  return -(*((double *) (_DBLINF)));
   } else if (fabs(_Ans)<1.1754943508222875e-38F) {
	  errno = 34;
	  return (float)0.0;
   }
   return (float)_Ans;
}

inline float sqrt(float _X) { return (float)sqrt( (double)_X ); }

inline float tan(float _X)
{
   double _Ans;
   _Ans = tan( (double)_X );
   if (_Ans>3.4028234663852886e+38F) {
	  errno = 34;
	  return (*((double *) (_DBLINF)));
   } else if (_Ans<-3.4028234663852886e+38F) {
	  errno = 34;
	  return -(*((double *) (_DBLINF)));
   } else if (0.0<fabs(_Ans) && fabs(_Ans)<1.1754943508222875e-38F) {
	  errno = 34;
	  return (float)0.0;
   }
   return (float)_Ans;
}

inline float tanh(float _X) { return (float)tanh( (double)_X ); }	
#line 470
	inline long double abs (long double _X)
	{
		return fabs( (double)_X );
	}

	inline long double acos (long double _X)
	{
		return acos( (double)_X );
	}

	inline long double asin (long double _X)
	{
		return asin( (double)_X );
	}

	inline long double atan (long double _X)
	{
		return atan( (double)_X );
	}

	inline long double atan2(long double _X, long double _Y)
	{
		return atan2( (double)_X,  (double)_Y );
	}

	inline long double ceil (long double _X)
	{
		return ceil( (double)_X );
	}

	inline long double cos (long double _X)
	{
		return cos( (double)_X );
	}

	inline long double cosh (long double _X)
	{
		return cosh( (double)_X );
	}

	inline long double exp (long double _X)
	{
		return exp( (double)_X );
	}

	inline long double fabs (long double _X)
	{
		return fabs( (double)_X );
	}

	inline long double floor(long double _X)
	{
		return floor( (double)_X );
	}
#line 526
	inline long double fmod (long double _X, long double _Y)
	{
		return fmod( (double)_X,  (double)_Y );
	}

	inline long double frexp(long double _X, int* _Y)
	{
		return frexp( (double)_X, _Y );
	}

	inline long double ldexp(long double _X, int _Y)
	{
		return ldexp( (double)_X, _Y );
	}

	inline long double log (long double _X)
	{
		return log( (double)_X );
	}

	inline long double log10(long double _X)
	{
		return log10( (double)_X );
	}

	inline long double modf (long double _X, long double* _Y)
	{
		return modf( (double)_X, (double *) _Y);
	}

	inline long double pow (long double _X, long double _Y)
	{
		return pow( (double)_X,  (double)_Y );
	}

	inline long double pow (long double _X, int _Y)
	{
		return pow( (double)_X, (double)_Y );
	}

	inline long double sin (long double _X)
	{
		return sin( (double)_X );
	}

	inline long double sinh (long double _X)
	{
		return sinh( (double)_X );
	}

	inline long double sqrt (long double _X)
	{
		return sqrt( (double)_X );
	}

	inline long double tan (long double _X)
	{
		return tan( (double)_X );
	}

	inline long double tanh (long double _X)
	{
		return tanh( (double)_X );
	}	
#line 592
inline double pow(double _X, int _Y)
{
	return pow( _X, (double)_Y );
}

namespace std {

using ::abs; using ::acos; using ::acosh; using ::asin; using ::asinh;
using ::atan; using ::atanh; using ::atan2; using ::ceil;
using ::cos; using ::cosh; using ::exp;
using ::fabs; using ::floor; using ::fmod;
using ::frexp; using ::ldexp; using ::log;
using ::log10; using ::modf; using ::pow;
using ::sin; using ::sinh; using ::sqrt; 
using ::tan; using ::tanh;
}
#line 613
}
extern "C" {
#line 40 "/usr/include/math.h"
extern "C" {
#line 59
extern  unsigned _DBLINF[2];
static  const unsigned int _SINFINITY = 0x7f800000;
static  const unsigned int _SQNAN = 0x7fc00000;
#line 70
typedef double float_t;
typedef double double_t;
#line 288
extern  double acos(double);
extern  double asin(double);
extern  double atan(double);
extern  double atan2(double,double);
extern  double ceil(double);
extern  double copysign(double, double);
extern  double cos(double);
extern  double cosh(double);
extern  double exp(double);
extern  double fabs(double);
extern  double floor(double);
extern  double fmod(double, double);
extern  double frexp(double, int *);
extern  double ldexp(double, int);
extern  double log(double);
extern  double log10(double);
extern  double modf(double, double *);
extern  double pow(double, double);
extern  double sin(double);
extern  double sinh(double);
extern  double sqrt(double);
extern  double tan(double);
extern  double tanh(double);
extern  double trunc(double);
#line 315
extern float        acosf(float);
extern float        acoshf(float);
extern long double  acoshl(long double);
extern long double  acosl(long double);
extern float        asinf(float);
extern float        asinhf(float);
extern long double  asinhl(long double);
extern long double  asinl(long double);
extern float        atan2f(float, float);
extern long double  atan2l(long double, long double);
extern float        atanf(float);
extern float        atanhf(float);
extern long double  atanhl(long double);
extern long double  atanl(long double);
extern float        cbrtf(float);
extern long double  cbrtl(long double);
extern float        ceilf(float);
extern long double  ceill(long double);
extern float        copysignf(float, float);
extern long double  copysignl(long double, long double);
extern float        cosf(float);
extern float        coshf(float);
extern long double  coshl(long double);
extern long double  cosl(long double);
extern float        erfcf(float);
extern long double  erfcl(long double);
extern float        erff(float);
extern long double  erfl(long double);
extern double       exp2(double);
extern float        exp2f(float);
extern long double  exp2l(long double);
extern float        expf(float);
extern long double  expl(long double);
extern float        expm1f(float);
extern long double  expm1l(long double);
extern float        fabsf(float);
extern long double  fabsl(long double);
extern double       fdim(double, double);
extern float        fdimf(float, float);
extern long double  fdiml(long double, long double);
extern float        floorf(float);
extern long double  floorl(long double);
extern double       fma(double, double, double);
extern float        fmaf(float, float, float);
extern long double  fmal(long double, long double, long double);
extern double       fmax(double, double);
extern float        fmaxf(float, float);
extern long double  fmaxl(long double, long double);
extern double       fmin(double, double);
extern float        fminf(float, float);
extern long double  fminl(long double, long double);
extern float        fmodf(float, float);
extern long double  fmodl(long double, long double);
extern float 	    frexpf(float, int *);
extern float        hypotf(float, float);
extern long double  hypotl(long double, long double);
extern int          ilogbf(float);
extern int          ilogbl(long double         );
extern float        ldexpf(float, int);
extern float        lgammaf(float);
extern long double  lgammal(long double);

extern long long int llrint(double);
extern long long int llrintf(float);
extern long long int llrintl(long double);
extern long long int llround(double);
extern long long int llroundf(float);
extern long long int llroundl(long double);

extern float        log10f(float);
extern long double  log10l(long double);
extern float        log1pf(float);
extern long double  log1pl(long double);
extern float        log2f(float);
extern double       log2(double);
extern long double  log2l(long double);
extern float        logbf(float);
extern long double  logbl(long double);
extern float        logf(float);
extern long double  logl(long double);
extern long int     lrint(double);
extern long int     lrintf(float);
extern long int     lrintl(long double);
extern long int     lround(double);
extern long int     lroundf(float);
extern long int     lroundl(long double);
extern float        modff(float, float *);
extern double       nan(const char *);
extern float        nanf(const char *);
extern long double  nanl(const char *);
extern double       nearbyint(double);
extern float        nearbyintf(float);
extern long double  nearbyintl(long double);
extern float        nextafterf(float, float);
extern long double  nextafterl(long double, long double);
extern double       nexttoward(double, long double);
extern float        nexttowardf(float, long double);
extern long double  nexttowardl(long double, long double);
extern float        powf(float, float);
extern long double  powl(long double, long double);
extern float        remainderf(float, float);
extern long double  remainderl(long double, long double);
extern double       remquo(double, double, int *);
extern float        remquof(float, float, int *);
extern long double  remquol(long double, long double, int *);
extern float        rintf(float);
extern long double  rintl(long double);
extern double       round(double);
extern float        roundf(float);
extern long double  roundl(long double);
extern double       scalbln(double, long);
extern float        scalblnf(float, long);
extern long double  scalblnl(long double, long);
extern double       scalbn(double, int);
extern float        scalbnf(float, int);
extern long double  scalbnl(long double, int);
extern float        sinf(float);
extern float        sinhf(float);
extern long double  sinhl(long double);
extern long double  sinl(long double);
extern float        sqrtf(float);
extern long double  sqrtl(long double);
extern float        tanf(float);
extern float        tanhf(float);
extern long double  tanhl(long double);
extern long double  tanl(long double);
extern double       tgamma(double);
extern float        tgammaf(float);
extern long double  tgammal(long double);
extern float        truncf(float);
extern long double  truncl(long double);
#line 488
static long double frexpl(long double __x, int *__i)
{
     return (long double) frexp((double) __x, __i);
}

static long double ldexpl(long double __x, int __i)
{
     return (long double) ldexp((double) __x, __i);
}
#line 499
static long double modfl(long double __x, long double *__y)
{
     return (long double) modf((double) __x, (double *) __y);
}
#line 737
extern     double   erf(double);
extern     double   erfc(double);
extern     double   hypot(double,double);
extern     double   lgamma(double);

extern     double   lgamma_r(double, int *);
#line 755
extern     double   acosh(double);
extern     double   asinh(double);
extern     double   atanh(double);
extern     double   cbrt(double);
extern     double   expm1(double);
extern     int      ____ilogb(double);
extern     double   log1p(double);
extern     double   ____logb(double);
extern     double   ____nextafter(double, double);
extern     double   remainder(double, double);
extern     double   rint(double);
#line 783
extern int signgam;
#line 823
extern unsigned int _SFPMAX;
#line 848
extern     int      isnan(double);
extern     double   gamma(double);
extern     double   gamma_r(double, int *);

extern     double   j0(double);
extern     double   j1(double);
extern     double   jn(int, double);
extern     double   y0(double);
extern     double   y1(double);
extern     double   yn(int, double);
#line 860
extern     double   scalb(double, double);
#line 933
     struct dbl_hypot {
         double x, y;
     };

extern     double   _cabshypot(struct dbl_hypot);
extern     double   drem(double, double);
extern     double   exp__E(double, double);
extern     double   log__L(double);
extern     double   nearest(double);
extern     double   rsqrt(double);
extern     int      ____finite(double);
extern     int      itrunc(double);
extern     int      unordered(double, double);
extern     unsigned  uitrunc(double);
extern     int      isinf(double);

extern     int      dtoi(double);
#line 961
extern     int      _class(double);
#line 983
struct __exception {
	int type;
	char *name;
	double arg1;
	double arg2;
	double retval;
};
#line 1024
extern     int   _class(double);
extern     int   _classf(float);
extern     int   _isfinite(double);
extern     int   _isfinitef(float);
extern     int   _isinf(double);
extern     int   _isinff(float);
extern     int   _isnan(double);
extern     int   _isnanf(float);
extern     int   _isnormal(double);
extern     int   _isnormalf(float);
extern     int   _signbit(double);
extern     int   _signbitf(float);
#line 1213
extern long long int __multi64( long long int, long long int );
extern long long int __divi64( long long int, long long int );
extern unsigned long long int __divu64( unsigned long long int, 
					unsigned long long int );
extern long long int __maxi64( long long int, long long int );
extern long long int __mini64( long long int, long long int );
extern long long int __f64toi64rz( double );
extern unsigned long long int __f64tou64rz( double );
#line 1530
}
}
#line 617 "/usr/vacpp/include/math.h"
extern "C++" {
#line 644
extern "C" {
      extern "builtin" double __acos(double);
      extern "builtin" double __acosh(double);
      extern "builtin" double __asin(double);
      extern "builtin" double __asinh(double);
      extern "builtin" double __atan(double);
      extern "builtin" double __atanh(double);
      extern "builtin" double __atan2(double, double);
      extern "builtin" double __cbrt(double);
      extern "builtin" double __cos(double);
      extern "builtin" double __cosh(double);
      extern "builtin" double __exp(double);
      extern "builtin" double __expm1(double);
      extern "builtin" double __fabs(double);
      extern "builtin" double __log(double);
      extern "builtin" double __log10(double);
      extern "builtin" double __log1p(double);
      extern "builtin" double __pow(double, double);
      extern "builtin" double __sin(double);
      extern "builtin" double __sinh(double);
      extern "builtin" double __sqrt(double);
      extern "builtin" double __tan(double);
      extern "builtin" double __tanh(double);
      extern "builtin" double __floor(double);
      extern "builtin" float __floorf(float);
      extern "builtin" long double __floorl(long double);
      extern "builtin" double __ceil(double);
      extern "builtin" float __ceilf(float);
      extern "builtin" long double __ceill(long double);
}
#line 676
extern "C" {
        extern "builtin" double __copysign(double, double);
}
#line 681
extern "C" {
      inline double acos(double __x) {return __acos(__x);}
      inline double acosh(double __x) {return __acosh(__x);}
      inline double asin(double __x) {return __asin(__x);}
      inline double asinh(double __x) {return __asinh(__x);}
      inline double atan(double __x) {return __atan(__x);}
      inline double atanh(double __x) {return __atanh(__x);}
      inline double atan2(double __x, double __y) {return __atan2(__x,__y);}
      inline double cbrt(double __x) { return __cbrt(__x);}
      inline double cos(double __x) {return __cos(__x);}
      inline double cosh(double __x) {return __cosh(__x);}
      inline double exp(double __x) {return __exp(__x);}
      inline double expm1(double __x) {return __expm1(__x);}
      inline double fabs(double __x) {return __fabs(__x);}
      inline double log(double __x) {return __log(__x);}
      inline double log10(double __x) {return __log10(__x);}
      inline double log1p(double __x) {return __log1p(__x);}
      inline double pow(double __x, double __y) 
      {return __pow(__x, __y);}
      inline double sin(double __x) {return __sin(__x);}
      inline double sinh(double __x) {return __sinh(__x);}
      inline double sqrt(double __x) {return __sqrt(__x);}
      inline double tan(double __x) {return __tan(__x);}
      inline double tanh(double __x) {return __tanh(__x);}

      inline double floor(double __x) { return __floor(__x); }
      inline float floorf(float __x) { return __floorf(__x); }
      inline long double floorl(long double __x) { return __floorl(__x); }
      inline double ceil(double __x) { return __ceil(__x); }
      inline float ceilf(float __x) { return __ceilf(__x); }
      inline long double ceill(long double __x) { return __ceill(__x); }
} 
#line 715
extern "C" {
        inline double copysign(double __x, double __y) 
          {return __copysign(__x,__y);}
}
#line 727
    inline double abs(double d) { return fabs(d); }
#line 744
    extern "C" {

        extern   double   logb(...);
        extern   int    ilogb(...);
        extern   double   nextafter(...);
        extern   int    finite(...);
#line 756
    }

}

# pragma info(none)

#   pragma report(pop)

# pragma info(restore)
extern "C" {
}
extern "C" {
#line 59 "/usr/include/sys/dir.h"
extern "C" {
#line 76
struct	dirent {
	__ulong64_t	d_offset;	 
	ino_t		d_ino;		 
	ushort_t	d_reclen;	 
	ushort_t	d_namlen;	 
	char	        d_name[255+1];	 

};
#line 102
typedef struct _dirdesc {

	int	dd_fd;		 
	blksize_t dd_blksize;	 
	char	*dd_buf;	 
	long	dd_size;	 
	long	dd_flag;	 
	off_t	dd_loc;		 
	off_t	dd_curoff;	
#line 126
} DIR;
#line 140
extern  DIR *opendir(const char *);
extern  struct dirent *readdir(DIR *);
#line 149
extern int readdir_r(DIR *restrict, struct dirent *restrict, struct dirent **restrict);
#line 154
extern  int closedir(DIR *);
extern  void rewinddir(DIR *);
#line 171
extern void seekdir(DIR *, long);
extern long telldir(DIR *);
#line 182
struct	dirent64 {
	uint64_t	d_offset;	 
	ino64_t		d_ino;		 
	ushort_t	d_reclen;	 
	ushort_t	d_namlen;	 
	char	        d_name[255+1];	 
};

typedef struct _dirdesc64 {
	int	dd_fd;		 
	blksize_t dd_blksize;	 
	char	*dd_buf;	 
	long	dd_size;	 
	long	dd_flag;	 
	offset_t dd_loc;	 
	offset_t dd_curoff;	
#line 203
} DIR64;
#line 233
extern int scandir(const char *, struct dirent ***,
                    int (*)(struct dirent *),
                    int (*)(void *, void *));

extern int scandir64(const char *, struct dirent64 ***,
                    int (*)(struct dirent64 *),
                    int (*)(void *, void *));

extern int alphasort(void *, void *);
extern int alphasort64(void *, void *);
extern ssize_t getdirentries(int, char *, size_t, off_t *);
#line 267
extern  DIR64 *opendir64(const char *);
extern int readdir64_r(DIR64 *, struct dirent64 *restrict, struct dirent64 **restrict);
extern  struct dirent64 *readdir64(DIR64 *);
extern  int closedir64(DIR64 *);
extern  void rewinddir64(DIR64 *);
extern void seekdir64(DIR64 *, offset_t);
extern offset_t telldir64(DIR64 *);
}
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 366
struct	direct {
	ushort_t d_ino;			 
	char	d_name[14];	 
};
#line 385
}
}
extern "C" {
}
#line 457 "/oracle/app/product/10.2.0/db_1/rdbms/public/oci.h"
extern "C" {
extern "C" {
}
#line 29 "/oracle/app/product/10.2.0/db_1/rdbms/public/oratypes.h"
  typedef unsigned char ub1;
  typedef   signed char sb1;
  typedef          char eb1;
#line 60
  typedef sb1 b1;
#line 71
  typedef unsigned short ub2;
  typedef   signed short sb2;
  typedef          short eb2;
#line 99
  typedef sb2 b2;
#line 110
  typedef unsigned int ub4;
  typedef   signed int sb4;
  typedef          int eb4;
#line 141
    typedef unsigned long oraub8;
    typedef   signed long orasb8;
#line 147
   typedef oraub8 ub8;
   typedef orasb8 sb8;
#line 184
  typedef sb4 b4;
#line 197
  typedef unsigned char oratext;
#line 205
   typedef oratext text;
   typedef oratext OraText;
#line 216
  typedef unsigned short utext;
#line 225
   typedef int boolean;
#line 234
  typedef          int eword;
  typedef unsigned int uword;
  typedef   signed int sword;
#line 262
  typedef unsigned long  ubig_ora;             
  typedef   signed long  sbig_ora;             
#line 292
typedef void (*lgenfp_t)( void );
#line 82 "/oracle/app/product/10.2.0/db_1/rdbms/public/ocidfn.h"
struct cda_head {
    sb2          v2_rc;
    ub2          ft;
    ub4          rpc;
    ub2          peo;
    ub1          fc;
    ub1          rcs1;
    ub2          rc;
    ub1          wrn;
    ub1          rcs2;
    sword        rcs3;
    struct {
        struct {
           ub4    rcs4;
           ub2    rcs5;
           ub1    rcs6;
        } rd;
        ub4    rcs7;
        ub2    rcs8;
    } rid;
    sword        ose;
    ub1           chk;
    void        *rcsp;
};
#line 126
struct cda_def {
    sb2          v2_rc;                                     
    ub2          ft;                                     
    ub4          rpc;                                 
    ub2          peo;                                   
    ub1          fc;                                     
    ub1          rcs1;                                         
    ub2          rc;                                        
    ub1          wrn;                                        
    ub1          rcs2;                                            
    sword        rcs3;                                            
    struct {                                               
        struct {
           ub4    rcs4;
           ub2    rcs5;
           ub1    rcs6;
        } rd;
        ub4    rcs7;
        ub2    rcs8;
    } rid;
    sword        ose;                                  
    ub1           chk;
    void        *rcsp;                           
    ub1          rcs9[88 - sizeof (struct cda_head)];         
};

typedef struct cda_def Cda_Def;
#line 156
typedef struct cda_def Lda_Def;
#line 2286 "/oracle/app/product/10.2.0/db_1/rdbms/public/oci.h"
typedef struct OCIEnv           OCIEnv;             
typedef struct OCIError         OCIError;                 
typedef struct OCISvcCtx        OCISvcCtx;              
typedef struct OCIStmt          OCIStmt;              
typedef struct OCIBind          OCIBind;                   
typedef struct OCIDefine        OCIDefine;               
typedef struct OCIDescribe      OCIDescribe;           
typedef struct OCIServer        OCIServer;               
typedef struct OCISession       OCISession;      
typedef struct OCIComplexObject OCIComplexObject;           
typedef struct OCITrans         OCITrans;           
typedef struct OCISecurity      OCISecurity;           
typedef struct OCISubscription  OCISubscription;       

typedef struct OCICPool         OCICPool;           
typedef struct OCISPool         OCISPool;              
typedef struct OCIAuthInfo      OCIAuthInfo;                   
typedef struct OCIAdmin         OCIAdmin;                     
typedef struct OCIEvent         OCIEvent;                  
#line 2307
typedef struct OCISnapshot      OCISnapshot;       
typedef struct OCIResult        OCIResult;       
typedef struct OCILobLocator    OCILobLocator;  
typedef struct OCIParam         OCIParam;         
typedef struct OCIComplexObjectComp OCIComplexObjectComp;

typedef struct OCIRowid OCIRowid;                     

typedef struct OCIDateTime OCIDateTime;            
typedef struct OCIInterval OCIInterval;            

typedef struct OCIUcb           OCIUcb;       
typedef struct OCIServerDNs     OCIServerDNs;     
#line 2322
typedef struct OCIAQEnqOptions    OCIAQEnqOptions;  
typedef struct OCIAQDeqOptions    OCIAQDeqOptions;  
typedef struct OCIAQMsgProperties OCIAQMsgProperties;   
typedef struct OCIAQAgent         OCIAQAgent;          
typedef struct OCIAQNfyDescriptor OCIAQNfyDescriptor;    
typedef struct OCIAQSignature     OCIAQSignature;             
typedef struct OCIAQListenOpts    OCIAQListenOpts;       
typedef struct OCIAQLisMsgProps   OCIAQLisMsgProps;    
#line 2334
typedef struct OCILobLocator OCIClobLocator;     
typedef struct OCILobLocator OCIBlobLocator;        
typedef struct OCILobLocator OCIBFileLocator;  
#line 2357
typedef ub4 OCILobOffset;
#line 2367
typedef ub4 OCILobLength;
#line 2379
enum OCILobMode
{
  OCI_LOBMODE_READONLY = 1,                                      
  OCI_LOBMODE_READWRITE = 2              
};
typedef enum OCILobMode OCILobMode;
#line 2484
typedef struct OCIPicklerTdsCtx OCIPicklerTdsCtx;
typedef struct OCIPicklerTds OCIPicklerTds;
typedef struct OCIPicklerImage OCIPicklerImage;
typedef struct OCIPicklerFdo OCIPicklerFdo;
typedef ub4 OCIPicklerTdsElement;

typedef struct OCIAnyData OCIAnyData;

typedef struct OCIAnyDataSet OCIAnyDataSet;
typedef struct OCIAnyDataCtx OCIAnyDataCtx;
#line 2600
typedef struct OCIMsg  OCIMsg;
typedef ub4            OCIWchar;
#line 124 "/oracle/app/product/10.2.0/db_1/rdbms/public/oci1.h"
typedef struct OCIFileObject OCIFileObject;
#line 130
typedef struct OCIThreadContext OCIThreadContext;
#line 133
typedef struct OCIThreadMutex   OCIThreadMutex; 
#line 136
typedef struct OCIThreadKey     OCIThreadKey;  
#line 139
typedef struct OCIThreadId      OCIThreadId;  
#line 142
typedef struct OCIThreadHandle  OCIThreadHandle;  
#line 148
typedef void (*OCIThreadKeyDestFunc)( );
#line 278 "/oracle/app/product/10.2.0/db_1/rdbms/public/oro.h"
typedef struct OCIRef OCIRef;
#line 291
typedef sb2 OCIInd;
#line 322
enum OCIPinOpt
{

  OCI_PIN_DEFAULT = 1,                                  
  OCI_PIN_ANY = 3,                           
  OCI_PIN_RECENT = 4,                     
  OCI_PIN_LATEST = 5                      
};
typedef enum OCIPinOpt OCIPinOpt;
#line 368
enum OCILockOpt
{

  OCI_LOCK_NONE = 1,                                
  OCI_LOCK_X = 2,                                           
  OCI_LOCK_X_NOWAIT = 3                       
};
typedef enum OCILockOpt OCILockOpt;
#line 386
enum OCIMarkOpt
{

  OCI_MARK_DEFAULT = 1,         
  OCI_MARK_NONE = OCI_MARK_DEFAULT,    
  OCI_MARK_UPDATE                                
};
typedef enum OCIMarkOpt OCIMarkOpt;
#line 403
typedef ub2 OCIDuration;
#line 469
enum OCIObjectProperty
{

  OCI_OBJECTPROP_DIRTIED = 1,                                
  OCI_OBJECTPROP_LOADED,                 
  OCI_OBJECTPROP_LOCKED                                     
};
typedef enum OCIObjectProperty OCIObjectProperty;
#line 484
enum OCIRefreshOpt
{

  OCI_REFRESH_LOADED = 1         
};
typedef enum OCIRefreshOpt OCIRefreshOpt; 
#line 504
enum OCIObjectEvent
{

   OCI_OBJECTEVENT_BEFORE_FLUSH = 1,             
   OCI_OBJECTEVENT_AFTER_FLUSH,                   
   OCI_OBJECTEVENT_BEFORE_REFRESH,             
   OCI_OBJECTEVENT_AFTER_REFRESH,               
   OCI_OBJECTEVENT_WHEN_MARK_UPDATED,     
   OCI_OBJECTEVENT_WHEN_MARK_DELETED,     
   OCI_OBJECTEVENT_WHEN_UNMARK,           
   OCI_OBJECTEVENT_WHEN_LOCK                
};
typedef enum OCIObjectEvent OCIObjectEvent;
#line 548
typedef ub1 OCIObjectPropId;
#line 565
enum OCIObjectLifetime
{

   OCI_OBJECT_PERSISTENT = 1,                           
   OCI_OBJECT_TRANSIENT,                                 
   OCI_OBJECT_VALUE                                          
};
typedef enum OCIObjectLifetime OCIObjectLifetime;
#line 581
typedef uword OCIObjectMarkStatus;
#line 695
typedef ub2 OCITypeCode;
#line 700
enum OCITypeGetOpt
{
  OCI_TYPEGET_HEADER,

  OCI_TYPEGET_ALL        
};
typedef enum OCITypeGetOpt OCITypeGetOpt;
#line 728
enum OCITypeEncap
{

  OCI_TYPEENCAP_PRIVATE,                 
  OCI_TYPEENCAP_PUBLIC  
};
typedef enum OCITypeEncap OCITypeEncap;
#line 742
enum OCITypeMethodFlag
{
  OCI_TYPEMETHOD_INLINE = 0x0001,                                   
  OCI_TYPEMETHOD_CONSTANT = 0x0002,                               
  OCI_TYPEMETHOD_VIRTUAL = 0x0004,                                 
  OCI_TYPEMETHOD_CONSTRUCTOR = 0x0008,                         
  OCI_TYPEMETHOD_DESTRUCTOR = 0x0010,                           
  OCI_TYPEMETHOD_OPERATOR  = 0x0020,                              
  OCI_TYPEMETHOD_SELFISH = 0x0040,      

  OCI_TYPEMETHOD_MAP = 0x0080,                     
  OCI_TYPEMETHOD_ORDER  = 0x0100,                
#line 756
  OCI_TYPEMETHOD_RNDS= 0x0200,                
  OCI_TYPEMETHOD_WNDS= 0x0400,                         
  OCI_TYPEMETHOD_RNPS= 0x0800,                       
  OCI_TYPEMETHOD_WNPS= 0x1000,                      
  OCI_TYPEMETHOD_ABSTRACT = 0x2000,     
  OCI_TYPEMETHOD_OVERRIDING = 0x4000,                    
  OCI_TYPEMETHOD_PIPELINED = 0x8000                    
};
typedef enum OCITypeMethodFlag OCITypeMethodFlag;
#line 842
enum OCITypeParamMode
{

  OCI_TYPEPARAM_IN = 0,                                                 
  OCI_TYPEPARAM_OUT,                                                   
  OCI_TYPEPARAM_INOUT,                                              
  OCI_TYPEPARAM_BYREF,               
  OCI_TYPEPARAM_OUTNCPY,                          
  OCI_TYPEPARAM_INOUTNCPY                      
};
typedef enum OCITypeParamMode OCITypeParamMode;
#line 694 "/oracle/app/product/10.2.0/db_1/rdbms/public/ort.h"
typedef struct OCIType OCIType;
#line 714
typedef struct OCITypeElem OCITypeElem;
#line 731
typedef struct OCITypeMethod OCITypeMethod;
#line 746
typedef struct OCITypeIter OCITypeIter;
#line 760
sword OCITypeIterNew(    OCIEnv *env, OCIError *err, OCIType *tdo, 
                         OCITypeIter **iterator_ort    );
#line 788
sword OCITypeIterSet(    OCIEnv *env, OCIError *err, OCIType *tdo, 
                  OCITypeIter *iterator_ort    );
#line 815
sword OCITypeIterFree(    OCIEnv *env, OCIError *err, OCITypeIter
                          *iterator_ort    );
#line 843
sword OCITypeByName(    OCIEnv *env, OCIError *err, const OCISvcCtx *svc, 
                        const oratext *schema_name, ub4 s_length,
                        const oratext *type_name, ub4 t_length,
                        const oratext *version_name, ub4 v_length,
                        OCIDuration pin_duration, OCITypeGetOpt get_option,
                        OCIType **tdo    );
#line 891
sword OCITypeArrayByName(    OCIEnv *env, OCIError *err, const OCISvcCtx *svc,
                             ub4 array_len,
                             const oratext *schema_name[], ub4 s_length[],
                             const oratext *type_name[], ub4 t_length[],
                             const oratext *version_name[], ub4 v_length[],
                             OCIDuration pin_duration,
                             OCITypeGetOpt get_option, OCIType **tdo    );
#line 961
sword   OCITypeByRef(    OCIEnv *env, OCIError *err,
                         const OCIRef *type_ref, OCIDuration pin_duration,
                         OCITypeGetOpt get_option, OCIType **tdo    );
#line 998
sword   OCITypeArrayByRef(    OCIEnv *env, OCIError *err,
                              ub4 array_len, const OCIRef **type_ref,
                              OCIDuration pin_duration,
                              OCITypeGetOpt get_option, OCIType **tdo    );
#line 1049
oratext* OCITypeName(    OCIEnv *env, OCIError *err, const OCIType *tdo, 
                      ub4 *n_length    );
#line 1080
oratext* OCITypeSchema(    OCIEnv *env, OCIError *err, const OCIType *tdo, 
                   ub4 *n_length    );
#line 1111
OCITypeCode OCITypeTypeCode(    OCIEnv *env, OCIError *err,
                                const OCIType *tdo    );
#line 1138
OCITypeCode OCITypeCollTypeCode(    OCIEnv *env, OCIError *err,
                                    const OCIType *tdo    );
#line 1168
oratext* OCITypeVersion(    OCIEnv *env, OCIError *err, const OCIType *tdo, 
                         ub4 *v_length    );
#line 1199
ub4 OCITypeAttrs(    OCIEnv *env, OCIError *err, const OCIType *tdo    );
#line 1225
ub4 OCITypeMethods(    OCIEnv *env, OCIError *err, const OCIType *tdo    );
#line 1256
oratext* OCITypeElemName(    OCIEnv *env, OCIError *err, 
                           const OCITypeElem *elem, ub4 *n_length    );
#line 1287
OCITypeCode OCITypeElemTypeCode(    OCIEnv *env, OCIError *err,
                                    const OCITypeElem *elem    );
#line 1322
sword OCITypeElemType(    OCIEnv *env, OCIError *err, const OCITypeElem *elem, 
                          OCIType **elem_tdo    );
#line 1358
ub4 OCITypeElemFlags(    OCIEnv *env, OCIError *err,
                         const OCITypeElem *elem    );
#line 1389
ub1 OCITypeElemNumPrec(    OCIEnv *env, OCIError *err,
                           const OCITypeElem *elem    );
#line 1414
sb1 OCITypeElemNumScale(    OCIEnv *env, OCIError *err,
                            const OCITypeElem *elem    );
#line 1436
ub4 OCITypeElemLength(    OCIEnv *env, OCIError *err,
                          const OCITypeElem *elem    );
#line 1459
ub2 OCITypeElemCharSetID(    OCIEnv *env, OCIError *err,
                             const OCITypeElem *elem    );
#line 1482
ub2 OCITypeElemCharSetForm(    OCIEnv *env, OCIError *err,
                               const OCITypeElem *elem    );
#line 1511
sword OCITypeElemParameterizedType(    OCIEnv *env, OCIError *err,
                                       const OCITypeElem *elem, 
                                       OCIType **type_stored    );
#line 1556
OCITypeCode OCITypeElemExtTypeCode(    OCIEnv *env, OCIError *err,
                                       const OCITypeElem *elem    );
#line 1589
sword OCITypeAttrByName(    OCIEnv *env, OCIError *err, const OCIType *tdo, 
                            const oratext *name, ub4 n_length,
                            OCITypeElem **elem    );
#line 1630
sword OCITypeAttrNext(    OCIEnv *env, OCIError *err, 
                        OCITypeIter *iterator_ort, OCITypeElem **elem    );
#line 1672
sword OCITypeCollElem(    OCIEnv *env, OCIError *err, const OCIType *tdo,
                          OCITypeElem **element    );
#line 1717
sword OCITypeCollSize(    OCIEnv *env, OCIError *err, const OCIType *tdo, 
                          ub4 *num_elems    );
#line 1752
sword OCITypeCollExtTypeCode(    OCIEnv *env, OCIError *err,
                               const OCIType *tdo, OCITypeCode *sqt_code    );
#line 1791
ub4 OCITypeMethodOverload(    OCIEnv *env, OCIError *err, const OCIType *tdo, 
                              const oratext *method_name, ub4 m_length    );
#line 1824
sword OCITypeMethodByName(    OCIEnv *env, OCIError *err, const OCIType *tdo, 
                              const oratext *method_name, ub4 m_length,
                              OCITypeMethod **mdos    );
#line 1868
sword OCITypeMethodNext(    OCIEnv *env, OCIError *err, 
                            OCITypeIter *iterator_ort,
                            OCITypeMethod **mdo   );
#line 1910
oratext *OCITypeMethodName(    OCIEnv *env, OCIError *err,
                            const OCITypeMethod *mdo, ub4 *n_length    );
#line 1939
OCITypeEncap OCITypeMethodEncap(    OCIEnv *env, OCIError *err,
                                    const OCITypeMethod *mdo    );
#line 1966
OCITypeMethodFlag OCITypeMethodFlags(    OCIEnv *env, OCIError *err,
                                         const OCITypeMethod *mdo    );
#line 1997
sword OCITypeMethodMap(    OCIEnv *env, OCIError *err, const OCIType *tdo, 
                           OCITypeMethod **mdo    );
#line 2034
sword OCITypeMethodOrder(    OCIEnv *env, OCIError *err, const OCIType *tdo, 
                             OCITypeMethod **mdo    );
#line 2071
ub4 OCITypeMethodParams(    OCIEnv *env, OCIError *err,
                            const OCITypeMethod *mdo    );
#line 2103
sword OCITypeResult(    OCIEnv *env, OCIError *err, const OCITypeMethod *mdo,
                        OCITypeElem **elem    );
#line 2141
sword OCITypeParamByPos(    OCIEnv *env, OCIError *err,
                            const OCITypeMethod *mdo, ub4 position, 
                            OCITypeElem **elem    );
#line 2177
sword OCITypeParamByName(    OCIEnv *env, OCIError *err,
                             const OCITypeMethod *mdo, 
                             const oratext *name, ub4 n_length,
                             OCITypeElem **elem    );
#line 2215
sword OCITypeParamPos(    OCIEnv *env, OCIError *err,
                          const OCITypeMethod *mdo, 
                          const oratext *name, ub4 n_length, ub4 *position, 
                          OCITypeElem **elem    );
#line 2257
OCITypeParamMode OCITypeElemParamMode(    OCIEnv *env, OCIError *err,
                                          const OCITypeElem *elem    );
#line 2285
oratext* OCITypeElemDefaultValue(    OCIEnv *env, OCIError *err,
                                  const OCITypeElem *elem,
                                  ub4 *d_v_length    );
#line 2328
sword OCITypeVTInit(    OCIEnv *env, OCIError *err    );
#line 2351
sword OCITypeVTInsert(    OCIEnv *env, OCIError *err, 
                          const oratext *schema_name, ub4 s_n_length, 
                          const oratext *type_name, ub4 t_n_length, 
                          const oratext *user_version, ub4 u_v_length    );
#line 2390
sword OCITypeVTSelect(    OCIEnv *env, OCIError *err, 
                          const oratext *schema_name, ub4 s_n_length, 
                          const oratext *type_name, ub4 t_n_length, 
                          oratext **user_version, ub4 *u_v_length,
                        ub2 *version );
#line 2427
sword ortgcty(    OCIEnv *env, OCIError *err, OCIType *coll_tdo,
                  OCIType **collelem_tdo    );
#line 2434
sword OCITypeBeginCreate(OCISvcCtx *svchp, OCIError *errhp, OCITypeCode tc,
                         OCIDuration dur, OCIType **type);
#line 2478
sword OCITypeSetCollection(OCISvcCtx *svchp, OCIError *errhp, OCIType *type,
                           OCIParam *collelem_info, ub4 coll_count);
#line 2504
sword OCITypeSetBuiltin(OCISvcCtx *svchp, OCIError *errhp, OCIType *type,
                        OCIParam *builtin_info);
#line 2530
sword OCITypeAddAttr(OCISvcCtx *svchp, OCIError *errhp, OCIType *type,
                     const oratext *a_name, ub4 a_length, 
                     OCIParam *attr_info);
#line 2556
sword OCITypeEndCreate(OCISvcCtx *svchp, OCIError *errhp, OCIType *type);
#line 579 "/oracle/app/product/10.2.0/db_1/rdbms/public/ori.h"
sword OCIObjectNew(    OCIEnv *env, OCIError *err, const OCISvcCtx *svc,
                       OCITypeCode typecode, OCIType *tdo, void *table, 
                       OCIDuration duration, boolean value, 
                       void **instance    );
#line 667
sword OCIObjectPin(    OCIEnv *env, OCIError *err, OCIRef *object_ref, 
                       OCIComplexObject *corhdl, OCIPinOpt pin_option, 
                       OCIDuration pin_duration, 
                       OCILockOpt lock_option, void **object    );
#line 760
sword OCIObjectUnpin(    OCIEnv *env, OCIError *err, void *object    );
#line 807
sword OCIObjectPinCountReset(    OCIEnv *env, OCIError *err, void *object   );
#line 847
sword OCIObjectLock(    OCIEnv *env, OCIError *err, void *object    );
#line 878
sword OCIObjectLockNoWait(    OCIEnv *env, OCIError *err, void *object    );
#line 911
sword OCIObjectMarkUpdate(    OCIEnv *env, OCIError *err, void *object    );
#line 951
sword OCIObjectUnmark(    OCIEnv *env, OCIError *err, void *object    );
#line 982
sword OCIObjectUnmarkByRef(    OCIEnv *env, OCIError *err, OCIRef *ref    );
#line 1013
sword OCIObjectFree(    OCIEnv *env, OCIError *err, void *instance, 
                        ub2 flags   );
#line 1069
sword OCIObjectMarkDeleteByRef(    OCIEnv *env, OCIError *err, 
                                   OCIRef *object_ref);
#line 1105
sword OCIObjectMarkDelete(    OCIEnv *env, OCIError *err, void *instance    );
#line 1139
sword OCIObjectFlush(    OCIEnv *env, OCIError *err, void *object    );
#line 1171
sword OCIObjectRefresh(    OCIEnv *env, OCIError *err, void *object    );
#line 1222
sword OCIObjectCopy(    OCIEnv *env, OCIError *err, const OCISvcCtx *svc, 
                        void *source, void *null_source,
                        void *target, void *null_target, OCIType *tdo, 
                        OCIDuration duration, ub1 option    );
#line 1278
sword OCIObjectGetTypeRef(    OCIEnv *env, OCIError *err, void *instance, 
                              OCIRef *type_ref    );
#line 1306
sword OCIObjectGetObjectRef(    OCIEnv *env, OCIError *err, void *object, 
                                OCIRef *object_ref    );
#line 1335
sword OCIObjectMakeObjectRef(    OCIEnv *env, OCIError *err, 
                                 const OCISvcCtx *svc, void * table,
                                 void **values, ub4 array_len, 
                                 OCIRef *object_ref    );
#line 1376
sword OCIObjectGetPrimaryKeyTypeRef( OCIEnv *env, OCIError *err,
                                     const OCISvcCtx *svc, void *table, 
                                     OCIRef *type_ref );
#line 1407
sword OCIObjectGetInd(    OCIEnv *env, OCIError *err, void *instance, 
                          void **null_struct    );
#line 1437
sword OCIObjectExists(OCIEnv *env, OCIError *err, void *ins, boolean *exist); 
#line 1463
sword OCIObjectGetProperty(OCIEnv *envh, OCIError *errh, const void *obj, 
                           OCIObjectPropId propertyId,
                           void *property, ub4 *size );
#line 1592
sword OCIObjectIsLocked(    OCIEnv *env, OCIError *err, void *ins,
                              boolean *lock);
#line 1619
sword OCIObjectIsDirty(    OCIEnv *env, OCIError *err, void *ins,
                           boolean *dirty);
#line 1646
sword OCIObjectPinTable(    OCIEnv *env, OCIError *err, const OCISvcCtx *svc, 
                  const oratext *schema_name, 
                  ub4 s_n_length, const oratext *object_name, ub4 o_n_length, 
                  const OCIRef *scope_obj_ref, OCIDuration pin_duration, 
                  void** object    );
#line 1682
sword OCIObjectArrayPin(OCIEnv *env, OCIError *err, OCIRef **ref_array, 
                  ub4 array_size, OCIComplexObject **cor_array,
                  ub4 cor_array_size, OCIPinOpt pin_option, 
                  OCIDuration pin_duration, OCILockOpt lock, 
                  void **obj_array, ub4 *pos    );
#line 1731
sword OCICacheFlush(    OCIEnv *env, OCIError *err, const OCISvcCtx *svc, 
                  void *context, OCIRef *(*get)(void *context, ub1 *last),
                  OCIRef **ref  );
#line 1791
sword OCICacheRefresh(OCIEnv *env, OCIError *err, const OCISvcCtx *svc,
                  OCIRefreshOpt option, void *context,
                  OCIRef *(*get)(void *context), OCIRef **ref);
#line 1847
sword OCICacheUnpin(    OCIEnv *env, OCIError *err, const OCISvcCtx *svc    );
#line 1875
sword OCICacheFree(    OCIEnv *env, OCIError *err, const OCISvcCtx *svc    ); 
#line 1903
sword OCICacheUnmark(    OCIEnv *env, OCIError *err, const OCISvcCtx *svc    );
#line 1930
sword OCIDurationBegin(    OCIEnv *env, OCIError *err, const OCISvcCtx *svc, 
                           OCIDuration parent, OCIDuration *dur    );
#line 1997
sword OCIDurationEnd(    OCIEnv *env, OCIError *err, const OCISvcCtx *svc, 
                         OCIDuration duration    );
#line 2050
sword OCIDurationGetParent(    OCIEnv *env, OCIError *err, 
                               OCIDuration duration, OCIDuration *parent    );

sword OCIObjectAlwaysLatest(    OCIEnv *env, OCIError *err, void *object    );

sword OCIObjectNotAlwaysLatest(    OCIEnv *env, OCIError *err, 
                                   void *object    );

sword OCIObjectFlushRefresh(    OCIEnv *env, OCIError *err, void *object);

sword OCIObjectIsLoaded(    OCIEnv *env, OCIError *err, void *ins, 
                              boolean *load);

sword OCIObjectIsDirtied(    OCIEnv *env, OCIError *err, void *ins,
                              boolean *dirty);

sword OCICacheGetObjects(       OCIEnv *env, OCIError *err,
                                const OCISvcCtx *svc,
                                OCIObjectProperty property,
                                void *client_context,
                                void (*client_callback)(
                                    void *client_context,
                                    void *object  ));

sword OCICacheRegister(      OCIEnv *env, OCIError *err,
                             OCIObjectEvent event,
                             void *client_context,
                             void (*client_callback)(
                                    void *client_context,
                                    OCIObjectEvent event,
                                    void *object));

sword OCICacheFlushRefresh(    OCIEnv *env, OCIError *err, 
                               const OCISvcCtx *svc, void *context,
                               OCIRef *(*get)(void *context, ub1 *last),
                               OCIRef **ref    );

sword OCIObjectSetData(OCIEnv *env, OCIError *err, void *obj_hdr, 
        void *data);

sword OCIObjectGetNewOID(OCIEnv *env, OCIError *err, OCISvcCtx *svc, 
        ub1 *oid);
#line 479 "/oracle/app/product/10.2.0/db_1/rdbms/public/orl.h"
struct OCINumber
{
  ub1 OCINumberPart[22];
};
typedef struct OCINumber OCINumber;
#line 601
sword OCINumberInc(    OCIError *err, OCINumber *number    );
#line 624
sword OCINumberDec(    OCIError *err, OCINumber *number    );
#line 647
void OCINumberSetZero(    OCIError *err, OCINumber *num    );
#line 659
void OCINumberSetPi(    OCIError *err, OCINumber *num    );
#line 670
sword OCINumberAdd(    OCIError *err, const OCINumber *number1, 
                       const OCINumber *number2, OCINumber *result    );
#line 692
sword OCINumberSub(    OCIError *err, const OCINumber *number1, 
                       const OCINumber *number2, OCINumber *result    );
#line 714
sword OCINumberMul(    OCIError *err, const OCINumber *number1, 
                       const OCINumber *number2, OCINumber *result    );
#line 736
sword OCINumberDiv(    OCIError *err, const OCINumber *number1, 
                       const OCINumber *number2, OCINumber *result    );
#line 762
sword OCINumberMod(    OCIError *err, const OCINumber *number1, 
                       const OCINumber *number2, OCINumber *result    );
#line 786
sword OCINumberIntPower(    OCIError *err, const OCINumber *base,
                            const sword exp, OCINumber *result    );
#line 810
sword OCINumberShift(    OCIError *err, const OCINumber *number,
                            const sword nDig, OCINumber *result    );
#line 834
sword OCINumberNeg(    OCIError *err, const OCINumber *number,
                       OCINumber *result    );
#line 856
sword OCINumberToText(    OCIError *err, const OCINumber *number, 
                          const oratext *fmt, ub4 fmt_length,
                          const oratext *nls_params, ub4 nls_p_length,
                          ub4 *buf_size, oratext *buf    );
#line 901
sword OCINumberFromText(    OCIError *err, const oratext *str, 
                          ub4 str_length, const oratext *fmt, ub4 fmt_length, 
                          const oratext *nls_params, ub4 nls_p_length, 
                          OCINumber *number    );
#line 942
sword OCINumberToInt(    OCIError *err, const OCINumber *number,
                         uword rsl_length, uword rsl_flag, void *rsl    );
#line 971
sword OCINumberFromInt(    OCIError *err, const void *inum, uword inum_length,
                         uword inum_s_flag, OCINumber *number    );
#line 1000
sword OCINumberToReal(    OCIError *err, const OCINumber *number,
                          uword rsl_length, void *rsl    );
#line 1028
sword OCINumberToRealArray(  OCIError *err, const OCINumber **number,
                             uword elems, uword rsl_length, void *rsl    );
#line 1057
sword OCINumberFromReal(    OCIError *err, const void *rnum,
                            uword rnum_length, OCINumber *number    );
#line 1083
sword OCINumberCmp(    OCIError *err, const OCINumber *number1, 
                       const OCINumber *number2, sword *result    );
#line 1106
sword OCINumberSign(    OCIError *err, const OCINumber *number,
                        sword *result    );
#line 1129
sword OCINumberIsZero(    OCIError *err, const OCINumber *number,
                          boolean *result    );
#line 1151
sword OCINumberIsInt(    OCIError *err, const OCINumber *number,
                          boolean *result    );
#line 1173
sword OCINumberAssign(    OCIError *err, const OCINumber *from,
                          OCINumber *to    );
#line 1195
sword OCINumberAbs(    OCIError *err, const OCINumber *number,
                       OCINumber *result    );
#line 1218
sword OCINumberCeil(    OCIError *err, const OCINumber *number,
                        OCINumber *result    );
#line 1241
sword OCINumberFloor(    OCIError *err, const OCINumber *number, 
                         OCINumber *result    );
#line 1264
sword OCINumberSqrt(    OCIError *err, const OCINumber *number, 
                       OCINumber *result    );
#line 1288
sword OCINumberTrunc(    OCIError *err, const OCINumber *number, 
                         sword decplace, OCINumber *result    );
#line 1313
sword OCINumberPower(    OCIError *err, const OCINumber *base, 
                         const OCINumber *number, OCINumber *result    );
#line 1337
sword OCINumberRound(    OCIError *err, const OCINumber *number,
                         sword decplace, OCINumber *result    );
#line 1362
sword OCINumberPrec(    OCIError *err, const OCINumber *number,
                         eword nDigs, OCINumber *result    );
#line 1387
sword OCINumberSin(    OCIError *err, const OCINumber *number,
                       OCINumber *result    );
#line 1409
sword OCINumberArcSin(    OCIError *err, const OCINumber *number,
                          OCINumber *result    );
#line 1432
sword OCINumberHypSin(    OCIError *err, const OCINumber *number, 
                          OCINumber *result    );
#line 1457
sword OCINumberCos(    OCIError *err, const OCINumber *number, 
                       OCINumber *result    );
#line 1479
sword OCINumberArcCos(    OCIError *err, const OCINumber *number, 
                          OCINumber *result    );
#line 1502
sword OCINumberHypCos(    OCIError *err, const OCINumber *number, 
                          OCINumber *result    );
#line 1527
sword OCINumberTan(    OCIError *err, const OCINumber *number, 
                       OCINumber *result    );
#line 1549
sword OCINumberArcTan(    OCIError *err, const OCINumber *number, 
                          OCINumber *result    );
#line 1571
sword OCINumberArcTan2(    OCIError *err, const OCINumber *number1, 
                           const OCINumber *number2, OCINumber *result    );
#line 1597
sword OCINumberHypTan(    OCIError *err, const OCINumber *number, 
                          OCINumber *result    );
#line 1622
sword OCINumberExp(    OCIError *err, const OCINumber *number, 
                       OCINumber *result    );
#line 1644
sword OCINumberLn(    OCIError *err, const OCINumber *number, 
                      OCINumber *result    );
#line 1668
sword OCINumberLog(    OCIError *err, const OCINumber *base, 
                       const OCINumber *number, OCINumber *result    );
#line 1695
struct OCITime
{
  ub1 OCITimeHH;                           
  ub1 OCITimeMI;                      
  ub1 OCITimeSS;                      
};
typedef struct OCITime OCITime;
#line 1711
struct OCIDate
{
  sb2 OCIDateYYYY;          
  ub1 OCIDateMM;                           
  ub1 OCIDateDD;                              
  OCITime OCIDateTime;                                                
};
typedef struct OCIDate OCIDate;
#line 1872
sword OCIDateAssign(    OCIError *err, const OCIDate *from, 
                        OCIDate *to    );
#line 1891
sword OCIDateToText(    OCIError *err, const OCIDate *date, 
                        const oratext *fmt, ub1 fmt_length, 
                        const oratext *lang_name, ub4 lang_length, 
                        ub4 *buf_size, oratext *buf    );
#line 1936
sword OCIDateFromText(    OCIError *err, const oratext *date_str, 
                        ub4 d_str_length, const oratext *fmt, ub1 fmt_length, 
                        const oratext *lang_name, ub4 lang_length, 
                        OCIDate *date    );
#line 1975
sword OCIDateCompare(    OCIError *err, const OCIDate *date1, 
                     const OCIDate *date2, sword *result    );
#line 2001
sword OCIDateAddMonths(    OCIError *err, const OCIDate *date, sb4 num_months,
                           OCIDate *result    );
#line 2032
sword OCIDateAddDays(    OCIError *err, const OCIDate *date, sb4 num_days,
                         OCIDate *result    );
#line 2058
sword OCIDateLastDay(    OCIError *err, const OCIDate *date, 
                         OCIDate *last_day    );
#line 2082
sword OCIDateDaysBetween(    OCIError *err, const OCIDate *date1, 
                             const OCIDate *date2, sb4 *num_days    );
#line 2106
sword OCIDateZoneToZone(    OCIError *err, const OCIDate *date1,
                            const oratext *zon1,
                            ub4 zon1_length, const oratext *zon2, 
                            ub4 zon2_length, OCIDate *date2    );
#line 2138
sword OCIDateNextDay(    OCIError *err, const OCIDate *date, 
                         const oratext *day_p, ub4 day_length, 
                         OCIDate *next_day    );
#line 2186
sword OCIDateCheck(    OCIError *err, const OCIDate *date, uword *valid    );
#line 2233
sword OCIDateSysDate(    OCIError *err, OCIDate *sys_date    );
#line 2276
typedef struct OCIString OCIString;
#line 2280
sword OCIStringAssign(    OCIEnv *env, OCIError *err, const OCIString *rhs, 
                          OCIString **lhs    );
#line 2306
sword OCIStringAssignText(    OCIEnv *env, OCIError *err, const oratext *rhs, 
                              ub4 rhs_len, OCIString **lhs    );
#line 2333
sword OCIStringResize(    OCIEnv *env, OCIError *err, ub4 new_size, 
                          OCIString **str    );
#line 2368
ub4 OCIStringSize(    OCIEnv *env, const OCIString *vs    );
#line 2382
oratext *OCIStringPtr(    OCIEnv *env, const OCIString *vs    );
#line 2396
sword OCIStringAllocSize(    OCIEnv *env, OCIError *err, const OCIString *vs, 
                             ub4 *allocsize    );
#line 2436
typedef struct OCIRaw OCIRaw;
#line 2440
sword OCIRawAssignRaw(    OCIEnv *env, OCIError *err, const OCIRaw *rhs, 
                          OCIRaw **lhs    );
#line 2465
sword OCIRawAssignBytes(    OCIEnv *env, OCIError *err, const ub1 *rhs, 
                            ub4 rhs_len, OCIRaw **lhs    );
#line 2491
sword OCIRawResize(    OCIEnv *env, OCIError *err, ub4 new_size, 
                       OCIRaw **raw    );
#line 2524
ub4 OCIRawSize(    OCIEnv * env, const OCIRaw *raw    );
#line 2537
ub1 *OCIRawPtr(    OCIEnv * env, const OCIRaw *raw    );
#line 2551
sword OCIRawAllocSize(    OCIEnv *env, OCIError *err, const OCIRaw *raw,
                          ub4 *allocsize    );
#line 2587
void OCIRefClear(    OCIEnv *env, OCIRef *ref    );
#line 2607
sword OCIRefAssign(    OCIEnv *env, OCIError *err, const OCIRef *source, 
                       OCIRef **target    );
#line 2632
boolean OCIRefIsEqual(    OCIEnv *env, const OCIRef *x, const OCIRef *y    );
#line 2652
boolean OCIRefIsNull(    OCIEnv *env, const OCIRef *ref    );
#line 2673
ub4 OCIRefHexSize(    OCIEnv *env, const OCIRef *ref    );
#line 2689
sword OCIRefFromHex(    OCIEnv *env, OCIError *err, const OCISvcCtx *svc, 
                        const oratext *hex, ub4 length, OCIRef **ref    );
#line 2720
sword OCIRefToHex(    OCIEnv *env, OCIError *err, const OCIRef *ref, 
                      oratext *hex, ub4 *hex_length    );
#line 2807
typedef struct OCIColl OCIColl;
#line 2810
typedef OCIColl OCIArray;
#line 2813
typedef OCIColl OCITable;
#line 2816
typedef struct OCIIter OCIIter;
#line 2820
sword OCICollSize( OCIEnv *env, OCIError *err, const OCIColl *coll, 
                   sb4 *size );
#line 2867
sb4 OCICollMax(    OCIEnv *env, const OCIColl *coll    );
#line 2886
sword OCICollGetElem(    OCIEnv *env, OCIError *err, const OCIColl *coll, 
                         sb4 index, boolean *exists, void **elem, 
                         void **elemind    );
#line 2964
sword OCICollGetElemArray(  OCIEnv *env, OCIError *err, const OCIColl *coll, 
                            sb4 index, boolean *exists, void **elem, 
                            void **elemind, uword *nelems);
#line 3043
sword OCICollAssignElem(    OCIEnv *env, OCIError *err, sb4 index, 
                            const void *elem, 
                            const void *elemind, OCIColl *coll    );
#line 3081
sword OCICollAssign(    OCIEnv *env, OCIError *err, const OCIColl *rhs, 
                        OCIColl *lhs    );
#line 3117
sword OCICollAppend(    OCIEnv *env, OCIError *err, const void *elem, 
                        const void *elemind, OCIColl *coll    );
#line 3156
sword OCICollTrim(    OCIEnv *env, OCIError *err, sb4 trim_num, 
                      OCIColl *coll    );
#line 3185
sword OCICollIsLocator(OCIEnv *env, OCIError *err, const OCIColl *coll,
                       boolean *result );
#line 3209
sword OCIIterCreate(    OCIEnv *env, OCIError *err, const OCIColl *coll, 
                        OCIIter **itr    );
#line 3245
sword OCIIterDelete(    OCIEnv *env, OCIError *err, OCIIter **itr    );
#line 3269
sword OCIIterInit(    OCIEnv *env, OCIError *err, const OCIColl *coll, 
                      OCIIter *itr    );
#line 3298
sword OCIIterGetCurrent(    OCIEnv *env, OCIError *err, const OCIIter *itr, 
                            void **elem, void **elemind    );
#line 3326
sword OCIIterNext(    OCIEnv *env, OCIError *err, OCIIter *itr, 
                      void **elem, void **elemind, boolean *eoc    );
#line 3361
sword OCIIterPrev(    OCIEnv *env, OCIError *err, OCIIter *itr, 
                      void **elem, void **elemind, boolean *boc    );
#line 3401
sword OCITableSize( OCIEnv *env, OCIError *err, const OCITable *tbl, 
                    sb4 *size);
#line 3444
sword OCITableExists(    OCIEnv *env, OCIError *err, const OCITable *tbl,
                             sb4 index, boolean *exists    );
#line 3470
sword OCITableDelete(    OCIEnv *env, OCIError *err, sb4 index, 
                      OCITable *tbl    );
#line 3499
sword OCITableFirst(    OCIEnv *env, OCIError *err, const OCITable *tbl, 
                        sb4 *index     );
#line 3524
sword OCITableLast(    OCIEnv *env, OCIError *err, const OCITable *tbl, 
                       sb4 *index     );
#line 3549
sword OCITableNext(    OCIEnv *env, OCIError *err, sb4 index, 
                       const OCITable *tbl, sb4 *next_index,
                       boolean *exists    );
#line 3578
sword OCITablePrev(    OCIEnv *env, OCIError *err, sb4 index, 
                       const OCITable *tbl, sb4 *prev_index,
                       boolean *exists    );
#line 3623
typedef struct OCIXMLType OCIXMLType;
#line 3626
typedef struct OCIDOMDocument OCIDOMDocument;
#line 88 "/oracle/app/product/10.2.0/db_1/rdbms/public/ociextp.h"
typedef struct OCIExtProcContext OCIExtProcContext;
#line 264
void *ociepacm(OCIExtProcContext *with_context, size_t amount);
#line 268
size_t ocieperr(OCIExtProcContext *with_context, int error_number);
#line 272
size_t ociepmsg(OCIExtProcContext *with_context, int error_number,
                oratext *error_message, size_t len );
#line 277
sword ociepgoe(OCIExtProcContext *with_context, OCIEnv **envh, 
               OCISvcCtx **svch, OCIError **errh);
#line 46 "/oracle/app/product/10.2.0/db_1/rdbms/public/ociapr.h"
sword  obindps(struct cda_def *cursor, ub1 opcode, OraText *sqlvar, 
	       sb4 sqlvl, ub1 *pvctx, sb4 progvl, 
	       sword ftype, sword scale,
	       sb2 *indp, ub2 *alen, ub2 *arcode, 
	       sb4 pv_skip, sb4 ind_skip, sb4 alen_skip, sb4 rc_skip,
	       ub4 maxsiz, ub4 *cursiz,
	       OraText *fmt, sb4 fmtl, sword fmtt);
sword  obreak(struct cda_def *lda);
sword  ocan  (struct cda_def *cursor);
sword  oclose(struct cda_def *cursor);
sword  ocof  (struct cda_def *lda);
sword  ocom  (struct cda_def *lda);
sword  ocon  (struct cda_def *lda);
#line 64
sword  odefinps(struct cda_def *cursor, ub1 opcode, sword pos,ub1 *bufctx,
		sb4 bufl, sword ftype, sword scale, 
		sb2 *indp, OraText *fmt, sb4 fmtl, sword fmtt, 
		ub2 *rlen, ub2 *rcode,
		sb4 pv_skip, sb4 ind_skip, sb4 alen_skip, sb4 rc_skip);
sword  odessp(struct cda_def *cursor, OraText *objnam, size_t onlen,
              ub1 *rsv1, size_t rsv1ln, ub1 *rsv2, size_t rsv2ln,
              ub2 *ovrld, ub2 *pos, ub2 *level, OraText **argnam,
              ub2 *arnlen, ub2 *dtype, ub1 *defsup, ub1* mode,
              ub4 *dtsiz, sb2 *prec, sb2 *scale, ub1 *radix,
              ub4 *spare, ub4 *arrsiz);
sword  odescr(struct cda_def *cursor, sword pos, sb4 *dbsize,
                 sb2 *dbtype, sb1 *cbuf, sb4 *cbufl, sb4 *dsize,
                 sb2 *prec, sb2 *scale, sb2 *nullok);
sword  oerhms   (struct cda_def *lda, sb2 rcode, OraText *buf,
                 sword bufsiz);
sword  oermsg   (sb2 rcode, OraText *buf);
sword  oexec    (struct cda_def *cursor);
sword  oexfet   (struct cda_def *cursor, ub4 nrows,
                 sword cancel, sword exact);
sword  oexn     (struct cda_def *cursor, sword iters, sword rowoff);
sword  ofen     (struct cda_def *cursor, sword nrows);
sword  ofetch   (struct cda_def *cursor);
sword  oflng    (struct cda_def *cursor, sword pos, ub1 *buf,
                 sb4 bufl, sword dtype, ub4 *retl, sb4 offset);
sword  ogetpi   (struct cda_def *cursor, ub1 *piecep, void **ctxpp, 
                 ub4 *iterp, ub4 *indexp);
sword  oopt     (struct cda_def *cursor, sword rbopt, sword waitopt);
sword  opinit   (ub4 mode);
sword  olog     (struct cda_def *lda, ub1* hda,
                 OraText *uid, sword uidl,
                 OraText *pswd, sword pswdl, 
                 OraText *conn, sword connl, 
                 ub4 mode);
sword  ologof   (struct cda_def *lda);
sword  oopen    (struct cda_def *cursor, struct cda_def *lda,
                 OraText *dbn, sword dbnl, sword arsize,
                 OraText *uid, sword uidl);
sword  oparse   (struct cda_def *cursor, OraText *sqlstm, sb4 sqllen,
                 sword defflg, ub4 lngflg);
sword  orol     (struct cda_def *lda);
sword  osetpi   (struct cda_def *cursor, ub1 piece, void *bufp, ub4 *lenp);

void sqlld2     (struct cda_def *lda, OraText *cname, sb4 *cnlen);
void sqllda     (struct cda_def *lda);
#line 111
sword onbset    (struct cda_def *lda ); 
sword onbtst    (struct cda_def *lda ); 
sword onbclr    (struct cda_def *lda ); 
sword ognfd     (struct cda_def *lda, void *fdp);
#line 124
sword  obndra(struct cda_def *cursor, OraText *sqlvar, sword sqlvl,
                 ub1 *progv, sword progvl, sword ftype, sword scale,
                 sb2 *indp, ub2 *alen, ub2 *arcode, ub4 maxsiz,
                 ub4 *cursiz, OraText *fmt, sword fmtl, sword fmtt);
sword  obndrn(struct cda_def *cursor, sword sqlvn, ub1 *progv,
                 sword progvl, sword ftype, sword scale, sb2 *indp,
                 OraText *fmt, sword fmtl, sword fmtt);
sword  obndrv(struct cda_def *cursor, OraText *sqlvar, sword sqlvl,
                 ub1 *progv, sword progvl, sword ftype, sword scale,
                 sb2 *indp, OraText *fmt, sword fmtl, sword fmtt);
#line 138
sword  odefin(struct cda_def *cursor, sword pos, ub1 *buf,
	      sword bufl, sword ftype, sword scale, sb2 *indp,
	      OraText *fmt, sword fmtl, sword fmtt, ub2 *rlen, ub2 *rcode);
#line 144
sword  oname    (struct cda_def *cursor, sword pos, sb1 *tbuf,
                 sb2 *tbufl, sb1 *buf, sb2 *bufl);
sword  orlon    (struct cda_def *lda, ub1 *hda, 
                 OraText *uid, sword uidl, 
                 OraText *pswd, sword pswdl, 
                 sword audit);
sword  olon     (struct cda_def *lda, OraText *uid, sword uidl,
                 OraText *pswd, sword pswdl, sword audit);
sword  osql3    (struct cda_def *cda, OraText *sqlstm, sword sqllen);
sword  odsc     (struct cda_def *cursor, sword pos, sb2 *dbsize,
                 sb2 *fsize, sb2 *rcode, sb2 *dtype, sb1 *buf,
                 sb2 *bufl, sb2 *dsize);
extern "C" {
#line 40 "/usr/include/stdarg.h"
extern "C" {
#line 95
}
}
#line 5 "/usr/vacpp/include/stdarg.h"
extern "C" {

}
#line 127 "/oracle/app/product/10.2.0/db_1/rdbms/public/nzerror.h"
typedef enum nzerror
{
  NZERROR_OK = 0,
  NZERROR_GENERIC = 28750,                           
  NZERROR_NO_MEMORY = 28751,                                
  NZERROR_DATA_SOURCE_INIT_FAILED = 28752,      
  NZERROR_DATA_SOURCE_TERM_FAILED = 28753, 
  NZERROR_OBJECT_STORE_FAILED = 28754,  
  NZERROR_OBJECT_GET_FAILED = 28755,

  NZERROR_MEMORY_ALLOC_FAILED = 28756,

  NZERROR_MEMORY_ALLOC_0_BYTES = 28757,

  NZERROR_MEMORY_FREE_FAILED = 28758,

  NZERROR_FILE_OPEN_FAILED = 28759,

  NZERROR_LIST_CREATION_FAILED = 28760,

  NZERROR_NO_ELEMENT = 28761,

  NZERROR_ELEMENT_ADD_FAILED = 28762,

  NZERROR_PARAMETER_BAD_TYPE = 28763,

  NZERROR_PARAMETER_RETRIEVAL = 28764,       

  NZERROR_NO_LIST = 28765,                 
  NZERROR_TERMINATE_FAIL = 28766,                      
  NZERROR_BAD_VERSION_NUMBER = 28767,                   
  NZERROR_BAD_MAGIC_NUMBER = 28768,                       
  NZERROR_METHOD_NOT_FOUND = 28769,

  NZERROR_ALREADY_INITIALIZED = 28770,

  NZERROR_NOT_INITIALIZED = 28771,      
  NZERROR_BAD_FILE_ID = 28772,                              
  NZERROR_WRITE_MAGIC_VERSION = 28773,   
  NZERROR_FILE_WRITE_FAILED = 28774,               
  NZERROR_FILE_CLOSE_FAILED = 28775,                  
  NZERROR_OUTPUT_BUFFER_TOO_SMALL = 28776,

  NZERROR_BINDING_CREATION_FAILED = 28777, 
  NZERROR_PARAMETER_MALFORMED = 28778,     
  NZERROR_PARAMETER_NO_METHOD = 28779,

  NZERROR_BAD_PARAMETER_METHOD = 28780,       
  NZERROR_PARAMETER_NO_DATA = 28781,     
  NZERROR_NOT_ALLOCATED = 28782,              
  NZERROR_INVALID_PARAMETER = 28783,                
  NZERROR_FILE_NAME_TRANSLATION = 28784, 
  NZERROR_NO_SUCH_PARAMETER = 28785,    

  NZERROR_DECRYPT_FAILED = 28786,  

  NZERROR_ENCRYPT_FAILED = 28787,      

  NZERROR_INVALID_INPUT = 28788,       

  NZERROR_NAME_TYPE_NOT_FOUND = 28789,

  NZERROR_NLS_STRING_OPEN_FAILED = 28790,

  NZERROR_CERTIFICATE_VERIFY = 28791,       
  NZERROR_OCI_PLSQL_FAILED = 28792,

  NZERROR_OCI_BIND_FAILED = 28793,

  NZERROR_ATTRIBUTE_INIT = 28794,            
  NZERROR_ATTRIBUTE_FINISH_FAILED = 28795, 
  NZERROR_UNSUPPORTED_METHOD = 28796,  
  NZERROR_INVALID_KEY_DATA_TYPE = 28797,

  NZEROR_BIND_SUBKEY_COUNT = 28798,

  NZERROR_AUTH_SHARED_MEMORY = 28799,

  NZERROR_RIO_OPEN = 28800,                                
  NZERROR_RIO_OBJECT_TYPE = 28801,                 
  NZERROR_RIO_MODE = 28802,                               
  NZERROR_RIO_IO = 28803,                      
  NZERROR_RIO_CLOSE = 28804,                              
  NZERROR_RIO_RETRIEVE = 28805,                        
  NZERROR_RIO_STORE = 28806,                              
  NZERROR_RIO_UPDATE = 28807,                            
  NZERROR_RIO_INFO = 28808,                                
  NZERROR_RIO_DELETE = 28809,                            
  NZERROR_KD_CREATE = 28810,                  
  NZERROR_RIO_ACCESS_DESCRIPTOR = 28811,         
  NZERROR_RIO_RECORD = 28812,                               
  NZERROR_RIO_RECORD_TYPE = 28813,     
  NZERROR_PLSQL_ORACLE_TO_REAL = 28814,

  NZERROR_PLSQL_REAL_TO_ORACLE = 28815,

  NZERROR_TK_PLSQL_NO_PASSWORD = 28816,

  NZERROR_TK_PLSQL_GENERIC = 28817,

  NZERROR_TK_PLSQL_NO_CONTEXT = 28818,

  NZERROR_TK_PLSQL_NO_DIST_NAME = 28819,

  NZERROR_TK_PLSQL_NO_STATE = 28820,

  NZERROR_TK_PLSQL_NO_INPUT = 28821,

  NZERROR_TK_PLSQL_NO_SEED = 28822,

  NZERROR_TK_PLSQL_NO_BYTES = 28823,

  NZERROR_TK_INVALID_STATE = 28824,

  NZERROR_TK_PLSQL_NO_ENG_FUNC = 28825,

  NZERROR_TK_INV_ENG_FUNC = 28826,

  NZERROR_TK_INV_CIPHR_TYPE = 28827,

  NZERROR_TK_INV_IDENT_TYPE = 28828,

  NZERROR_TK_PLSQL_NO_CIPHER_TYPE = 28829,

  NZERROR_TK_PLSQL_NO_IDENT_TYPE = 28830,

  NZERROR_TK_PLSQL_NO_DATA_FMT = 28831,

  NZERROR_TK_INV_DATA_FMT = 28832,

  NZERROR_TK_PLSQL_INSUFF_INFO = 28833,

  NZERROR_TK_PLSQL_BUF_TOO_SMALL = 28834,

  NZERROR_TK_PLSQL_INV_IDENT_DESC = 28835,

  NZERROR_TK_PLSQL_WALLET_NOTOPEN = 28836,

  NZERROR_TK_PLSQL_NO_WALLET = 28837,

  NZERROR_TK_PLSQL_NO_IDENTITY = 28838,

  NZERROR_TK_PLSQL_NO_PERSONA = 28839,

  NZERROR_TK_PLSQL_WALLET_OPEN = 28840,

  NZERROR_UNSUPPORTED = 28841,                  
  NZERROR_FILE_BAD_PERMISSION = 28842,       
  NZERROR_FILE_OSD_ERROR = 28843,              
  NZERROR_NO_WALLET  = 28844,   
  NZERROR_NO_CERTIFICATE_ALERT    = 28845,   
  NZERROR_NO_PRIVATE_KEY          = 28846,   
  NZERROR_NO_CLEAR_PRIVATE_KEY_FILE   = 28847,    
  NZERROR_NO_ENCRYPTED_PRIVATE_KEY_FILE = 28848,   
  NZERROR_NO_TRUSTPOINTS     = 28849,        
  NZERROR_NO_CLEAR_TRUSTPOINT_FILE    = 28850,    
  NZERROR_NO_ENCRYPTED_TRUSTPOINT_FILE = 28851,    
  NZERROR_BAD_PASSWORD    = 28852,    
  NZERROR_INITIALIZATION_FAILED   =  28853, 
#line 299
  NZERROR_SSLMemoryErr = 28854,
  NZERROR_SSLUnsupportedErr = 28855,
  NZERROR_SSLOverflowErr = 28856,
  NZERROR_SSLUnknownErr = 28857,
  NZERROR_SSLProtocolErr = 28858,
  NZERROR_SSLNegotiationErr = 28859,
  NZERROR_SSLFatalAlert = 28860,
  NZERROR_SSLWouldBlockErr = 28861,
  NZERROR_SSLIOErr = 28862,
  NZERROR_SSLSessionNotFoundErr = 28863,
  NZERROR_SSLConnectionClosedGraceful = 28864,
  NZERROR_SSLConnectionClosedError = 28865,
  NZERROR_ASNBadEncodingErr = 28866,
  NZERROR_ASNIntegerTooBigErr = 28867,
  NZERROR_X509CertChainInvalidErr = 28868,
  NZERROR_X509CertExpiredErr = 28869,
  NZERROR_X509NamesNotEqualErr = 28870,
  NZERROR_X509CertChainIncompleteErr = 28871,
  NZERROR_X509DataNotFoundErr = 28872,
  NZERROR_SSLBadParameterErr = 28873,
  NZERROR_SSLIOClosedOverrideGoodbyeKiss = 28874,
  NZERROR_X509MozillaSGCErr  =  28875,
  NZERROR_X509IESGCErr       =  28876,
  NZERROR_ImproperServerCredentials = 28877,
  NZERROR_ImproperClientCredentials = 28878,
  NZERROR_NoProtocolSideSet = 28879,
  NZERROR_setPersonaFailed = 28880,
  NZERROR_setCertFailed = 28881,
  NZERROR_setVKeyFailed = 28882,
  NZERROR_setTPFailed = 28883,
  NZERROR_BadCipherSuite = 28884,
  NZERROR_NoKeyPairForKeyUsage = 28885,
#line 333
  NZERROR_EntrustLoginFailed = 28890,
  NZERROR_EntrustGetInfoFailed = 28891,
  NZERROR_EntrustLoadCertificateFailed = 28892,
  NZERROR_EntrustGetNameFailed = 28893,
#line 339
  NZERROR_CertNotInstalled = 29000,
  NZERROR_ServerDNMisMatched = 29002,
  NZERROR_ServerDNMisConfigured = 29003,
#line 346
  NZERROR_CIC_ERR_SSL_ALERT_CB_FAILURE = 29004,
  NZERROR_CIC_ERR_SSL_BAD_CERTIFICATE = 29005,
  NZERROR_CIC_ERR_SSL_BAD_CERTIFICATE_REQUEST = 29006,
  NZERROR_CIC_ERR_SSL_BAD_CLEAR_KEY_LEN = 29007,
  NZERROR_CIC_ERR_SSL_BAD_DHPARAM_KEY_LENGTH = 29008,
  NZERROR_CIC_ERR_SSL_BAD_ENCRYPTED_KEY_LEN = 29009,
  NZERROR_CIC_ERR_SSL_BAD_EXPORT_KEY_LENGTH = 29010,
  NZERROR_CIC_ERR_SSL_BAD_FINISHED_MESSAGE = 29011,
  NZERROR_CIC_ERR_SSL_BAD_KEY_ARG_LEN = 29012,
  NZERROR_CIC_ERR_SSL_BAD_MAC = 29013,
  NZERROR_CIC_ERR_SSL_BAD_MAX_FRAGMENT_LENGTH_EXTENSION = 29014,
  NZERROR_CIC_ERR_SSL_BAD_MESSAGE_LENGTH = 29015,
  NZERROR_CIC_ERR_SSL_BAD_PKCS1_PADDING = 29016,
  NZERROR_CIC_ERR_SSL_BAD_PREMASTER_SECRET_LENGTH = 29017,
  NZERROR_CIC_ERR_SSL_BAD_PREMASTER_SECRET_VERSION = 29018,
  NZERROR_CIC_ERR_SSL_BAD_PROTOCOL_VERSION = 29019,
  NZERROR_CIC_ERR_SSL_BAD_RECORD_LENGTH = 29020,
  NZERROR_CIC_ERR_SSL_BAD_SECRET_KEY_LEN = 29021,
  NZERROR_CIC_ERR_SSL_BAD_SIDE = 29022,
  NZERROR_CIC_ERR_SSL_BUFFERS_NOT_EMPTY = 29023,
  NZERROR_CIC_ERR_SSL_CERTIFICATE_VALIDATE_FAILED = 29024,
  NZERROR_CIC_ERR_SSL_CERT_CHECK_CALLBACK = 29025,
  NZERROR_CIC_ERR_SSL_DECRYPT_FAILED = 29026,
  NZERROR_CIC_ERR_SSL_ENTROPY_COLLECTION = 29027,
  NZERROR_CIC_ERR_SSL_FAIL_SERVER_VERIFY = 29028,
  NZERROR_CIC_ERR_SSL_HANDSHAKE_ALREADY_COMPLETED = 29029,
  NZERROR_CIC_ERR_SSL_HANDSHAKE_REQUESTED = 29030,
  NZERROR_CIC_ERR_SSL_HANDSHAKE_REQUIRED = 29031,
  NZERROR_CIC_ERR_SSL_INCOMPLETE_IDENTITY = 29032,
  NZERROR_CIC_ERR_SSL_INVALID_PFX = 29033,
  NZERROR_CIC_ERR_SSL_NEEDS_CIPHER_OR_CLIENTAUTH = 29034,
  NZERROR_CIC_ERR_SSL_NEEDS_PRNG = 29035,
  NZERROR_CIC_ERR_SSL_NOT_SUPPORTED = 29036,
  NZERROR_CIC_ERR_SSL_NO_CERTIFICATE = 29037,
  NZERROR_CIC_ERR_SSL_NO_MATCHING_CERTIFICATES = 29038,
  NZERROR_CIC_ERR_SSL_NO_MATCHING_CIPHER_SUITES = 29039,
  NZERROR_CIC_ERR_SSL_NO_SUPPORTED_CIPHER_SUITES = 29040,
  NZERROR_CIC_ERR_SSL_NULL_CB = 29041,
  NZERROR_CIC_ERR_SSL_READ_BUFFER_NOT_EMPTY = 29042,
  NZERROR_CIC_ERR_SSL_READ_REQUIRED = 29043,
  NZERROR_CIC_ERR_SSL_RENEGOTIATION_ALREADY_REQUESTED = 29044,
  NZERROR_CIC_ERR_SSL_RENEGOTIATION_REFUSED = 29045,
  NZERROR_CIC_ERR_SSL_RESUMABLE_SESSION = 29046,
  NZERROR_CIC_ERR_SSL_TLS_EXTENSION_MISMATCH = 29047,
  NZERROR_CIC_ERR_SSL_UNEXPECTED_MSG = 29048,
  NZERROR_CIC_ERR_SSL_UNKNOWN_RECORD = 29049,
  NZERROR_CIC_ERR_SSL_UNSUPPORTED_CLIENT_AUTH_MODE = 29050,
  NZERROR_CIC_ERR_SSL_UNSUPPORTED_PUBKEY_TYPE = 29051,
  NZERROR_CIC_ERR_SSL_WRITE_BUFFER_NOT_EMPTY = 29052,
  NZERROR_CIC_ERR_PKCS12_MISSING_ALG = 29053,
  NZERROR_CIC_ERR_PKCS_AUTH_FAILED = 29054,
  NZERROR_CIC_ERR_PKCS_BAD_CONTENT_TYPE = 29055,
  NZERROR_CIC_ERR_PKCS_BAD_INPUT = 29056,
  NZERROR_CIC_ERR_PKCS_BAD_PADDING = 29057,
  NZERROR_CIC_ERR_PKCS_BAD_SN = 29058,
  NZERROR_CIC_ERR_PKCS_BAD_SN_LENGTH = 29059,
  NZERROR_CIC_ERR_PKCS_BAD_VERSION = 29060,
  NZERROR_CIC_ERR_PKCS_BASE = 29061,
  NZERROR_CIC_ERR_PKCS_FIELD_NOT_PRESENT = 29062,
  NZERROR_CIC_ERR_PKCS_NEED_CERTVAL = 29063,
  NZERROR_CIC_ERR_PKCS_NEED_PASSWORD = 29064,
  NZERROR_CIC_ERR_PKCS_NEED_PKC = 29065,
  NZERROR_CIC_ERR_PKCS_NEED_PRV_KEY = 29066,
  NZERROR_CIC_ERR_PKCS_NEED_TRUSTED = 29067,
  NZERROR_CIC_ERR_PKCS_UNSUPPORTED_CERT_FORMAT = 29068,
  NZERROR_CIC_ERR_PKCS_UNSUP_PRVKEY_TYPE = 29069,
  NZERROR_CIC_ERR_CODING_BAD_PEM = 29070,
  NZERROR_CIC_ERR_CODING_BASE = 29071, 
  NZERROR_CIC_ERR_DER_BAD_ENCODING = 29072,
  NZERROR_CIC_ERR_DER_BAD_ENCODING_LENGTH = 29073,
  NZERROR_CIC_ERR_DER_BASE = 29074,
  NZERROR_CIC_ERR_DER_ELEMENT_TOO_LONG = 29075,
  NZERROR_CIC_ERR_DER_INDEFINITE_LENGTH = 29076,
  NZERROR_CIC_ERR_DER_NO_MORE_ELEMENTS = 29077,
  NZERROR_CIC_ERR_DER_OBJECT_TOO_LONG = 29078,
  NZERROR_CIC_ERR_DER_TAG_SIZE = 29079,
  NZERROR_CIC_ERR_DER_TIME_OUT_OF_RANGE = 29080,
  NZERROR_CIC_ERR_DER_UNUSED_BITS_IN_BIT_STR = 29081,
  NZERROR_CIC_ERR_GENERAL_BASE = 29082,
  NZERROR_CIC_ERR_HASH_BASE = 29083,
  NZERROR_CIC_ERR_ILLEGAL_PARAM = 29084,
  NZERROR_CIC_ERR_MEM_NOT_OURS = 29085,
  NZERROR_CIC_ERR_MEM_OVERRUN = 29086,
  NZERROR_CIC_ERR_MEM_UNDERRUN = 29087,
  NZERROR_CIC_ERR_MEM_WAS_FREED = 29088,
  NZERROR_CIC_ERR_NOT_FOUND = 29090,
  NZERROR_CIC_ERR_NO_PTR = 29091,
  NZERROR_CIC_ERR_TIMEOUT = 29092,
  NZERROR_CIC_ERR_UNIT_MASK = 29093,
  NZERROR_CIC_ERR_BAD_CTX = 29094,
  NZERROR_CIC_ERR_BAD_INDEX = 29095,
  NZERROR_CIC_ERR_BAD_LENGTH = 29096,
  NZERROR_CIC_ERR_CODING_BAD_ENCODING = 29097,
  NZERROR_CIC_ERR_SSL_NO_CLIENT_AUTH_MODES = 29098,
#line 443
  NZERROR_LOCKEYID_CREATE_FAILED = 29100,
  NZERROR_P12_ADD_PVTKEY_FAILED = 29101,
  NZERROR_P12_ADD_CERT_FAILED = 29102,
  NZERROR_P12_WLT_CREATE_FAILED = 29103,
  NZERROR_P12_ADD_CERTREQ_FAILED = 29104,
  NZERROR_P12_WLT_EXP_FAILED = 29105,
  NZERROR_P12_WLT_IMP_FAILED = 29106,
  NZERROR_P12_CREATE_FAILED = 29107,
  NZERROR_P12_DEST_FAILED = 29107,
  NZERROR_P12_RAND_ERROR = 29108, 
  NZERROR_P12_PVTKEY_CRT_FAILED = 29109,
  NZERROR_P12_INVALID_BAG = 29110,
  NZERROR_P12_INVALID_INDEX = 29111,
  NZERROR_P12_GET_CERT_FAILED = 29112,
  NZERROR_P12_GET_PVTKEY_FAILED = 29113,
  NZERROR_P12_IMP_PVTKEY_FAILED = 29114,
  NZERROR_P12_EXP_PVTKEY_FAILED = 29115,
  NZERROR_P12_GET_ATTRIB_FAILED = 29116,
  NZERROR_P12_ADD_ATTRIB_FAILED = 29117,
  NZERROR_P12_CRT_ATTRIB_FAILED = 29118,
  NZERROR_P12_IMP_CERT_FAILED = 29119,
  NZERROR_P12_EXP_CERT_FAILED = 29120,
  NZERROR_P12_ADD_SECRET_FAILED = 29121,
  NZERROR_P12_ADD_PKCS11INFO_FAILED = 29122,
  NZERROR_P12_GET_PKCS11INFO_FAILED = 29123,
  NZERROR_P12_MULTIPLE_PKCS11_LIBNAME = 29124,
  NZERROR_P12_MULTIPLE_PKCS11_TOKENLABEL = 29125,
  NZERROR_P12_MULTIPLE_PKCS11_TOKENPASSPHRASE = 29126,
  NZERROR_P12_UNKNOWN_PKCS11INFO = 29127,
  NZERROR_P12_PKCS11_LIBNAME_NOT_SET = 29128,
  NZERROR_P12_PKCS11_TOKENLABEL_NOT_SET = 29129,
  NZERROR_P12_PKCS11_TOKENPASSPHRASE_NOT_SET = 29130,
  NZERROR_P12_MULTIPLE_PKCS11_CERTLABEL = 29131,
#line 478
  NZERROR_CIC_ERR_RANDOM = 29135,
  NZERROR_CIC_ERR_SMALL_BUFFER = 29136,
  NZERROR_CIC_ERR_SSL_BAD_CONTEXT = 29137,
#line 483
  NZERROR_MUTEX_INITIALIZE_FAILED = 29138,
  NZERROR_MUTEX_DESTROY_FAILED = 29139,
#line 488
  NZERROR_BS_CERTOBJ_CREAT_FAILED = 29140,
  NZERROR_BS_DER_IMP_FAILED = 29141,
#line 493
  NZERROR_DES_SELF_TEST_FAILED = 29150,
  NZERROR_3DES_SELF_TEST_FAILED = 29151,
  NZERROR_SHA_SELF_TEST_FAILED = 29152,
  NZERROR_RSA_SELF_TEST_FAILED = 29153,
  NZERROR_DRNG_SELF_TEST_FAILED = 29154,
  NZERROR_CKEYPAIR_SELF_TEST_FAILED = 29155,
  NZERROR_CRNG_SELF_TEST_FAILED = 29156,
  NZERROR_FIPS_PATHNAME_ERROR = 29157,
  NZERROR_FIPS_LIB_OPEN_FAILED = 29158,
  NZERROR_FIPS_LIB_READ_ERROR = 29159,
  NZERROR_FIPS_LIB_DIFFERS = 29160,
  NZERROR_DAC_SELF_TEST_FAILED = 29161,
  NZERROR_NONFIPS_CIPHERSUITE = 29162,
  NZERROR_VENDOR_NOT_SUPPORTED_FIPS_MODE = 29163,
  NZERROR_EXTERNAL_PKCS12_NOT_SUPPORTED_FIPS_MODE = 29164,
  NZERROR_AES_SELF_TEST_FAILED = 29165,
#line 511
  NZERROR_CRL_SIG_VERIFY_FAILED = 29176,   
  NZERROR_CERT_NOT_IN_CRL = 29177, 

  NZERROR_CERT_IN_CRL = 29178,             
  NZERROR_CERT_IN_CRL_CHECK_FAILED = 29179,   
  NZERROR_INVALID_CERT_STATUS_PROTOCOL = 29180, 
  NZERROR_LDAP_OPEN_FAILED = 29181,   
  NZERROR_LDAP_BIND_FAILED = 29182,   
  NZERROR_LDAP_SEARCH_FAILED = 29183,   
  NZERROR_LDAP_RESULT_FAILED = 29184,   
  NZERROR_LDAP_FIRSTATTR_FAILED = 29185,   
  NZERROR_LDAP_GETVALUESLEN_FAILED = 29186,   
  NZERROR_LDAP_UNSUPPORTED_VALMEC = 29187, 

  NZERROR_LDAP_COUNT_ENTRIES_FAILED = 29188, 
  NZERROR_LDAP_NO_ENTRY_FOUND = 29189,  
  NZERROR_LDAP_MULTIPLE_ENTRIES_FOUND = 29190,  
  NZERROR_OID_INFO_NOT_SET = 29191, 
  NZERROR_LDAP_VALMEC_NOT_SET = 29192,  

  NZERROR_CRLDP_NO_CRL_FOUND = 29193,  

  NZERROR_CRL_NOT_IN_CACHE = 29194,   
  NZERROR_CRL_EXPIRED = 29195,        
#line 537
  NZERROR_DN_MATCH  =            29222,   
  NZERROR_CERT_CHAIN_CREATION  = 29223,  
#line 542
  NZERROR_NO_MATCHING_CERT_REQ = 29224,  
#line 547
  NZERROR_CERT_ALREADY_INSTALLED = 29225, 
#line 552
  NZERROR_NO_MATCHING_PRIVATE_KEY = 29226, 
#line 557
  NZERROR_VALIDITY_EXPIRED = 29227,  
  NZERROR_TK_BYTES_NEEDED = 29228,    
  NZERROR_TK_BAD_MAGIC_NUMBER = 29229,

  NZERROR_TK_BAD_HEADER_LENGTH = 29230,

  NZERROR_TK_CE_INIT = 29231,           
  NZERROR_TK_CE_KEYINIT = 29232,   
  NZERROR_TK_CE_ENCODE_KEY = 29233,            
  NZERROR_TK_CE_DECODE_KEY = 29234,       
  NZERROR_TK_CE_GEYKEYINFO = 29235,   
  NZERROR_TK_SEED_RANDOM = 29236,    
  NZERROR_TK_CE_ALGFINISH = 29237,               
  NZERROR_TK_CE_ALGAPPLY = 29238,         
  NZERROR_TK_CE_ALGINIT = 29239,            
  NZERROR_TK_ALGORITHM = 29240,       
  NZERROR_TK_CANNOT_GROW = 29241,          
  NZERROR_TK_KEYSIZE = 29242,                
  NZERROR_TK_KEYTYPE = 29243,                            

  NZERROR_TK_PLSQL_NO_WRL = 29244,
#line 580
  NZERROR_TK_CE_FUNC = 29245,               
  NZERROR_TK_TDU_FORMAT = 29246,                        
  NZERROR_TK_NOTOPEN = 29247,                          
  NZERROR_TK_WRLTYPE = 29248,                                 
  NZERROR_TK_CE_STATE = 29249,   
#line 587
  NZERROR_PKCS11_LIBRARY_NOT_FOUND = 43000,  
  NZERROR_PKCS11_TOKEN_NOT_FOUND = 43001, 

  NZERROR_PKCS11_BAD_PASSPHRASE = 43002,   
  NZERROR_PKCS11_GET_FUNC_LIST = 43003,   
  NZERROR_PKCS11_INITIALIZE = 43004,      
  NZERROR_PKCS11_NO_TOKENS_PRESENT = 43005,  
  NZERROR_PKCS11_GET_SLOT_LIST = 43006,   

  NZERROR_PKCS11_GET_TOKEN_INFO = 43008,   
  NZERROR_PKCS11_SYMBOL_NOT_FOUND = 43009,  

  NZERROR_PKCS11_TOKEN_LOGIN_FAILED = 43011,  

  NZERROR_PKCS11_CHANGE_PROVIDERS_ERROR = 43013,  
  NZERROR_PKCS11_GET_PRIVATE_KEY_ERROR = 43014, 

  NZERROR_PKCS11_CREATE_KEYPAIR_ERROR = 43015,  
  NZERROR_PKCS11_WALLET_CONTAINS_P11_INFO = 43016, 

  NZERROR_PKCS11_NO_CERT_ON_TOKEN = 43017,       
  NZERROR_PKCS11_NO_USER_CERT_ON_TOKEN = 43018,  
  NZERROR_PKCS11_NO_CERT_ON_TOKEN_WITH_GIVEN_LABEL = 43019,  
  NZERROR_PKCS11_MULTIPLE_CERTS_ON_TOKEN_WITH_GIVEN_LABEL = 43020,  
  NZERROR_PKCS11_CERT_WITH_LABEL_NOT_USER_CERT  = 43021,  
#line 614
  NZERROR_BIND_SERVICE_ERROR = 43050,     
  NZERROR_CREATE_KEY_OBJ_ERROR = 43051,   
  NZERROR_GET_CERT_FIELDS = 43052,        
  NZERROR_CREATE_PKCS10_OBJECT = 43053,  

  NZERROR_SET_PKCS10_FIELDS = 43054,      
  NZERROR_SIGN_CERT_REQUEST = 43055,      
  NZERROR_GET_PKCS10_DER = 43056,         
  NZERROR_INITIALIZE_CERTC = 43057,       
  NZERROR_INSERT_PRIVATE_KEY = 43058,    
  NZERROR_RSA_ERROR = 43059,             
#line 627
  NZERROR_SLTSCTX_INIT_FAILED = 43060,     
  NZERROR_SLTSKYC_FAILED = 43061,          
  NZERROR_SLTSCTX_TERM_FAILED = 43062,     
  NZERROR_SLTSKYS_FAILED = 43063,          

  NZERROR_INVALID_HEADER_LENGTH = 43070,        
  NZERROR_WALLET_CONTAINS_USER_CREDENTIALS = 43071,  

  NZERROR_LAST_ERROR = 43499,                         
#line 643
  NZERROR_THIS_MUST_BE_LAST

} nzerror;
#line 191 "/oracle/app/product/10.2.0/db_1/rdbms/public/nzt.h"
enum nzttwrl 
{
   NZTTWRL_DEFAULT = 1,     
   NZTTWRL_SQLNET,          
   NZTTWRL_FILE,            
   NZTTWRL_ENTR,            
   NZTTWRL_MCS,             
   NZTTWRL_ORACLE,       
   NZTTWRL_NULL,            
   NZTTWRL_REGISTRY         
};
typedef enum nzttwrl nzttwrl;
#line 209
   typedef struct nzctx nzctx;
   typedef struct nzstrc nzstrc;
   typedef struct nzosContext nzosContext;
#line 216
typedef struct nzttIdentity nzttIdentity;
typedef struct nzttIdentityPrivate nzttIdentityPrivate;
typedef struct nzttPersona nzttPersona;
typedef struct nzttPersonaPrivate nzttPersonaPrivate;
typedef struct nzttWallet nzttWallet;
typedef struct nzttWalletPrivate nzttWalletPrivate;
typedef struct nzttWalletObj nzttWalletObj;  
typedef struct nzssEntry nzssEntry;  
typedef struct nzpkcs11_Info nzpkcs11_Info;
#line 236
enum nzttces 
{
   NZTTCES_CONTINUE = 1,     
   NZTTCES_END,              
   NZTTCES_RESET             
};
typedef enum nzttces nzttces;
#line 250
enum nzttcef
{
   NZTTCEF_DETACHEDSIGNATURE = 1,    
   NZTTCEF_SIGNATURE,                
   NZTTCEF_ENVELOPING,               
   NZTTCEF_PKENCRYPTION,             
   NZTTCEF_ENCRYPTION,               
   NZTTCEF_KEYEDHASH,                
   NZTTCEF_HASH,                     
   NZTTCEF_RANDOM,                   

   NZTTCEF_LAST                      
};
typedef enum nzttcef nzttcef;
#line 268
enum nzttState
{
   NZTTSTATE_EMPTY = 0,      
   NZTTSTATE_REQUESTED,      
   NZTTSTATE_READY,          
   NZTTSTATE_INVALID,          
   NZTTSTATE_RENEWAL         
};
typedef enum nzttState nzttState;
#line 283
enum nzttVersion
{
   NZTTVERSION_X509v1 = 1,         
   NZTTVERSION_X509v3,             
#line 290
   NZTTVERSION_INVALID_TYPE        
};
typedef enum nzttVersion nzttVersion;
#line 300
enum nzttCipherType 
{
   NZTTCIPHERTYPE_RSA = 1,           
   NZTTCIPHERTYPE_DES,               
   NZTTCIPHERTYPE_RC4,               
   NZTTCIPHERTYPE_MD5DES,            
   NZTTCIPHERTYPE_MD5RC2,            
   NZTTCIPHERTYPE_MD5,               
   NZTTCIPHERTYPE_SHA                
};
typedef enum nzttCipherType nzttCipherType;
#line 318
enum nztttdufmt
{
   NZTTTDUFMT_PKCS7 = 1,             
   NZTTTDUFMT_RSAPAD,                
   NZTTTDUFMT_ORACLEv1,              
   NZTTTDUFMT_LAST                   
};
typedef enum nztttdufmt nztttdufmt;
#line 332
enum nzttValState
{
   NZTTVALSTATE_NONE = 1,         
   NZTTVALSTATE_GOOD,             
   NZTTVALSTATE_REVOKED           
};
typedef enum nzttValState nzttValState;
#line 345
enum nzttPolicy
{
   NZTTPOLICY_NONE = 0,
   NZTTPOLICY_RETRY_1,  
   NZTTPOLICY_RETRY_2,  
   NZTTPOLICY_RETRY_3   
};
typedef enum nzttPolicy nzttPolicy;
#line 373
typedef ub1 nzttID[16];
#line 380
enum nzttIdentType 
{
   NZTTIDENTITYTYPE_INVALID_TYPE = 0,  
   NZTTIDENTITYTYPE_CERTIFICTAE,      
   NZTTIDENTITYTYPE_CERT_REQ,      
   NZTTIDENTITYTYPE_RENEW_CERT_REQ,      
   NZTTIDENTITYTYPE_CLEAR_ETP,      
   NZTTIDENTITYTYPE_CLEAR_UTP,      
   NZTTIDENTITYTYPE_CLEAR_PTP       
};
typedef enum nzttIdentType nzttIdentType;

typedef ub4 nzttKPUsage;
#line 407
typedef ub1 nzttTStamp[4];
#line 432
struct nzttBufferBlock
{
#line 436
   uword flags_nzttBufferBlock;      
   ub4 buflen_nzttBufferBlock;    
   ub4 usedlen_nzttBufferBlock;   
   ub1 *buffer_nzttBufferBlock;      
};
typedef struct nzttBufferBlock nzttBufferBlock;
#line 446
struct nzttWallet
{
   ub1 *ldapName_nzttWallet;               
   ub4  ldapNamelen_nzttWallet;            
   nzttPolicy securePolicy_nzttWallet;     
   nzttPolicy openPolicy_nzttWallet;       
   nzttPersona *persona_nzttWallet;        
   nzttWalletPrivate *private_nzttWallet;  
#line 457
};
#line 472
struct nzttPersona
{
   ub1 *genericName_nzttPersona;               
   ub4  genericNamelen_nzttPersona;            
   nzttPersonaPrivate *private_nzttPersona;    
   nzttIdentity *mycertreqs_nzttPersona;       
   nzttIdentity *mycerts_nzttPersona;          
   nzttIdentity *mytps_nzttPersona;            
   nzssEntry *mystore_nzttPersona;             
   nzpkcs11_Info *mypkcs11Info_nzttPersona;    
   struct nzttPersona *next_nzttPersona;       
#line 493
};
#line 504
struct nzttIdentity
{
   text *dn_nzttIdentity;                       
   ub4 dnlen_nzttIdentity;                   
   text *comment_nzttIdentity;                  
   ub4 commentlen_nzttIdentity;              
   nzttIdentityPrivate *private_nzttIdentity;   
   nzttIdentity *next_nzttIdentity;             
};

struct nzttB64Cert
{
   ub1 *b64Cert_nzttB64Cert;
   ub4  b64Certlen_nzttB64Cert;
   struct nzttB64Cert *next_nzttB64Cert;
};
typedef struct nzttB64Cert nzttB64Cert;
#line 523
struct nzttPKCS7ProtInfo
{
   nzttCipherType mictype_nzttPKCS7ProtInfo;     
   nzttCipherType symmtype_nzttPKCS7ProtInfo;    
   ub4 keylen_nzttPKCS7ProtInfo;              
};
typedef struct nzttPKCS7ProtInfo nzttPKCS7ProtInfo;
#line 536
union nzttProtInfo
{
   nzttPKCS7ProtInfo pkcs7_nzttProtInfo;
};
typedef union nzttProtInfo nzttProtInfo;
#line 556
struct nzttPersonaDesc
{
   ub4 privlen_nzttPersonaDesc;         
   ub1 *priv_nzttPersonaDesc;              
   ub4 prllen_nzttPersonaDesc;          
   text *prl_nzttPersonaDesc;              
   ub4 aliaslen_nzttPersonaDesc;        
   text *alias_nzttPersonaDesc;            
   ub4 longlen_nzttPersonaDesc;         
   text *long_nzttPersonaDesc;             
};
typedef struct nzttPersonaDesc nzttPersonaDesc;
#line 577
struct nzttIdentityDesc
{
   ub4 publen_nzttIdentityDesc;         
   ub1 *pub_nzttIdentityDesc;              
   ub4 dnlen_nzttIdentityDesc;          
   text *dn_nzttIdentityDesc;              
   ub4 longlen_nzttIdentityDesc;        
   text *long_nzttIdentityDesc;            
   ub4 quallen_nzttIdentityDesc;        
   text *trustqual_nzttIdentityDesc;       
};
typedef struct nzttIdentityDesc nzttIdentityDesc;
#line 638
nzerror nztwOpenWallet(nzctx *, ub4, text *, ub4, text *, 
                           nzttWallet *);
#line 668
nzerror nztwCloseWallet(nzctx *, nzttWallet *);
#line 676
nzerror nztwGetCertInfo(
#line 679
 );
#line 719
nzerror nztwRetrievePersonaCopy(nzctx *, nzttWallet *, ub4, nzttPersona **);
#line 750
nzerror nztwRetrievePersonaCopyByName(nzctx *, nzttWallet *, 
                                      char *, nzttPersona **);
#line 776
nzerror nzteOpenPersona(nzctx *, nzttPersona *);
#line 799
nzerror nzteClosePersona(nzctx *, nzttPersona *);
#line 828
nzerror nzteDestroyPersona(nzctx *,  nzttPersona **);
#line 858
nzerror nzteRetrieveTrustedIdentCopy(nzctx *, nzttPersona *, ub4, 
                 nzttIdentity **);
#line 891
nzerror nztePriKey(nzctx *, nzttPersona *, ub1 **, ub4 *);
#line 921
nzerror nzteMyCert(nzctx *, nzttPersona *, ub1 **, ub4 *);
#line 947
nzerror nzteX509CreatePersona(nzctx *, ub1 *, ub4, nzttPersona **);
#line 976
nzerror nztiCreateIdentity(nzctx *, nzttVersion, nzttIdentityDesc *,
                               nzttIdentity **);
#line 1034
nzerror nztiAbortIdentity(nzctx *, nzttIdentity **);
#line 1111
nzerror nztific_FreeIdentityContent(nzctx *ossctx,
                                        nzttIdentity *identity);
#line 1142
nzerror nztSign(nzctx *, nzttPersona *, nzttces, ub4, ub1 *,
                    nzttBufferBlock *);
#line 1175
nzerror nztVerify(nzctx *, nzttPersona *, nzttces, ub4, ub1 *,
                      nzttBufferBlock *, boolean *, boolean *,
                      nzttIdentity **);
#line 1204
nzerror nztValidate(nzctx *, nzttPersona *, nzttIdentity *, boolean *);
#line 1232
nzerror nztsd_SignDetached(nzctx *, nzttPersona *, nzttces, ub4, ub1 *, 
                               nzttBufferBlock *);
#line 1265
nzerror nztved_VerifyDetached(nzctx *, nzttPersona *, nzttces, ub4, 
                                  ub1 *, ub4, ub1 *, boolean *, boolean *, 
                                  nzttIdentity **);
#line 1301
nzerror nztkec_PKEncrypt(nzctx *, nzttPersona *, ub4, nzttIdentity *, 
                             nzttces, ub4, ub1 *, nzttBufferBlock *);
#line 1329
nzerror nztxkec_PKEncryptExpansion(nzctx *, nzttPersona *, ub4, ub4,
                                       ub4 *);
#line 1359
nzerror nztkdc_PKDecrypt(nzctx *, nzttPersona *, nzttces, ub4, ub1 *,
                             nzttBufferBlock *);
#line 1389
nzerror nztHash(nzctx *, nzttPersona *, nzttces, ub4, ub1 *,
                    nzttBufferBlock *);
#line 1416
nzerror nztSeedRandom(nzctx *, nzttPersona *, ub4, ub1 *);
#line 1442
nzerror nztrb_RandomBytes(nzctx *, nzttPersona *, ub4, 
                              nzttBufferBlock *);
#line 1468
nzerror nztrn_RandomNumber(nzctx *, nzttPersona *, uword *);
#line 1491
nzerror nztbbInitBlock(nzctx *, nzttBufferBlock *);
#line 1515
nzerror nztbbReuseBlock(nzctx *, nzttBufferBlock *);
#line 1537
nzerror nztbbSizeBlock(nzctx *, ub4, nzttBufferBlock *);
#line 1559
nzerror nztbbGrowBlock(nzctx *, ub4, nzttBufferBlock *);
#line 1582
nzerror nztbbPurgeBlock(nzctx *, nzttBufferBlock *);
#line 1612
nzerror nztbbSetBlock(nzctx *,  uword, ub4, ub4, ub1 *, 
                          nzttBufferBlock *);
#line 1642
nzerror nztiGetSecInfo(nzctx *, nzttPersona *, text **, ub4 *,
          text **, ub4 *, ub1 **, ub4 *);
#line 1670
nzerror nztiGetDName(nzctx *, nzttIdentity *,
           text **, ub4 *);
#line 1696
nzerror nztiGetIssuerName(nzctx *, nzttIdentity *,
              text **, ub4 *);
#line 1723
nzerror nztgch_GetCertHash(nzctx *, nzttIdentity *,
              ub1 **, ub4 *);
#line 1747
nzerror nztdbuf_DestroyBuf( nzctx *, void **);
#line 1769
nzerror nztGetCertChain(nzctx *, nzttWallet * );
#line 1794
nzerror nztCompareDN(nzctx *, ub1 *, ub4,  ub1 *, ub4, boolean * );
#line 1976
nzerror nztCheckValidity( nzctx *, ub4 , ub4 );
#line 2012
nzerror nztwCreateWallet(nzctx *, ub4, text *, ub4, text *, 
                             nzttWallet *);
#line 2041
nzerror nztwDestroyWallet(nzctx *, ub4, text *, ub4, text *);
#line 2088
nzerror nzteStorePersona(nzctx *, nzttPersona **, nzttWallet *);
#line 2118
nzerror nzteRemovePersona(nzctx *, nzttPersona **);
#line 2148
nzerror nzteCreatePersona(nzctx *, nzttVersion, nzttCipherType, 
           nzttPersonaDesc *, nzttPersona **);
#line 2178
nzerror nztiStoreTrustedIdentity(nzctx *, nzttIdentity **,
                                     nzttPersona *);
#line 2206
nzerror nzteSetProtection(nzctx *, nzttPersona *, nzttcef, nztttdufmt,
                              nzttProtInfo *);
#line 2232
nzerror nzteGetProtection(nzctx *, nzttPersona *, nzttcef, nztttdufmt *,
                              nzttProtInfo *);
#line 2262
nzerror nztiRemoveIdentity(nzctx *, nzttIdentity **);
#line 2286
nzerror nztifdn(nzctx         *ossctx,
                    ub4         length,
                    text          *distinguished_name,
                    nzttIdentity **ppidentity);
#line 2317
nzerror nztxSignExpansion(nzctx *, nzttPersona *, ub4, ub4 *);
#line 2342
nzerror nztxsd_SignDetachedExpansion(nzctx *, nzttPersona *, ub4,
                                         ub4 *);
#line 2371
nzerror nztEncrypt(nzctx *, nzttPersona *, nzttces, ub4, ub1 *,
                       nzttBufferBlock *);
#line 2398
nzerror nztxEncryptExpansion(nzctx *, nzttPersona *, ub4, ub4 *);
#line 2426
nzerror nztDecrypt(nzctx *, nzttPersona *, nzttces, ub4, ub1 *,
                       nzttBufferBlock *);
#line 2458
nzerror nztEnvelope(nzctx *, nzttPersona *, ub4, nzttIdentity *,
                        nzttces, ub4, ub1 *, nzttBufferBlock *);
#line 2491
nzerror nztDeEnvelope(nzctx *, nzttPersona *, nzttces, ub4, ub1 *,
                          nzttBufferBlock *, boolean *, boolean *,
                          nzttIdentity **);
#line 2523
nzerror nztKeyedHash(nzctx *, nzttPersona *, nzttces, ub4, ub1 *,
                         nzttBufferBlock *);
#line 2550
nzerror nztxKeyedHashExpansion(nzctx *, nzttPersona *, ub4, 
                                   ub4 *);
#line 2577
nzerror nztxHashExpansion(nzctx *, nzttPersona *, ub4, ub4 *);
#line 2602
nzerror nztiae_IsAuthEnabled( nzctx *, ub2, boolean *);
#line 2628
nzerror nztiee_IsEncrEnabled( nzctx *, ub2, boolean *);
#line 2653
nzerror nztihe_IsHashEnabled( nzctx *, ub2, boolean *);
#line 2667
nzerror nztGetIssuerName(
#line 2670
 );
#line 2676
nzerror nztGetSubjectName(
#line 2679
 );
#line 2686
nzerror nztGetBase64Cert(
#line 2689
 );
#line 2695
nzerror nztGetSerialNumber(
#line 2698
 );
#line 2704
nzerror nztGetValidDate(
#line 2707
 );
#line 2713
nzerror nztGetVersion(

 );
#line 2721
nzerror nztGetPublicKey(
#line 2724
 );
#line 2731
nzerror nztGenericDestroy(
 );
#line 2738
nzerror nztSetAppDefaultLocation(

 );
#line 2746
nzerror nztSearchNZDefault(
 );
#line 6333 "/oracle/app/product/10.2.0/db_1/rdbms/public/ociap.h"
typedef sb4 (*OCICallbackInBind)(void *ictxp, OCIBind *bindp, ub4 iter,
                                  ub4 index, void **bufpp, ub4 *alenp,
                                  ub1 *piecep, void **indp);

typedef sb4 (*OCICallbackOutBind)(void *octxp, OCIBind *bindp, ub4 iter,
                                 ub4 index, void **bufpp, ub4 **alenp,
                                 ub1 *piecep, void **indp,
                                 ub2 **rcodep);

typedef sb4 (*OCICallbackDefine)(void *octxp, OCIDefine *defnp, ub4 iter,
                                 void **bufpp, ub4 **alenp, ub1 *piecep,
                                 void **indp, ub2 **rcodep);

typedef sword (*OCIUserCallback)(void *ctxp, void *hndlp, ub4 type,
                                 ub4 fcode, ub4 when, sword returnCode,
                                 sb4 *errnop, va_list arglist);

typedef sword (*OCIEnvCallbackType)(OCIEnv *env, ub4 mode,
                                   size_t xtramem_sz, void *usrmemp,
                                   OCIUcb *ucbDesc); 

typedef sb4 (*OCICallbackLobRead)(void *ctxp, const void *bufp,
                                             ub4 len, ub1 piece);

typedef sb4 (*OCICallbackLobWrite)(void *ctxp, void *bufp, 
                                          ub4 *lenp, ub1 *piece);
#line 6362
typedef sb4 (*OCICallbackLobRead2)(void *ctxp, const void *bufp, oraub8 len,
                                   ub1 piece, void **changed_bufpp,
                                   oraub8 *changed_lenp);

typedef sb4 (*OCICallbackLobWrite2)(void *ctxp, void *bufp, oraub8 *lenp,
                                    ub1 *piece, void **changed_bufpp,
                                    oraub8 *changed_lenp);

typedef sb4 (*OCICallbackLobArrayRead)(void *ctxp, ub4 array_iter,
                                       const void *bufp, oraub8 len,
                                       ub1 piece, void **changed_bufpp,
                                       oraub8 *changed_lenp);

typedef sb4 (*OCICallbackLobArrayWrite)(void *ctxp, ub4 array_iter,
                                        void *bufp, oraub8 *lenp,
                                        ub1 *piece, void **changed_bufpp,
                                        oraub8 *changed_lenp);
#line 6382
typedef sb4 (*OCICallbackAQEnq)(void *ctxp, void **payload, 
                                void **payload_ind);

typedef sb4 (*OCICallbackAQDeq)(void *ctxp, void **payload, 
                                void **payload_ind);
#line 6389
typedef sb4 (*OCICallbackFailover)(void *svcctx, void *envctx,
                                   void *fo_ctx, ub4 fo_type,
                                   ub4 fo_event);

typedef struct
{
  OCICallbackFailover callback_function;
  void *fo_ctx;
} 
OCIFocbkStruct;
#line 6401
typedef void (*OCIEventCallback)(void *evtctx, OCIEvent *eventhp);
#line 6408
sword   OCIInitialize   (ub4 mode, void *ctxp, 
                 void *(*malocfp)(void *ctxp, size_t size),
                 void *(*ralocfp)(void *ctxp, void *memptr, size_t newsize),
                 void   (*mfreefp)(void *ctxp, void *memptr) );

sword   OCITerminate( ub4 mode);

sword   OCIEnvCreate (OCIEnv **envp, ub4 mode, void *ctxp,
                 void *(*malocfp)(void *ctxp, size_t size),
                 void *(*ralocfp)(void *ctxp, void *memptr, size_t newsize),
                 void   (*mfreefp)(void *ctxp, void *memptr),
                 size_t xtramem_sz, void **usrmempp);

sword   OCIEnvNlsCreate (OCIEnv **envp, ub4 mode, void *ctxp,
                 void *(*malocfp)(void *ctxp, size_t size),
                 void *(*ralocfp)(void *ctxp, void *memptr, size_t newsize),
                 void   (*mfreefp)(void *ctxp, void *memptr),
                 size_t xtramem_sz, void **usrmempp,
                 ub2 charset, ub2 ncharset);

sword   OCIFEnvCreate (OCIEnv **envp, ub4 mode, void *ctxp,
                 void *(*malocfp)(void *ctxp, size_t size),
                 void *(*ralocfp)(void *ctxp, void *memptr, size_t newsize),
                 void   (*mfreefp)(void *ctxp, void *memptr),
                 size_t xtramem_sz, void **usrmempp, void *fupg);

sword   OCIHandleAlloc(const void *parenth, void **hndlpp, const ub4 type, 
                       const size_t xtramem_sz, void **usrmempp);

sword   OCIHandleFree(void *hndlp, const ub4 type);
#line 6440
sword   OCIDescriptorAlloc(const void *parenth, void **descpp, 
                           const ub4 type, const size_t xtramem_sz, 
                           void **usrmempp);

sword   OCIDescriptorFree(void *descp, const ub4 type);

sword   OCIEnvInit (OCIEnv **envp, ub4 mode, 
                    size_t xtramem_sz, void **usrmempp);

sword   OCIServerAttach  (OCIServer *srvhp, OCIError *errhp,
                          const OraText *dblink, sb4 dblink_len, ub4 mode);

sword   OCIServerDetach  (OCIServer *srvhp, OCIError *errhp, ub4 mode);

sword   OCISessionBegin  (OCISvcCtx *svchp, OCIError *errhp, OCISession *usrhp,
                          ub4 credt, ub4 mode);

sword   OCISessionEnd   (OCISvcCtx *svchp, OCIError *errhp, OCISession *usrhp, 
                         ub4 mode);

sword   OCILogon (OCIEnv *envhp, OCIError *errhp, OCISvcCtx **svchp, 
                  const OraText *username, ub4 uname_len, 
                  const OraText *password, ub4 passwd_len, 
                  const OraText *dbname, ub4 dbname_len);

sword   OCILogon2 (OCIEnv *envhp, OCIError *errhp, OCISvcCtx **svchp,
                  const OraText *username, ub4 uname_len,
                  const OraText *password, ub4 passwd_len,
                  const OraText *dbname, ub4 dbname_len,
                  ub4 mode);

sword   OCILogoff (OCISvcCtx *svchp, OCIError *errhp);
#line 6474
sword   OCIPasswordChange   (OCISvcCtx *svchp, OCIError *errhp, 
                             const OraText *user_name, ub4 usernm_len, 
                             const OraText *opasswd, ub4 opasswd_len, 
                             const OraText *npasswd, ub4 npasswd_len, 
                             ub4 mode);

sword   OCIStmtPrepare   (OCIStmt *stmtp, OCIError *errhp, const OraText *stmt,
                          ub4 stmt_len, ub4 language, ub4 mode);

sword OCIStmtPrepare2 ( OCISvcCtx *svchp, OCIStmt **stmtp, OCIError *errhp,
                     const OraText *stmt, ub4 stmt_len, const OraText *key,
                     ub4 key_len, ub4 language, ub4 mode);

sword OCIStmtRelease ( OCIStmt *stmtp, OCIError *errhp, const OraText *key,
                       ub4 key_len, ub4 mode);

sword   OCIBindByPos  (OCIStmt *stmtp, OCIBind **bindp, OCIError *errhp,
                       ub4 position, void *valuep, sb4 value_sz,
                       ub2 dty, void *indp, ub2 *alenp, ub2 *rcodep,
                       ub4 maxarr_len, ub4 *curelep, ub4 mode);

sword   OCIBindByName   (OCIStmt *stmtp, OCIBind **bindp, OCIError *errhp,
                         const OraText *placeholder, sb4 placeh_len, 
                         void *valuep, sb4 value_sz, ub2 dty, 
                         void *indp, ub2 *alenp, ub2 *rcodep, 
                         ub4 maxarr_len, ub4 *curelep, ub4 mode);

sword   OCIBindObject  (OCIBind *bindp, OCIError *errhp, const OCIType *type, 
                        void **pgvpp, ub4 *pvszsp, void **indpp, 
                        ub4 *indszp);

sword   OCIBindDynamic   (OCIBind *bindp, OCIError *errhp, void *ictxp,
                          OCICallbackInBind icbfp, void *octxp,
                          OCICallbackOutBind ocbfp);

sword   OCIBindArrayOfStruct   (OCIBind *bindp, OCIError *errhp, 
                                ub4 pvskip, ub4 indskip,
                                ub4 alskip, ub4 rcskip);

sword   OCIStmtGetPieceInfo   (OCIStmt *stmtp, OCIError *errhp, 
                               void **hndlpp, ub4 *typep,
                               ub1 *in_outp, ub4 *iterp, ub4 *idxp, 
                               ub1 *piecep);

sword   OCIStmtSetPieceInfo   (void *hndlp, ub4 type, OCIError *errhp, 
                               const void *bufp, ub4 *alenp, ub1 piece, 
                               const void *indp, ub2 *rcodep);

sword   OCIStmtExecute  (OCISvcCtx *svchp, OCIStmt *stmtp, OCIError *errhp, 
                         ub4 iters, ub4 rowoff, const OCISnapshot *snap_in, 
                         OCISnapshot *snap_out, ub4 mode);

sword   OCIDefineByPos  (OCIStmt *stmtp, OCIDefine **defnp, OCIError *errhp,
                         ub4 position, void *valuep, sb4 value_sz, ub2 dty,
                         void *indp, ub2 *rlenp, ub2 *rcodep, ub4 mode);

sword   OCIDefineObject  (OCIDefine *defnp, OCIError *errhp, 
                          const OCIType *type, void **pgvpp, 
                          ub4 *pvszsp, void **indpp, ub4 *indszp);

sword   OCIDefineDynamic   (OCIDefine *defnp, OCIError *errhp, void *octxp,
                            OCICallbackDefine ocbfp);

sword   OCIRowidToChar  (OCIRowid *rowidDesc, OraText *outbfp, ub2 *outbflp,
                         OCIError *errhp);

sword   OCIDefineArrayOfStruct  (OCIDefine *defnp, OCIError *errhp, ub4 pvskip,
                                 ub4 indskip, ub4 rlskip, ub4 rcskip);

sword   OCIStmtFetch   (OCIStmt *stmtp, OCIError *errhp, ub4 nrows, 
                        ub2 orientation, ub4 mode);

sword   OCIStmtFetch2   (OCIStmt *stmtp, OCIError *errhp, ub4 nrows, 
                        ub2 orientation, sb4 scrollOffset, ub4 mode);

sword   OCIStmtGetBindInfo   (OCIStmt *stmtp, OCIError *errhp, ub4 size, 
                              ub4 startloc,
                              sb4 *found, OraText *bvnp[], ub1 bvnl[],
                              OraText *invp[], ub1 inpl[], ub1 dupl[],
                              OCIBind **hndl);

sword   OCIDescribeAny  (OCISvcCtx *svchp, OCIError *errhp, 
                         void *objptr, 
                         ub4 objnm_len, ub1 objptr_typ, ub1 info_level,
                         ub1 objtyp, OCIDescribe *dschp);

sword   OCIParamGet (const void *hndlp, ub4 htype, OCIError *errhp, 
                     void **parmdpp, ub4 pos);

sword   OCIParamSet(void *hdlp, ub4 htyp, OCIError *errhp, const void *dscp,
                    ub4 dtyp, ub4 pos);

sword   OCITransStart  (OCISvcCtx *svchp, OCIError *errhp, 
                        uword timeout, ub4 flags );

sword   OCITransDetach  (OCISvcCtx *svchp, OCIError *errhp, ub4 flags );

sword   OCITransCommit  (OCISvcCtx *svchp, OCIError *errhp, ub4 flags);

sword   OCITransRollback  (OCISvcCtx *svchp, OCIError *errhp, ub4 flags);

sword   OCITransPrepare (OCISvcCtx *svchp, OCIError *errhp, ub4 flags);

sword   OCITransMultiPrepare (OCISvcCtx *svchp, ub4 numBranches, 
                              OCITrans **txns, OCIError **errhp);

sword   OCITransForget (OCISvcCtx *svchp, OCIError *errhp, ub4 flags);

sword   OCIErrorGet   (void *hndlp, ub4 recordno, OraText *sqlstate,
                       sb4 *errcodep, OraText *bufp, ub4 bufsiz, ub4 type);

sword   OCILobAppend  (OCISvcCtx *svchp, OCIError *errhp, 
                       OCILobLocator *dst_locp,
                       OCILobLocator *src_locp);

sword   OCILobAssign (OCIEnv *envhp, OCIError *errhp, 
                      const OCILobLocator *src_locp, 
                      OCILobLocator **dst_locpp);

sword   OCILobCharSetForm (OCIEnv *envhp, OCIError *errhp, 
                           const OCILobLocator *locp, ub1 *csfrm);

sword   OCILobCharSetId (OCIEnv *envhp, OCIError *errhp, 
                         const OCILobLocator *locp, ub2 *csid);

sword   OCILobCopy (OCISvcCtx *svchp, OCIError *errhp, OCILobLocator *dst_locp,
                    OCILobLocator *src_locp, ub4 amount, ub4 dst_offset, 
                    ub4 src_offset);

sword OCILobCreateTemporary(OCISvcCtx          *svchp,
                            OCIError           *errhp,
                            OCILobLocator      *locp,
                            ub2                 csid,
                            ub1                 csfrm,
                            ub1                 lobtype,
                            boolean             cache,
                            OCIDuration         duration);
#line 6613
sword OCILobClose( OCISvcCtx        *svchp,
                   OCIError         *errhp,
                   OCILobLocator    *locp );
#line 6618
sword   OCILobDisableBuffering (OCISvcCtx      *svchp,
                                OCIError       *errhp,
                                OCILobLocator  *locp);

sword   OCILobEnableBuffering (OCISvcCtx      *svchp,
                               OCIError       *errhp,
                               OCILobLocator  *locp);

sword   OCILobErase (OCISvcCtx *svchp, OCIError *errhp, OCILobLocator *locp,
                      ub4 *amount, ub4 offset);

sword   OCILobFileClose (OCISvcCtx *svchp, OCIError *errhp, 
                         OCILobLocator *filep);

sword   OCILobFileCloseAll (OCISvcCtx *svchp, OCIError *errhp);

sword   OCILobFileExists (OCISvcCtx *svchp, OCIError *errhp, 
                          OCILobLocator *filep,
                          boolean *flag);

sword   OCILobFileGetName (OCIEnv *envhp, OCIError *errhp, 
                           const OCILobLocator *filep, 
                           OraText *dir_alias, ub2 *d_length, 
                           OraText *filename, ub2 *f_length);

sword   OCILobFileIsOpen (OCISvcCtx *svchp, OCIError *errhp, 
                          OCILobLocator *filep,
                          boolean *flag);

sword   OCILobFileOpen (OCISvcCtx *svchp, OCIError *errhp, 
                        OCILobLocator *filep,
                        ub1 mode);

sword   OCILobFileSetName (OCIEnv *envhp, OCIError *errhp, 
                           OCILobLocator **filepp, 
                           const OraText *dir_alias, ub2 d_length, 
                           const OraText *filename, ub2 f_length);

sword   OCILobFlushBuffer (OCISvcCtx       *svchp,
                           OCIError        *errhp,
                           OCILobLocator   *locp,
                           ub4              flag);

sword OCILobFreeTemporary(OCISvcCtx          *svchp,
                          OCIError           *errhp,
                          OCILobLocator      *locp);

sword OCILobGetChunkSize(OCISvcCtx         *svchp,
                         OCIError          *errhp,
                         OCILobLocator     *locp,
                         ub4               *chunksizep);

sword   OCILobGetLength  (OCISvcCtx *svchp, OCIError *errhp, 
                          OCILobLocator *locp,
                          ub4 *lenp);

sword   OCILobIsEqual  (OCIEnv *envhp, const OCILobLocator *x, 
                        const OCILobLocator *y, 
                        boolean *is_equal);

sword OCILobIsOpen( OCISvcCtx     *svchp,
                    OCIError      *errhp,
                    OCILobLocator *locp,
                    boolean       *flag);

sword OCILobIsTemporary(OCIEnv            *envp,
                        OCIError          *errhp,
                        OCILobLocator     *locp,
                        boolean           *is_temporary);

sword   OCILobLoadFromFile (OCISvcCtx *svchp, OCIError *errhp, 
                            OCILobLocator *dst_locp,
                            OCILobLocator *src_filep, 
                            ub4 amount, ub4 dst_offset, 
                            ub4 src_offset);

sword   OCILobLocatorAssign  (OCISvcCtx *svchp, OCIError *errhp, 
                            const OCILobLocator *src_locp, 
                            OCILobLocator **dst_locpp);
#line 6699
sword   OCILobLocatorIsInit (OCIEnv *envhp, OCIError *errhp, 
                             const OCILobLocator *locp, 
                             boolean *is_initialized);

sword   OCILobOpen( OCISvcCtx        *svchp,
                   OCIError         *errhp,
                   OCILobLocator    *locp,
                   ub1               mode );

sword   OCILobRead  (OCISvcCtx *svchp, OCIError *errhp, OCILobLocator *locp,
                     ub4 *amtp, ub4 offset, void *bufp, ub4 bufl, void *ctxp,
                     OCICallbackLobRead cbfp, ub2 csid, ub1 csfrm);

sword   OCILobTrim  (OCISvcCtx *svchp, OCIError *errhp, OCILobLocator *locp,
                     ub4 newlen);

sword   OCILobWrite  (OCISvcCtx *svchp, OCIError *errhp, OCILobLocator *locp,
                      ub4 *amtp, ub4 offset, void *bufp, ub4 buflen, ub1 piece,
                      void *ctxp, OCICallbackLobWrite cbfp, ub2 csid,
                      ub1 csfrm);

sword OCILobWriteAppend(OCISvcCtx *svchp, OCIError *errhp, OCILobLocator *lobp,
                        ub4 *amtp, void *bufp, ub4 bufl, ub1 piece, void *ctxp,
                        OCICallbackLobWrite cbfp, ub2 csid, ub1 csfrm);

sword   OCIBreak (void *hndlp, OCIError *errhp);

sword   OCIReset (void *hndlp, OCIError *errhp);

sword   OCIServerVersion  (void *hndlp, OCIError *errhp, OraText *bufp, 
                           ub4 bufsz,
                           ub1 hndltype);

sword   OCIServerRelease  (void *hndlp, OCIError *errhp, OraText *bufp,
                           ub4 bufsz,
                           ub1 hndltype, ub4 *version);

sword   OCIAttrGet (const void *trgthndlp, ub4 trghndltyp, 
                    void *attributep, ub4 *sizep, ub4 attrtype, 
                    OCIError *errhp);

sword   OCIAttrSet (void *trgthndlp, ub4 trghndltyp, void *attributep,
                    ub4 size, ub4 attrtype, OCIError *errhp);

sword   OCISvcCtxToLda (OCISvcCtx *svchp, OCIError *errhp, Lda_Def *ldap);

sword   OCILdaToSvcCtx (OCISvcCtx **svchpp, OCIError *errhp, Lda_Def *ldap);

sword   OCIResultSetToStmt (OCIResult *rsetdp, OCIError *errhp);

sword OCIFileClose ( void  *hndl, OCIError *err, OCIFileObject *filep );

sword   OCIUserCallbackRegister(void *hndlp, ub4 type, void *ehndlp,
                                    OCIUserCallback callback, void *ctxp,
                                    ub4 fcode, ub4 when, OCIUcb *ucbDesc);

sword   OCIUserCallbackGet(void *hndlp, ub4 type, void *ehndlp,
                               ub4 fcode, ub4 when, OCIUserCallback *callbackp,
                               void **ctxpp, OCIUcb *ucbDesc);

sword   OCISharedLibInit(void *metaCtx, void *libCtx, ub4 argfmt, sword argc,
                         void **argv, OCIEnvCallbackType envCallback);

sword OCIFileExists ( void  *hndl, OCIError *err, OraText *filename,
                     OraText *path, ub1 *flag  );

sword OCIFileFlush( void *hndl, OCIError *err, OCIFileObject *filep  );
#line 6768
sword OCIFileGetLength( void *hndl, OCIError *err, OraText *filename,
                        OraText *path, ubig_ora *lenp  );

sword OCIFileInit ( void *hndl, OCIError *err );

sword OCIFileOpen ( void *hndl, OCIError *err, OCIFileObject **filep,
                    OraText *filename, OraText *path, ub4 mode, ub4 create, 
                    ub4 type );

sword OCIFileRead ( void *hndl, OCIError *err, OCIFileObject *filep,
                    void *bufp, ub4 bufl, ub4 *bytesread );

sword OCIFileSeek ( void *hndl, OCIError *err, OCIFileObject *filep,
                     uword origin, ubig_ora offset, sb1 dir );

sword OCIFileTerm ( void *hndl, OCIError *err );
#line 6786
sword OCIFileWrite ( void *hndl, OCIError *err, OCIFileObject   *filep,
                     void *bufp, ub4 buflen, ub4 *byteswritten );
#line 6792
sword   OCILobCopy2 (OCISvcCtx *svchp, OCIError *errhp, OCILobLocator *dst_locp,
                     OCILobLocator *src_locp, oraub8 amount, oraub8 dst_offset, 
                     oraub8 src_offset);

sword   OCILobErase2 (OCISvcCtx *svchp, OCIError *errhp, OCILobLocator *locp,
                      oraub8 *amount, oraub8 offset);

sword   OCILobGetLength2 (OCISvcCtx *svchp, OCIError *errhp, 
                          OCILobLocator *locp, oraub8 *lenp);

sword   OCILobLoadFromFile2 (OCISvcCtx *svchp, OCIError *errhp, 
                             OCILobLocator *dst_locp,
                             OCILobLocator *src_filep, 
                             oraub8 amount, oraub8 dst_offset, 
                             oraub8 src_offset);

sword   OCILobRead2 (OCISvcCtx *svchp, OCIError *errhp, OCILobLocator *locp,
                     oraub8 *byte_amtp, oraub8 *char_amtp, oraub8 offset,
                     void *bufp, oraub8 bufl, ub1 piece, void *ctxp,
                     OCICallbackLobRead2 cbfp, ub2 csid, ub1 csfrm);

sword   OCILobArrayRead (OCISvcCtx *svchp, OCIError *errhp, ub4 *array_iter,
                         OCILobLocator **lobp_arr, oraub8 *byte_amt_arr,
                         oraub8 *char_amt_arr, oraub8 *offset_arr,
                         void **bufp_arr, oraub8 *bufl_arr, ub1 piece,
                         void *ctxp, OCICallbackLobArrayRead cbfp, ub2 csid,
                         ub1 csfrm);

sword   OCILobTrim2 (OCISvcCtx *svchp, OCIError *errhp, OCILobLocator *locp,
                     oraub8 newlen);

sword   OCILobWrite2 (OCISvcCtx *svchp, OCIError *errhp, OCILobLocator *locp,
                      oraub8 *byte_amtp, oraub8 *char_amtp, oraub8 offset,
                      void *bufp, oraub8 buflen, ub1 piece, void *ctxp, 
                      OCICallbackLobWrite2 cbfp, ub2 csid, ub1 csfrm);

sword   OCILobArrayWrite (OCISvcCtx *svchp, OCIError *errhp, ub4 *array_iter,
                          OCILobLocator **lobp_arr, oraub8 *byte_amt_arr,
                          oraub8 *char_amt_arr, oraub8 *offset_arr,
                          void **bufp_arr, oraub8 *bufl_arr, ub1 piece,
                          void *ctxp, OCICallbackLobArrayWrite cbfp, ub2 csid,
                          ub1 csfrm);

sword OCILobWriteAppend2 (OCISvcCtx *svchp, OCIError *errhp, OCILobLocator *lobp,
                          oraub8 *byte_amtp, oraub8 *char_amtp, void *bufp,
                          oraub8 bufl, ub1 piece, void *ctxp,
                          OCICallbackLobWrite2 cbfp, ub2 csid, ub1 csfrm);

sword OCILobGetStorageLimit (OCISvcCtx *svchp, OCIError *errhp,
                             OCILobLocator *lobp, oraub8 *limitp);
#line 6848
sword   OCISecurityInitialize (OCISecurity *sechandle, OCIError *error_handle);

sword   OCISecurityTerminate (OCISecurity *sechandle, OCIError *error_handle);

sword OCISecurityOpenWallet(OCISecurity *osshandle,
                            OCIError *error_handle,
                            size_t wrllen,
                            OraText *wallet_resource_locator,
                            size_t pwdlen,
                            OraText *password,
                            nzttWallet *wallet);

sword OCISecurityCloseWallet(OCISecurity *osshandle,
                             OCIError *error_handle,
                             nzttWallet *wallet);

sword OCISecurityCreateWallet(OCISecurity *osshandle,
                              OCIError *error_handle,
                              size_t wrllen,
                              OraText *wallet_resource_locator,
                              size_t pwdlen,
                              OraText *password,
                              nzttWallet *wallet);

sword OCISecurityDestroyWallet(OCISecurity *osshandle,
                               OCIError *error_handle,
                               size_t wrllen,
                               OraText *wallet_resource_locator,
                               size_t pwdlen,
                               OraText *password);

sword OCISecurityStorePersona(OCISecurity *osshandle,
                              OCIError *error_handle,
                              nzttPersona **persona,
                              nzttWallet *wallet);

sword OCISecurityOpenPersona(OCISecurity *osshandle,
                             OCIError *error_handle,
                             nzttPersona *persona);

sword OCISecurityClosePersona(OCISecurity *osshandle,
                              OCIError *error_handle,
                              nzttPersona *persona);

sword OCISecurityRemovePersona(OCISecurity *osshandle,
                               OCIError *error_handle,
                               nzttPersona **persona);

sword OCISecurityCreatePersona(OCISecurity *osshandle,
                               OCIError *error_handle,
                               nzttIdentType identity_type,
                               nzttCipherType cipher_type,
                               nzttPersonaDesc *desc,
                               nzttPersona **persona);

sword OCISecuritySetProtection(OCISecurity *osshandle,
                               OCIError *error_handle,
                               nzttPersona *persona,
                               nzttcef crypto_engine_function,
                               nztttdufmt data_unit_format,
                               nzttProtInfo *protection_info);

sword OCISecurityGetProtection(OCISecurity *osshandle,
                               OCIError *error_handle,
                               nzttPersona *persona,
                               nzttcef crypto_engine_function,
                               nztttdufmt * data_unit_format_ptr,
                               nzttProtInfo *protection_info);

sword OCISecurityRemoveIdentity(OCISecurity *osshandle,
                                OCIError *error_handle,
                                nzttIdentity **identity_ptr);

sword OCISecurityCreateIdentity(OCISecurity *osshandle,
                                OCIError *error_handle,
                                nzttIdentType type,
                                nzttIdentityDesc *desc,
                                nzttIdentity **identity_ptr);

sword OCISecurityAbortIdentity(OCISecurity *osshandle,
                               OCIError *error_handle,
                               nzttIdentity **identity_ptr);

sword OCISecurityFreeIdentity(OCISecurity *osshandle,
                              OCIError *error_handle,
                              nzttIdentity **identity_ptr);
#line 6936
sword OCISecurityStoreTrustedIdentity(OCISecurity *osshandle,
                                      OCIError *error_handle,
                                      nzttIdentity **identity_ptr,
                                      nzttPersona *persona);

sword OCISecuritySign(OCISecurity *osshandle,
                      OCIError *error_handle,
                      nzttPersona *persona,
                      nzttces signature_state,
                      size_t input_length,
                      ub1 *input,
                      nzttBufferBlock *buffer_block);

sword OCISecuritySignExpansion(OCISecurity *osshandle,
                               OCIError *error_handle,
                               nzttPersona *persona,
                               size_t inputlen,
                               size_t *signature_length);

sword OCISecurityVerify(OCISecurity *osshandle,
                        OCIError *error_handle,
                        nzttPersona *persona,
                        nzttces signature_state,
                        size_t siglen,
                        ub1 *signature,
                        nzttBufferBlock *extracted_message,
                        boolean *verified,
                        boolean *validated,
                        nzttIdentity **signing_party_identity);

sword OCISecurityValidate(OCISecurity *osshandle,
                          OCIError *error_handle,
                          nzttPersona *persona,
                          nzttIdentity *identity,
                          boolean *validated);

sword OCISecuritySignDetached(OCISecurity *osshandle,
                              OCIError *error_handle,
                              nzttPersona *persona,
                              nzttces signature_state,
                              size_t input_length,
                              ub1 * input,
                              nzttBufferBlock *signature);

sword OCISecuritySignDetExpansion(OCISecurity *osshandle,
                                  OCIError *error_handle,
                                  nzttPersona *persona,
                                  size_t input_length,
                                  size_t *required_buffer_length);

sword OCISecurityVerifyDetached(OCISecurity *osshandle,
                                OCIError *error_handle,
                                nzttPersona *persona,
                                nzttces signature_state,
                                size_t data_length,
                                ub1 *data,
                                size_t siglen,
                                ub1 *signature,
                                boolean *verified,
                                boolean *validated,
                                nzttIdentity **signing_party_identity);

sword OCISecurity_PKEncrypt(OCISecurity *osshandle,
                            OCIError *error_handle,
                            nzttPersona *persona,
                            size_t number_of_recipients,
                            nzttIdentity *recipient_list,
                            nzttces encryption_state,
                            size_t input_length,
                            ub1 *input,
                            nzttBufferBlock *encrypted_data);

sword OCISecurityPKEncryptExpansion(OCISecurity *osshandle,
                                    OCIError *error_handle,
                                    nzttPersona *persona,
                                    size_t number_recipients,
                                    size_t input_length,
                                    size_t *buffer_length_required);

sword OCISecurityPKDecrypt(OCISecurity *osshandle,
                           OCIError *error_handle,
                           nzttPersona *persona,
                           nzttces encryption_state,
                           size_t input_length,
                           ub1 *input,
                           nzttBufferBlock *encrypted_data);

sword OCISecurityEncrypt(OCISecurity *osshandle,
                         OCIError *error_handle,
                         nzttPersona *persona,
                         nzttces encryption_state,
                         size_t input_length,
                         ub1 *input,
                         nzttBufferBlock *encrypted_data);

sword OCISecurityEncryptExpansion(OCISecurity *osshandle,
                                  OCIError *error_handle,
                                  nzttPersona *persona,
                                  size_t input_length,
                                  size_t *encrypted_data_length);

sword OCISecurityDecrypt(OCISecurity *osshandle,
                         OCIError *error_handle,
                         nzttPersona *persona,
                         nzttces decryption_state,
                         size_t input_length,
                         ub1 *input,
                         nzttBufferBlock *decrypted_data);

sword OCISecurityEnvelope(OCISecurity *osshandle,
                          OCIError *error_handle,
                          nzttPersona *persona,
                          size_t number_of_recipients,
                          nzttIdentity *identity,
                          nzttces encryption_state,
                          size_t input_length,
                          ub1 *input,
                          nzttBufferBlock *enveloped_data);

sword OCISecurityDeEnvelope(OCISecurity *osshandle,
                            OCIError *error_handle,
                            nzttPersona *persona,
                            nzttces decryption_state,
                            size_t input_length,
                            ub1 *input,
                            nzttBufferBlock *output_message,
                            boolean *verified,
                            boolean *validated,
                            nzttIdentity **sender_identity);

sword OCISecurityKeyedHash(OCISecurity *osshandle,
                           OCIError *error_handle,
                           nzttPersona *persona,
                           nzttces hash_state,
                           size_t input_length,
                           ub1 *input,
                           nzttBufferBlock *keyed_hash);

sword OCISecurityKeyedHashExpansion(OCISecurity *osshandle,
                                    OCIError *error_handle,
                                    nzttPersona *persona,
                                    size_t input_length,
                                    size_t *required_buffer_length);

sword OCISecurityHash(OCISecurity *osshandle,
                      OCIError *error_handle,
                      nzttPersona *persona,
                      nzttces hash_state,
                      size_t input,
                      ub1 *input_length,
                      nzttBufferBlock *hash);

sword OCISecurityHashExpansion(OCISecurity *osshandle,
                               OCIError *error_handle,
                               nzttPersona *persona,
                               size_t input_length,
                               size_t *required_buffer_length);

sword OCISecuritySeedRandom(OCISecurity *osshandle,
                            OCIError *error_handle,
                            nzttPersona *persona,
                            size_t seed_length,
                            ub1 *seed);

sword OCISecurityRandomBytes(OCISecurity *osshandle,
                             OCIError *error_handle,
                             nzttPersona *persona,
                             size_t number_of_bytes_desired,
                             nzttBufferBlock *random_bytes);

sword OCISecurityRandomNumber(OCISecurity *osshandle,
                              OCIError *error_handle,
                              nzttPersona *persona,
                              uword *random_number_ptr);

sword OCISecurityInitBlock(OCISecurity *osshandle,
                           OCIError *error_handle,
                           nzttBufferBlock *buffer_block);

sword OCISecurityReuseBlock(OCISecurity *osshandle,
                            OCIError *error_handle,
                            nzttBufferBlock *buffer_block);

sword OCISecurityPurgeBlock(OCISecurity *osshandle,
                            OCIError *error_handle,
                            nzttBufferBlock *buffer_block);

sword OCISecuritySetBlock(OCISecurity *osshandle,
                          OCIError *error_handle,
                          uword flags_to_set,
                          size_t buffer_length,
                          size_t used_buffer_length,
                          ub1 *buffer,
                          nzttBufferBlock *buffer_block);

sword OCISecurityGetIdentity(OCISecurity   *osshandle,
                             OCIError      *error_handle,
                             size_t         namelen,
                             OraText          *distinguished_name,
                             nzttIdentity **identity);

sword OCIAQEnq(OCISvcCtx *svchp, OCIError *errhp, OraText *queue_name,
                 OCIAQEnqOptions *enqopt, OCIAQMsgProperties *msgprop,
                 OCIType *payload_tdo, void **payload, void **payload_ind, 
                 OCIRaw **msgid, ub4 flags); 

sword OCIAQDeq(OCISvcCtx *svchp, OCIError *errhp, OraText *queue_name,
                 OCIAQDeqOptions *deqopt, OCIAQMsgProperties *msgprop,
                 OCIType *payload_tdo, void **payload, void **payload_ind, 
                 OCIRaw **msgid, ub4 flags); 

sword OCIAQEnqArray(OCISvcCtx *svchp, OCIError *errhp, OraText *queue_name,
                    OCIAQEnqOptions *enqopt, ub4 *iters,
                    OCIAQMsgProperties **msgprop, OCIType *payload_tdo,
                    void **payload, void **payload_ind, OCIRaw **msgid,
                    void *ctxp, OCICallbackAQEnq enqcbfp, ub4 flags);

sword OCIAQDeqArray(OCISvcCtx *svchp, OCIError *errhp, OraText *queue_name,
                    OCIAQDeqOptions *deqopt, ub4 *iters,
                    OCIAQMsgProperties **msgprop, OCIType *payload_tdo,
                    void **payload, void **payload_ind, OCIRaw **msgid,
                    void *ctxp, OCICallbackAQDeq deqcbfp, ub4 flags);

sword OCIAQListen(OCISvcCtx *svchp, OCIError *errhp, 
                      OCIAQAgent **agent_list, ub4 num_agents,
                      sb4 wait, OCIAQAgent **agent,
                      ub4 flags);

sword OCIAQListen2(OCISvcCtx *svchp, OCIError *errhp, 
                   OCIAQAgent **agent_list, ub4 num_agents,
                   OCIAQListenOpts  *lopts, OCIAQAgent **agent, 
                   OCIAQLisMsgProps *lmops, ub4 flags);

sword OCIExtractInit(void *hndl, OCIError *err);

sword OCIExtractTerm(void *hndl, OCIError *err);

sword OCIExtractReset(void *hndl, OCIError *err);

sword OCIExtractSetNumKeys(void *hndl, OCIError *err, uword numkeys);

sword OCIExtractSetKey(void *hndl, OCIError *err, const OraText *name, 
                       ub1 type, ub4 flag, const void *defval, 
                       const sb4 *intrange, const OraText *const *strlist);

sword OCIExtractFromFile(void *hndl, OCIError *err, ub4 flag, 
                         OraText *filename);

sword OCIExtractFromStr(void *hndl, OCIError *err, ub4 flag, OraText *input);

sword OCIExtractToInt(void *hndl, OCIError *err, OraText *keyname, 
                      uword valno, sb4 *retval);

sword OCIExtractToBool(void *hndl, OCIError *err, OraText *keyname, 
                       uword valno, ub1 *retval);

sword OCIExtractToStr(void *hndl, OCIError *err, OraText *keyname, 
                      uword valno, OraText *retval, uword buflen);

sword OCIExtractToOCINum(void *hndl, OCIError *err, OraText *keyname, 
                         uword valno, OCINumber *retval);

sword OCIExtractToList(void *hndl, OCIError *err, uword *numkeys);

sword OCIExtractFromList(void *hndl, OCIError *err, uword index, 
                         OraText **name, 
                         ub1 *type, uword *numvals, void ***values);
#line 7206
sword OCIMemoryAlloc(void *hdl, OCIError *err, void **mem,
        OCIDuration dur, ub4 size, ub4 flags);

sword OCIMemoryResize(void *hdl, OCIError *err, void **mem,
                        ub4 newsize, ub4 flags);

sword OCIMemoryFree(void *hdl, OCIError *err, void *mem);

sword OCIContextSetValue(void *hdl, OCIError *err, OCIDuration duration,
                        ub1 *key, ub1 keylen, void *ctx_value);

sword OCIContextGetValue(void *hdl, OCIError *err, ub1 *key,
                        ub1 keylen, void **ctx_value);

sword OCIContextClearValue(void *hdl, OCIError *err, ub1 *key, 
                        ub1 keylen);

sword OCIContextGenerateKey(void *hdl, OCIError *err, ub4 *key);

sword OCIMemorySetCurrentIDs(void *hdl, OCIError *err, 
                             ub4 curr_session_id, ub4 curr_trans_id, 
                             ub4 curr_stmt_id);

sword OCIPicklerTdsCtxInit(OCIEnv *env, OCIError *err, 
                           OCIPicklerTdsCtx **tdsc);

sword OCIPicklerTdsCtxFree(OCIEnv *env, OCIError *err, OCIPicklerTdsCtx *tdsc);

sword OCIPicklerTdsInit(OCIEnv *env, OCIError *err, OCIPicklerTdsCtx *tdsc, 
                                        OCIPicklerTds **tdsh);

sword OCIPicklerTdsFree(OCIEnv *env, OCIError *err, OCIPicklerTds *tdsh);

sword OCIPicklerTdsCreateElementNumber(OCIEnv *env, OCIError *err, 
                                        OCIPicklerTds *tdsh, ub1 prec, 
                                        sb1 scale, OCIPicklerTdsElement *elt);

sword OCIPicklerTdsCreateElementChar(OCIEnv *env, OCIError *err, 
                                     OCIPicklerTds *tdsh, ub2 len, 
                                     OCIPicklerTdsElement *elt);

sword OCIPicklerTdsCreateElementVarchar(OCIEnv *env, OCIError *err, 
                                        OCIPicklerTds *tdsh, ub2 len, 
                                        OCIPicklerTdsElement *elt);

sword OCIPicklerTdsCreateElementRaw(OCIEnv *env, OCIError *err, 
                                    OCIPicklerTds *tdsh, ub2 len, 
                                    OCIPicklerTdsElement *elt);

sword OCIPicklerTdsCreateElement(OCIEnv *env, OCIError *err, 
                                 OCIPicklerTds *tdsh, OCITypeCode dty, 
                                 OCIPicklerTdsElement *elt);

sword OCIPicklerTdsAddAttr(OCIEnv *env, OCIError *err, 
                           OCIPicklerTds *tdsh, OCIPicklerTdsElement elt);

sword OCIPicklerTdsGenerate(OCIEnv *env, OCIError *err, 
                                OCIPicklerTds *tdsh);

sword OCIPicklerTdsGetAttr(OCIEnv *env, OCIError *err, 
                                const OCIPicklerTds *tdsh, ub1  attrno,
                                OCITypeCode *typ, ub2  *len);

sword OCIPicklerFdoInit(OCIEnv *env, OCIError *err, 
                                OCIPicklerFdo **fdoh);

sword OCIPicklerFdoFree(OCIEnv *env, OCIError *err, 
                                OCIPicklerFdo *fdoh);

sword OCIPicklerImageInit(OCIEnv *env, OCIError *err, 
                          OCIPicklerFdo *fdoh, 
                          OCIPicklerTds *tdsh,
                          OCIPicklerImage **imgh);

sword OCIPicklerImageFree(OCIEnv *env, OCIError *err, 
                                OCIPicklerImage *imgh);

sword OCIPicklerImageAddScalar(OCIEnv *env, OCIError *err,  
                               OCIPicklerImage *imgh, 
                               void *scalar, ub4  len);

sword OCIPicklerImageAddNullScalar(OCIEnv *env, OCIError *err, 
                                OCIPicklerImage *imgh);

sword OCIPicklerImageGenerate(OCIEnv *env, OCIError *err, 
                                OCIPicklerImage *imgh);

sword OCIPicklerImageGetScalarSize(OCIEnv *env, OCIError *err, 
                                OCIPicklerImage *imgh, 
                                ub4  attrno, ub4  *size);

sword OCIPicklerImageGetScalar(OCIEnv *env, OCIError *err, 
                                OCIPicklerImage *imgh, ub4  attrno, 
                                void *buf, ub4  *len, OCIInd *ind);

sword OCIPicklerImageCollBegin(OCIEnv *env, OCIError *err,
                OCIPicklerImage *imgh, const OCIPicklerTds *colltdsh);

sword OCIPicklerImageCollAddScalar( OCIEnv *env, OCIError *err,
                OCIPicklerImage *imgh, void *scalar,
                ub4 buflen, OCIInd ind);

sword OCIPicklerImageCollEnd(OCIEnv *env, OCIError *err,
                OCIPicklerImage *imgh);
#line 7312
sword OCIPicklerImageCollBeginScan(OCIEnv *env, OCIError *err,
                OCIPicklerImage *imgh, const OCIPicklerTds *coll_tdsh,
                ub4 attrnum, ub4 startidx, OCIInd *ind);

sword OCIPicklerImageCollGetScalarSize(OCIEnv *env, OCIError *err,
                const OCIPicklerTds *coll_tdsh, ub4 *size);

sword OCIPicklerImageCollGetScalar(OCIEnv *env, OCIError *err,
                                   OCIPicklerImage *imgh, void *buf,
                                   ub4 *buflen, OCIInd *ind);

sword OCIAnyDataGetType(OCISvcCtx *svchp, OCIError *errhp, OCIAnyData *sdata,
        OCITypeCode *tc, OCIType **type);

sword OCIAnyDataIsNull(OCISvcCtx *svchp, OCIError *errhp, OCIAnyData *sdata,
        boolean *isnull);

sword OCIAnyDataConvert(OCISvcCtx *svchp, OCIError *errhp, OCITypeCode tc,
        OCIType *type, OCIDuration dur, void *ind, void *data_val,
        ub4 len, OCIAnyData **sdata);

sword OCIAnyDataBeginCreate(OCISvcCtx *svchp, OCIError *errhp, OCITypeCode tc,
        OCIType *type, OCIDuration dur, OCIAnyData **sdata);

sword OCIAnyDataDestroy(OCISvcCtx *svchp, OCIError *errhp, OCIAnyData *sdata);

sword OCIAnyDataAttrSet(OCISvcCtx *svchp, OCIError *errhp, OCIAnyData *sdata,
        OCITypeCode tc, OCIType *type, void *ind, void *attr_val,
        ub4 length, boolean is_any);

sword OCIAnyDataCollAddElem(OCISvcCtx *svchp, OCIError *errhp,
        OCIAnyData *sdata, OCITypeCode tc, OCIType *type, void *ind,
        void *attr_val, ub4 length, boolean is_any, boolean last_elem);

sword OCIAnyDataEndCreate(OCISvcCtx *svchp, OCIError *errhp,
                          OCIAnyData *sdata);

sword OCIAnyDataAccess(OCISvcCtx *svchp, OCIError *errhp, OCIAnyData *sdata,
        OCITypeCode tc, OCIType *type, void *ind, void *attr_val,
        ub4 *length);

sword OCIAnyDataGetCurrAttrNum(OCISvcCtx *svchp, OCIError *errhp, 
                               OCIAnyData *sdata, ub4 *attrnum);

sword OCIAnyDataAttrGet(OCISvcCtx *svchp, OCIError *errhp, OCIAnyData *sdata,
  OCITypeCode tc, OCIType *type, void *ind, void *attr_val,
        ub4 *length, boolean is_any);

sword OCIAnyDataCollGetElem(OCISvcCtx *svchp, OCIError *errhp,
  OCIAnyData *sdata,
  OCITypeCode tc, OCIType *type, void *ind, void *celem_val,
  ub4 *length, boolean is_any);
#line 7397
sword OCIAnyDataSetBeginCreate(OCISvcCtx *svchp, OCIError *errhp,
     OCITypeCode typecode, const OCIType *type, OCIDuration dur,
     OCIAnyDataSet ** data_set);
#line 7414
sword OCIAnyDataSetDestroy(OCISvcCtx *svchp, OCIError *errhp,
     OCIAnyDataSet *data_set);
#line 7451
sword OCIAnyDataSetAddInstance(OCISvcCtx *svchp, OCIError *errhp,
     OCIAnyDataSet *data_set, OCIAnyData **data);
#line 7470
sword OCIAnyDataSetEndCreate(OCISvcCtx *svchp, OCIError *errhp,
     OCIAnyDataSet *data_set);
#line 7492
sword OCIAnyDataSetGetType (OCISvcCtx *svchp, OCIError *errhp,
     OCIAnyDataSet *data_set, OCITypeCode *tc, OCIType **type);
#line 7508
sword OCIAnyDataSetGetCount(OCISvcCtx *svchp, OCIError *errhp,
     OCIAnyDataSet *data_set, ub4 *count);
#line 7543
sword OCIAnyDataSetGetInstance(OCISvcCtx *svchp, OCIError *errhp,
     OCIAnyDataSet *data_set, OCIAnyData **data);
#line 7548
sword OCIFormatInit(void *hndl, OCIError *err);

sword OCIFormatString(void *hndl, OCIError *err, OraText *buffer,
                      sbig_ora bufferLength, sbig_ora *returnLength,
                      const OraText *formatString, ...);

sword OCIFormatTerm(void *hndl, OCIError *err);

sword OCIFormatTUb1(void);
sword OCIFormatTUb2(void);
sword OCIFormatTUb4(void);
sword OCIFormatTUword(void);
sword OCIFormatTUbig_ora(void);
sword OCIFormatTSb1(void);
sword OCIFormatTSb2(void);
sword OCIFormatTSb4(void);
sword OCIFormatTSword(void);
sword OCIFormatTSbig_ora(void);
sword OCIFormatTEb1(void);
sword OCIFormatTEb2(void);
sword OCIFormatTEb4(void);
sword OCIFormatTEword(void);
sword OCIFormatTChar(void);
sword OCIFormatTText(void);
sword OCIFormatTDouble(void);
sword OCIFormatTDvoid(void);
sword OCIFormatTEnd(void);
#line 7587
OCISvcCtx *xaosvch(OraText *dbname);
#line 7602
OCISvcCtx *xaoSvcCtx(OraText *dbname);
#line 7617
OCIEnv *xaoEnv(OraText *dbname);
#line 7626
int xaosterr(OCISvcCtx *svch, sb4 error);
#line 7712
sword OCINlsGetInfo(void *envhp, OCIError *errhp, OraText *buf,
                    size_t buflen, ub2 item);
#line 7741
sword OCINlsNumericInfoGet(void *envhp, OCIError *errhp, sb4 *val, ub2 item);
#line 7759
ub2 OCINlsCharSetNameToId(void *envhp, const oratext *name);
#line 7782
sword OCINlsCharSetIdToName(void *envhp, oratext *buf, size_t buflen, ub2 id);
#line 7819
sword OCINlsNameMap(void *envhp, oratext *buf, size_t buflen,
                    const oratext *srcbuf, ub4 flag);
#line 7842
sword OCIMultiByteToWideChar(void *envhp, OCIWchar *dst, const OraText *src,
                             size_t *rsize);
#line 7877
sword OCIMultiByteInSizeToWideChar(void *envhp, OCIWchar *dst,
                                  size_t dstsz, const OraText *src, 
                                  size_t srcsz, size_t *rsize);
#line 7902
sword OCIWideCharToMultiByte(void *envhp, OraText *dst, const OCIWchar *src,
                             size_t *rsize);
#line 7937
sword OCIWideCharInSizeToMultiByte(void *envhp, OraText *dst,
                                    size_t dstsz, const OCIWchar *src,
                                    size_t srcsz, size_t *rsize);
#line 7956
boolean OCIWideCharIsAlnum(void *envhp, OCIWchar wc);
#line 7972
boolean OCIWideCharIsAlpha(void *envhp, OCIWchar wc);
#line 7988
boolean OCIWideCharIsCntrl(void *envhp, OCIWchar wc);
#line 8004
boolean OCIWideCharIsDigit(void *envhp, OCIWchar wc);
#line 8022
boolean OCIWideCharIsGraph(void *envhp, OCIWchar wc);
#line 8038
boolean OCIWideCharIsLower(void *envhp, OCIWchar wc);
#line 8054
boolean OCIWideCharIsPrint(void *envhp, OCIWchar wc);
#line 8070
boolean OCIWideCharIsPunct(void *envhp, OCIWchar wc);
#line 8088
boolean OCIWideCharIsSpace(void *envhp, OCIWchar wc);
#line 8104
boolean OCIWideCharIsUpper(void *envhp, OCIWchar wc);
#line 8120
boolean OCIWideCharIsXdigit(void *envhp, OCIWchar wc);
#line 8137
boolean OCIWideCharIsSingleByte(void *envhp, OCIWchar wc);
#line 8154
OCIWchar OCIWideCharToLower(void *envhp, OCIWchar wc);
#line 8171
OCIWchar OCIWideCharToUpper(void *envhp, OCIWchar wc);
#line 8199
int OCIWideCharStrcmp(void *envhp, const OCIWchar *wstr1, 
                const OCIWchar *wstr2, int flag);
#line 8233
int OCIWideCharStrncmp(void *envhp, const OCIWchar *wstr1, size_t len1,
                 const OCIWchar *wstr2, size_t len2, int flag);
#line 8256
size_t OCIWideCharStrcat(void *envhp, OCIWchar *wdststr,
                         const OCIWchar *wsrcstr);
#line 8277
OCIWchar *OCIWideCharStrchr(void *envhp, const OCIWchar *wstr,
                            OCIWchar wc);
#line 8298
size_t OCIWideCharStrcpy(void *envhp, OCIWchar *wdststr,
                         const OCIWchar *wsrcstr);
#line 8317
size_t OCIWideCharStrlen(void *envhp, const OCIWchar *wstr);
#line 8341
size_t OCIWideCharStrncat(void *envhp, OCIWchar *wdststr,
                          const OCIWchar *wsrcstr, size_t n);
#line 8365
size_t OCIWideCharStrncpy(void *envhp, OCIWchar *wdststr,
                          const OCIWchar *wsrcstr, size_t n);
#line 8386
OCIWchar *OCIWideCharStrrchr(void *envhp, const OCIWchar *wstr,
                             OCIWchar wc);
#line 8414
size_t OCIWideCharStrCaseConversion(void *envhp, OCIWchar *wdststr,
                                    const OCIWchar *wsrcstr, ub4 flag);
#line 8433
size_t OCIWideCharDisplayLength(void *envhp, OCIWchar wc );
#line 8450
size_t OCIWideCharMultiByteLength(void *envhp, OCIWchar wc);
#line 8478
int OCIMultiByteStrcmp(void *envhp, const OraText *str1,
                       const OraText *str2, int flag);
#line 8512
int OCIMultiByteStrncmp(void *envhp, const OraText *str1, size_t len1,
                        OraText *str2, size_t len2, int flag);
#line 8535
size_t OCIMultiByteStrcat(void *envhp, OraText *dststr,
                          const OraText *srcstr);
#line 8557
size_t OCIMultiByteStrcpy(void *envhp, OraText *dststr,
                          const OraText *srcstr);
#line 8574
size_t OCIMultiByteStrlen(void *envhp, const OraText *str);
#line 8598
size_t OCIMultiByteStrncat(void *envhp, OraText *dststr,
                           const OraText *srcstr, size_t n);
#line 8623
size_t OCIMultiByteStrncpy(void *envhp, OraText *dststr,
                           const OraText *srcstr, size_t n);
#line 8644
size_t OCIMultiByteStrnDisplayLength(void *envhp, const OraText *str1,
                                     size_t n);
#line 8671
size_t OCIMultiByteStrCaseConversion(void *envhp, OraText *dststr,
                                     const OraText *srcstr, ub4 flag);
#line 8702
sword OCICharSetToUnicode(void *envhp, ub2 *dst, size_t dstlen,
                          const OraText *src, size_t  srclen, size_t *rsize);
#line 8736
sword OCIUnicodeToCharSet(void *envhp, OraText *dst, size_t dstlen, 
                           const ub2 *src, size_t srclen, size_t *rsize);
#line 8782
sword OCINlsCharSetConvert(void *envhp, OCIError *errhp, 
                        ub2 dstid, void *dstp, size_t dstlen,
                        ub2 srcid, const void *srcp, size_t srclen,
                        size_t *rsize);
#line 8804
boolean OCICharSetConversionIsReplacementUsed(void *envhp);
#line 8842
sword OCINlsEnvironmentVariableGet(void  *valp, size_t size, ub2 item,
                                   ub2 charset, size_t *rsize);
#line 8889
sword OCIMessageOpen(void *envhp, OCIError *errhp, OCIMsg **msghp,
                      const OraText *product, const OraText *facility, 
                      OCIDuration dur);
#line 8919
OraText *OCIMessageGet(OCIMsg *msgh, ub4 msgno, OraText *msgbuf,
                       size_t buflen);
#line 8941
sword OCIMessageClose(void *envhp, OCIError *errhp, OCIMsg *msghp);
#line 10068
void OCIThreadProcessInit();

sword OCIThreadInit(void *hndl, OCIError *err);

sword OCIThreadTerm(void *hndl, OCIError *err);

boolean OCIThreadIsMulti();

sword OCIThreadMutexInit(void *hndl, OCIError *err,  
                         OCIThreadMutex **mutex); 

sword OCIThreadMutexDestroy(void *hndl, OCIError *err, 
                            OCIThreadMutex **mutex);

sword OCIThreadMutexAcquire(void *hndl, OCIError *err,
                            OCIThreadMutex *mutex);

sword OCIThreadMutexRelease(void *hndl, OCIError *err,
                            OCIThreadMutex *mutex);

sword OCIThreadKeyInit(void *hndl, OCIError *err, OCIThreadKey **key,
                       OCIThreadKeyDestFunc destFn);

sword OCIThreadKeyDestroy(void *hndl, OCIError *err, 
                          OCIThreadKey **key);

sword OCIThreadKeyGet(void *hndl, OCIError *err, OCIThreadKey *key,
                      void **pValue);

sword OCIThreadKeySet(void *hndl, OCIError *err, OCIThreadKey *key,
                      void *value);

sword OCIThreadIdInit(void *hndl, OCIError *err, OCIThreadId **tid);

sword OCIThreadIdDestroy(void *hndl, OCIError *err, OCIThreadId **tid);

sword OCIThreadIdSet(void *hndl, OCIError *err, 
                     OCIThreadId *tidDest, OCIThreadId *tidSrc);

sword OCIThreadIdSetNull(void *hndl, OCIError *err, OCIThreadId *tid);

sword OCIThreadIdGet(void *hndl, OCIError *err, OCIThreadId *tid);

sword OCIThreadIdSame(void *hndl, OCIError *err,
                      OCIThreadId *tid1, OCIThreadId *tid2,
                      boolean *result);

sword OCIThreadIdNull(void *hndl, OCIError *err,
                      OCIThreadId *tid, boolean *result);

sword OCIThreadHndInit(void *hndl, OCIError *err, OCIThreadHandle **thnd);

sword OCIThreadHndDestroy(void *hndl, OCIError *err, OCIThreadHandle **thnd);

sword OCIThreadCreate(void *hndl, OCIError *err,
                      void (*start)(void *), void *arg,
                      OCIThreadId *tid, OCIThreadHandle *tHnd);

sword OCIThreadJoin(void *hndl, OCIError *err, OCIThreadHandle *tHnd);

sword OCIThreadClose(void *hndl, OCIError *err, OCIThreadHandle *tHnd);

sword OCIThreadHandleGet(void *hndl, OCIError *err, OCIThreadHandle *tHnd);
#line 10135
typedef sword (*OCIBindRowCallback)(void *ctx);
typedef sword (*OCIFetchRowCallback)(void *ctx);
#line 10142
typedef ub4 (*OCISubscriptionNotify)(void *ctx, OCISubscription *subscrhp, 
                                     void *pay, ub4 payl, 
                                     void *desc, ub4 mode);

sword OCISubscriptionRegister(OCISvcCtx *svchp, OCISubscription **subscrhpp, 
                              ub2 count, OCIError *errhp, ub4 mode);
#line 10150
sword OCISubscriptionPost(OCISvcCtx *svchp, OCISubscription **subscrhpp, 
                              ub2 count, OCIError *errhp, ub4 mode);

sword OCISubscriptionUnRegister(OCISvcCtx *svchp, OCISubscription *subscrhp, 
                              OCIError *errhp, ub4 mode);

sword OCISubscriptionDisable(OCISubscription *subscrhp, 
                           OCIError *errhp, ub4 mode);

sword OCISubscriptionEnable(OCISubscription *subscrhp, 
                          OCIError *errhp, ub4 mode);
#line 10166
sword OCIDateTimeGetTime(void *hndl, OCIError *err, OCIDateTime *datetime, 
                         ub1 *hr, ub1 *mm, ub1 *ss, ub4 *fsec);

sword OCIDateTimeGetDate(void *hndl, OCIError *err,  const OCIDateTime *date, 
                 sb2 *yr, ub1 *mnth, ub1 *dy );

sword OCIDateTimeGetTimeZoneOffset(void *hndl,OCIError *err,
                                   const OCIDateTime *datetime,
                                   sb1 *hr,sb1 *mm);

sword OCIDateTimeConstruct(void  *hndl,OCIError *err,OCIDateTime *datetime,
               sb2 yr,ub1 mnth,ub1 dy,ub1 hr,ub1 mm,ub1 ss,ub4 fsec,
               OraText  *timezone,size_t timezone_length);

sword OCIDateTimeSysTimeStamp(void *hndl, OCIError *err, 
                              OCIDateTime *sys_date );

sword OCIDateTimeAssign(void *hndl, OCIError *err, const OCIDateTime *from, 
                       OCIDateTime *to);

sword OCIDateTimeToText(void *hndl, OCIError *err, const OCIDateTime *date, 
                        const OraText *fmt, ub1 fmt_length, ub1 fsprec, 
                        const OraText *lang_name, size_t lang_length, 
                        ub4 *buf_size, OraText *buf );

sword OCIDateTimeFromText(void *hndl, OCIError *err, const OraText *date_str, 
             size_t dstr_length, const OraText *fmt, ub1 fmt_length,
             const OraText *lang_name, size_t lang_length, OCIDateTime *date );

sword OCIDateTimeCompare(void *hndl, OCIError *err, const OCIDateTime *date1, 
                     const OCIDateTime *date2,  sword *result );

sword OCIDateTimeCheck(void *hndl, OCIError *err, const OCIDateTime *date, 
                 ub4 *valid );

sword OCIDateTimeConvert(void *hndl, OCIError *err, OCIDateTime *indate,
                                OCIDateTime *outdate);

sword OCIDateTimeSubtract(void *hndl, OCIError *err, OCIDateTime *indate1, 
                OCIDateTime *indate2,    OCIInterval *inter);

sword OCIDateTimeIntervalAdd(void *hndl, OCIError *err, OCIDateTime *datetime,
         OCIInterval *inter, OCIDateTime *outdatetime);

sword OCIDateTimeIntervalSub(void *hndl, OCIError *err, OCIDateTime *datetime,
         OCIInterval *inter, OCIDateTime *outdatetime);

sword OCIIntervalSubtract(void *hndl, OCIError *err, OCIInterval *minuend, 
                            OCIInterval *subtrahend, OCIInterval *result );

sword OCIIntervalAdd(void *hndl, OCIError *err, OCIInterval *addend1, 
                        OCIInterval *addend2, OCIInterval *result );

sword OCIIntervalMultiply(void *hndl, OCIError *err, const OCIInterval *inter,
                        OCINumber *nfactor, OCIInterval *result );

sword OCIIntervalDivide(void *hndl, OCIError *err, OCIInterval *dividend, 
                OCINumber *divisor, OCIInterval *result );

sword OCIIntervalCompare(void *hndl, OCIError *err, OCIInterval *inter1, 
                        OCIInterval *inter2, sword *result );

sword OCIIntervalFromNumber(void *hndl, OCIError *err, OCIInterval *inter, 
                        OCINumber *number);

sword OCIIntervalFromText( void *hndl, OCIError *err, const OraText *inpstr, 
                size_t str_len, OCIInterval *result );

sword OCIIntervalToText( void *hndl, OCIError *err, const OCIInterval *inter,
                         ub1 lfprec, ub1 fsprec, 
                        OraText *buffer, size_t buflen, size_t *resultlen );

sword OCIIntervalToNumber(void *hndl, OCIError *err,const OCIInterval *inter, 
                        OCINumber *number);

sword OCIIntervalCheck(void *hndl, OCIError *err, const OCIInterval *interval,
                         ub4 *valid );

sword OCIIntervalAssign(void *hndl, OCIError *err, const OCIInterval *ininter,
                        OCIInterval *outinter );

sword OCIIntervalSetYearMonth(void *hndl, OCIError *err, sb4 yr, sb4 mnth,
                        OCIInterval *result );

sword OCIIntervalGetYearMonth(void *hndl, OCIError *err, sb4 *yr, sb4 *mnth,
                        const OCIInterval *result );

sword OCIIntervalSetDaySecond(void *hndl, OCIError *err, sb4 dy, sb4 hr,
                        sb4 mm, sb4 ss, sb4 fsec, OCIInterval *result );

sword OCIIntervalGetDaySecond(void *hndl, OCIError *err, sb4 *dy, sb4 *hr,
                     sb4 *mm, sb4 *ss, sb4 *fsec, const OCIInterval *result );

sword OCIDateTimeToArray(void *hndl, OCIError *err,
                         const OCIDateTime *datetime, const OCIInterval *reftz,
                         ub1 *outarray, ub4 *len, ub1 fsprec);

sword OCIDateTimeFromArray(void *hndl, OCIError *err, ub1 *inarray, ub4 len,
                           ub1 type, OCIDateTime *datetime,
                           const OCIInterval *reftz, ub1 fsprec);

sword OCIDateTimeGetTimeZoneName(void *hndl, OCIError *err,
                                 const OCIDateTime *datetime, 
                                 ub1 *buf, ub4 *buflen);

sword OCIIntervalFromTZ(void *hndl, OCIError *err, const oratext *inpstring,
                        size_t str_len, OCIInterval *result);
#line 10277
sword OCIConnectionPoolCreate(OCIEnv *envhp, OCIError *errhp, OCICPool *poolhp,
                              OraText **poolName, sb4 *poolNameLen,  
                              const OraText *dblink, sb4 dblinkLen,
                              ub4 connMin, ub4 connMax, ub4 connIncr,
                              const OraText *poolUserName, sb4 poolUserLen,
                              const OraText *poolPassword, sb4 poolPassLen,
                              ub4 mode);

sword OCIConnectionPoolDestroy(OCICPool *poolhp,
                               OCIError *errhp, ub4 mode);
#line 10292
sword OCISessionPoolCreate (OCIEnv *envhp, OCIError *errhp, OCISPool *spoolhp, 
                            OraText **poolName, ub4 *poolNameLen, 
                            const OraText *connStr, ub4 connStrLen,
                            ub4 sessMin, ub4 sessMax, ub4 sessIncr,
                            OraText *userid, ub4 useridLen,
                            OraText *password, ub4 passwordLen,
                            ub4 mode);

sword OCISessionPoolDestroy (OCISPool *spoolhp,
                             OCIError *errhp,
                             ub4 mode);

sword OCISessionGet (OCIEnv *envhp, OCIError *errhp, OCISvcCtx **svchp,
                     OCIAuthInfo *authhp,
                     OraText *poolName, ub4 poolName_len, 
                     const OraText *tagInfo, ub4 tagInfo_len,
                     OraText **retTagInfo, ub4 *retTagInfo_len,
                     boolean *found, ub4 mode);

sword OCISessionRelease (OCISvcCtx *svchp, OCIError *errhp,
                         OraText *tag, ub4 tag_len,
                         ub4 mode);
#line 10320
sword OCIAppCtxSet(void * sesshndl, void *nsptr, ub4 nsptrlen,
                   void *attrptr,  ub4 attrptrlen,
                   void *valueptr, ub4 valueptrlen,
                   OCIError *errhp, ub4 mode);

sword OCIAppCtxClearAll(void *sesshndl, void *nsptr, ub4 nsptrlen,
                        OCIError *errhp, ub4 mode);
#line 10329
sword OCIPing (OCISvcCtx *svchp, OCIError *errhp, ub4 mode);
#line 10333
sword OCIKerbAttrSet(OCISession *trgthndlp, ub4 cred_use, ub1 *ftgt_ticket, 
                     ub4 ticket_len, ub1 *session_key, ub4 skey_len, 
                     ub2 ftgt_keytype, ub4 ftgt_ticket_flags, 
                     sb4 ftgt_auth_time, sb4 ftgt_start_time, 
                     sb4 ftgt_end_time, sb4 ftgt_renew_time, 
                     text *ftgt_client_principal, 
                     ub4 ftgt_client_principal_len, text *ftgt_client_realm,
                     ub4 ftgt_client_realm_len, OCIError *errhp);
#line 10346
sword OCIDBStartup (OCISvcCtx     *svchp,
                    OCIError      *errhp,
                    OCIAdmin      *admhp,
                    ub4            mode,
                    ub4            flags);

sword OCIDBShutdown(OCISvcCtx     *svchp,
                    OCIError      *errhp,
                    OCIAdmin      *admhp,
                    ub4            mode);
#line 10360
void OCIClientVersion(sword *major_version,
                      sword *minor_version,
                      sword *update_num,
                      sword *patch_num,
                      sword *port_update_num);
#line 10369
sword OCIInitEventHandle(OCIError *errhp, 
                         OCIEvent *event,
                         text     *str,
                         ub4       size);
#line 57 "/oracle/app/product/10.2.0/db_1/rdbms/public/ocixmldb.h"
struct xmlctx; typedef struct xmlctx xmlctx;
#line 60
typedef enum 
{
  XCTXINIT_OCIDUR  = 1,
  XCTXINIT_ERRHDL  = 2
} ocixmldbpname;

typedef struct ocixmldbparam
{
  ocixmldbpname   name_ocixmldbparam;
  void           *value_ocixmldbparam;
} ocixmldbparam;
#line 126
struct xmlctx *OCIXmlDbInitXmlCtx(OCIEnv *, OCISvcCtx *, OCIError *, 
                            ocixmldbparam *, int);

void    OCIXmlDbFreeXmlCtx(struct xmlctx *xctx);
#line 63 "/oracle/app/product/10.2.0/db_1/rdbms/public/oci8dp.h"
typedef struct OCIDirPathCtx      OCIDirPathCtx;                   
typedef struct OCIDirPathFuncCtx  OCIDirPathFuncCtx;      
typedef struct OCIDirPathColArray OCIDirPathColArray;         
typedef struct OCIDirPathStream   OCIDirPathStream;                 
typedef struct OCIDirPathDesc     OCIDirPathDesc;   
#line 133
sword
OCIDirPathAbort( OCIDirPathCtx *dpctx, OCIError *errhp );
#line 148
sword
OCIDirPathDataSave( OCIDirPathCtx *dpctx, OCIError *errhp, ub4 action );
#line 162
sword
OCIDirPathFinish( OCIDirPathCtx *dpctx, OCIError  *errhp );
#line 176
sword
OCIDirPathFlushRow( OCIDirPathCtx *dpctx, OCIError  *errhp );
#line 190
sword
OCIDirPathPrepare( OCIDirPathCtx *dpctx, OCISvcCtx *svchp,
                      OCIError  *errhp );
#line 206
sword
OCIDirPathLoadStream( OCIDirPathCtx *dpctx, OCIDirPathStream *dpstr,
                         OCIError      *errhp );
#line 225
sword
OCIDirPathColArrayEntryGet( OCIDirPathColArray *dpca, OCIError *errhp,
                              ub4 rownum, ub2 colIdx, ub1 **cvalpp, ub4 *clenp,
                              ub1 *cflgp );
#line 242
sword
OCIDirPathColArrayEntrySet( OCIDirPathColArray *dpca, OCIError *errhp,
                               ub4 rownum, ub2 colIdx, ub1 *cvalp, ub4 clen,
                               ub1 cflg );
#line 261
sword
OCIDirPathColArrayRowGet( OCIDirPathColArray *dpca, OCIError *errhp,
                         ub4 rownum, ub1 ***cvalppp, ub4 **clenpp,
                         ub1 **cflgpp );
#line 279
sword
OCIDirPathColArrayReset( OCIDirPathColArray *dpca, OCIError *errhp );
#line 294
sword
OCIDirPathColArrayToStream( OCIDirPathColArray *dpca,  OCIDirPathCtx *dpctx,
                               OCIDirPathStream   *dpstr, OCIError      *errhp,
                               ub4 rowcnt, ub4 rowoff );
#line 313
sword
OCIDirPathStreamReset( OCIDirPathStream *dpstr, OCIError *errhp );
#line 2690 "/oracle/app/product/10.2.0/db_1/rdbms/public/oci.h"
}
#line 4 "/cbilling/app/petri/libsrc/liboci/exception.h"
class TException
{
public:
  TException();
  TException(const char* err);
  virtual ~TException();

  virtual char* GetErrMsg() const;
private:
  char errMsg[1024+1];
};
#line 24 "/usr/vacpp/include/strings.h"
      inline char  *index(const char *, int );
      inline char  *rindex(const char *, int );
extern "C" {
#line 41 "/usr/include/strings.h"
extern "C" {
#line 64
extern int bcmp(const void *, const void *, size_t);
extern void bcopy(const void *, void *, size_t);
extern void bzero(void *, size_t);
extern int  ffs(int);

extern char *index(const char *, int);
extern char *rindex(const char *, int);
#line 93
}
}
#line 5 "/usr/vacpp/include/stdarg.h"
extern "C" {

}
#line 11 "/cbilling/app/petri/libsrc/lib/Exception.h"
class Exception
{
  public:

    Exception(int code, int err, int line, char *file);
    Exception(int code, int err, int line, char const *file); 
    Exception(int code, int err, int line, char const *file,char const *format, ...);         
#line 20
    char *descript();

  public:

    int m_iCode;
#line 27
    int m_iErrNo;
#line 30
    int m_iLineNo;
#line 33
    char  m_sFile[200];

    char m_sBuf[1024];
#line 38
};
#line 41
class SRException
{
  public:

    SRException(int code, int err, int line, char const *file,char const *format, ...);         

  public:

    int m_iCode;
#line 52
    int m_iErrNo;
#line 55
    int m_iLineNo;
#line 58
    char  m_sFile[200];

    char m_sBuf[2048];
#line 63
};
#line 10 "/cbilling/app/petri/libsrc/liboci/TOCIQuery.h"
typedef signed int dword;
const int PREFETCH_ROWS = 200;						 
const	int MAX_STRING_VALUE_LENGTH = 255;			 
const	int MAX_LOB_BUFFER_LENGTH = 1024;			 
const	int MAX_ERRMSG_LENGTH = 1024;					 
const	int MAX_SQLSTMT_LENGTH = 1024;				 
const	int MAX_PARAMS_COUNT = 100;						 
const	int MAX_ERR_CAT_LENGTH = 50;					 
const	int LOB_FLUSH_BUFFER_SIZE = 400*1024;		 
#line 21
const	char* const ERR_GENERAL = "General Error: %s";  
const	char* const ERR_INDEX_OUT_OF_BOUND = "%s";     
const	char* const ERR_DB_INIT = "OCI: OCI handles init fail in TDatabase constructor: @line:%d";
const	char* const ERR_SET_LOGIN = "OCI: You can only set login infomation on disconnect status: line %d";
const	char* const ERR_CONNECT_NO_LOGIN_INFO = "No login information provided before Connect(), call SetLogin first, line:%d";
const	char* const ERR_NO_DATASET = "OCI: function:%s , Result Dataset is on Bof/Eof. field:%s";  
const	char* const ERR_DATA_TYPE_CONVERT = "Data type convertion error: field:%s data type:%d can not be access by %s";  
const	char* const ERR_NOMORE_MEMORY_BE_ALLOCATED = "no more memory can be allocate when :%s, source code:%d";  
const	char* const ERR_FILE_IO = "%s: can not open file:%s";  
const	char* const ERR_MEM_BUFFER_IO = "asBlobWriter() error: read from file to buffer, field:%s, file:%s, @line:%d";  
const	char* const ERR_DATA_TYPE_NOT_SUPPORT = "field:%s, datatype:%d not yet supported";  
const	char* const ERR_PARAM_NOT_EXISTS = "param:%s does not exists.";  
const	char* const ERR_FIELD_NOT_EXISTS = "field:%s does not exists.";
const	char* const ERR_INVALID_METHOD_CALL	= "%s: invalid call method:%s";
const	char* const ERR_CAPABILITY_NOT_YET_SUPPORT = "capability not support yet:%s";  
const	char* const ERR_READ_PARAM_DATA = "read parameter value data type error, parameter name:%s, method:%s";
#line 39
const char* const NULL_STRING = "";
const int NULL_NUMBER = 0;
#line 43
class TOCIException;
class TOCIDatabase;
class TOCIQuery;
class TOCIField;
class TOCIParam;
class TOCISession;
class TOCIDirPath;	 

class TOCIException : public TException
{
public:
	char *getErrMsg() const;
	char *getErrSrc() const;
	int getErrCode() const;

public:
	TOCIException(sword errNumb, OCIError *err, char *cat, char *sql); 
	TOCIException(const char *sql, const char* errFormat, ...);	
	~TOCIException();

private:
	char	errCategory[MAX_ERR_CAT_LENGTH+1];	 
	text	errMessage[MAX_ERRMSG_LENGTH+1];		 
	char	errSQL[MAX_SQLSTMT_LENGTH+1];			 
	int	errNo;										 
	int	m_iErrCode;
};

class TOCIDatabase
{
friend class TOCIQuery;
friend class TOCISession;
friend class TOCIDirPath;
public:

public:
	TOCIDatabase();
	~TOCIDatabase();
	void setLogin(char *user, char *password, char *tnsString) ;
	bool connect();
	bool connect(char *usr, char *pwd, char *tns) ;
	void disconnect();
	void commit();
	void rollback();
	OCISession *hUser;

	OCISvcCtx *hDBSvc;		 
private:
	char *usr, *pwd, *tns;	 
	bool fConnected;			 
	sword fErrorNo;						 
	void checkError() ;					 

	OCIError *hDBErr;

	OCIEnv *hEnv;
	OCIServer *hSvr;
};

class TOCIParam
{
friend class TOCIQuery;
public:
	~TOCIParam();
	char	*name;

	int		asInteger();	 
	double	asFloat();
	long		asLong();
	char		*asString();
	bool		isNULL();
private:
	TOCIParam();
	ub2		dataType;

	int		intValue;
	double	dblValue;			 
	long		longValue;			 
	char		*stringValue;		 

	int    * intArray;     
	double * dblArray;     
	long   * longArray;   
	char ** stringArray;  
	int   stringSize;     

	bool		fIsOutput;			 
	sb2		indicator;			 
	OCIBind  *hBind;
};

class TOCIField
{
friend class TOCIQuery;

public:	
	~TOCIField(); 
	char	*name;				 
	long	size;					 
	long	type;					 
	int	precision;			 
	int	scale;				 
	bool	nullable;			 

	bool		isNULL();			 
	char		*asString();
	double	asFloat();
	int		asInteger();
	long		asLong();

	void		asBlobFile(const char *fileName);			 
	void		loadFromFile(const char *fileName);			 
	void		loadFromBuffer(unsigned char *buf, unsigned int bufLength);	 
	void		asBlobBuffer(unsigned char* &buf, unsigned int *bufLength);	 
#line 159
	char		*asDateTimeString();	 
	void		asDateTime(int &year, int &month, int &day, int &hour, int &minute, int &second);  
private:

	void		asDateTimeInternal(int &year, int &month, int &day, int &hour, int &minute, int &second);  
	TOCIQuery *fParentQuery;					 
	TOCIField();

	ub1	fStrBuffer[MAX_STRING_VALUE_LENGTH];	 
	ub1	*fDataBuf;						 
	OCILobLocator *hBlob;				 
	sb2	*fDataIndicator;				 

	ub2   fReturnDataLen;				 
	ub2	fInternalType;					 
	ub2	fRequestType;					 
	OCIDefine *hDefine;					 
	int	  iBlobBufCnt;					 
};

class TOCIQuery
{
friend class TOCIField;

public:

	void close();													 
	void setSQL(const char *inSqlstmt);								 
	void open(int prefetchRows=PREFETCH_ROWS);			 
	bool next();													 
	bool execute(int iters=1);	                           
	bool commit();													 
	bool rollback();												 
	int  rowsAffected() { return fTotalRowsFetched;};	 
	int  getSQLCode() { return fErrorNo;};				 
#line 196
	int fieldCount();												 
	TOCIField& field(int index)		;						 
	TOCIField& field(char *fieldName) ;						 
#line 201
	TOCIParam& param(long index);								 
	TOCIParam& param(char *paramName);						 
	int paramCount();

	void setParameter(const char *paramName, const char* paramValue, bool isOutput = false); 	
	void setParameter(const char *paramName, int paramValue, bool isOutput = false); 
	void setParameter(const char *paramName, double paramValue, bool isOutput = false) ;
	void setParameter(const char *paramName, long paramValue, bool isOutput = false);
	void setParameterNULL(const char *paramName);
#line 213
	void setParameter(const long iPos, const char* paramValue, bool isOutput = false);

    void setLongRawParameter(char *paramName, char* paramValue, bool isOutput = false);

    void setParameter(char *paramName, void* paramValue, int iLen,bool isOutput = false);
#line 220
	void setParamArray(char *paramName, char ** paramValue,int iStructSize,int iStrSize ,bool isOutput = false); 	
	void setParamArray(char *paramName, int * paramValue,int iStructSize, bool isOutput = false); 
	void setParamArray(char *paramName, double * paramValue, int iStructSize,bool isOutput = false) ;
	void setParamArray(char *paramName, long * paramValue, int iStructSize,bool isOutput = false);

	void setParamArray(char *paramName, void ** paramValue,int iStructSize,int iStrSize,  bool isOutput=false);
#line 229
  int get_fFieldCount() const;   

  int get_fParamCount() const;

  ub2 get_fStmtType() const;
#line 236
	TOCIQuery(TOCIDatabase *oradb);
	TOCIQuery(TOCIDatabase *oradb,TOCISession *session);
	~TOCIQuery();

private:
	char *fSqlStmt;						 
	ub2 fStmtType;							 
	bool fActivated;						 

	unsigned	fFetched;					 
	unsigned	fPrefetchRows;				 
	unsigned	fCurrRow;					 
	unsigned	fTotalRowsFetched;		 

	int fFieldCount;						 
	TOCIDatabase *db;						 
	TOCIField *fieldList;				 
	void getFieldsDef();					 

	TOCIParam *paramByName(const char *paramName); 

	TOCIParam *paramByIndex(const long iIndex); 

	void checkError() ;					 

	int fParamCount;						 
	TOCIParam *paramList;				 
	void getParamsDef();					 
	int nTransTimes;						 
#line 267
	OCIStmt *hStmt;						 
	OCIError *hErr;						 
	sword fErrorNo;						 
	bool fEof;								 
	bool fBof;								 
	bool fOpened;							 
#line 276
};

class TOCISession
{	
public:
	TOCISession(TOCIDatabase *pDB);
	~TOCISession();

	void sessionBegin();
	void sessionEnd();

private:

	OCISvcCtx	*m_hSrvCtx;
	OCISession	*m_hSession;
	OCIError	*m_hError;

	bool	m_bActive;

	int	m_iErrorNo;

	void checkError();

friend	class TOCIDirPath;
friend  class TOCIQuery;	
};
#line 13 "/usr/vacpp/include/fstream"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 46
#pragma object_model(compat)
#line 51
  #pragma namemangling(v7)
#line 82
namespace std {
#line 86
extern FILE *_Fiopen(const char *,
        ios_base::openmode  );

template<class _E> inline
        bool _Fgetc(_E& _C, FILE *_Fi)
        {return (fread(&_C, sizeof (_E), 1, _Fi) == 1); }
template<> inline bool _Fgetc(char& _C, FILE *_Fi)
        {int _Ch;
        if ((_Ch = fgetc(_Fi)) == (-1))
                return (false);
        else
                {_C = _Ch;
                return (true); }}
template<> inline bool _Fgetc(wchar_t& _C, FILE *_Fi)
        {wint_t _Ch;
        if ((_Ch = fgetwc(_Fi)) == (-1))
                return (false);
        else
                {_C = _Ch;
                return (true); }}

template<class _E> inline
        bool _Fputc(_E _C, FILE *_Fi)
        {return (fwrite(&_C, sizeof (_E), 1, _Fi) == 1); }
template<> inline bool _Fputc(char _C, FILE *_Fi)
        {return (fputc(_C, _Fi) != (-1)); }
template<> inline bool _Fputc(wchar_t _C, FILE *_Fi)
        {return (fputwc(_C, _Fi) != (-1)); }

template<class _E>
        bool _Ungetc(const _E& _C, FILE *_Fi, size_t _N);
template<class _E> inline
        bool _Ungetc(const _E& _C, FILE *_Fi)
        {return (_Ungetc(_C, _Fi, sizeof (_E))); }
template<> inline bool _Ungetc(const char& _C, FILE *_Fi)
        {return (ungetc((unsigned char)_C, _Fi) != (-1)); }
template<> inline bool _Ungetc(const wchar_t& _C, FILE *_Fi)
        {return (ungetwc(_C, _Fi) != (-1)); }

template<class _E, class _Tr>
        class basic_filebuf : public basic_streambuf<_E, _Tr> {
public:
        typedef basic_filebuf<_E, _Tr> _Myt;
        typedef basic_streambuf<_E, _Tr> _Mysb;
        typedef codecvt<_E, char, typename _Tr::state_type> _Cvt;
        virtual ~basic_filebuf()
                {if (_Closef)
                        close();
                delete _Str; }
        typedef typename _Tr::int_type int_type;
        typedef typename _Tr::pos_type pos_type;
        typedef typename _Tr::off_type off_type;
        basic_filebuf(FILE *_Fi = 0)
                : _Loc(_Noinit), _Mysb()
                {_Init(_Fi, _Newfl); }
        basic_filebuf(_Uninitialized)
                : _Loc(_Noinit), _Mysb(_Noinit)
                {}
        enum _Initfl {_Newfl, _Openfl, _Closefl};
        bool is_open() const
                {return (_File != 0); }
#line 153
        _Myt *open(const char *_N, ios_base::open_mode _M  )
                {return (open(_N, (ios_base::openmode)_M  )); }
        _Myt *open(const char *_S, ios_base::openmode _M  )
                {FILE *_Fi;
                if (_File != 0 || (_Fi = _Fiopen(_S, _M  )) == 0)
                        return (0);
                _Init(_Fi, _Openfl);
                _Initcvt();
                return (this); }
        _Myt *close()
                {if (_File != 0 && _Endwrite() && fclose(_File) == 0)
                        {_Init(0, _Closefl);
                        return (this); }
                else
                        return (0); }

       FILE * fd () const { return _File; }

protected:
        virtual int_type overflow(int_type _C = _Tr::eof());
        virtual int_type pbackfail(int_type _C = _Tr::eof());
        virtual int_type underflow()
                {if (_Mysb::gptr() != 0
                        && _Mysb::gptr() < _Mysb::egptr())
                        return (_Tr::to_int_type(*_Mysb::gptr()));
                else
                        return (pbackfail(uflow())); }
        virtual int_type uflow();
        virtual pos_type seekoff(off_type _O, ios_base::seekdir _Way,
                ios_base::openmode =
                        (ios_base::openmode)(ios_base::in | ios_base::out))
                {fpos_t _Fp;
#line 199
                  if (_File == 0 || !_Endwrite()
                          || fseek(_File, _O, _Way) != 0

                          || fgetpos(_File, &_Fp) != 0
#line 206
                          )
                          return (pos_type(_BADOFF));
#line 210
                  return (pos_type(_State, _Fp)); }
#line 214
        virtual pos_type seekpos(pos_type _P,
                ios_base::openmode =
                        (ios_base::openmode)(ios_base::in | ios_base::out))
                {fpos_t _Fp = _P.seekpos();
                off_type _Off = (off_type)_P - ((long)(_Fp));
#line 237
                  if (_File == 0 || !_Endwrite()
#line 241
                          || fsetpos(_File, &_Fp) != 0
                          || _Off != 0 && fseek(_File, _Off, 1) != 0

                          || fgetpos(_File, &_Fp) != 0
#line 248
                          )
                          return (pos_type(_BADOFF));

                if (_Str != 0)
                        _State = _P.state(), _Str->erase();

                  return (pos_type(_State, _Fp)); }
#line 258
        virtual _Mysb *setbuf(_E *_S, streamsize _N)
                {return (_File == 0 || setvbuf(_File, (char *)_S,
                        _S == 0 && _N == 0 ? 0004 : 0000,
                        _N * sizeof (_E)) != 0 ? 0 : this); }
        virtual int sync()
                {return (_File == 0
                        || _Tr::eq_int_type(_Tr::eof(), overflow())
                        || 0 <= fflush(_File) ? 0 : -1); }
        void _Init(FILE *_Fp, _Initfl _Which);
        bool _Endwrite();
        void _Initcvt()
                {_Pcvt = (_Cvt *)&use_facet<_Cvt >(_Mysb::getloc());
                _Loc = locale(_Loc, _Pcvt);
                if (_Pcvt->always_noconv())
                        _Pcvt = 0;
                else
                        _Mysb::_Init();
                if (_Str == 0)
                        _Str = new string; }
private:
        _Cvt *_Pcvt;
        typename _Tr::state_type _State0;
        string *_Str;
        bool _Writef;
        typename _Tr::state_type _State;
        bool _Closef;
        locale _Loc;
        FILE *_File;
        };

template<class _E, class _Tr>
        class basic_ifstream : public basic_istream<_E, _Tr> {
public:
        typedef basic_ifstream<_E, _Tr> _Myt;
        typedef basic_filebuf<_E, _Tr> _Myfb;
        typedef basic_ios<_E, _Tr> _Myios;
        basic_ifstream()
                : basic_istream<_E, _Tr>(&_Fb) {}
#line 307
        explicit basic_ifstream(const char *_S)
                : basic_istream<_E, _Tr>(&_Fb)
                {if (_Fb.open(_S, ios_base::in) == 0)
                        _Myios::setstate(ios_base::failbit); }
        explicit basic_ifstream(const char *_S, ios_base::openmode _M)
                : basic_istream<_E, _Tr>(&_Fb)
                {if (_Fb.open(_S, _M | ios_base::in) == 0)
                        _Myios::setstate(ios_base::failbit); }
        virtual ~basic_ifstream()
                {}
        _Myfb *rdbuf() const
                {return ((_Myfb *)&_Fb); }
        bool is_open() const
                {return (_Fb.is_open()); }
#line 331
        void open(const char *_S, ios_base::open_mode _M  )
                {return ( open(_S, (ios_base::openmode)_M  )); }
        void open(const char *_S)
                {if (_Fb.open(_S, ios_base::in) == 0)
                        _Myios::setstate(ios_base::failbit); }
        void open(const char *_S, ios_base::openmode _M  )
                {if (_Fb.open(_S, _M | ios_base::in  ) == 0)
                        _Myios::setstate(ios_base::failbit); }
        void close()
                {if (_Fb.close() == 0)
                        _Myios::setstate(ios_base::failbit); }
private:
        _Myfb _Fb;
        };

template<class _E, class _Tr>
        class basic_ofstream : public basic_ostream<_E, _Tr> {
public:
        typedef basic_ofstream<_E, _Tr> _Myt;
        typedef basic_filebuf<_E, _Tr> _Myfb;
        typedef basic_ios<_E, _Tr> _Myios;
        basic_ofstream()
                : basic_ostream<_E, _Tr>(&_Fb) {}
#line 364
        explicit basic_ofstream(const char *_S)
                : basic_ostream<_E, _Tr>(&_Fb)
                {if (_Fb.open(_S, ios_base::out) == 0)
                        _Myios::setstate(ios_base::failbit); }
        explicit basic_ofstream(const char *_S, ios_base::openmode _M)
                : basic_ostream<_E, _Tr>(&_Fb)
                {if (_Fb.open(_S, _M | ios_base::out) == 0)
                        _Myios::setstate(ios_base::failbit); }
        virtual ~basic_ofstream()
                {}
        _Myfb *rdbuf() const
                {return ((_Myfb *)&_Fb); }
        bool is_open() const
                {return (_Fb.is_open()); }
#line 388
        void open(const char *_S, ios_base::open_mode _M  )
                {return ( open(_S, (ios_base::openmode)_M  )); }
        void open(const char *_S)
                {if (_Fb.open(_S, ios_base::out) == 0)
                        _Myios::setstate(ios_base::failbit); }
        void open(const char *_S, ios_base::openmode _M  )
                {if (_Fb.open(_S, _M | ios_base::out  ) == 0)
                        _Myios::setstate(ios_base::failbit); }
        void close()
                {if (_Fb.close() == 0)
                        _Myios::setstate(ios_base::failbit); }
private:
        _Myfb _Fb;
        };

template<class _E, class _Tr>
        class basic_fstream : public basic_iostream<_E, _Tr> {
public:
        typedef basic_ios<_E, _Tr> _Myios;
        typedef _E char_type;
        typedef _Tr traits_type;
        typedef typename _Tr::int_type int_type;
        typedef typename _Tr::pos_type pos_type;
        typedef typename _Tr::off_type off_type;
        basic_fstream()
                : basic_iostream<_E, _Tr>(&_Fb) {}
#line 424
        explicit basic_fstream(const char *_S)
                : basic_iostream<_E, _Tr>(&_Fb)
                {if (_Fb.open(_S, ios_base::in | ios_base::out) == 0)
                        _Myios::setstate(ios_base::failbit); }
        explicit basic_fstream(const char *_S, ios_base::openmode _M)
                : basic_iostream<_E, _Tr>(&_Fb)
                {if (_Fb.open(_S, _M) == 0)
                        _Myios::setstate(ios_base::failbit); }
        virtual ~basic_fstream()
                {}
        basic_filebuf<_E, _Tr> *rdbuf() const
                {return ((basic_filebuf<_E, _Tr> *)&_Fb); }
        bool is_open() const
                {return (_Fb.is_open()); }
#line 448
        void open(const char *_S, ios_base::open_mode _M  )
                {return ( open(_S, (ios_base::openmode)_M  )); }
        void open(const char *_S)
                {if (_Fb.open(_S, ios_base::in | ios_base::out) == 0)
                        _Myios::setstate(ios_base::failbit); }
        void open(const char *_S, ios_base::openmode _M  )
                {if (_Fb.open(_S, _M  ) == 0)
                        _Myios::setstate(ios_base::failbit); }
        void close()
                {if (_Fb.close() == 0)
                        _Myios::setstate(ios_base::failbit); }
private:
        basic_filebuf<_E, _Tr> _Fb;
        };
#line 468
};

#pragma implementation("fstream.t")
#line 31 "/usr/vacpp/include/fstream.t"
namespace std {
#line 36
template<class _E>
inline
bool _Ungetc(const _E& _C, FILE *_Fi, size_t _N)
        {const unsigned char *_P = (const unsigned char *)&_C;
        for (_P += _N; 0 < _N && ungetc(*--_P, _Fi) != (-1); --_N)
                ;
        if (_N == 0)
                return (true);
        else
                {for (; _N < sizeof (_E); ++_N)
                        fgetc(_Fi);
                return (false); }}

template<class _E, class _Tr>
inline
typename basic_filebuf<_E, _Tr>::int_type
basic_filebuf<_E, _Tr>::overflow(int_type _C)
        {if (_Tr::eq_int_type(_Tr::eof(), _C))
                return (_Tr::not_eof(_C));
        else if (_Mysb::pptr() != 0
                && _Mysb::pptr() < _Mysb::epptr())
                {*_Mysb::_Pninc() = _Tr::to_char_type(_C);
                return (_C); }
        else if (_File == 0)
                return (_Tr::eof());
        else if (_Pcvt == 0)
                return (_Fputc(_Tr::to_char_type(_C), _File)
                        ? _C : _Tr::eof());
        else
                {const int _NC = 8;
                const _E _X = _Tr::to_char_type(_C);
                const _E *_S;
                char *_D;
                _Str->assign(_NC, '\0');
                for (; ; )
                        switch (_Pcvt->out(_State,
                                &_X, &_X + 1, _S,
                                &*_Str->begin(), &*_Str->end(), _D))
                        {case codecvt_base::partial:
                                _Str->append(_NC, '\0');
                        case codecvt_base::ok:   
                                {size_t _N = _D - &*_Str->begin();
                                if (0 < _N && _N !=
                                        fwrite(&*_Str->begin(), 1, _N, _File))
                                        return (_Tr::eof());
                                _Writef = true;
                                if (_S != &_X)
                                        return (_C);
                                break; }
                        case codecvt_base::noconv:
                                return (_Fputc(_X, _File) ? _C : _Tr::eof());
                        default:
                                return (_Tr::eof()); }}}
#line 91
template<class _E, class _Tr>
inline
typename basic_filebuf<_E, _Tr>::int_type
basic_filebuf<_E, _Tr>::pbackfail(int_type _C)
        {if (_Mysb::gptr() != 0
                && _Mysb::eback() < _Mysb::gptr()
                && (_Tr::eq_int_type(_Tr::eof(), _C)
                 || _Tr::eq_int_type(_Tr::to_int_type(_Mysb::gptr()[-1]),
                        _C)))
                {_Mysb::_Gndec();
                return (_Tr::not_eof(_C)); }
        else if (_File == 0 || _Tr::eq_int_type(_Tr::eof(), _C))
                return (_Tr::eof());
        else if (_Pcvt == 0)
                return (_Ungetc(_Tr::to_char_type(_C), _File)
                        ? _C : _Tr::eof());
        else if (0 < _Str->size()
                && _Ungetc(*_Str->begin(), _File, _Str->size()))
                {_Str->erase();
                _State = _State0;
                return (_C); }
        else
                return (_Tr::eof()); }
#line 116
template<class _E, class _Tr>
inline
typename basic_filebuf<_E, _Tr>::int_type
basic_filebuf<_E, _Tr>::uflow()
        {if (_Mysb::gptr() != 0
                && _Mysb::gptr() < _Mysb::egptr())
                return (_Tr::to_int_type(*_Mysb::_Gninc()));
        else if (_File == 0)
                return (_Tr::eof());
        else if (_Pcvt == 0)
                {_E _C;
                return (_Fgetc(_C, _File) ? _Tr::to_int_type(_C)
                        : _Tr::eof()); }
        else
                for (_State0 = _State, _Str->erase(); ; )
                        {_E _X, *_D;
                        const char *_S;
                        int _C = fgetc(_File);
                        if (_C == (-1))
                                return (_Tr::eof());     
                        _Str->append(1, (char)_C);
                        _State = _State0;
                        switch (_Pcvt->in(_State,
                                &*_Str->begin(), &*_Str->end(), _S,
                                &_X, &_X + 1, _D))
                        {case codecvt_base::partial:
                                break;
                        case codecvt_base::noconv:
                                if (_Str->size() < sizeof (_E))
                                        break;
                                memcpy(&_X, &*_Str->begin(), sizeof (_E));
                        case codecvt_base::ok:   
                                return (_Tr::to_int_type(_X));
                        default:
                                return (_Tr::eof()); }}}
#line 153
template<class _E, class _Tr>
inline
void basic_filebuf<_E, _Tr>::_Init(FILE *_Fp, _Initfl _Which)
        {static typename _Tr::state_type _Stinit;
        _Closef = _Which == _Openfl;
        _Writef = false;
        if (_Which == _Newfl)
                {new (&_Loc) locale;
                _Str = 0; }
        _Mysb::_Init();
        if (_Fp != 0 && sizeof (_E) == 1)
#line 172
                {_Mysb::_Init((_E **)&_Fp->_base,
                        (_E **)&_Fp->_ptr, (int *)&_Fp->_cnt,
                        (_E **)&_Fp->_base, (_E **)&_Fp->_ptr,
                        (int *)&_Fp->_cnt); }
#line 184
        _File = _Fp;
        _State = _Stinit;
        _State0 = _Stinit;
        _Pcvt = 0; }
#line 190
template<class _E, class _Tr>
inline
bool basic_filebuf<_E, _Tr>::_Endwrite()
        {if (_Pcvt == 0 || !_Writef)
                return (true);
        else
                {const int _NC = 8;
                char *_D;
                overflow();
                _Str->assign(_NC, '\0');
                for (; ; )
                        switch (_Pcvt->unshift(_State,
                                &*_Str->begin(), &*_Str->end(), _D))
                        {case codecvt_base::ok:
                                _Writef = false;
                        case codecvt_base::partial:      
                                {size_t _N = _D - &*_Str->begin();
                                if (0 < _N && _N !=
                                        fwrite(&*_Str->begin(), _N, 1, _File))
                                        return (false);
                                if (!_Writef)
                                        return (true);
                                _Str->append(_NC, '\0');
                                break; }
                        case codecvt_base::noconv:
                                return (true);
                        default:
                                return (false); }}}
#line 225
};
#line 476 "/usr/vacpp/include/fstream"
#pragma namemangling()

#pragma object_model(pop)
#line 485
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 13 "/usr/vacpp/include/sstream"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 46
#pragma object_model(compat)
#line 51
  #pragma namemangling(v7)
#line 76
namespace std {

enum __Strstate {_Allocated = 1, _Constant = 2, _Noread = 4};
typedef int _Strstate;
#line 86
template<class _E, class _Tr, class _A>
        class basic_stringbuf : public basic_streambuf<_E, _Tr> {
public:
        typedef basic_streambuf<_E, _Tr> _Mysb;
        typedef basic_string<_E, _Tr, _A> _Mystr;
        explicit basic_stringbuf(
                ios_base::openmode _W = ios_base::in | ios_base::out)
                {_Init(0, 0, _Mode(_W)); }
        explicit basic_stringbuf(const _Mystr& _S,
                ios_base::openmode _W = ios_base::in | ios_base::out)
                {_Init(_S.c_str(), _S.size(), _Mode(_W)); }
        virtual ~basic_stringbuf()
                {_Tidy(); }
        typedef typename _Tr::int_type int_type;
        typedef typename _Tr::pos_type pos_type;
        typedef typename _Tr::off_type off_type;
        _Mystr str() const;
        void str(const _Mystr& _S)
                {_Tidy();
                _Init(_S.c_str(), _S.size(), _Strmode); }
protected:
        virtual int_type overflow(int_type _C = _Tr::eof());
        virtual int_type pbackfail(int_type _C = _Tr::eof());
        virtual int_type underflow();
        virtual pos_type seekoff(off_type _O, ios_base::seekdir _Way,
                ios_base::openmode _Which = ios_base::in | ios_base::out);
        virtual pos_type seekpos(pos_type _P,
                ios_base::openmode _Which = ios_base::in | ios_base::out);
        void _Init(const _E *_S, size_t _N, _Strstate _M);
        void _Tidy();
private:
        enum {_MINSIZE = 32};
        _Strstate _Mode(ios_base::openmode _W)
                {_Strstate _St = (_Strstate)0;
                if (!(_W & ios_base::in))
                        _St |= _Noread;
                if (!(_W & ios_base::out))
                        _St |= _Constant;
                return (_St); }
        _E *_Pendsave, *_Seekhigh;
        int _Dummy;      
        _Strstate _Strmode;
        _A _Al;
        };
#line 132
template<class _E, class _Tr, class _A>
        class basic_istringstream : public basic_istream<_E, _Tr> {
public:
        typedef basic_stringbuf<_E, _Tr, _A> _Mysb;
        typedef basic_string<_E, _Tr, _A> _Mystr;
        explicit basic_istringstream(ios_base::openmode _M =
                ios_base::in)
                : basic_istream<_E, _Tr>(&_Sb), _Sb(_M | ios_base::in) {}
        explicit basic_istringstream(const _Mystr& _S,
                ios_base::openmode _M = ios_base::in)
                : basic_istream<_E, _Tr>(&_Sb),
                        _Sb(_S, _M | ios_base::in) {}
        virtual ~basic_istringstream()
                {}
        _Mysb *rdbuf() const
                {return ((_Mysb *)&_Sb); }
        _Mystr str() const
                {return (_Sb.str()); }
        void str(const _Mystr& _S)
                {_Sb.str(_S); }
private:
        _Mysb _Sb;
        };
#line 157
template<class _E, class _Tr, class _A>
        class basic_ostringstream : public basic_ostream<_E, _Tr> {
public:
        typedef basic_stringbuf<_E, _Tr, _A> _Mysb;
        typedef basic_string<_E, _Tr, _A> _Mystr;
        explicit basic_ostringstream(ios_base::openmode _M =
                ios_base::out)
                : basic_ostream<_E, _Tr>(&_Sb), _Sb(_M | ios_base::out) {}
        explicit basic_ostringstream(const _Mystr& _S,
                ios_base::openmode _M = ios_base::out)
                : basic_ostream<_E, _Tr>(&_Sb),
                        _Sb(_S, _M | ios_base::out) {}
        virtual ~basic_ostringstream()
                {}
        _Mysb *rdbuf() const
                {return ((_Mysb *)&_Sb); }
        _Mystr str() const
                {return (_Sb.str()); }
        void str(const _Mystr& _S)
                {_Sb.str(_S); }
private:
        _Mysb _Sb;
        };
#line 182
template<class _E, class _Tr, class _A>
        class basic_stringstream : public basic_iostream<_E, _Tr> {
public:
        typedef _E char_type;
        typedef _Tr traits_type;
        typedef typename _Tr::int_type int_type;
        typedef typename _Tr::pos_type pos_type;
        typedef typename _Tr::off_type off_type;
        typedef basic_string<_E, _Tr, _A> _Mystr;
        explicit basic_stringstream(ios_base::openmode _W =
                ios_base::in | ios_base::out)
                : basic_iostream<_E, _Tr>(&_Sb), _Sb(_W) {}
        explicit basic_stringstream(const _Mystr& _S,
                ios_base::openmode _W = ios_base::in | ios_base::out)
                : basic_iostream<_E, _Tr>(&_Sb), _Sb(_S, _W) {}
        virtual ~basic_stringstream()
                {}
        basic_stringbuf<_E, _Tr, _A> *rdbuf() const
                {return ((basic_stringbuf<_E, _Tr, _A> *)&_Sb); }
        _Mystr str() const
                {return (_Sb.str()); }
        void str(const _Mystr& _S)
                {_Sb.str(_S); }
private:
        basic_stringbuf<_E, _Tr, _A> _Sb;
        };
#line 214
};

#pragma implementation("sstream.t")
#line 31 "/usr/vacpp/include/sstream.t"
namespace std {
#line 37
template<class _E, class _Tr, class _A>
inline
typename basic_stringbuf<_E, _Tr, _A>::_Mystr
basic_stringbuf<_E, _Tr, _A>::str() const
        {if (!(_Strmode & _Constant) && _Mysb::pptr() != 0)
                {_Mystr _Str(_Mysb::pbase(),
                        (_Seekhigh < _Mysb::pptr()
                        ? _Mysb::pptr() : _Seekhigh) - _Mysb::pbase());
                return (_Str); }
        else if (!(_Strmode & _Noread) && _Mysb::gptr() != 0)
                {_Mystr _Str(_Mysb::eback(),
                        _Mysb::egptr() - _Mysb::eback());
                return (_Str); }
        else
                {_Mystr _Nul;
                return (_Nul); }}

template<class _E, class _Tr, class _A>
inline
typename basic_stringbuf<_E, _Tr, _A>::int_type
basic_stringbuf<_E, _Tr, _A>::overflow(int_type _C)
        {if (_Tr::eq_int_type(_Tr::eof(), _C))
                return (_Tr::not_eof(_C));
        else if (_Mysb::pptr() != 0
                && _Mysb::pptr() < _Mysb::epptr())
                {*_Mysb::_Pninc() = _Tr::to_char_type(_C);
                return (_C); }
        else if (_Strmode & _Constant)
                return (_Tr::eof());
        else
                {size_t _Os = _Mysb::gptr() == 0
                        ? 0 : _Mysb::epptr() - _Mysb::eback();
                size_t _Ns = _Os;
                size_t _Inc = _Ns / 2 < _MINSIZE
                        ? _MINSIZE : _Ns / 2;
                _E *_P = 0;
                while (0 < _Inc && (2147483647) - _Inc < _Ns)
                        _Inc /= 2;
                if (0 < _Inc)
                        {_Ns += _Inc;
                        _P = _Al.allocate(_Ns, (void *)0); }
                if (_P == 0)
                        _Nomemory();
                if (0 < _Os)
                        _Tr::copy(_P, _Mysb::eback(), _Os);
                if (_Strmode & _Allocated)
                        _Al.deallocate(_Mysb::eback(), _Os);
                _Strmode |= _Allocated;
                if (_Os == 0)
                        {_Seekhigh = _P;
                        _Mysb::setp(_P, _P + _Ns);
                        _Mysb::setg(_P, _P, _Noread ? _P : _P + 1); }
                else
                        {_Seekhigh = _Seekhigh - _Mysb::eback() + _P;
                        _Mysb::setp(_Mysb::pbase() - _Mysb::eback() + _P,
                                _Mysb::pptr() - _Mysb::eback() + _P,
                                _P + _Ns);
                        if (_Strmode & _Noread)
                                _Mysb::setg(_P, _P, _P);
                        else
                                _Mysb::setg(_P,
                                        _Mysb::gptr() - _Mysb::eback() + _P,
                                        _Mysb::pptr() + 1); }
                *_Mysb::_Pninc() = _Tr::to_char_type(_C);
                return (_C); }}

template<class _E, class _Tr, class _A>
inline
typename basic_stringbuf<_E, _Tr, _A>::int_type
basic_stringbuf<_E, _Tr, _A>::pbackfail(int_type _C)
        {if (_Mysb::gptr() == 0
                || _Mysb::gptr() <= _Mysb::eback()
                || !_Tr::eq_int_type(_Tr::eof(), _C)
                && !_Tr::eq(_Tr::to_char_type(_C), _Mysb::gptr()[-1])
                && _Strmode & _Constant)
                return (_Tr::eof());
        else
                {_Mysb::gbump(-1);
                if (!_Tr::eq_int_type(_Tr::eof(), _C))
                        *_Mysb::gptr() = _Tr::to_char_type(_C);
                return (_Tr::not_eof(_C)); }}

template<class _E, class _Tr, class _A>
inline
typename basic_stringbuf<_E, _Tr, _A>::int_type
basic_stringbuf<_E, _Tr, _A>::underflow()
        {if (_Mysb::gptr() == 0)
                return (_Tr::eof());
        else if (_Mysb::gptr() < _Mysb::egptr())
                return (_Tr::to_int_type(*_Mysb::gptr()));
        else if (_Strmode & _Noread || _Mysb::pptr() == 0
                || _Mysb::pptr() <= _Mysb::gptr()
                        && _Seekhigh <= _Mysb::gptr())
                return (_Tr::eof());
        else
                {if (_Seekhigh < _Mysb::pptr())
                        _Seekhigh = _Mysb::pptr();
                _Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Seekhigh);
                return (_Tr::to_int_type(*_Mysb::gptr())); }}

template<class _E, class _Tr, class _A>
inline
typename basic_stringbuf<_E, _Tr, _A>::pos_type
basic_stringbuf<_E, _Tr, _A>::seekoff(off_type _O, ios_base::seekdir _Way,
                ios_base::openmode _Which)
        {if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())
                _Seekhigh = _Mysb::pptr();
        if (_Which & ios_base::in && _Mysb::gptr() != 0)
                {if (_Way == ios_base::end)
                        _O += _Seekhigh - _Mysb::eback();
                else if (_Way == ios_base::cur
                        && !(_Which & ios_base::out))
                        _O += _Mysb::gptr() - _Mysb::eback();
                else if (_Way != ios_base::beg)
                        _O = _BADOFF;
                if (0 <= _O && _O <= _Seekhigh - _Mysb::eback())
                        {_Mysb::gbump(_Mysb::eback()
                                - _Mysb::gptr() + _O);
                        if (_Which & ios_base::out && _Mysb::pptr() != 0)
                                _Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
                                        _Mysb::epptr()); }
                else
                        _O = _BADOFF; }
        else if (_Which & ios_base::out && _Mysb::pptr() != 0)
                {if (_Way == ios_base::end)
                        _O += _Seekhigh - _Mysb::eback();
                else if (_Way == ios_base::cur)
                        _O += _Mysb::pptr() - _Mysb::eback();
                else if (_Way != ios_base::beg)
                        _O = _BADOFF;
                if (0 <= _O && _O <= _Seekhigh - _Mysb::eback())
                        _Mysb::pbump(_Mysb::eback() - _Mysb::pptr() + _O);
                else
                        _O = _BADOFF; }
        else
                _O = _BADOFF;
        return (pos_type(_O)); }

template<class _E, class _Tr, class _A>
inline
typename basic_stringbuf<_E, _Tr, _A>::pos_type
basic_stringbuf<_E, _Tr, _A>::seekpos(pos_type _P,
                ios_base::openmode _Which)
        {streamoff _O = (streamoff)_P;
        if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())
                _Seekhigh = _Mysb::pptr();
        if (_O == _BADOFF)
                ;
        else if (_Which & ios_base::in && _Mysb::gptr() != 0)
                {if (0 <= _O && _O <= _Seekhigh - _Mysb::eback())
                        {_Mysb::gbump(_Mysb::eback()
                                - _Mysb::gptr() + _O);
                        if (_Which & ios_base::out
                                && _Mysb::pptr() != 0)
                                _Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
                                        _Mysb::epptr()); }
                else
                        _O = _BADOFF; }
        else if (_Which & ios_base::out && _Mysb::pptr() != 0)
                {if (0 <= _O && _O <= _Seekhigh - _Mysb::eback())
                        _Mysb::pbump(_Mysb::eback() - _Mysb::pptr() + _O);
                else
                        _O = _BADOFF; }
        else
                _O = _BADOFF;
        return (streampos(_O)); }

template<class _E, class _Tr, class _A>
inline
void basic_stringbuf<_E, _Tr, _A>::_Init(const _E *_S, size_t _N, _Strstate _M)
        {_Pendsave = 0, _Seekhigh = 0;
        _Strmode = _M;
        if (_N != 0 && (_Strmode & (_Noread | _Constant))
                != (_Noread | _Constant))
                {_E *_P = _Al.allocate(_N, (void *)0);
                _Tr::copy(_P, _S, _N);
                _Seekhigh = _P + _N;
                if (!(_Strmode & _Noread))
                        _Mysb::setg(_P, _P, _P + _N);
                if (!(_Strmode & _Constant))
                        {_Mysb::setp(_P, _P + _N);
                        if (_Mysb::gptr() == 0)
                                _Mysb::setg(_P, _P, _P); }
                _Strmode |= _Allocated; }}
#line 223
template<class _E, class _Tr, class _A>
inline
void basic_stringbuf<_E, _Tr, _A>::_Tidy()
        {if (_Strmode & _Allocated)
                _Al.deallocate(_Mysb::eback(),
                        (_Mysb::pptr() != 0 ? _Mysb::epptr()
                                : _Mysb::egptr()) - _Mysb::eback());
        _Mysb::setg(0, 0, 0);
        _Mysb::setp(0, 0);
        _Seekhigh = 0;
        _Strmode &= ~_Allocated; }
#line 241
};
#line 222 "/usr/vacpp/include/sstream"
#pragma namemangling()

#pragma object_model(pop)
#line 231
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 26 "/cbilling/app/petri/libsrc/lib/platform.h"
        using namespace std;     
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 43 "/usr/include/sys/flock.h"
struct	flock	{
	short	l_type;
	short	l_whence;
#line 52
	unsigned int	l_sysid;
#line 57
	pid_t	l_pid;

	int	l_vfs;
#line 64
	off_t	l_start;
	off_t	l_len;

};

typedef struct flock flock_t;
#line 77
struct	flock64	{
	short		l_type;
	short		l_whence;
	unsigned int	l_sysid;
	pid_t		l_pid;
	int		l_vfs;
	off64_t		l_start;
	off64_t		l_len;
};
}
extern "C" {
#line 100 "/usr/include/fcntl.h"
extern int open(const char *, int, ...);
extern int creat(const char *, mode_t);

extern int open64(const char *, int, ...);
extern int creat64(const char *, mode_t);

extern int fcntl(int, int,...);
#line 160
extern int posix_fadvise(int,off_t,off_t,int);
#line 167
extern int posix_fallocate(int,off_t,off_t);
#line 206
extern int openx(char *path, int oflag, mode_t, long);
}
extern "C" {
#line 60 "/usr/include/fnmatch.h"
extern	int	fnmatch(const char *, const char *, int);
}
#line 13 "/usr/vacpp/include/set"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 40
#pragma object_model(compat)
#line 45
  #pragma namemangling(v7)
#line 70
namespace std {

template<class _K, class _Pr, class _Ax, bool _Mfl>
        class _Tset_traits {
public:
        typedef _K key_type;
        typedef _K value_type;
        typedef _Pr key_compare;
        typedef typename _Ax::template rebind<value_type>::other
                allocator_type;
        enum {_Multi = _Mfl};
        _Tset_traits()
                : comp()
                {}
        _Tset_traits(_Pr _Parg)
                : comp(_Parg)
                {}
        typedef key_compare value_compare;
        struct _Kfn {
                const _K& operator()(const value_type& _X) const
                        {return (_X); }
                };
        _Pr comp;
        };
#line 96
template<class _K,
        class _Pr = less<_K>,
        class _A = allocator<_K> >
        class set
                : public _Tree<_Tset_traits<_K, _Pr, _A, false> > {
public:
        typedef set<_K, _Pr, _A> _Myt;
        typedef _Tree<_Tset_traits<_K, _Pr, _A, false> >
                _Mybase;
        typedef _K key_type;
        typedef _Pr key_compare;
        typedef typename _Mybase::value_compare value_compare;
        typedef typename _Mybase::allocator_type allocator_type;
        typedef typename _Mybase::size_type size_type;
        typedef typename _Mybase::difference_type difference_type;
        typedef typename _Mybase::pointer pointer;
        typedef typename _Mybase::const_pointer const_pointer;
        typedef typename _Mybase::reference reference;
        typedef typename _Mybase::const_reference const_reference;
        typedef typename _Mybase::iterator iterator;
        typedef typename _Mybase::const_iterator const_iterator;
        typedef typename _Mybase::reverse_iterator reverse_iterator;
        typedef typename _Mybase::const_reverse_iterator
                const_reverse_iterator;
        typedef typename _Mybase::value_type value_type;
        set()
                : _Mybase(key_compare(), allocator_type()) {}
        explicit set(const key_compare& _Pred)
                : _Mybase(_Pred, allocator_type()) {}
        set(const key_compare& _Pred, const allocator_type& _Al)
                : _Mybase(_Pred, _Al) {}
        template<class _It>
                set(_It _F, _It _L)
                : _Mybase(key_compare(), allocator_type())
                {for (; _F != _L; ++_F)
                        _Mybase::insert(*_F); }
        template<class _It>
                set(_It _F, _It _L, const key_compare& _Pred)
                : _Mybase(_Pred, allocator_type())
                {for (; _F != _L; ++_F)
                        _Mybase::insert(*_F); }
        template<class _It>
                set(_It _F, _It _L, const key_compare& _Pred,
                const allocator_type& _Al)
                : _Mybase(_Pred, _Al)
                {for (; _F != _L; ++_F)
                        _Mybase::insert(*_F); }
        };
#line 146
template<class _K,
        class _Pr = less<_K>,
        class _A = allocator<_K> >
        class multiset
                : public _Tree<_Tset_traits<_K, _Pr, _A, true> > {
public:
        typedef multiset<_K, _Pr, _A> _Myt;
        typedef _Tree<_Tset_traits<_K, _Pr, _A, true> >
                _Mybase;
        typedef _K key_type;
        typedef _Pr key_compare;
        typedef typename _Mybase::value_compare value_compare;
        typedef typename _Mybase::allocator_type allocator_type;
        typedef typename _Mybase::size_type size_type;
        typedef typename _Mybase::difference_type difference_type;
        typedef typename _Mybase::pointer pointer;
        typedef typename _Mybase::const_pointer const_pointer;
        typedef typename _Mybase::reference reference;
        typedef typename _Mybase::const_reference const_reference;
        typedef typename _Mybase::iterator iterator;
        typedef typename _Mybase::const_iterator const_iterator;
        typedef typename _Mybase::reverse_iterator reverse_iterator;
        typedef typename _Mybase::const_reverse_iterator
                const_reverse_iterator;
        typedef typename _Mybase::value_type value_type;
        multiset()
                : _Mybase(key_compare(), allocator_type()) {}
        explicit multiset(const key_compare& _Pred)
                : _Mybase(_Pred, allocator_type()) {}
        multiset(const key_compare& _Pred, const allocator_type& _Al)
                : _Mybase(_Pred, _Al) {}
        template<class _It>
                multiset(_It _F, _It _L)
                : _Mybase(key_compare(), allocator_type())
                {for (; _F != _L; ++_F)
                        insert(*_F); }
        template<class _It>
                multiset(_It _F, _It _L, const key_compare& _Pred)
                : _Mybase(_Pred, allocator_type())
                {for (; _F != _L; ++_F)
                        insert(*_F); }
        template<class _It>
                multiset(_It _F, _It _L, const key_compare& _Pred,
                const allocator_type& _Al)
                : _Mybase(_Pred, _Al)
                {for (; _F != _L; ++_F)
                        insert(*_F); }
        iterator insert(const value_type& _X)
                {return (_Mybase::insert(_X).first); }
        iterator insert(iterator _P, const value_type& _X)
                {return (_Mybase::insert(_P, _X)); }
        template<class _It>
                void insert(_It _F, _It _L)
                {for (; _F != _L; ++_F)
                        insert(*_F); }
        };
};

#pragma namemangling()

#pragma object_model(pop)
#line 213
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
extern "C" {
#line 87 "/usr/include/sys/socket.h"
typedef __ulong32_t socklen_t;
#line 97
extern "C" int naccept(int, struct sockaddr *, socklen_t *);
extern "C" int ngetpeername(int, struct sockaddr *, socklen_t *);
extern "C" int ngetsockname(int, struct sockaddr *, socklen_t *);
extern "C" ssize_t nrecvfrom(int, void *, size_t, int, struct sockaddr *,
	                     socklen_t *);
inline int accept(int socketfd, struct sockaddr *address, socklen_t *address_len)
{
	return naccept(socketfd, address, address_len);
}
inline int getpeername(int socketfd, struct sockaddr *address,
	               socklen_t *address_len)
{
	return ngetpeername(socketfd, address, address_len);
}
inline int getsockname(int socketfd, struct sockaddr *address,
	               socklen_t *address_len)
{
	return ngetsockname(socketfd, address, address_len);
}
inline ssize_t recvfrom(int socketfd, void *buffer, size_t length, int flags,
	                struct sockaddr *address, socklen_t *address_len)
{
	return nrecvfrom(socketfd, buffer, length, flags, address,
	                 address_len);
}
int     getpeereid(int, uid_t *restrict, gid_t *restrict);

extern "C" ssize_t nrecvmsg(int, struct msghdr *, int);
extern "C" ssize_t nsendmsg(int, const struct msghdr *, int);
inline ssize_t recvmsg(int socketfd, struct msghdr *message, int flags)
{
	return nrecvmsg(socketfd, message, flags);
}
inline ssize_t sendmsg(int socketfd, const struct msghdr *message, int flags)
{
	return nsendmsg(socketfd, message, flags);
}
#line 157
struct peercred_struct {
	pid_t pid;                       
	tid_t tid;			 
	uid_t euid;                      
	gid_t egid;                      
};
#line 165
struct peercred_struct_32_64 {
	pid32_t pid;
	tid_t tid;
	uid_t euid;
	gid_t egid;
};
#line 173
struct peercred_struct32 {
	pid32_t pid;
	tid32_t tid;
	uid_t euid;
	gid_t egid;
};
#line 181
struct peercred_struct64 {
	pid32_t pid;
	tid64_t tid;
	uid_t euid;
	gid_t egid;
};
#line 242
struct  linger {
	int     l_onoff;                 
	int     l_linger;                
};
#line 294
typedef uchar_t sa_family_t;
#line 309
struct sockaddr {
	uchar_t         sa_len;          
	sa_family_t     sa_family;       
	char            sa_data[14];     
};
#line 432
struct msghdr {
	void    *msg_name;               
	socklen_t  msg_namelen;          
	struct  iovec   *msg_iov;        
	int     msg_iovlen;              
	void    *msg_control;            
	socklen_t  msg_controllen;       
	int     msg_flags;               
};
#line 463
struct cmsghdr {
	socklen_t  cmsg_len;
	int     cmsg_level;              
	int     cmsg_type;               

};
#line 544
int     bind(int, const struct sockaddr *, socklen_t);
int     connect(int, const struct sockaddr *, socklen_t);
int     getsockopt(int, int, int, void *restrict, socklen_t *restrict);
int     listen(int, int);
ssize_t recv(int, void *, size_t, int);
ssize_t send(int, const void *, size_t, int);
ssize_t sendto(int, const void *, size_t, int, const struct sockaddr *, socklen_t);
int     setsockopt(int, int, int, const void *, socklen_t);
int     shutdown(int, int);
int     socket(int, int, int);
int     socketpair(int, int, int, int[2]);

int sockatmark(int);
#line 614
struct sockaddr_storage {
	uchar_t		__ss_len;	 
	sa_family_t	ss_family;	 
	char		__ss_pad1[((sizeof (int64_t)) - (sizeof(uchar_t) + sizeof(sa_family_t)))];  

	int64_t		__ss_align;	 
#line 624
	char		__ss_pad2[(1280 - (sizeof(sa_family_t) + ((sizeof (int64_t)) - (sizeof(uchar_t) + sizeof(sa_family_t))) + (sizeof (int64_t))))];

};
#line 632
struct osockaddr {
	u_short sa_family;               
	char    sa_data[14];             
};
#line 641
struct sockproto {
	u_short sp_family;               
	u_short sp_protocol;             
};
#line 649
struct omsghdr {
	caddr_t msg_name;                
	int     msg_namelen;             
	struct  iovec *msg_iov;          
	int     msg_iovlen;              
	caddr_t msg_accrights;           
	int     msg_accrightslen;
};
#line 695
struct sf_parms {

    void      *header_data;          
    uint_t    header_length;         

    int       file_descriptor;       
#line 709
    uint64_t file_size;             
    uint64_t file_offset;           
    int64_t file_bytes;             

    void      *trailer_data;         
    uint_t    trailer_length;        

    uint64_t bytes_sent;            
};
#line 736
ssize_t send_file(int *, struct sf_parms *, uint_t);
}
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 111 "/usr/include/netinet/in.h"
typedef uint16_t	in_port_t;	  
typedef uint32_t	in_addr_t;	 
#line 121
struct in_addr {
	in_addr_t	s_addr;
};
#line 166
struct sockaddr_in {
	uchar_t	       sin_len;
	sa_family_t    sin_family;
	in_port_t      sin_port;
	struct in_addr sin_addr;
	uchar_t	       sin_zero[8];
};
#line 336
uint16_t ntohs(uint16_t);
uint16_t htons(uint16_t);
uint32_t ntohl(uint32_t);
uint32_t htonl(uint32_t);
#line 362
uint64_t ntohll(uint64_t);
uint64_t htonll(uint64_t);
#line 400
struct in6_addr {
	union {
		u_int32_t u6_addr32[4];
#line 406
		u_int16_t u6_addr16[8];
		u_int8_t  u6_addr8[16];
	} u6_addr;
};
#line 450
struct sockaddr_in6 {
	u_char		sin6_len;
	u_char		sin6_family;
	u_int16_t	sin6_port;
	u_int32_t	sin6_flowinfo;
	struct 		in6_addr	sin6_addr;
	uint32_t	sin6_scope_id;	 
};
#line 472
struct sockaddr_inds {
	u_char  sin_len;
	u_char  sin_family;
	u_short sin_num;
	char    sin_data[12];
};
#line 499
struct ip_mreq {
	struct in_addr	imr_multiaddr;	 
	struct in_addr	imr_interface;	 
};
struct ipv6_mreq {
	struct in6_addr ipv6mr_multiaddr;  
	unsigned int ipv6mr_interface;   
};

struct oipv6_mreq {
	struct in6_addr	ipv6mr_multiaddr;	 
	struct in6_addr	ipv6mr_interface;	 
};
#line 531
struct if_info {
	char			ifi_name[16];
	struct	in_addr		ifi_addr;
	int			ifi_type;
};
#line 543
struct get_mtus {
	int	buf_len;
	int	*mtus_list;
};

typedef struct _mtu_node {
	int	mtu_value;
	struct	_mtu_node *next;
} mtu_node;
}
extern "C" {
}
extern "C" {
#line 772
extern const struct in6_addr in6addr_any, in6addr_loopback;
#line 820
struct in6_pktinfo {
      struct in6_addr ipi6_addr;       
      int             ipi6_ifindex;    
};
#line 828
struct ip6_mtuinfo {
        struct sockaddr_in6 ip6m_addr;      
        uint32_t                ip6m_mtu;   
};
#line 839
socklen_t	inet6_rth_space(int, int);
void		*inet6_rth_init(void *, socklen_t, int, int);
int		inet6_rth_add(void *, const struct in6_addr *);
int		inet6_rth_reverse(const void *, void *);
int		inet6_rth_segments(const void *);
struct in6_addr *inet6_rth_getaddr(const void *, int);

int             inet6_opt_init(void *, socklen_t);
int		inet6_opt_append(void *, socklen_t, int, uint8_t,
				socklen_t, uint_t, void **);
int		inet6_opt_finish(void *,socklen_t, int);
int		inet6_opt_set_val(void *, int, void *, socklen_t);
int		inet6_opt_next(void *, socklen_t, int, uint8_t *,
				socklen_t *, void **);
int		inet6_opt_find(void *, socklen_t, int, uint8_t,
				socklen_t *, void **);
int		inet6_opt_get_val(void *, int, void *, socklen_t);
}
extern "C" {
#line 95 "/usr/include/arpa/inet.h"
in_addr_t	____inet_addr(const char *);
in_addr_t	inet_lnaof(struct in_addr);
struct in_addr	____inet_makeaddr(in_addr_t, in_addr_t);
in_addr_t	inet_netof(struct in_addr);
in_addr_t	____inet_network(const char *);
char		*____inet_ntoa(struct in_addr);
}
extern "C" {
#line 68 "/usr/include/netinet/if_ether.h"
struct ether_addr {
	u_char	ether_addr_octet[6];
};
}
extern "C" {
}
extern "C" {
#line 86 "/usr/include/net/if_dl.h"
struct sockaddr_dl {
	u_char	sdl_len;	 
	u_char	sdl_family;	 
	u_short	sdl_index;	 
	u_char	sdl_type;	 
	u_char	sdl_nlen;	 
	u_char	sdl_alen;	 
	u_char	sdl_slen;	 
#line 96
        char    sdl_data[120]; 

};
}
extern "C" {
#line 170 "/usr/include/arpa/inet.h"
int		inet_aton(const char *, struct in_addr *);
char 		*inet_neta(in_addr_t, char *, size_t);
char            *inet_net_ntop(int, const void *, int, char *, size_t);
int              inet_net_pton(int, const char *, void *, size_t);
char            *____inet_ntoa(struct in_addr);
int              inet_pton(int, const char *restrict, void *restrict);
const char      *inet_ntop(int, const void *restrict, char *restrict, size_t);
u_int            inet_nsap_addr(const char *, u_char *, int);
char            *inet_nsap_ntoa(int, const u_char *, char *);
int		ether_line(char *, struct ether_addr *, char *);
char		*ether_ntoa(struct ether_addr *);
int		ether_ntoa_r(struct ether_addr *, char *);
struct ether_addr *ether_aton(char *);
int		ether_aton_r(char *, struct ether_addr *);
int		ether_hostton(char *, struct ether_addr *);
int		ether_ntohost(char *, struct ether_addr *);
int		link_addr(char *, struct sockaddr_dl *);
char 		*link_ntoa(const struct sockaddr_dl *);
int		link_ntoa_r(const struct sockaddr_dl *, char *, int);
void            **which_inetntoa(void);
}
#line 17 "/usr/vacpp/include/arpa/inet.h"
extern "C"
{
in_addr_t       inet_addr(const char *);
struct in_addr  inet_makeaddr(in_addr_t, in_addr_t);
in_addr_t       inet_network(const char *);
char            *inet_ntoa(struct in_addr);
}
extern "C" {
#line 45 "/usr/include/pthread.h"
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 44 "/usr/include/sys/proc.h"
extern "C" {
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 33 "/usr/include/sys/processor.h"
typedef short cpu_t;             
typedef short cpuidx_t;          
typedef short sradid_t;          
typedef short processor_t;       
#line 40
extern int bindprocessor(int What, int Who, cpu_t Where); 
#line 53
extern cpu_t mycpu(void);
}
extern "C" {
}
extern "C" {
#line 46 "/usr/include/sys/var.h"
struct var_hdr
{
        __ulong32_t var_vers;    
        __ulong32_t var_gen;     
        __ulong32_t var_size;    

};
#line 59
struct var {
	struct var_hdr	var_hdr;	 

	int		v_bufhw;	 
	int     	v_mbufhw;	 
	int		v_maxup;	 
	int		v_iostrun;	 
	int		v_leastpriv;	 
	int		v_autost;	 
	int		v_maxpout;	 

	int		v_minpout;	 

	int		v_memscrub;	 

	int		v_lock;		 
	__cptr32 	ve_lock;	 
	int		v_file;		 
	__cptr32 	ve_file;	 
	int		v_proc;		 
	__cptr32 	ve_proc; 	 
	int		v_clist;	 
	int		v_thread;	 
	__cptr32	ve_thread;	 
	__cptr32	vb_proc;	 
	__cptr32	vb_thread;	 
	int		v_ncpus;	 
	int		v_ncpus_cfg;	 
	int		v_fullcore;	 
	char		v_initlvl[4];	 
	char		v_pre430core;	 
	int		v_xmgc;		 
	int             v_cpuguard;	 
	int		v_ncargs;	 
	int             v_pre520tune;	 
	long long       v_hardstack;	 
	int		v_xmdbg_segs;	 
	int		v_max_logname;	 
	int		v_num_xmfrecs;	 
	long long       v_sed_config;	 
	long long	v_acl_config;	 
};
#line 107
struct kernvars {
	struct var_hdr	var_hdr;	 

	long long	v_bufhw;	 
	long long     	v_mbufhw;	 
	long long	v_maxup;	 
	long long	v_maxpout;	 

	long long	v_minpout;	 

	int		v_iostrun;	 
	int		v_leastpriv;	 
	int		v_autost;	 
	int		v_memscrub;	 

	long long	v_lock;		 
	__cptr64 	ve_lock;	 
	long long	v_file;		 
	__cptr64 	ve_file;	 
	long long	v_proc;		 
	__cptr64 	ve_proc; 	 
	long long	v_clist;	 
	long long	v_thread;	 
	__cptr64	ve_thread;	 
	__cptr64	vb_proc;	 
	__cptr64	vb_thread;	 
	int		v_ncpus;	 
	int		v_ncpus_cfg;	 
	int		v_fullcore;	 
	char		v_initlvl[4];	 
	int		v_coreformat;	 
	int		v_xmgc;		 
	int             v_cpuguard;      
	int		v_ncargs;	 
	int             v_pre520tune;	 
	long long       v_hardstack;	 
	int		v_xmdbg_segs;	 
	int		v_max_logname;	 
	int		v_num_xmfrecs;	 
	long long       v_sed_config;	 
	long long	v_acl_config;	 
};
#line 168
struct vario 
{
    union v
    {
	struct { 
	  long long value;
	} v_bufhw;
	struct { 
	  long long value;
	} v_mbufhw;
	struct { 
	  long long value;
	} v_maxup;
	struct { 
	  long long value;
	} v_maxpout;
	struct { 
	  long long value;
	} v_minpout;
	struct {
	  int	fill;
	  int	value;
	} v_iostrun;
	struct {
	  int	fill;
	  int	value;
	} v_leastpriv;
	struct {
	  int	fill;
	  int	value;
	} v_autost;
	struct {
	  int	fill;
	  int	value;
	} v_memscrub;
	struct {
	  long long value;
	} v_lock;		
	struct {
	  __cptr64 value;
	} ve_lock;
	struct {
	  long long value;
	} v_file;
	struct {
	  __cptr64 value;
	} ve_file;
	struct {
	  long long value;
	} v_proc;
	struct {
	  __cptr64 value; 	
	} ve_proc;
	struct {
	  long long value;
	} v_clist;
	struct {
	  long long value;
	} v_thread;	
	struct {
	  __cptr64 value; 	
	} ve_thread;
	struct {
	  __cptr64 value; 	
	} vb_proc;
	struct {
	  __cptr64 value; 	
	} vb_thread;	
	struct {
	  int	fill;
	  int	value;
	} v_ncpus;
	struct {
	  int	fill;
	  int	value;
	} v_ncpus_cfg;	
	struct {
	  int	fill;
	  int	value;
	} v_fullcore;
	struct {
	  int	fill;
	  char	value[4];
	} v_initlvl;
	struct {
	  int	fill;
#line 257
	  char  fill2[3];
	  char  value;

	} v_coreformat;
	struct {
	  int	fill;
	  int	value;
	} v_xmgc;
	struct {
	  int	fill;
	  int	value;
	} v_cpuguard;
	struct {
	  int	fill;
	  int	value;
	} v_ncargs;
	struct {
	  int	fill;
	  int	value;
	} v_pre520tune;
	struct { 
	  int	fill;
	  int	value;  
	} v_hardstack;
	struct { 
	  int	fill;
	  int	value;
	} v_xmdbg_segs;
	struct {
  	  int	fill;
  	  int	value;
	} v_max_logname;
	struct {
	  int fill;
	  int value;
	} v_num_xmfrecs;
	struct { 
	  long long value;
	} v_sed_config;
	struct {
	  long long value;
	} v_acl_config;
	struct {
	  int fill;
	  int value;
	} turbo_acct;
    } v;
};
#line 307
int sys_parm(int cmd,int parmflag,void *uptr);
}
extern "C" {
}
extern "C" {
#line 40 "/usr/include/sys/atomic_op.h"
typedef int	*atomic_p;
typedef ushort	*atomic_h;
typedef long	*atomic_l;
#line 70
int  fetch_and_add(atomic_p,int);
uint fetch_and_and(atomic_p,uint);
uint fetch_and_or(atomic_p,uint);
boolean_t compare_and_swap(atomic_p,int *,int);
long  fetch_and_addlp(atomic_l,long);
ulong fetch_and_andlp(atomic_l,ulong);
ulong fetch_and_orlp(atomic_l,ulong);
boolean_t compare_and_swaplp(atomic_l, long *, long);
ushort fetch_and_add_h(atomic_h,int);
#line 104
boolean_t _check_lock(atomic_p, int, int);
void _clear_lock(atomic_p, int);
void _clear_lock_mem(atomic_p, int);

int _safe_fetch(atomic_p);
#line 115
#pragma mc_func _clear_lock { \
 "48003403"   \
}
#pragma mc_func _clear_lock_mem { \
 "48003413"   \
}
#pragma mc_func _check_lock { \
 "48003423"   \
}
#pragma mc_func _safe_fetch {          \
 "80630000"   \
 "5463003F"   \
 "41820004"   \
}
#pragma reg_killed_by _safe_fetch cr0,gr3
}
extern "C" {
}
extern "C" {
#line 157 "/usr/include/sys/timer.h"
struct	trb  {
	struct trb 	*to_next;	 
	struct trb 	*knext;		 
	struct trb 	*kprev;		 
	ulong		id;		 
	volatile cpu_t  cpunum; 	 
	unsigned short  flags;           
	ulong		timerid;	 
	tid_t		eventlist;	 
	struct itimerstruc_t timeout;	 
	void		(*func)();	 
	union  parmunion  {		 
		ulong	data;		 
		int	sdata;		 
		caddr_t	addr;		 
	}  t_union;
	int		ipri;		 
	void		(*tof)();	 
};
#line 284
struct cputime_tmr {
	struct posix_tmr   *next;          
	struct posix_tmr   *prev;          
	int                id;             
	timer_t            timerid;        
	unsigned short     flags;          
	unsigned int       value;          
	unsigned int       interval;       
	void		   (*func)();	   
	caddr_t            data;            
};
#line 299
struct posix_tmr {
	clockid_t tmr_clockid;                
	short     tmr_active_overrun;         
	short     tmr_prev_overrun;           
	int       tmr_notify;                 
	union {                
		tid_t  tid;    

                void  *sip;    

        } tmr_notifunion;
	union {                   
		struct trb         *trb;      

		struct cputime_tmr cpu_tmr;   

	} tmr_union;
};
#line 326
struct cputime_clock {
	uint_t             rt_ticks;       

	struct posix_tmr   *active_tmrs;   

};
}
extern "C" {
#line 47 "/usr/include/sys/thread.h"
extern "C" {
#line 53
typedef unsigned long	thread_eye_catch_t;
#line 97
typedef union	{
			unsigned long long mrq_mask_word[2];
			unsigned int mrq_mask_int[(2 * 2)];
		} mrq_mask_t;
#line 111
struct	thread {
#line 114
	tid_t		t_tid;		 
	tid_t		t_vtid;		 
#line 118
	vmhandle_t	t_kthreadseg;	 
	ulong 		t_atomic;	 
	uint 		t_flags;	 
        uint 		t_flags2;        
	ushort 		t_lockcount;	 
	short		t_suspend;	 
#line 126
        struct pvthread *t_pvthreadp;    
	struct proc	*t_procp;	 
	struct t_uaddress {
	    struct uthread *uthreadp;	 
	    struct user	*userp;		 
	}		t_uaddress;
#line 135
        uint           	t_ulock64;       
        uint		t_ulock;         
        uint           	t_uchan64;       
        uint		t_uchan;         
	uint		t_userdata64;	 
	int		t_userdata;	 
	uint		t_cv64;		 
	int		t_cv;		 
	uint		t_stackp64;	 
	char		*t_stackp;	 
	uint		t_scp64;	 
	struct __sigcontext *t_scp;	 
#line 157
	char		*t_wchan2;	 
	char		*t_wchan1;	 
	struct thread	*t_eventlist;	 
	ulong 		t_pevent;	 
	ulong 		t_wevent;	 
        vmhandle_t      t_usid;    	 
#line 165
	char		*t_swchan;	 
	struct thread	*t_slist;	 
        struct thread   *t_lockowner;    

	vmhandle_t	t_wchan1sid;     
	uint		t_wchan1offset;  
	int		t_fsflags;	 
	int		t_result;	 
	int		t_polevel;	 
#line 176
	__ptr64		t_threadcontrolp;  
	struct thread	*t_prior;	 
	struct thread	*t_next;	 
	void		*t_graphics;     
	struct run_queue *t_run_queue;	 

	u_longlong_t	t_time_start;	 
	u_longlong_t	t_spurr_time_start; 
	time_t		t_affinity_ts; 	 

	ulong 		t_dispct;	 
	ulong 		t_fpuct;	 
	mrq_mask_t	t_allowed_cpus;	 
	ushort		t_adsp_flags;	 
	ushort 		t_ticks;	 
	char		t_pri_band;	 
	char		t_savsigno;	 
	cpu_t		t_prefunnel_cpu; 
#line 196
	cpu_t		t_cpuid;	 
	cpu_t		t_scpuid;	 
	ushort		t_cpu2;		 
	ushort		t_cpu;		 
#line 202
	char		t_norun_secs;	 
	char		t_policy;	 

        char 		t_lockpri;	 
        char		t_wakepri;	 
#line 210
	uchar 		t_time;		 
	char 		t_sav_pri;	 
	char            t_ceiling;       
	char		t_nice;		 
#line 216
	char		t_sigproc;	 
	char		t_cursig;	 
	char		t_whystop;	 
#line 223
	sigset64_t	t_sig;		 
	sigset64_t	t_sigmask;	 
#line 228
	int		t_chkblock;	 
	ushort		t_whatstop;	 
	ushort		t_chkerror;	 
	pid_t		t_wlm_charge;	
#line 237
        ulong           t_minflt;        
        ulong           t_majflt;        
	uint		t_wlmevtcnt;	 
	uint		t_trcgenct;	 
	uint		t_cpu_tb;	 
	cpu_t		t_ldispcpu;	 

	uint            t_rt_ticks;      

	unsigned long long t_interval_start;	 
#line 254
	unsigned long long t_cputime;		 
	unsigned long long t_scputime;		 
        unsigned long long pth_utime;		 
        unsigned long long pth_stime;		 

	cred_t		*t_credp;	 
#line 271
	cpu_t		t_homecpu;	 
	short		t_homenode;	 
	void		*t_rs_attinfo;	 
        void            *t_nft_dabr;     
        void            *t_nft_descr;    

	void		*t_ulock_listp;	 

	unsigned long   t_ipc_data;
#line 282
	uint		t_procfslr64;	 
	uint		t_procfslr;	 
#line 290
	thread_eye_catch_t	t_eyec;		 
};
#line 296
struct	pvthread {
#line 299
	tid_t		tv_tid;		 
	tid_t		tv_vtid;	 
#line 303
        struct thread 	*tv_threadp;   	 
	struct pvproc	*tv_pvprocp;	 

	struct {
	    struct pvthread *prevthread; 
	    struct pvthread *nextthread; 
	}		tv_threadlist;	 

	Simple_lock	tv_lock_d;	 
	tid_t		tv_synch;	 

	tid_t		tv_tsleep;	 
	char		*tv_wchan;	 

	uint 		tv_flags;	 
        uint 		tv_flags2;     	 
#line 330
	u_longlong_t	tv_totalcputime;   
        u_longlong_t	tv_totalscputime;  
#line 334
        int		tv_boosted;    	 
	cpu_t		tv_affinity;	 
	char		tv_state;	 
	char		tv_wtype;	 

	void		*tv_pmcontext;	 
	char 		tv_pri;		 
#line 351
	struct vnode 	*tv_procfsvn;	 
	void		*tv_chkfile;	 
#line 355
	unsigned long long tv_prbase;	 
	unsigned long long *tv_prpinned;  	
        ushort          tv_prflags;	 
	ushort		tv_prbufcount;	 
	uint		tv_ptid;	 
#line 363
	int		tv_wlm;		 
	class_id_t	tv_class;	 
        void 		*tv_rset;	 
        char            *tv_ptag;        
#line 372
	thread_eye_catch_t	tv_eyec;	 
#line 390
};
#line 731
struct tstate {
#line 734
        struct __context64 mst;
        int		**errnop_addr;
#line 740
        sigset_t        sigmask;
        sigset_t        psig;
        int             policy;
        int             priority;
        int             flags;
        int             flagmask;
        long		userdata;
	uint		fpinfo;
	uint		fpscrx;
	stack_t		sigaltstack;
	__ptr64		thread_control_p;
	void		*prbase;
	void		*credp;
	uint		ptid;
	uint            tct_clock;
	u_longlong_t	ukeyset;
	struct rusage   rusg;
};
#line 822
struct func_desc {
	char *entry_point;
	char *toc_ptr;
	char *data_ptr;
};

struct func_desc32 {
	int entry_point;
	int toc_ptr;
	int data_ptr;
};
#line 835
typedef struct thread_credentials {
	uint 		flags;		 
	cred_ext_t	cred;		 
	int 		reserved[9];	 
} thread_creds_t;
#line 852
extern int errno;

extern int *errnop;
#line 912
tid_t	thread_create(void);
#line 920
void	thread_init(unsigned long long, unsigned long long);

int	thread_kill(tid_t, int);
int     thread_post(tid_t);
int     thread_post_many(int, tid_t *, tid_t *);
tid_t	thread_self(void);
int	thread_setcredentials(int, struct thread_credentials *);
int	thread_setmystate(struct tstate *, struct tstate *);
#line 932
int	thread_setmystate_fast(int, int **, ulong);
int	thread_setmymask_fast(sigset_t);

int     thread_boostceiling(int, int);
int	thread_setsched(tid_t, int, int);
int	thread_setstate(tid_t, struct tstate *, struct tstate *);
int	thread_setstate_fast(tid_t, int);
void	thread_terminate(void);
int	thread_terminate_ack(tid_t);
void    thread_terminate_unlock(atomic_p);
int	thread_getregs(tid_t, mcontext_t *, ulong *, ulong *, int *);
int	thread_getextregs(tid_t, __extctx_t *);
int     thread_tsleep(int, atomic_p, const sigset_t *, struct timestruc_t *);
int     thread_tsleep_chkpnt(int, atomic_p, const sigset_t *);
int     thread_tsleep_event(void *, atomic_p, int, struct timestruc_t *);
int	thread_twakeup(tid_t, int);
int     thread_twakeup_event(void *, int, int);
int     thread_twakeup_unlock(tid_t, int, atomic_p);
int	thread_unlock(atomic_p);
long	thread_userdata(void);
int     thread_wait(int);
int	thread_waitlock(atomic_p);
int	thread_waitlock_local(atomic_p);
int	thread_waitlock_(atomic_p, int, struct timestruc_t *);
int	thread_waitlock_local_(atomic_p, tid_t, struct timestruc_t *);
int     thread_waitact(int);
void    threads_runnable(int);
int	count_event_waiters(void *);
void	thread_callout(tid_t, uint);
#line 965
}
}
extern "C" {
#line 129 "/usr/include/sys/ptrace.h"
int ptrace(int request, int32long64_t id, int *address, int data, int *buffer);
int ptracex(int request, int32long64_t id, long long addr, int data, int *buff);
int ptrace64(int request, long long id, long long addr, int data, int *buff);
#line 136
struct ptsprs {
        unsigned int    pt_iar;          
        unsigned int    pt_msr;          
        unsigned int    pt_cr;           
        unsigned int    pt_lr;           
        unsigned int    pt_ctr;          
        unsigned int    pt_xer;          
        unsigned int    pt_mq;           
        unsigned int    pt_reserved_0;   
        unsigned int    pt_fpscr;        
        char            pt_reserved_1;   
        char            pt_reserved_2;   
        char            pt_reserved_3[2]; 
        unsigned int    pt_reserved_4[5]; 
        unsigned int    pt_reserved_5;   
        unsigned int    pt_reserved_6;   
        unsigned int    pt_reserved_7;   
        unsigned int    pt_reserved_8;   
        unsigned int    pt_reserved_9;   
        unsigned int    pt_fpscrx;       
};
#line 161
struct ptxsprs {
        unsigned long long      pt_msr;   
        unsigned long long      pt_iar;   
        unsigned long long      pt_lr;    
        unsigned long long      pt_ctr;   
        unsigned int            pt_cr;    
        unsigned int            pt_xer;   
        unsigned int            pt_fpscr;  
        unsigned int            pt_fpscrx;  
};

struct ptthreads 
{
	tid32_t	th[32767];
};

struct ptthreads64
{
	tid64_t	th[32767];
};

typedef struct _ptrace_info {
	unsigned int	ptrace_info_size;     
	unsigned int	total_info_size;      
	offset_t	watchpoints_hdr_off;  
} _ptrace_info;

typedef struct _pt_watchpoints_hdr {
	offset_t	pt_watchpoints_offset;	 
	unsigned int	pt_watchpoints_count;	 
	unsigned int	pt_watchpoint_size;	 
	unsigned int	pt_validate:1;	 
	unsigned int	pt_wp_write:1;	 
	unsigned int	pt_wp_read:1;	 
	unsigned int	pt_wp_thread:1;	 
	unsigned int	pt_wp_value:1;	 
	unsigned int	pt_wp_shmem:1;	 
	unsigned int	pt_wp_mapped:1;	 
	unsigned int	:25;
	unsigned int	reserved;
} _pt_watchpoints_hdr;

typedef struct _pt_watchpoint {
	unsigned long long		wp_start;  
	unsigned long long		wp_size;   
	union {
		unsigned long long	wp_tid;    
		struct {
			unsigned int	wp_minsize;  
			unsigned short	wp_count;    
			unsigned short	wp_align;    
		} pt_watchpoint_info;		     
	} pt_wp_u;
#line 217
	void				*wp_value;     
	unsigned int			wp_ignore:1;   
	unsigned int			wp_invalid:1;  
	unsigned int			wp_filter:1;   
	unsigned int			wp_thread:1;   
	unsigned int			wp_shmem:1;    
	unsigned int			wp_mapped:1;   
	unsigned int			wp_read:1;     
	unsigned int			wp_write:1;    
	unsigned char			wp_style;      
} _pt_watchpoint;
#line 287
enum __ptrace_request {
	PTRACE_TRACEME,
	PTRACE_PEEKTEXT,
	PTRACE_PEEKDATA,
	PTRACE_PEEKUSER,
	PTRACE_POKETEXT,
	PTRACE_POKEDATA,
	PTRACE_POKEUSER,
	PTRACE_CONT,
	PTRACE_KILL,
	PTRACE_SINGLESTEP,
	PTRACE_GETREGS,
	PTRACE_SETREGS,
	PTRACE_GETFPREGS,
	PTRACE_SETFPREGS,
	PTRACE_ATTACH,
	PTRACE_DETACH,
	PTRACE_SYSCALL
};
}
extern "C" {
}
extern "C" {
}
extern "C" {
#line 61 "/usr/include/sys/proc.h"
typedef unsigned long	proc_eye_catch_t;
#line 68
struct uidinfo {
	struct uidinfo	*pu_next;	 
	struct uidinfo	*pu_prev;	 
	uid_t		pu_uid;		 
	long		pu_cnt;		 
	int		pu_pad[4];	 
};
extern struct uidinfo	*get_uidinfo (uid_t uid);
extern void		free_uidinfo (struct uidinfo *uidinfo);
#line 95
struct kernext_svc {
	void    (*kernext_svc_cleanup)(void *);
};
#line 110
struct proc_counts {
		unsigned long long	trp_count[10];
	};
#line 123
struct	proc {

	struct pvproc 	*p_pvprocp;	 
	pid_t		p_pid;		 
	uint		p_flag;		 
	uint		p_flag2;	 
	uint 		p_int;		 
	uint		p_atomic;	  
#line 134
	ushort 		p_threadcount;	 
	ushort		p_active;     	 
	ushort		p_suspended;  	 
	ushort		p_terminating;	 
	ushort		p_local;      	 
#line 148
        ulong 		p_rss;           
        short	  	p_sradassign;  	  
        ushort 		p_boundcount;    
	void 		*p_rs_attinfo;	 
#line 154
	ulong 		p_pevent;	 
	vmhandle_t	p_adspace;	 
#line 178
	sigset64_t	p_sig;		 
	sigset64_t	p_sigignore;	 
	sigset64_t	p_sigcatch;	 
	sigset64_t	p_siginfo;	 

	struct ksiginfo	*p_infoq;	 
#line 186
	unsigned long long p_size;	 
	unsigned long long p_minflt;	 
	unsigned long long p_majflt;	 
	long long	p_repage;	 
	uint 		p_pctcpu;        
	int	 	p_sched_count;	  
	short		p_cpticks;	 
	short		p_msgcnt;	 
	uint 		p_majfltsec;	 
#line 197
	char		p_nice;		 
#line 201
	char		p_sched_pri;	 
#line 205
	int		p_chkblock;	 
	void		*p_chkfile;	 
	void 		*p_prtrcset;	 

	void 		*p_lgpage;	 
#line 212
	struct posix_tmr *p_rt_timer[32];  
	struct cputime_clock p_clock;    
	ushort p_io_priority;		 
#line 220
	time_t			p_memory_lbolt;    
	unsigned long long	p_interval_start;  

	struct proc_counts p_acct;		 

        struct diskiostat {
            unsigned long long      inbytes;     
            unsigned long long      outbytes;    
            unsigned long long      logbytes;    
            unsigned long long      logops;      
            unsigned long long      inops;       
            unsigned long long      outops;      
        } p_diskiostat;
	int	p_wlmthrds;	      
        int     p_wlmocthrds;         
	int	p_thrsetcnt;	      

	void	*p_ptbpt;		 
	tid_t	p_ptsynch;		 
#line 244
	proc_eye_catch_t           	p_eyec;		 
};
#line 255
struct	pvproc {
#line 258
        pid_t           pv_pid;          
        pid_t           pv_ppid;         
        pid_t           pv_sid;          
        pid_t           pv_pgrp;         
        uid_t           pv_uid;          
        uid_t           pv_suid;         
	class_id_t	pv_class;	 
#line 270
        pid_t           pv_vpid;         
        pid_t           pv_vppid;        
        pid_t           pv_vsid;         
        pid_t           pv_vpgrp;        
        crid_t          pv_crid;         
        uint            pv_crid_token;   
#line 278
        struct trusage64 pv_ru;          

	ulong		pv_spare[1];	 

	Simple_lock	pv_lock;	 
#line 285
	char		pv_stat;	 
	char		pv_sigs_queued;	 
	ushort		pv_xstat;	
#line 292
	uint		pv_atomic;	 
	uint		pv_flag;	 
	uint		pv_flag2;	 
	int		pv_wlm;		 
	uint 		pv_auditmask;	 
#line 299
	Simple_lock	pv_usched_lock;	 
	struct pvthread	*pv_uschedp;	 
#line 303
	struct ptipc	*pv_ipc;	 
	struct pvproc	*pv_dblist;	 
	struct pvproc	*pv_dbnext;	 
#line 308
	struct vnode *	pv_procfsvn;	 
#line 311
	struct pvproc	*pv_sched_next;	 
	struct pvproc	*pv_sched_back;	 
#line 315
	struct proc 	*pv_procp;	 
	struct pvproc	*pv_child;	 
	struct pvproc	*pv_siblings;	 
	struct uidinfo	*pv_uidinfo;	 
#line 322
	struct pvproc	*pv_ganchor;	 
        struct pvproc   *pv_pgrpl;       
        struct pvproc   *pv_pgrpb;       
        struct pvproc   *pv_ttyl;        
#line 333
        struct pvproc   *pv_cridnext;    

	Simple_lock pv_session_lock;	 
	Simple_lock pv_parent_lock; 	 
	Simple_lock pv_lock_d; 		 
#line 340
	struct pvthread	*pv_threadlist;	 
	tid_t		pv_synch;	 
#line 345
	uint64_t 	pv_mempools[1];	 
	void 		*pv_rset;	 
#line 349
	unsigned long long pv_nframes;	 
	unsigned long long pv_npsblks;	 
	unsigned long long pv_nvpages;	 
#line 354
	struct kernext_svc *pv_asyncio;
	tid_t		pv_chksynch;	 
	struct pvthread *pv_chktv;	 
#line 382
	unsigned long long     pv_totalcputime;	  
        unsigned long long     pv_totalscputime;  
        unsigned long long     pv_xcputime;       
        unsigned long long     pv_xscputime;      

	unsigned long long     pv_totaldiskio;    
	time_t                 pv_termtime;
	void		      *pv_gcipc;        
#line 392
	char pv_pri;                   
	char pv_policy;                
#line 396
	short			pv_acctflags;
	int			pv_projid;	 
	unsigned long long	pv_subproj;	 
	int			pv_sprojid;	 
	int			pv_pad1;	 

	dev64_t			pv_app_dev;	 
	ino64_t			pv_app_ino;	 
	uint_t			pv_app_gen;	 
	void			*pv_ewlmproc;	 
	struct prochr		*pv_handlers;	 

	void			*pv_cached_credp;  
	Simple_lock		pv_handlers_lock; 

	unsigned long long      pv_wlm_nvpages;   
#line 420
	uint			pv_flag3;	 
	int			pv_pad3;
#line 427
	 proc_eye_catch_t		pv_eyec;	 
#line 447
	int		pv_pad[1];
#line 450
};
#line 915
extern Simple_lock crid_lock;
extern Simple_lock ptrace_lock;
extern Complex_lock core_lock;
extern Simple_lock time_lock;	

extern Simple_lock uidinfo_lock;

extern Simple_lock uex_lock;
#line 926
extern Simple_lock suspending_q_lock;
#line 932
struct proch 
{
	struct	proch	*next;	 
	void (*handler)();		 
};
#line 1004
struct prochr
{
	struct	prochr	*prochr_next;	 
	void	(*prochr_handler)();	 
	uint	prochr_mask;		 
	int	pad;			 
};
#line 1015
typedef struct prochr_execexit
{
        int         len;             
        dev_t       dev;             
        ino_t       ino;             
        uint_t      gen;             
} prochr_execexit_t;        
#line 1097
}
}
extern "C" {
}
extern "C" {
#line 63 "/usr/include/sys/sched.h"
extern "C" {
#line 66
struct sched_param
{
        int      sched_priority;
        int      sched_policy;
        int      sched_reserved[6];
};

struct timespec;

int      sched_get_priority_max(int);
int      sched_get_priority_min(int);
int      sched_getparam(pid_t, struct sched_param *);
int      sched_getscheduler(pid_t);
int      sched_rr_get_interval(pid_t, struct timespec *);
int      sched_setparam(pid_t, const struct sched_param *);
int      sched_setscheduler(pid_t, int, const struct sched_param *);
int 	 sched_yield(void);	
#line 85
}
}
extern "C" {
}
extern "C" {
#line 229 "/usr/include/pthread.h"
extern int
pthread_attr_init (pthread_attr_t *);

extern int
pthread_attr_destroy (pthread_attr_t *);
#line 236
extern int
pthread_attr_setstack 
#line 237
(pthread_attr_t *, void *, size_t);
#line 241
extern int
pthread_attr_getstack 
#line 242
(const pthread_attr_t *restrict, void **restrict, size_t *restrict);
#line 247
extern int
pthread_attr_setstacksize 
#line 248
(pthread_attr_t *, size_t);
#line 251
extern int
pthread_attr_getstacksize 
#line 252
(const pthread_attr_t *restrict, size_t *restrict);
#line 255
extern int
pthread_attr_setstackaddr 
#line 256
(pthread_attr_t *, void *);
#line 259
extern int
pthread_attr_getstackaddr 
#line 260
(const pthread_attr_t *restrict, void **restrict);
#line 263
extern int
pthread_attr_setschedpolicy 
#line 264
(pthread_attr_t *, int);
#line 267
extern int
pthread_attr_getschedpolicy 
#line 268
(const pthread_attr_t *restrict, int *restrict);
#line 271
extern int
pthread_attr_setschedparam 
#line 272
(pthread_attr_t *restrict, const struct sched_param *restrict);
#line 275
extern int
pthread_attr_getschedparam 
#line 276
(const pthread_attr_t *restrict, struct sched_param *restrict);
#line 279
extern int
pthread_attr_setinheritsched 
#line 280
(pthread_attr_t *, int);
#line 283
extern int
pthread_attr_getinheritsched 
#line 284
(const pthread_attr_t *restrict, int *restrict);
#line 287
extern int
pthread_attr_setdetachstate 
#line 288
(pthread_attr_t *, int);
#line 291
extern int
pthread_attr_getdetachstate 
#line 292
(const pthread_attr_t *, int *);
#line 296
extern int
pthread_attr_setguardsize 
#line 297
(pthread_attr_t *, size_t);
#line 300
extern int
pthread_attr_getguardsize 
#line 301
(const pthread_attr_t *restrict, size_t *restrict);
#line 309
extern int
pthread_setschedparam 
#line 310
(pthread_t, int, const struct sched_param *);
#line 314
extern int
pthread_getschedparam 
#line 315
(pthread_t, int *restrict, struct sched_param *restrict);
#line 319
extern int
pthread_setschedprio 
#line 320
(pthread_t, int);
#line 323
extern pthread_t
pthread_self (void);
#line 330
extern int
pthread_create 
#line 331
(pthread_t *restrict, const pthread_attr_t *restrict, void *(*)(void *), void *restrict);
#line 335
extern int
pthread_detach (pthread_t);

extern int
pthread_join 
#line 339
(pthread_t, void **);
#line 342
extern void
pthread_exit (void *);
#line 350
extern void
pthread_cleanup_push (void (*)(void *), void *);

extern void
pthread_cleanup_pop (int);

extern int
pthread_cancel (pthread_t);

extern int
pthread_attr_setscope 
#line 360
(pthread_attr_t *, int);
#line 363
extern int
pthread_attr_getscope 
#line 364
(const pthread_attr_t *restrict, int *restrict);
#line 367
extern int
pthread_equal 
#line 368
(pthread_t, pthread_t);
#line 371
extern int
pthread_kill 
#line 372
(pthread_t, int);
#line 375
extern int
pthread_checkpnt_pending ();
#line 382
extern int
pthread_getcpuclockid 
#line 383
(pthread_t, clockid_t *);
#line 391
extern int
pthread_mutexattr_init (pthread_mutexattr_t *);

extern int
pthread_mutexattr_destroy (pthread_mutexattr_t *);

extern int
pthread_mutexattr_setprotocol 
#line 398
(pthread_mutexattr_t *, int);
#line 401
extern int
pthread_mutexattr_getprotocol 
#line 402
(const pthread_mutexattr_t *restrict, int *restrict);
#line 405
extern int
pthread_mutexattr_setprioceiling 
#line 406
(pthread_mutexattr_t *, int);
#line 409
extern int
pthread_mutexattr_getprioceiling 
#line 410
(const pthread_mutexattr_t *restrict, int *restrict);
#line 413
extern int
pthread_mutexattr_getpshared 
#line 414
(const pthread_mutexattr_t *restrict, int *restrict);
#line 422
extern int
pthread_mutexattr_setpshared 
#line 423
(pthread_mutexattr_t *, int);
#line 428
extern int
pthread_mutexattr_gettype 
#line 429
(const pthread_mutexattr_t *restrict, int *restrict);
#line 432
extern int
pthread_mutexattr_settype 
#line 433
(pthread_mutexattr_t *, int);
#line 441
extern int

pthread_mutex_init 
#line 443
(pthread_mutex_t *restrict, const pthread_mutexattr_t *restrict);
#line 450
extern int
pthread_mutex_destroy (pthread_mutex_t *);

extern int
pthread_mutex_lock (pthread_mutex_t *);
#line 458
extern int
pthread_mutex_timedlock 
#line 459
(pthread_mutex_t *restrict, const struct timespec *restrict);
#line 463
extern int
pthread_mutex_trylock (pthread_mutex_t *);

extern int
pthread_mutex_unlock (pthread_mutex_t *);

extern int
pthread_mutex_setprioceiling 
#line 470
(pthread_mutex_t *restrict, int, int *restrict);
#line 474
extern int

pthread_mutex_getprioceiling 
#line 476
(const pthread_mutex_t *restrict, int *restrict);
#line 487
extern int
pthread_condattr_init (pthread_condattr_t *);

extern int
pthread_condattr_destroy (pthread_condattr_t *);

extern int
pthread_condattr_getpshared 
#line 494
(const pthread_condattr_t *restrict, int *restrict);
#line 502
extern int
pthread_condattr_setpshared 
#line 503
(pthread_condattr_t *, int);
#line 508
extern int
pthread_condattr_getclock 
#line 509
(const pthread_condattr_t *restrict, clockid_t *restrict);
#line 512
extern int
pthread_condattr_setclock 
#line 513
(pthread_condattr_t *, clockid_t);
#line 525
extern int
pthread_cond_init 
#line 526
(pthread_cond_t *restrict, const pthread_condattr_t *restrict);
#line 530
extern int
pthread_cond_destroy (pthread_cond_t *);

extern int
pthread_cond_wait 
#line 534
(pthread_cond_t *restrict, pthread_mutex_t *restrict);
#line 537
extern int
pthread_cond_timedwait 
#line 538
(pthread_cond_t *restrict, pthread_mutex_t *restrict, const struct timespec *restrict);
#line 542
extern int
pthread_cond_signal (pthread_cond_t *);

extern int
pthread_cond_broadcast (pthread_cond_t *);
#line 552
extern int
pthread_key_create 
#line 553
(pthread_key_t *, void (*)(void *));
#line 556
extern int
pthread_key_delete (pthread_key_t);

extern void *
pthread_getspecific (pthread_key_t);

extern int
pthread_setspecific 
#line 563
(pthread_key_t, const void *);
#line 570
extern void
pthread_testcancel (void);

extern int
pthread_setcancelstate 
#line 574
(int, int *);
#line 577
extern int
pthread_setcanceltype 
#line 578
(int, int *);
#line 585
extern int
pthread_once 
#line 586
(pthread_once_t *, void (*)(void));
#line 595
extern int
pthread_rwlock_destroy (pthread_rwlock_t *);

extern int
pthread_rwlock_init 
#line 599
(pthread_rwlock_t *restrict, const pthread_rwlockattr_t *restrict);
#line 602
extern int
pthread_rwlock_rdlock (pthread_rwlock_t *);

extern int
pthread_rwlock_tryrdlock (pthread_rwlock_t *);

extern int
pthread_rwlock_trywrlock (pthread_rwlock_t *);

extern int
pthread_rwlock_unlock (pthread_rwlock_t *);

extern int
pthread_rwlock_wrlock (pthread_rwlock_t *);

extern int
pthread_rwlockattr_destroy (pthread_rwlockattr_t *);

extern int
pthread_rwlockattr_getpshared 
#line 621
(const pthread_rwlockattr_t *restrict, int *restrict);
#line 624
extern int
pthread_rwlockattr_init (pthread_rwlockattr_t *);

extern int
pthread_rwlockattr_setpshared 
#line 628
(pthread_rwlockattr_t *, int);
#line 631
extern int
pthread_atfork (void (*)(void), void (*)(void), void (*)(void));
#line 638
extern int
pthread_rwlock_timedwrlock 
#line 639
(pthread_rwlock_t *restrict, const struct timespec *restrict);
#line 642
extern int
pthread_rwlock_timedrdlock 
#line 643
(pthread_rwlock_t *restrict, const struct timespec *restrict);
#line 652
extern int
pthread_getconcurrency (void);

extern int
pthread_setconcurrency (int);
#line 665
extern int
pthread_spin_init 
#line 666
(pthread_spinlock_t *, int);

extern int
pthread_spin_destroy (pthread_spinlock_t *);

extern int
pthread_spin_lock (pthread_spinlock_t *);

extern int
pthread_spin_unlock (pthread_spinlock_t *);

extern int
pthread_spin_trylock (pthread_spinlock_t *);
#line 685
extern int
pthread_barrierattr_init (pthread_barrierattr_t *);

extern int
pthread_barrierattr_destroy (pthread_barrierattr_t *);

extern int
pthread_barrierattr_getpshared 
#line 692
(const pthread_barrierattr_t *restrict, int *restrict);

extern int
pthread_barrierattr_setpshared 
#line 695
(pthread_barrierattr_t *, int);
#line 702
extern int
pthread_barrier_init 
#line 703
(pthread_barrier_t *restrict, const pthread_barrierattr_t *restrict, unsigned);
#line 706
extern int
pthread_barrier_destroy (pthread_barrier_t *);

extern int
pthread_barrier_wait (pthread_barrier_t *);
#line 721
extern int __pthread_trace;		 
extern int __n_pthreads;		 
#line 837
struct __pthrdscontext
{
	unsigned long long	__pc_gpr[32];  
	unsigned long long	__pc_msr;	   
	unsigned long long	__pc_iar;	   
	unsigned long long	__pc_lr;	   
	unsigned long long	__pc_ctr;	   
	unsigned int		__pc_cr;	   
	unsigned int		__pc_xer;	   
	unsigned int		__pc_fpscr;	  
	unsigned int		__pc_fpscrx;	  
	unsigned long long	__pc_except[1];	   
	double			__pc_fpr[32];  
	char			__pc_fpeu;	   
	char			__pc_fpinfo;	   
	unsigned char		__pc_fpscr24_31;   
	unsigned char		__pc_pad;	   
	unsigned int		__pc_mq;	   
	int			__pc_excp_type;	   
};

struct __pthrdsinfo
{
	unsigned long long	__pi_handle;		 
	pthread_t		__pi_ptid;		 
	tid_t			__pi_tid;		 
	int			__pi_state;		 
	int			__pi_suspendstate;	 
	void *			__pi_exit;		 
	unsigned long		__pi_ustk;		 
	void *			__pi_func;		 
	void *			__pi_arg;		 
	unsigned int		__pi_siglevel;		 
	unsigned int		__pi_frame_count;	 
	char *			__pi_stackaddr;		 
	char *			__pi_stackend;		 
	size_t			__pi_stacksize;		 

	ulong			__pi_pad[14];
#line 879
	struct __pthrdscontext	__pi_context;		 
};
#line 885
struct __pthrdsinfox
{
	struct __pthrdsinfo	__pi;			 
	__extctx_t		__pi_ec;		 
};
#line 894
typedef struct __pthrdstlsinfo {
	void *pti_vaddr;	 
	int   pti_region;	 
} PTHRDS_TLS_INFO;
#line 904
struct __pthrdscreds {
	uint			__pc_flags;	 
	cred_ext_t		__pc_cred;	 
	int			__pc_reserved[9];
};
#line 985
extern void __funcblock_np();
#line 991
extern int
pthread_getunique_np 
#line 992
(pthread_t *, int *);
#line 995
extern int
pthread_mutexattr_getkind_np 
#line 996
(pthread_mutexattr_t *, int *);
#line 1003
extern int
pthread_geteffectiveprio_np  
#line 1004
(pthread_t , int *);

extern int
pthread_mutexattr_setkind_np 
#line 1007
(pthread_mutexattr_t *, int);
#line 1010
extern int
pthread_set_mutexattr_default_np (int);

extern int
pthread_signal_to_cancel_np 
#line 1014
(sigset_t *, pthread_t *);
#line 1017
extern int
pthread_delay_np (struct timespec *);

extern int
pthread_get_expiration_np 
#line 1021
(struct timespec *, struct timespec *);
#line 1024
extern void
pthread_lock_global_np (void);

extern void
pthread_unlock_global_np (void);

extern int
pthread_atfork_np 
#line 1031
(void *, void (*)(void *), void (*)(void *), void (*)(void *));
#line 1042
extern int
pthread_atfork_unregister_np 
#line 1043
(void *, void (*)(), void (*)(), void (*)(), int);
#line 1049
extern int
pthread_test_exit_np (int *);

extern void
pthread_clear_exit_np (pthread_t);

extern int
pthread_setcancelstate_np 
#line 1056
(int, int *);
#line 1059
extern int
pthread_join_np 
#line 1060
(pthread_t, void **);
#line 1063
extern void
pthread_cleanup_push_np 
#line 1064
(void (*)(void *), void *, pthread_t *);
#line 1068
extern void
pthread_cleanup_pop_np 
#line 1069
(int, pthread_t);
#line 1072
extern int
pthread_cleanup_information_np 
#line 1073
(pthread_t, void *, tid_t *, void *, pthread_t *);
#line 1083
extern int
pthread_create_withcred_np 
#line 1084
(pthread_t *, const pthread_attr_t *, void *(*)(void *), void *, struct __pthrdscreds *);
#line 1095
extern int
sigthreadmask 
#line 1096
(int, const sigset_t *, sigset_t *);
#line 1100
extern int
pthread_attr_setsuspendstate_np 
#line 1101
(pthread_attr_t *, int);
#line 1104
extern int
pthread_attr_getsuspendstate_np 
#line 1105
(const pthread_attr_t *, int *);
#line 1108
extern int
pthread_suspend_np (pthread_t);

extern int
pthread_suspend_others_np (void);

extern int
pthread_suspend (pthread_t);

extern int
pthread_continue_np (pthread_t);

extern int
pthread_unsuspend_np (pthread_t);

extern int
pthread_continue_others_np (void);

extern int
pthread_unsuspend_others_np (void);

extern int
pthread_continue (pthread_t);

extern int
pthread_attr_setstacksize_np 
#line 1133
(pthread_attr_t *, size_t);
#line 1136
extern int
pthread_attr_setukeyset_np 
#line 1137
(pthread_attr_t *, unsigned long long *);
#line 1140
extern int
pthread_attr_getukeyset_np 
#line 1141
(const pthread_attr_t *, unsigned long long *);
#line 1155
extern int
pthread_getthrds_np 
#line 1156
(pthread_t *, int, struct __pthrdsinfo *, int, void *, int *);
#line 1164
extern int
pthread_getrusage_np 
#line 1165
(pthread_t, struct rusage *, int);
#line 1174
}
}
#line 12 "/cbilling/app/petri/libsrc/lib/ReadIni.h"
class ReadIni {
private:

public:
	ReadIni ();
	~ReadIni ();
	char *trim( char *str );
	char *readIniString( char const *IniFile, char const *Section, char const *Ident, char *sItem, char *defstr );
	int readIniInteger( char const *IniFile, char const *Section, char const *Ident, int defint );
	long readIniLong( char const *IniFile, char const *Section, char const *Ident, long defint );
	unsigned int readIniUInteger( char const *IniFile, char const *Section, char const *Ident, int defint );
	char *readIniStr( FILE *fd, char *Section, char *Ident, char *sItem, char *defstr );
	int readIniInt( FILE *fd, char *Section, char *Ident, int defint );
	int readIniUInt( FILE *fd, char *Section, char *Ident, int defint );
	char *TruncStr( char *sp , char *sDst , int len);
	int SectionCheck(char *IniFile,char *Section);
	char *SubStr (char *, char *, int);
};
#line 5 "/cbilling/app/petri/libsrc/lib/encode.h"
extern "C"
{
extern void encode(char *inblock,char * outblock);
extern void decode(char *inblock,char * outblock);
}
#line 28 "/cbilling/app/petri/libsrc/framework/Environment.h"
extern int g_argc;
extern char ** g_argv;
#line 32
int snprintf(char *str, size_t size, const char *format, ...);
int vsnprintf(char *str, size_t size, const char *format, va_list ap);
#line 40
class Environment
{
  public:

    static void setDBLogin(char *name, char *pwd, char *str);
#line 47
    static TOCIDatabase *getDBConn(bool bReconnect = false);
    static void useUserInfo();
    static void commit();

   static void rollback();

    static void disconnect();

	static void initSQLStatement();
	static void Terminate();
#line 59
    static bool m_bConnect;
    static void getConnectInfo(
            char * sIniHeader, char *sUserName, char *sPasswd, char *sConnStr);

  private:
    static char m_sDBUser[24];
    static char m_sDBPwd[24];
    static char m_sDBStr[32];
    static TOCIDatabase m_oDBConn;

    static bool m_bDefaultConn;

    static void getDefaultLogin();
};
#line 8 "/cbilling/app/petri/libsrc/lib/SeqMgrExt.h"
class SeqMgrExt
{
public:
    SeqMgrExt(char const *sSeqName, int iStep) {
        strcpy (m_sSeqName, sSeqName);
        m_iStep = iStep;
        m_iCursor = iStep;
        m_lBaseValue = 0;
    }

    long getNextVal() {
        if (m_iCursor == m_iStep) {
            TOCIQuery qry (Environment::getDBConn());
            char sSQL[512];

		    sprintf (sSQL, "select seq from sqlite_sequence where name='%s'", m_sSeqName);
		    qry.setSQL (sSQL); 
		    qry.open (); 
		    qry.next ();
        m_lBaseValue = qry.field (0).asLong ();
        qry.close ();

        memset(sSQL,0,sizeof(sSQL));
        sprintf (sSQL,"update  sqlite_sequence set seq= seq+%d where name = '%s' ",m_iStep,m_sSeqName);
        qry.setSQL (sSQL); 
        qry.execute();
        qry.commit();
        qry.close();
        m_iCursor = 0;
        }

        long bRet = m_lBaseValue + m_iCursor;
        m_iCursor++;

        return bRet;
    }

private:
    char m_sSeqName[48];
    int  m_iStep;
    int  m_iCursor;
    long m_lBaseValue;

};
#line 13 "/cbilling/app/petri/libsrc/lib/KeyList.h"
template <class T>
class KeyList
{

  public:

    KeyList(int key, T data);
    KeyList(char *key, T data);
#line 23
    void add(char *key, T data);
#line 26
    void add(int key, T data);
#line 29
    bool get(int key, 
#line 32
        T *vlaue);
#line 35
    bool get(char *key, T *value) const;

    void remove(KeyList<T> **pList, int key);
    void remove(KeyList<T> **pList, char *key);
#line 41
    ~KeyList();
#line 44
	KeyList<T> *m_poNext;	
	T m_oData;
	char *m_sOriKey;
	int m_iOriKey;
};
#line 51
template <class T>
KeyList<T>::KeyList(int key, T data) 
: m_poNext(0),m_oData(data),m_sOriKey(0),m_iOriKey(key)
{
}

template <class T>
KeyList<T>::KeyList(char * key, T data) 
: m_poNext(0),m_oData(data),m_iOriKey(0)
{
	m_sOriKey = new char[strlen(key)+1];
	if (!m_sOriKey)
		throw Exception((100100000+1), errno, 63, "/cbilling/app/petri/libsrc/lib/KeyList.h");
	strcpy (m_sOriKey, key);
}
#line 68
template <class T>
void KeyList<T>::add(char *key, T data)
{

	KeyList<T> * p = (KeyList<T> *) this;

	while (p) {
		if (!strcmp(key, p->m_sOriKey)) {
			p->m_oData = data;
			return;
		}
		p = p->m_poNext;
	}
#line 83
	p = new KeyList<T> (key, data);
	if (!p)
		throw Exception((100100000+1), errno, 85, "/cbilling/app/petri/libsrc/lib/KeyList.h");

	p->m_poNext = this->m_poNext;
	this->m_poNext = p;
}
#line 92
template <class T>
void KeyList<T>::add(int key, T data)
{

	KeyList<T> * p = (KeyList<T> *) this;

	while (p) {
		if (key == m_iOriKey) {
			p->m_oData = data;
			return;
		}
		p = p->m_poNext;
	}
#line 107
	p = new KeyList<T> (key, data);
	if (!p)
		throw Exception((100100000+1), errno, 109, "/cbilling/app/petri/libsrc/lib/KeyList.h");

	p->m_poNext = this->m_poNext;
	this->m_poNext = p;
}
#line 116
template <class T>
bool KeyList<T>::get(int key, T *value)
{

	KeyList<T> * p = (KeyList<T> *) this;

	while (p) {
		if (key == p->m_iOriKey) {
			*value = p->m_oData;
			return true;
		}
		p = p->m_poNext;
	}

	return false;
}
#line 134
template <class T>
bool KeyList<T>::get(char *key, T *value) const
{

	KeyList<T> * p = (KeyList<T> *) this;
#line 141
	int iFlag=0;

	while (p) {
		if (!strcmp(key, p->m_sOriKey)) {
			*value = p->m_oData;
			iFlag =1;
			break;

		}
		p = p->m_poNext;
	}

	if (iFlag) 
		return true;
	else
		return false;
}

template <class T>
void KeyList<T>::remove(KeyList<T> ** ppList, int key)
{
	KeyList<T> * p;

	while ((p = *ppList) != 0) {
		if (p->m_iOriKey == key) {
			*ppList = p->m_poNext;
			p->m_poNext = 0;
			delete p;
			return;
		}

		ppList = &(p->m_poNext);
	}
}

template <class T>
void KeyList<T>::remove(KeyList<T> ** ppList, char *key)
{
	KeyList<T> * p;
	while ((p = *ppList) != 0) {
		if (!strcmp(key, p->m_sOriKey)) {
			*ppList = p->m_poNext;
			p->m_poNext = 0;
			delete p;
			return;
		}

		ppList = &(p->m_poNext);
	}
}
#line 193
template <class T>
KeyList<T>::~KeyList()
{

	KeyList<T> * p;

	if (m_sOriKey) 
		delete [] m_sOriKey;

	while (m_poNext) {
		p = m_poNext;
		m_poNext = p->m_poNext;
		p->m_poNext = 0;
		delete p;
	}
}
#line 15 "/cbilling/app/petri/libsrc/lib/HashList.h"
template <class T>
class HashList
{
  public:
	friend class Iteration;

	class Iteration
	{
	  public:
		bool next(T &value)
		{
			while (!m_poCur && m_iHashIndex<m_poHashList->m_iHashValue) {
				m_poCur = m_poHashList->m_poKeyList[m_iHashIndex];
				m_iHashIndex++;
			}

			if (!m_poCur) return false;

			value = m_poCur->m_oData;
			m_poCur = m_poCur->m_poNext;
			return true;		
		}

		Iteration (long i, KeyList<T> *p1, HashList<T> *p2):
		m_iHashIndex(i), m_poCur(p1), m_poHashList(p2)
		{}

		Iteration (const Iteration & right)
		{
			m_iHashIndex = right.m_iHashIndex;
			m_poCur = right.m_poCur;
			m_poHashList = right.m_poHashList;
		}

	  private:
		unsigned long m_iHashIndex;
		KeyList<T> * m_poCur;
		HashList<T> * m_poHashList;
	};
#line 62
	Iteration getIteration ()
	{
		return Iteration (0, 0, this);
	}	
#line 68
    void add(long key, T data) ;
#line 71
    bool get(long key, T *value) ;
#line 74
    void destroy();

    void clearAll();
#line 79
    HashList(unsigned long hashvalue);
#line 82
    ~HashList();
#line 85
    void add(char *key, T data) ;
#line 88
    bool get(char *key, T *value) ;
#line 91
    void remove(long key);
    void remove(char *key);
#line 95
  private:

    long calKey(long key);
#line 100
    long calKey(char *key);

  public:
#line 106
    unsigned long m_iHashValue;
#line 109
    unsigned long m_iCount;
#line 112
    KeyList<T> **m_poKeyList;

};
#line 118
template <class T>
void HashList<T>::add(long key, T data) 
{
	long i = calKey (key);
	if (m_poKeyList[i]) {
		m_poKeyList[i]->add (key, data);
	} else {
		m_poKeyList[i] = new KeyList<T> (key, data);
		if (!m_poKeyList[i])
			throw Exception((100090000+1), errno, 127, "/cbilling/app/petri/libsrc/lib/HashList.h");
	}
}
#line 132
template <class T>
bool HashList<T>::get(long key, T *value) 
{
	long i = calKey (key);
	if (m_poKeyList[i]) {
		return m_poKeyList[i]->get (key, value);
	} else {
		return false;
	}

}
#line 145
template <class T>
void HashList<T>::remove(long key)
{
	long i = calKey (key);
	if (m_poKeyList[i]) {
		m_poKeyList[i]->remove(&(m_poKeyList[i]), key);
	}
}

template <class T>
void HashList<T>::remove(char *key)
{
	long i = calKey (key);
	if (m_poKeyList[i]) {
		m_poKeyList[i]->remove(&(m_poKeyList[i]), key);
	}
}

template <class T>
void HashList<T>::clearAll()
{
	unsigned long i;
	if (!m_poKeyList)
		return;

	for (i=0; i<m_iHashValue; i++) {
		if (m_poKeyList[i]) {
			delete m_poKeyList[i];
			m_poKeyList[i] = 0;
		}		
	}
}
#line 180
template <class T>
void HashList<T>::destroy()
{
	unsigned long i;
	if (!m_poKeyList)
		return;

	for (i=0; i<m_iHashValue; i++) {
		if (m_poKeyList[i])
			delete m_poKeyList[i];
	}

	delete [] m_poKeyList;
	m_poKeyList = 0;
}
#line 197
template <class T>
HashList<T>::HashList(unsigned long hashvalue) : m_iHashValue(hashvalue)
{
	if (!hashvalue)
		throw Exception((100090000+2), errno, 201, "/cbilling/app/petri/libsrc/lib/HashList.h");

	m_poKeyList = new KeyList<T> * [hashvalue];
	if (!m_poKeyList)
		throw Exception((100090000+1), errno, 205, "/cbilling/app/petri/libsrc/lib/HashList.h");

	memset (m_poKeyList, 0, sizeof(KeyList<T> *) * hashvalue);
}
#line 211
template <class T>
HashList<T>::~HashList()
{
	destroy ();
}
#line 218
template <class T>
void HashList<T>::add(char *key, T data) 
{	
	long i = calKey (key);
	if (m_poKeyList[i]) {
		m_poKeyList[i]->add (key, data);
	} else {
		m_poKeyList[i] = new KeyList<T> (key, data);
		if (!m_poKeyList[i])
			throw Exception((100090000+1), errno, 227, "/cbilling/app/petri/libsrc/lib/HashList.h");
	}
}
#line 232
template <class T>
bool HashList<T>::get(char *key, T *value) 
{
	long i = calKey (key);
	if (m_poKeyList[i]) {
		return m_poKeyList[i]->get (key, value);
	} else {
		return false;
	}
}
#line 244
template <class T>
long HashList<T>::calKey(long key)
{
	return key % m_iHashValue;
}
#line 251
template <class T>
long HashList<T>::calKey(char *key)
{
	long i ,j;

	i = 0;
	for (j = 1; *key && (j<13); j++) {
		i += ((*key) * j);  
		key++;
	}

	return i % m_iHashValue;
}
#line 9 "/cbilling/app/petri/libsrc/lib/SimpleSHM.h"
using namespace std;
#line 19
class SimpleSHM
{
  public:

    void close();
#line 26
    void remove();
#line 29
    bool exist();
	long getIPCKey();

    SimpleSHM(long key, unsigned long size, char * pNeed =0 );
#line 35
    SimpleSHM(char *name, unsigned long size, bool bShm = true, char * pNeed =0 );
#line 38
    void open(bool ifcreate = true);
#line 41
    operator char *();
#line 44
    unsigned long size(); 
    unsigned long getLastSize();
    void setLastSize(unsigned long ulsize ) ;
  	 time_t  getShmTime();
#line 50
    ~SimpleSHM();

    int nattch();
#line 57
    unsigned long getlba();
    unsigned long expand( unsigned long xSize );

  private:

    bool _create();
#line 65
    bool _open();
#line 68
    int m_iSysID;
#line 71
    long m_lKey;
#line 74
    bool m_bAttached;
#line 77
    unsigned long m_ulSize;
#line 80
    char *m_pPointer;
    char * m_pNeedPos ;

    bool m_bSHMFile;
    string m_sFileName;
};
#line 11 "/cbilling/app/petri/libsrc/lib/SHMAccess.h"
const int MAX_SHM_EX_CNT = 8;
#line 14
class SHMAccess
{
  public:

    SHMAccess(char *shmname, bool bShm = true);
#line 21
    SHMAccess(long shmkey);
	SHMAccess(unsigned int iType,char *pAddr);
    SHMAccess(char *sType,char *pAddr);
    SHMAccess(long shmkey , long iNextSize, int iMaxExCnt );
#line 27
    ~SHMAccess();
#line 32
    bool exist();
#line 37
    void remove();
	char* getMemAddr()
    {
    	if(m_poSHM)
			return (char *)(*m_poSHM ); 
    	else
			return 0; 
    };

  public:
  	int connnum();
  	void initExpand(unsigned int * pExCnt, int iUnitSize, unsigned int * pSeg );
  	unsigned long expandit();
  	unsigned long totalSize();
    void setExpandNull();
  	void showExpandInfo();
#line 55
	long getKey();

	void close();
#line 60
    void create(unsigned long size);
  	bool reopen();
#line 64
  protected:
#line 67
    unsigned int *m_piSize;
#line 70
    SimpleSHM *m_poSHM;
    SimpleSHM *m_poExSHM[MAX_SHM_EX_CNT];
    int m_iExShmCnt;
    int m_iMaxExCnt;
    long m_lNextSize;
    unsigned int *m_piExpandCnt;
    int m_iUnitSize;
#line 81
    char *m_sSHMName;
    char *m_sExSHMName[MAX_SHM_EX_CNT];

    long m_lSHMKey;
    long m_lExSHMKey[MAX_SHM_EX_CNT];
#line 92
    bool m_bShm;

public:
#line 97
    char *       m_sSegment[MAX_SHM_EX_CNT+1];

    unsigned int * m_piSeg;
#line 102
  private:

    void open();
    bool openEx(int i);
#line 111
};
#line 31 "/cbilling/app/petri/libsrc/lib/SHMData.h"
template <class T>
class SHMData : public SHMAccess
{
public:
	typedef T value_type;
#line 38
	SHMData(char *shmname, bool bShm = true);
#line 41
	SHMData(long shmkey);
#line 44
	~SHMData();
#line 47
	operator T *();
#line 52
	void create(
#line 55
		unsigned int itemnumber) ;

	void reset();

	void clear();
#line 65
	unsigned int malloc();
#line 68
	unsigned int erase(unsigned int i);

	unsigned int getCount();

	void	setCount(unsigned int iCount);
#line 75
	unsigned int getTotal();

	time_t getLoadTime();

	unsigned  int  getMemSize();

	unsigned  long getRealSize();

	unsigned  int  getUsedSize();

	unsigned int getHead(); 

	unsigned int getTail(); 

	int *m_piIdleNext;                 

	unsigned long   getMemAdress();

private:

	void open();

	unsigned int countChange(unsigned int count);
#line 100
	unsigned int *m_piTotal;
#line 103
	unsigned int *m_piUsed;

	unsigned int *m_piHead; 

	unsigned int *m_piTail; 
#line 110
	T *m_pPointer;

};
#line 115
template <class T>
SHMData<T>::SHMData(char *shmname, bool bShm) :
SHMAccess (shmname, bShm)
{
	if (m_poSHM)
		open ();
}
#line 125
template <class T>
SHMData<T>::SHMData(long shmkey) :
SHMAccess (shmkey)
{
	if (m_poSHM)
		open ();
}
#line 135
template <class T>
SHMData<T>::~SHMData()
{
}
#line 141
template <class T>
SHMData<T>::operator T *()
{
	return m_pPointer;
}
#line 151
template <class T>
unsigned int SHMData<T>::countChange(unsigned int count)
{
#line 160
	if ((20+4*(count+1))%sizeof(T) == 0){
		return ((20+4*(count+1))/sizeof(T)+count+1);
	} else {
		return (((20+4*(count+1))/sizeof(T)+1)+count+1);
	}
}
#line 168
template <class T>
void SHMData<T>::open()
{
	m_piTotal = (unsigned *)((char *)(*m_poSHM)) + 1;
	m_piUsed = m_piTotal + 1;
	m_piHead = m_piUsed + 1;
	m_piTail = m_piHead + 1;
	m_piIdleNext =(int *)m_piTail + 1;

	m_pPointer = (T *)(m_piIdleNext+(*m_piTotal)+1);
#line 180
}
#line 183
template <class T>
void SHMData<T>::create(unsigned int itemnumber)                                                                                                                   
{
	unsigned long ulItemnum = 0;
	ulItemnum = countChange(itemnumber);
	SHMAccess::create(ulItemnum*(sizeof(T))); 

	open ();
#line 193
	*m_piTotal = itemnumber;       
	*m_piUsed  = 0;
	*m_piHead  = 1;
	*m_piTail  = *m_piTotal;

	m_pPointer = (T *)(m_piIdleNext+(*m_piTotal)+1);

	for(int i=*m_piHead;i<*m_piTail;i++){
		m_piIdleNext[i] = i+1;
	}
	m_piIdleNext[*m_piTail] = 0;
}

template <class T>
void SHMData<T>::reset()
{
	*m_piUsed = 0;	
	*m_piHead = 1;
	*m_piTail = *m_piTotal;
	for(int i=*m_piHead;i<*m_piTail;i++){
        m_piIdleNext[i] = i+1;
    }
    m_piIdleNext[*m_piTail] = 0;
}

template <class T>
void SHMData<T>::clear()
{
	*m_piUsed = 0;	
	*m_piHead = 1;
	*m_piTail = *m_piTotal;
	for(int i=*m_piHead;i<*m_piTail;i++){
		m_piIdleNext[i] = i+1;
	}
	m_piIdleNext[*m_piTail] = 0;

	memset(m_pPointer,0,*m_piTotal*sizeof(T));
}
#line 233
template <class T>
unsigned int SHMData<T>::malloc()
{
	if (*m_piUsed == *m_piTotal)
		return 0;

	(*m_piUsed)++;
	int iResult = *m_piHead;

	if( *m_piUsed == *m_piTotal )
	{
		*m_piHead = 0;
		*m_piTail = 0;
	}
	else
		*m_piHead = m_piIdleNext[iResult];
	m_piIdleNext[iResult] = -1;                                 
	return (iResult);
}

template <class T>
unsigned int SHMData<T>::erase(unsigned int i)
{
	m_piIdleNext[i] = 0;
	if( *m_piUsed < *m_piTotal ) 
		m_piIdleNext[*m_piTail] = i;
	else
		*m_piHead = i;
	*m_piTail = i;
	(*m_piUsed)--;
	return 1;
}
#line 267
template <class T>
void SHMData<T>::setCount(unsigned int iCount)
{
	if(*m_piTotal<iCount)
		return ;
	(*m_piUsed)=iCount;
}
#line 276
template <class T>
unsigned int SHMData<T>::getCount()
{
	if (*m_piUsed)
		return (*m_piUsed);

	return 0;
}
#line 286
template <class T>
unsigned int SHMData<T>::getTotal()
{
	if (*m_piTotal)
		return (*m_piTotal)-1;

	return 0;	
}
template <class T>
unsigned int SHMData<T>::getMemSize()
{
	if (*m_piTotal)
		return (*m_piTotal)* sizeof(T);

	return 0;
}
template <class T>
unsigned int SHMData<T>::getUsedSize()
{
	if (*m_piUsed)
		return (*m_piUsed)* sizeof(T);

	return 0;
}

template <class T>
unsigned long SHMData<T>::getMemAdress()
{		
	if (m_poSHM)
	{
		return   (unsigned long)m_poSHM;
	}

	return 0;
}

template <class T>
time_t SHMData<T>::getLoadTime()
{
	time_t shm_ctime;

	if (m_poSHM)
	{
		shm_ctime = m_poSHM->getShmTime();	

		return shm_ctime ;
	}
	return  0;
}

template <class T>
unsigned long SHMData<T>::getRealSize()
{
	unsigned long size = m_poSHM->size();
	return size;

}
#line 35 "/cbilling/app/petri/libsrc/lib/SHMData_A.h"
using namespace std;
#line 54
template <class T>
class SHMData_A : public SHMAccess
{
  public:
	  typedef T value_type;
#line 61
	class Iteration
	{
      private:
        unsigned int m_iCurOffset;
        SHMData_A<T> * m_pDataA;
        unsigned char *pData;
        unsigned int m_iStateCnt;

	  private:

        unsigned int getInfo()
        {    

            unsigned int uiTemp = (*(m_pDataA->m_piTotalSE));

            pData = new unsigned char[uiTemp];
            memset(pData, '0', sizeof(unsigned char)*uiTemp );

            unsigned int i = (*(m_pDataA->m_piUsedSE));
            unsigned int j =0;

            if(i!=0  && 0==m_pDataA->m_pIArray[i]){

                uiTemp = i;
                i=0;

                for(; i != (*(m_pDataA->m_piDeledSE)); i++){
                    if( i>= uiTemp ){

                        break;
                    }
                    j = m_pDataA->m_pIArray[i];
                    if( 0== j){
                        j = i;
                    }
                    pData[j]++;                       
                }
                return uiTemp;
            } 
#line 102
            for(; i != (*(m_pDataA->m_piDeledSE)); i++){
                if( i>= uiTemp ){
                    i = 0;
                }
                j = m_pDataA->m_pIArray[i];
                if( 0== j){
                    j = i;
                }
                if( '0' == pData[j] ){

                    pData[j] = '1';

                }else{

                    pData[j]++;
                }
            }

            return uiTemp;

        }

	  public:
	    void close(){ 
	        if(pData){ delete [] pData; pData =0;}
	        m_iCurOffset = 1;
	        m_iStateCnt = 0;
	    }
#line 133
		bool next(T & tOut, unsigned int &uiOffsetOut)
		{
			if(!pData){
			    m_iStateCnt = getInfo();
			}
			if(pData && m_iCurOffset>0){
			    while( m_iCurOffset< m_iStateCnt ){
    			    if('0' == pData[m_iCurOffset] ){
    			        uiOffsetOut = m_iCurOffset;
        			    tOut = m_pDataA->m_pPointer[ m_iCurOffset ];
        			    m_iCurOffset++;

        			    return true;
        			}
        			m_iCurOffset++;
        		}
    			return false;
			}      
			return false;		
		}

		bool nextBatch(unsigned int uiMax, T tOut[], unsigned int &iOutCnt)
		{
			if(!pData){
			    m_iStateCnt = getInfo();
			}
			unsigned int iTotal = (*(m_pDataA->m_piTotalSE));
			unsigned int iCnt=0;
			if(pData && m_iCurOffset>0 && uiMax){
			    while(iCnt<uiMax && m_iCurOffset < m_iStateCnt ){
    			    if('0' == pData[m_iCurOffset] ){
        			    tOut[iCnt] = m_pDataA->m_pPointer[ m_iCurOffset ];
        			    iCnt++;
        			}
        			m_iCurOffset++;

        		}
        		if(iCnt){
        		    iOutCnt = iCnt;
        		    return true;
        		}
        		iOutCnt = 0;
    			return false;
			}      
			return false;		
		}

		Iteration ( unsigned int iCur, SHMData_A<T> * pSHMDataA):
		    m_iCurOffset(iCur), m_pDataA(pSHMDataA),pData(0),m_iStateCnt(0)
		{}

		Iteration (const Iteration & right)
		{
			m_iCurOffset = right.m_iCurOffset;
			m_pDataA = right.m_pDataA;
            pData = 0;
            m_iStateCnt = 0;
		}

		~Iteration () 
		{ if(pData)
		    { delete [] pData; pData =0;}
		}
#line 198
	};

	Iteration getIteration ()
	{
		return Iteration ( 1, this);
	}

  public:
	friend class Iteration;
    SHMData_A(char *shmname, bool bShm = true);

    SHMData_A(long shmkey);

    ~SHMData_A();

    operator T *();

    void create(
        unsigned int itemnumber) ;

    void reset();

    bool revoke( unsigned int uiOffset);
    void showDetail();
    bool checkHealth();
    unsigned int kick(unsigned int uiBeginOff, 
        int iNxtOffset, int iExpOffset, const char * sDate, unsigned int * o_uiKickSelf, bool * o_bKickSelf );
    unsigned int kickAndRevoke(unsigned int uiBeginOff, 
        int iNxtOffset, int iExpOffset, const char * sDate,
        int iChkOffset1, int iChkOffset2, unsigned int * o_uiKickSelf , bool * o_bKickSelf);

    unsigned int malloc();

    unsigned int getCount();

    unsigned int getTotal();

    unsigned long getDelTotal();
    unsigned int  getDelFree ();
    time_t getLoadTime();
	unsigned  int  getMemSize();
	unsigned  int  getUsedSize();
	unsigned long  getMemAdress();
#line 243
    inline void checkSafe(){
        if(0 == *m_piFlag) return;
        while(*m_piFlag){
            usleep(102400);
        }            
    };

    bool setRevokeFlag( unsigned int iFlag){
        if(m_poSHM && m_piFlag){
            *m_piFlag = iFlag; 
            return true;
        }
        return false;
    };

    bool ifSetRevokeFlag(){
        if( *m_piFlag )
            return true;
        return false;
        };
#line 265
  private:

    void open();

  protected :
    unsigned int *m_piTotal;
    unsigned int *m_piUsed;
    T *m_pPointer;

    unsigned int *m_piVersion; 
    unsigned int *m_piTotalSE;
    unsigned int *m_piUsedSE;
    unsigned int *m_piDeledSE;
    unsigned int *m_piFlag;      
    unsigned int *m_piDelOver;   
    unsigned int *m_pIArray; 
};
#line 284
template <class T>
SHMData_A<T>::SHMData_A(char *shmname, bool bShm) :
SHMAccess (shmname, bShm)
{
    if (m_poSHM){
        open ();
        if( 1 != *m_piVersion )
            throw Exception((110170000+1), errno, 291, "/cbilling/app/petri/libsrc/lib/SHMData_A.h");
    }
}
#line 296
template <class T>
SHMData_A<T>::SHMData_A(long shmkey) :
SHMAccess (shmkey)
{
    if (m_poSHM){
        open ();
        if( 1 != *m_piVersion )
            throw Exception((110170000+1), errno, 303, "/cbilling/app/petri/libsrc/lib/SHMData_A.h");
    }

}
#line 310
template <class T>
SHMData_A<T>::~SHMData_A()
{
}

template <class T>
SHMData_A<T>::operator T *()
{
    return m_pPointer;
}
#line 322
template <class T>
void SHMData_A<T>::create(unsigned int itemnumber) 
{
    if( sizeof(T)< 16 )
        throw Exception((110170000+2), errno, 326, "/cbilling/app/petri/libsrc/lib/SHMData_A.h");
    SHMAccess::create((itemnumber+2)* (sizeof(T)+sizeof(int))  );
    open ();
#line 331
    *m_piTotal = 2;
    *m_piUsed = 2;

    *m_piVersion = 1;
    *m_piTotalSE = itemnumber + 1 ;

    m_pIArray =(unsigned int *) &m_pPointer[(*m_piTotalSE)+1];

    *m_piUsedSE = 1;
    *m_piDeledSE= 0;

    if( sizeof(T)< 32 ){
#line 345
        *m_piUsedSE = 2;
        *m_piDeledSE = 1;
        m_pIArray[0] = itemnumber+1;
    }
}

template <class T>
void SHMData_A<T>::reset()
{
    *m_piUsedSE = 1;
    *m_piDeledSE= 0;
    memset( m_pIArray, 0, (*m_piTotalSE) * sizeof(int) );
    *m_piDelOver =0;

    if( sizeof(T)< 32 ){
#line 362
        *m_piUsedSE  = 2;
        *m_piDeledSE = 1;
        m_pIArray[0] = *m_piTotalSE; 
    }

}
#line 370
template <class T>
unsigned int SHMData_A<T>::malloc()
{
    if (*m_piDeledSE == *m_piUsedSE)
        return 0;
    unsigned int uiRet = m_pIArray[(*m_piUsedSE)];
    if(!uiRet)
        uiRet = (*m_piUsedSE);

    (*m_piUsedSE)++;
    if( (*m_piUsedSE) >= (*m_piTotalSE) )
        (*m_piUsedSE) = 0 ;

    return uiRet;

}
#line 388
template <class T>
void SHMData_A<T>::open()
{
    m_piTotal = (unsigned *)((char *)(*m_poSHM)) + 1;
    m_piUsed = m_piTotal + 1;
    m_pPointer = (T *)( (char *)(*m_poSHM));

    m_piVersion = m_piTotal - 1;
    m_piTotalSE = m_piTotal + 2;
    m_piFlag    = m_piTotal + 3;
    m_piUsedSE  = m_piTotal + 4;
    m_piDeledSE = m_piTotal + 5;
    m_piDelOver = m_piTotal + 6;
    if( (*m_piTotalSE) ) {
        m_pIArray =(unsigned int *) &m_pPointer[(*m_piTotalSE)+1];

    }else{
        m_pIArray = 0;
    }
#line 410
}
template <class T>
unsigned int SHMData_A<T>::getCount()
{
    unsigned int iCnt = 0;

    if( (*m_piUsedSE) > (*m_piDeledSE) ){
        iCnt = ( (*m_piUsedSE) - (*m_piDeledSE) -1 );
    }else{
        iCnt = (*m_piTotalSE)- 1 -  (  (*m_piDeledSE) - (*m_piUsedSE) );    
    }

    return iCnt;
}
#line 426
template <class T>
unsigned int SHMData_A<T>::getTotal()
{
    if (*m_piTotalSE)
        return (*m_piTotalSE)-1;

    return 0;   
}
#line 436
template <class T>
bool SHMData_A<T>::revoke( unsigned int uiOffset)
{
    if(!m_poSHM)
        return false;

    if( ((*m_piDeledSE)+1 )%(*m_piTotalSE) == (*m_piUsedSE) )
        return false;

    T oTemp;
    memset(&oTemp, 0, sizeof(T) );
    if(memcmp(& m_pPointer[uiOffset], &oTemp, sizeof(T)) ==0){

        return false;
    }

    m_pIArray[(*m_piDeledSE)] = uiOffset;
    memset( & m_pPointer[uiOffset], 0, sizeof(T) );
#line 456
    if( (*m_piDeledSE)+1 >= (*m_piTotalSE) ){
        (*m_piDeledSE) = 0;
        (*m_piDelOver)++;
    }else{
        (*m_piDeledSE)++;
    }

    return true;   

}
#line 468
template <class T>
unsigned long SHMData_A<T>::getDelTotal( )
{
#line 473
    if( sizeof(T) <32 )
        return ( (*m_piTotalSE) * (*m_piDelOver) + (*m_piDeledSE)  ) - 1;

    return ( (*m_piTotalSE) * (*m_piDelOver) + (*m_piDeledSE)  );
}
#line 481
template <class T>
unsigned int SHMData_A<T>::getDelFree( )
{
    if( (*m_piDelOver) ){

        return getTotal()-getCount();
    }else{
        if( (*m_piUsedSE) > (*m_piDeledSE) ){
            if( sizeof(T) <32 )
                return (*m_piDeledSE)-1;
            else
                return (*m_piDeledSE) ;
        }else{
            return (*m_piDeledSE)-(*m_piUsedSE);
        }
    }
#line 499
}
#line 503
template <class T>
bool SHMData_A<T>::checkHealth()
{
    unsigned char * pData = new unsigned char[(*m_piTotalSE)];
    memset(pData, '0', sizeof(char)*(*m_piTotalSE)  );
    unsigned int i = (* m_piUsedSE );
    unsigned int j =0;
    bool bRet = true;

    for(; i != (* m_piDeledSE ); i++){
        if( i>= (* m_piTotalSE ) ){
            i = 0;
        }
        j = m_pIArray[i];
        if( 0== j){
            j = i;
        }
        if( '0' == pData[j] ){

            pData[j] = '1';

        }else{

            pData[j]++;
            bRet = false;
            cout<< pData[j]<<":"<< j<<",";
        }
        cout<<endl;
    }
    delete []pData;

    if( 0== m_pIArray[(* m_piTotalSE)]  ){

        if((*m_piDelOver)!=0 ){
            bRet = false;
            cout<<"1.";
        }
    }

    if( 0!= m_pIArray[(* m_piTotalSE)]  ){

        if( 0 == (*m_piDelOver) ){
            bRet = false;
            cout<<"2.";
        }
        unsigned int i = (* m_piUsedSE );
        if( i!=0  && 0== m_pIArray[i] ){
            bRet = false;
            cout<<"3.";
        }
#line 556
    }

    return bRet;

}

template <class T>
void SHMData_A<T>::showDetail()
{
    if(!m_poSHM)
        return ;
#line 572
    char sText[256];
    char keys[64];
    if(m_sSHMName) {
        strncpy(keys, m_sSHMName, sizeof(keys));
    }else{
        sprintf(keys, "%ld", m_lSHMKey);
    }
    if( !m_poSHM ){
    snprintf(sText, sizeof(sText), "%-10s 0x%-10lx %2u %-12s %-9d %-10u %-10u %4d%%",
        keys, 0,(*m_piVersion), "DATA_A", sizeof(T), 0, 0, 0 );
    }else{
    char * pp = (char * )(*m_poSHM);
    unsigned int uiTotal = getTotal();
    unsigned int uiCount = getCount();
    int percent = 100*uiCount/uiTotal;
    if( (100*uiCount)%uiTotal )
        percent++;
    snprintf(sText, sizeof(sText), "%-10s 0x%-10lx %2u %-12s %-9d %-10u %-10u %4u%% %-9u %-10lu",
        keys, pp,(*m_piVersion), "DATA_A", sizeof(T), uiTotal, uiCount, percent,
        getDelFree(), getDelTotal() );
    }
    cout<< sText<<endl;
#line 596
}
#line 601
template <class T>
unsigned int SHMData_A<T>::kick(unsigned int uiBeginOff, 
    int iNxtOffset, int iExpOffset, const char * sDate, unsigned int * o_uiKickSelf, bool * o_bKickSelf )
{
    if(!sDate || iNxtOffset<0 || iExpOffset<0 )
        return 0 ;

    unsigned int uiDataOff = uiBeginOff;
    unsigned int iCnt=0;
    *o_bKickSelf=false;
    if( uiDataOff ){
        unsigned int uiDataNext = *(unsigned int *)( ( (char *)&m_pPointer[uiDataOff] )+ iNxtOffset);
        unsigned int uiSelf= uiDataOff;

        while(uiDataNext){
            char * pExp = ( ( (char *)&m_pPointer[uiDataNext] ) + iExpOffset);
            if( strncmp(pExp, sDate, 8)<0 ){

                *(unsigned int *)( ( (char *)&m_pPointer[uiDataOff] )+ iNxtOffset) =
                *(unsigned int *)( ( (char *)&m_pPointer[uiDataNext])+ iNxtOffset);

                *(unsigned int *)( ( (char *)&m_pPointer[uiDataNext])+ iNxtOffset)=0;
                iCnt++;
                uiDataNext=*(unsigned int *)( ( (char *)&m_pPointer[uiDataOff] )+ iNxtOffset);
                continue;
            }
            uiDataOff = uiDataNext;
            uiDataNext=*(unsigned int *)( ( (char *)&m_pPointer[uiDataOff] )+ iNxtOffset);
        }
        char * pExp = ( ( (char *)&m_pPointer[uiSelf] ) + iExpOffset);
        if( strncmp(pExp, sDate, 8)<0 ){
            *o_uiKickSelf =
            *(unsigned int *)( ( (char *)&m_pPointer[uiSelf])+ iNxtOffset);

            *(unsigned int *)( ( (char *)&m_pPointer[uiSelf])+ iNxtOffset)=0;
            iCnt++;
            *o_bKickSelf = true;

        }

    }
    return iCnt;
}
#line 648
template <class T>
unsigned int SHMData_A<T>::kickAndRevoke(unsigned int uiBeginOff, 
    int iNxtOffset, int iExpOffset, const char * sDate,
    int iChkOffset1, int iChkOffset2 , unsigned int  *o_uiKickSelf, bool * o_bKickSelf)
{
    if(!sDate || iNxtOffset<0 || iExpOffset<0 )
        return 0 ;

    unsigned int uiDataOff = uiBeginOff;
    unsigned int iCnt=0;
    *o_bKickSelf=false;

    if( uiDataOff ){
        unsigned int uiDataNext = *(unsigned int *)( ( (char *)&m_pPointer[uiDataOff] )+ iNxtOffset);
        unsigned int uiSelf= uiDataOff;

        while(uiDataNext){
            char * pExp = ( ( (char *)&m_pPointer[uiDataNext] ) + iExpOffset);
            if( strncmp(pExp, sDate, 8)<0 
                && ( iChkOffset1<0 
                    || 0 == *(unsigned int *)( ( (char *)&m_pPointer[uiDataOff] )+ iChkOffset1) )
                && ( iChkOffset2<0 
                    || 0 == *(unsigned int *)( ( (char *)&m_pPointer[uiDataOff] )+ iChkOffset2) )
                ){

                *(unsigned int *)( ( (char *)&m_pPointer[uiDataOff] )+ iNxtOffset) =
                *(unsigned int *)( ( (char *)&m_pPointer[uiDataNext])+ iNxtOffset);

                *(unsigned int *)( ( (char *)&m_pPointer[uiDataNext])+ iNxtOffset)=0;
                revoke(uiDataNext);
                iCnt++;
                uiDataNext=*(unsigned int *)( ( (char *)&m_pPointer[uiDataOff] )+ iNxtOffset);
                continue;
            }
            uiDataOff = uiDataNext;
            uiDataNext=*(unsigned int *)( ( (char *)&m_pPointer[uiDataOff] )+ iNxtOffset);
        }

        char * pExp = ( ( (char *)&m_pPointer[uiSelf] ) + iExpOffset);
        if( strncmp(pExp, sDate, 8)<0 
                && ( iChkOffset1<0 
                    || 0 == *(unsigned int *)( ( (char *)&m_pPointer[uiSelf] )+ iChkOffset1) )
                && ( iChkOffset2<0 
                    || 0 == *(unsigned int *)( ( (char *)&m_pPointer[uiSelf] )+ iChkOffset2) )
            ){
            *o_uiKickSelf =
            *(unsigned int *)( ( (char *)&m_pPointer[uiSelf])+ iNxtOffset);

            *(unsigned int *)( ( (char *)&m_pPointer[uiSelf])+ iNxtOffset)=0;
            iCnt++;
            revoke(uiSelf);
            *o_bKickSelf = true;

        }
    }
    return iCnt;
}
template <class T>
unsigned int SHMData_A<T>::getMemSize()
{
	unsigned int  size = 0;
	if (*m_piTotalSE)
	{
		size = (*m_piTotalSE)* sizeof(T);
	}
	if (size)
		return size ;

	return 0;
}
template <class T>
unsigned int SHMData_A<T>::getUsedSize()
{
	unsigned int size = 0;

	if (*m_piUsedSE)
	{
		 size = (*m_piUsedSE)* sizeof(T);
	}
	if (size)
		return size ;

	return 0;
}

template <class T>
unsigned long SHMData_A<T>::getMemAdress()
{		
	if (m_poSHM)
	{
		return   (unsigned long)m_poSHM;
	}

	return 0;
}

template <class T>
time_t  SHMData_A<T>::getLoadTime()
{
	time_t shm_ctime;

	if (m_poSHM)
	{
		shm_ctime = m_poSHM->getShmTime();	

		return shm_ctime;
	}
	return  0;

}
#line 11 "/cbilling/app/petri/libsrc/lib/CSemaphore.h"
class CSemaphore 
{
public:
    bool getSemEx(const char * sem_name, 

                int init_count = 1,

                int max_count = 64);
#line 21
    bool getSemEx(int iKey, 

                int init_count = 1,

                int max_count = 64);

	bool getSem(const char * sem_name, 

                int init_count = 1,

                int max_count = 64);

    bool P(bool bWait = true);                            
    bool V();                                                
    bool V_W();                                                
    bool P_W(bool bWait = true);                            
    bool close();                                            
public:
    CSemaphore();                                            
    virtual ~CSemaphore();                                   
private:
    void * _Handle;                                          
	char m_sSemName[19];
};
extern "C" {
}
#line 25 "/cbilling/app/petri/libsrc/lib/SHMIntHashIndex.h"
class SHMIntList
{
    friend class SHMIntHashIndex;
public:

    long m_lKey;
#line 33
    unsigned int m_iValue;
#line 36
    unsigned int m_iNext;

};
#line 44
class SHMIntHashIndex : public SHMAccess
{
  public:
	class Iteration
	{
	  public:
		bool next(long & key, unsigned int & value)
		{
			unsigned int j;

            if(m_iCur>m_iHash){
                return false;
            }
            if( m_iNextOffset !=0
                && 0 != m_pIdx->m_poList[m_iNextOffset].m_iValue){
                m_iCurOffset = m_iNextOffset;

                value = m_pIdx->m_poList[m_iCurOffset].m_iValue;
                key = m_pIdx->m_poList[m_iCurOffset].m_lKey;
                m_iNextOffset = m_pIdx->m_poList[m_iCurOffset].m_iNext;
                return true;

            }
            if(0==m_iNextOffset){
                m_iCur++;
                m_iNextOffset = 0;
                m_iCurOffset = 0;
                if(m_iCur>m_iHash){
                    return false;
                }
            }
            while( 1 ){
                j=m_pIdx->m_poHash[m_iCur-1];
                if( 0 == j){
                    m_iCur++;
                    m_iNextOffset = 0;
                    m_iCurOffset = 0;
                    if(m_iCur>m_iHash){
                        return false;
                    }
                    continue;
                }
                if(0 == m_iNextOffset )
                    m_iNextOffset = j;

                while( m_iNextOffset != 0 
                    && 0 == m_pIdx->m_poList[m_iNextOffset].m_iValue ){
                    m_iNextOffset = m_pIdx->m_poList[m_iNextOffset].m_iNext;
                }

                if(0 == m_iNextOffset ){
                    m_iCur++;
                    m_iNextOffset = 0;
                    m_iCurOffset = 0;
                    if(m_iCur>m_iHash){
                        return false;
                    }
                    continue;
                }

                break;

            }
            m_iCurOffset = m_iNextOffset;
			value = m_pIdx->m_poList[m_iCurOffset].m_iValue;
			key = m_pIdx->m_poList[m_iCurOffset].m_lKey;
			m_iNextOffset = m_pIdx->m_poList[m_iCurOffset].m_iNext;
			return true;		
		}

		Iteration ( unsigned int iHash, SHMIntHashIndex * pIdx):
		m_iCur(0), m_iCurOffset(0),m_iNextOffset(0), m_iHash(iHash), m_pIdx(pIdx)
		{}

		Iteration (const Iteration & right)
		{
			m_iCur = right.m_iCur;
			m_iHash = right.m_iHash;
			m_iCurOffset = right.m_iCurOffset;
			m_iNextOffset = right.m_iNextOffset;
			m_pIdx = right.m_pIdx;
		}

        bool setValue( unsigned int iValue ){
            if( m_iCurOffset ){
                m_pIdx->m_poList[m_iCurOffset].m_iValue = iValue;
                return true;
            }
            return false;
        }

	  private:
		unsigned int m_iCur;
		unsigned int m_iHash;
		unsigned int m_iCurOffset;
		unsigned int m_iNextOffset;

		SHMIntHashIndex * m_pIdx;
	};

	Iteration getIteration ()
	{
		return Iteration ( (*m_piHashValue)+1, this);
	}

    friend class Iteration;
#line 152
  	 time_t  getLoadTime();

    SHMIntHashIndex(char *shmname);

    SHMIntHashIndex(long shmkey);
#line 159
    ~SHMIntHashIndex();
#line 162
    void add(long key, unsigned int value);
#line 165
    bool get(long key, unsigned int *pvalue);

	void erase(long key);
	void reset();
#line 173
    void create(
#line 176
        unsigned int itemnumber) ;
#line 179
	void empty();
	int  getMemSize();
	int getUsedSize();			
	unsigned long getMemAdress(); 
	unsigned int getCount()
	{
		if (*m_piUsed)
			return (*m_piUsed)-1;

		return 0;
	};

	unsigned int getTotal()
	{
		if (*m_piTotal)
			return (*m_piTotal)-1;

		return 0;
	};

  private:

    void open();
#line 206
    unsigned int *m_piHashValue;
#line 209
    unsigned int *m_piTotal;
#line 212
    unsigned int *m_piUsed;
#line 215
    unsigned int *m_poHash;
    unsigned long *m_piIndexTime;
	unsigned long *m_pimemAdr;

    SHMIntList *m_poList;

};
#line 29 "/cbilling/app/petri/libsrc/lib/SHMIntHashIndex_A.h"
class SHMIntList_A
{
    friend class SHMIntHashIndex_A;
public:

    long m_lKey;
#line 37
    unsigned int m_iValue;
#line 40
    unsigned int m_iNext;

};
#line 48
class SHMIntHashIndex_A : public SHMAccess
{
public:

	class Iteration
	{
	  public:
		bool next(long & key, unsigned int & value)
		{
			unsigned int j;

            if(m_iCur>m_iHash){
                return false;
            }
            if( m_iNextOffset !=0
                && 0 != m_pIdx->m_poList[m_iNextOffset].m_iValue){

                 if(*m_puiPrePosition!=m_iNextOffset ){
                    m_puiPrePosition=&m_pIdx->m_poList[m_iCurOffset].m_iNext;
                } 

                m_iCurOffset = m_iNextOffset;

                value = m_pIdx->m_poList[m_iCurOffset].m_iValue;
                key = m_pIdx->m_poList[m_iCurOffset].m_lKey;
                m_iNextOffset = m_pIdx->m_poList[m_iCurOffset].m_iNext;
                return true;

            }
            if(0==m_iNextOffset){

                m_iCur++;
                m_iNextOffset = 0;
                m_iCurOffset = 0;
                m_puiPrePosition=& m_pIdx->m_poHash[m_iCur-1];
                if(m_iCur>m_iHash){
                    return false;
                }
            }
            while( 1 ){
                j=m_pIdx->m_poHash[m_iCur-1];
                m_puiPrePosition=& m_pIdx->m_poHash[m_iCur-1];
                if( 0 == j){
                    m_iCur++;
                    m_iNextOffset = 0;
                    m_iCurOffset = 0;
                    m_puiPrePosition=& m_pIdx->m_poHash[m_iCur-1];
                    if(m_iCur>m_iHash){
                        return false;
                    }
                    continue;
                }
                if(0 == m_iNextOffset )
                    m_iNextOffset = j;

                while( m_iNextOffset != 0 
                    &&( 0 == m_pIdx->m_poList[m_iNextOffset].m_iValue ) ){
                    m_puiPrePosition=& m_pIdx->m_poList[m_iNextOffset].m_iNext;
                    m_iNextOffset = m_pIdx->m_poList[m_iNextOffset].m_iNext;

                }

                if(0 == m_iNextOffset ){
                    m_iCur++;
                    m_iNextOffset = 0;
                    m_iCurOffset = 0;
                    m_puiPrePosition=& m_pIdx->m_poHash[m_iCur-1];
                    if(m_iCur>m_iHash){
                        return false;
                    }
                    continue;
                }

                break;

            }
            m_iCurOffset = m_iNextOffset;
			value = m_pIdx->m_poList[m_iCurOffset].m_iValue;
			key = m_pIdx->m_poList[m_iCurOffset].m_lKey;
			m_iNextOffset = m_pIdx->m_poList[m_iCurOffset].m_iNext;
			return true;		
		}

		Iteration ( unsigned int iHash, SHMIntHashIndex_A * pIdx):
		m_iCur(0), m_iCurOffset(0),m_iNextOffset(0),m_puiPrePosition(0), m_iHash(iHash), m_pIdx(pIdx)
		{}

		Iteration (const Iteration & right)
		{
			m_iCur = right.m_iCur;
			m_iHash = right.m_iHash;
			m_iCurOffset = right.m_iCurOffset;
			m_iNextOffset = right.m_iNextOffset;
			m_puiPrePosition = right.m_puiPrePosition;
			m_pIdx = right.m_pIdx;
		}

        bool setValue( unsigned int iValue ){
            if( m_iCurOffset ){
                m_pIdx->m_poList[m_iCurOffset].m_iValue = iValue;
                if(0 == iValue){
                    return removeMe();
                }
                return true;
            }
            return false;
        }

        bool removeMe(){

            SHMIntList_A * m_poList = m_pIdx->m_poList;
            unsigned int * m_piUsed = m_pIdx->m_piUsed;
            unsigned int * m_piTotal = m_pIdx->m_piTotal;
            unsigned int * m_piTail = m_pIdx->m_piTail;
            unsigned int * m_piHead = m_pIdx->m_piHead;
#line 165
            if(m_puiPrePosition && (*m_puiPrePosition == m_iCurOffset) ){
                *m_puiPrePosition = m_iNextOffset;
#line 169
                m_poList[m_iCurOffset].m_lKey = 0;
                m_poList[m_iCurOffset].m_iValue = 0;

                *m_puiPrePosition = m_poList[m_iCurOffset].m_iNext;
                m_poList[m_iCurOffset].m_iNext = 0;

                if( *m_piUsed <= *m_piTotal ) 
                    m_poList[*m_piTail].m_iNext = m_iCurOffset;
                else
                    *m_piHead = m_iCurOffset;

                *m_piTail = m_iCurOffset;
                (*m_piUsed)--;
                return true;
            }
            return false;

        }
	  private:
		unsigned int m_iCur;
		unsigned int m_iHash;
		unsigned int m_iCurOffset;
		unsigned int m_iNextOffset;
		unsigned int * m_puiPrePosition;

		SHMIntHashIndex_A * m_pIdx;
	};
#line 198
  public:
    Iteration getIteration ()
	{
		return Iteration ( (*m_piHashValue)+1, this);
	}

	friend class Iteration;
#line 207
    SHMIntHashIndex_A(char *shmname);
#line 210
    SHMIntHashIndex_A(long shmkey);
#line 213
    ~SHMIntHashIndex_A();
#line 216
    void add(long key, unsigned int value);
#line 219
    bool get(long key, unsigned int *pvalue);
    bool get(char* skey, unsigned int *pvalue){
		if((!skey)&&(skey[0]!=0))
			return get(atol(skey),pvalue);
		return false;
	};

    bool revokeIdx(long key, unsigned int &value);
    void reset();  
    unsigned int malloc();
    void showDetail();
#line 234
    void create(
#line 237
        unsigned int itemnumber) ;
#line 240
    void empty();

    unsigned int getMemSize();

	int getUsedSize();

	unsigned long getMemAdress();

	time_t getLoadTime();
#line 251
    unsigned int getCount()
    {
        if (*m_piUsed)
            return (*m_piUsed)-1;

        return 0;
    };

    unsigned int getTotal()
    {
        if (*m_piTotal)
            return (*m_piTotal);

        return 0;
    };
#line 268
  private:

    void open();
#line 275
    unsigned int *m_piHashValue;
#line 278
    unsigned int *m_piTotal;
#line 281
    unsigned int *m_piUsed;
#line 284
    unsigned int *m_poHash;
#line 287
    SHMIntList_A *m_poList;

    unsigned int *m_piHead; 
    unsigned int *m_piTail; 
    unsigned int *m_piVersion;  
    unsigned int *m_piDelOver; 
};
#line 12 "/cbilling/app/petri/src/threelogapi/ThreeLogGroupBase.h"
using namespace std;
#line 44
class LogFileData
{ 
 public:
    LogFileData():m_lFileSize(0)
    {
        memset(m_sFileName,0,sizeof(m_sFileName));
        memset(m_sGroupPath,0,sizeof(m_sGroupPath));
    }
 public:
    long m_lFileSize;                
    char m_sFileName[100];           
    char m_sGroupPath[500];          
};

class LogInfoData
{ 
 public:
    LogInfoData():m_illCode(-1),m_illProId(-1),m_illAppId(-1),m_illLevelId(-1),m_illClassId(-1),
                    m_illTypeId(-1),m_iNextOffset(0),m_iThreadId(-1),m_iNetId(-1)
    {
        memset(m_sAreaCode,0,sizeof(m_sAreaCode));
        memset(m_sLogTime,0,sizeof(m_sLogTime));
        memset(m_sCodeName,0,sizeof(m_sCodeName));
        memset(m_sInfo,0,sizeof(m_sInfo));
        memset(m_sActionName,0,sizeof(m_sActionName));
		memset(m_sFlow,0,sizeof(m_sFlow));
    }
 public:
    int m_illCode;                   
    char m_sLogTime[17+1];           
    int m_illProId;                  
    int m_illEmployee;               
    int m_illLevelId;                
    int m_illClassId;                
    int m_illTypeId ;                
	int m_illAppId;                  
    int m_illActionId;               
    char m_sActionName[64]; 
    char m_sAreaCode[4+1];           
    char m_sCodeName[64];   
    int m_iThreadId;                
    int m_iNetId;					 
    char m_sFlow[8];				 

    char m_sInfo[320];          

    unsigned int m_iNextOffset;      
};

class ThreeLogGoupData
{
 public:
    ThreeLogGoupData():m_iGoupId(0),m_iSeq(0),m_iState(0)
        ,m_bPigeonhole(false),m_bCheckPoint(false),m_bPigeonholeState(0),
        m_lCurFileSize(0),m_lCurDirSize(0),m_iNext(0),m_iWritSeq(0),m_iMemSeq(0)
        ,m_lPredictFileSize(0),m_iFileCheckPercent(0),m_lFileSizeThreshold(0)
    {
    }
 public:
	int m_iGoupId;                       
	int m_iLevel ;                       
	int m_iSeq;                          
	int m_iState;                        
	int m_bPigeonholeState;              
	int m_iMemSeq;                       
	int m_iWritSeq;                      
	bool m_bPigeonhole;                  
	bool m_bCheckPoint;                  
	long m_lCurFileSize;                 

	long m_lPredictFileSize;			 

	int m_iFileCheckPercent;            
	long m_lFileSizeThreshold;          

	long m_lCurDirSize;                  
	LogFileData m_File[6];  
	unsigned int m_iNext;                
};

class ThreeLogGroupBase
{
public:
    ThreeLogGroupBase();
    ~ThreeLogGroupBase();

	long getLogGroupDataKey(int iGroupId);
	long getLogGroupIndexKey(int iGroupId);

	void initBase();

protected:
    static void bindData();
    static void bindGroupData(int GroupId);
    static void freeAll();
    static bool m_bAttached;

    static ThreeLogGoupData *m_poLogGroup;
    static SHMIntHashIndex_A *m_poLogGroupIndex;
    static SHMData<ThreeLogGoupData> *m_poLogGroupData;

    static SHMData_A<LogInfoData> *m_poInfoDataAll[6+1];
    static SHMIntHashIndex_A *m_poInfoIndexAll[6+1];

    static CSemaphore* m_poInfoDataLock;                        
    static CSemaphore* m_poDataLock;                            
    static CSemaphore* m_poIndexLock;                           
    static CSemaphore* m_poLogGroupMgrLock;					   

    static LogInfoData *m_poInfoGroup;                           
    static SHMData_A<LogInfoData> *m_poInfoData;                 
    static SHMIntHashIndex_A *m_poInfoIndex;                     

    static bool getIpcCfg() ;
private :
	 static long SHM_LOG_GROUP_DATA   ;
   static long SHM_LOG_GROUP_INDEX        ;
   static long SHM_LOG_GROUP_LOCK         ;
   static long SHM_LOG_GROUP_INDEX_LOCK   ;
   static long SHM_LOG_GROUP_INFO_LOCK ;
   static long SHM_LOG_GROUP_MGR_LOCK ;
   static long SHM_LOG_GROUP_INFO_DATA_1  ;
   static long SHM_LOG_GROUP_INFO_DATA_2  ;
   static long SHM_LOG_GROUP_INFO_DATA_3  ;
   static long SHM_LOG_GROUP_INFO_DATA_4  ;
   static long SHM_LOG_GROUP_INFO_DATA_5  ;
   static long SHM_LOG_GROUP_INFO_DATA_6  ;
   static long SHM_LOG_GROUP_INFO_INDEX_1 ;
   static long SHM_LOG_GROUP_INFO_INDEX_2 ;
   static long SHM_LOG_GROUP_INFO_INDEX_3 ;
   static long SHM_LOG_GROUP_INFO_INDEX_4 ;
   static long SHM_LOG_GROUP_INFO_INDEX_5 ;
   static long SHM_LOG_GROUP_INFO_INDEX_6 ;     
   static bool SHM_KEY_IFLOAD;
};
#line 8 "/cbilling/app/petri/libsrc/app_guard_lib/HBECodeParse.h"
using namespace std;
#line 11
const unsigned MAX_ERROR_CAUSE_LEN = 100;        
const unsigned MAX_ERROR_ADVICE_LEN = 100;       

struct EInfo
{
public:
    EInfo()
    {
        memset(m_sCause, 0x00, sizeof(m_sCause));
        memset(m_sAdvice, 0x00, sizeof(m_sAdvice));
    }

public:
    char m_sCause[MAX_ERROR_CAUSE_LEN + 1];      
    char m_sAdvice[MAX_ERROR_ADVICE_LEN + 1];    

};

typedef std::map<int, EInfo*>  EInfoMap;
class File;
class HBErrorCode
{
public:
    HBErrorCode()
    {
        m_poEFile = 0;
    }

    virtual ~HBErrorCode();
#line 47
    int init();
#line 55
    char* getCauseInfo(int iHBErrorCode);
#line 63
    char* getAdviceInfo(int iHBErrorCode);
#line 71
    EInfo* getErrorInfo(int iHBErrorCode);

private:
#line 80
    int ParseErrorFile();
#line 88
    int CompStrHead(const char *sStr);
private:
    File *m_poEFile;               
    EInfoMap m_oEInfo;  

};
#line 5 "/usr/vacpp/include/stdarg.h"
extern "C" {

}
#line 6 "/cbilling/app/petri/libsrc/lib/Date.h"
class DateDiff
{
	public:
		int days;  
		int secs;  
		int milsecs; 

		DateDiff (int iDays, int iSecs, int iMilSecs)
		: days (iDays), secs(iSecs), milsecs(iMilSecs) {}

		DateDiff ()
		: days(0), secs(0), milsecs(0) {}

		DateDiff (const DateDiff & right)
		{
			days = right.days;
			secs = right.secs;
			milsecs = right.milsecs;
		}

};
#line 29
class Date
{
  public:

    Date();
#line 36
    Date(char const *sDateStr, char const *sFormat = 0);
#line 40
    int operator- (const Date& right);

    long diffSec (Date & right);

    int diffMon (Date & right);

    int diffStrictYear (Date & right);
    int diffStrictMon (Date & right);
    int diffStrictDay (Date & right);
#line 51
    void getCurDate();
#line 54
    virtual ~Date();
#line 57
    bool operator==(const Date& right);
#line 60
    bool operator!=(const Date& right);
#line 63
    bool operator<(const Date& right);
#line 66
    bool operator<=(const Date& right);
#line 69
    bool operator>(const Date& right);
#line 72
    bool operator>=(const Date& right);
#line 75
    int getDay() {
        return m_iDay;
    }
#line 80
    void setDay(int iDay);
#line 83
    int getHour() {
        return m_iHour;
    }
#line 88
    void setHour(int iHour);
#line 91
    int getMilSec();
#line 94
    void setMilSec(int iMilSec);
#line 97
    int getMin() {
        return m_iMin;
    }
#line 102
    void setMin(int iMin);
#line 105
    int getMonth() {
        return m_iMon;
    }
#line 110
    void setMonth(int iMonth);
#line 113
    int getSec();
#line 116
    void setSec(int iSec);
#line 119
    int getWeek();
#line 122
    int getYear() {
        return m_iYear + 1600;
    }
#line 127
    void setYear(int iYear);
#line 130
    char *toString(char * sFormat = 0);

    operator char * ();

    void addDay(int iDay);
#line 137
    void addYear(int iYear);
#line 140
    void addSec(int iSec);
#line 143
    void addMilSec(int iMidSec);
#line 146
    void addMin(int iMin);
#line 149
    void addMonth(int iMonth);
#line 152
    void addHour(int iHour);
#line 155
    int getDayNumInMonth(int iMonth);
#line 158
    bool isLeapYear(int iYear = 0);
#line 161
    bool parse(char const *sDateStr, char const *sFormat = 0);
#line 164
    void parseToDay(char const *sDateStr);
#line 167
    char *getTimeString(char *sDestination, char const *sFormat = 0);

  private:

    inline void stdToInner();
#line 175
    inline void innerToStd();

    inline void stdToInnerA();
    inline void innerToStdA();
#line 181
    int m_iYear;
#line 184
    int m_iMon;
#line 187
    int m_iDay;
#line 190
    int m_iHour;
#line 193
    int m_iMin;
#line 196
    int m_iSec;
#line 199
    int m_iWeek;
#line 202
    int m_iMilSec;
#line 206
    static short m_iDaysSumOfOneYear[2][14];
    static short m_iDaysOfOneYear[2][13];
#line 212
    static int m_iYearsSumDays[401];
#line 215
    static char m_iYearsDays[400];
#line 220
    int m_iDays;
#line 223
    int m_iSeconds;

    char m_sOutBuf[32];
};
#line 23 "/cbilling/app/petri/libsrc/lib/Log.h"
class Log
{
  public:

    Log();
#line 30
    virtual ~Log();
#line 33
    static void setFileName(char *name);
#line 36
    static void log(int log_level, char *format, ...);
    static void log(int log_level, const char *format, ...);

  private:

    static int m_iLogLevel;
#line 44
    static char m_sLogFileName[256];
#line 47
    static FILE *m_pLogFile;

};
#line 14 "/cbilling/app/petri/src/threelogapi/ThreeLogGroup.h"
using namespace std;
#line 22
class ThreeLogGroup : public ThreeLogGroupBase
{
 public:
    ThreeLogGroup(bool bGreat = false);
    ~ThreeLogGroup();

    bool  init();
    bool  AddLogGroup(int GroupId);
    bool  AddLogGroupFile(int GroupId,char *pPath,bool bmml=false);

    void  LoggLog(int iLogType,char const *format, ...);
    void  bakGroupFile(int LogGroupId,char *path);
    void  CheckLogDir(char* Path);
    bool  CheckLogFile(int iGroupId);
    void  DisplayFileList(int GroupId,char *sDest = 0);

    int   GetGroupNum();
    int   GetUseGroup();
    int   GetGroupState(int GroupId,char *sRetVal = 0);
    int   GetGroupWriteMode();
    int   GetGroupFileSeq(int GroupId);
    int   GetGroupInfoUsed(int GroupId);
	int   GetGroupInfoTotal(int GroupId);

    bool  GetGroupFilePath(int GroupId);
    bool  GetGroupPigeonhole(int GroupId);
    bool  GetPigeonholeFileName(char *pFileName);
    bool  GetCurUsedInfoData(int GroupId);
    bool  GetCurUsedInfoIndex(int GroupId);
    bool  GetCurUsedInfoLock(int GroupId);
    bool  GetCurUseFileName(int GroupId,char *pFileName,char *pFilePath);
    bool  GetProNameByModule(int iParam, char * sReturn);

    long  GetGroupMaxSize();
    long  GetGroupMaxFileSize();

    char* GetGroupBakPath();

    double GetGroupSize(int GroupId);
    double GetGroupPercent(int GroupId);
    double GetGroupInfoPercent(int GroupId);

    bool  DisplayLogGroup(int GroupId,char * sDest = 0);
    bool  ClearGroupFile(int LogGroupId,char *pFileName,bool bmml=false);
    bool  ChangeLogGroup(bool bmml,int GroupId=-1);

 public:
    bool  SetLogGroupPigeonhole(bool bParam);
    bool  SetGroupBakPath(char *path);
    bool  SetGroupDefaultPath(char *path);
    bool  SetGroupMaxFileSize(int size);
	bool  RefreshGroupMaxFileSize(int size);
    bool  SetGroupMaxSize(int size);
    bool  SetGroupWriteMode(int mode);
    bool  SetCheckPointTouch(int num);
    bool  SetLogLevel(int level);
	bool  SetFileCheckPercent(int iValue);

    void  SetGroupFilePath(int GroupId,int FileSeq,char *path);
    void  InitLogGroup();
#line 84
    bool CheckParam(int iLogTypeId,int iLogDisFlag,int iLogClassId,char *sParam,LogInfoData *pInfo);
    bool GetField(int iSeq,char *sBuf,char *sParam);
    bool GetInfoFromMem(vector<string> &v_list,int iLogTypeId,int iLogDisFlag,
                 int iLogClassId=0,char *sParam = 0);
   bool GetInfoFromMem(vector<string> &v_list,
                         int iLogFlag,int iLogCond, char *sParam, char *sBeginTime = 0, char *sEndTime = 0);
#line 92
    bool  CheckInfoCallBack();
    bool  CommitInfoFile();
    bool  FileDownInfo(int GroupId, bool bPrintFlag = true);
    bool  CallBackInfo(int GroupId);
    bool  Check75CheckPoint(bool &bCheck);
	void  UpdateLogFileArchiveSeq();

	bool  RefreshLogFilePath(int iGroupID,int iFileSeq,char *sNewPath);
#line 103
    void  log(int iCodeId,int iLogLevel,int iLogClassId,int iLogTypeId,
              int iAction,const char *pExpand,const char* format,...);
    void log(int iCodeId,int iLogLevel, int iLogTypeId,const char* format,...);
#line 108
	void sgwlog(int iCodeId,int iProcId,int iThreadId,int iAppId,int iLogLevel,int iLogTypeId,
					int iNetId,const char *sFlow,const char *format,...);
#line 112
	void combineLog(LogInfoData *p, char *sDest, int iMode = 1);

	void refreshArchivePath();

    bool  GetLoggInfo(vector<LogInfoData> &v_list,int iLogFlag,int iLogCond, char *sBTime,char *sETime=0);
    bool  GetAllLoggInfo(vector<LogInfoData> &v_list);

 private:
	bool  AddInfoDataInfo(int iCodeId,int iLogProcid,int iThreadId,int iLogAppid,int iLogLevel,
							 int iLogClassId,int iLogTypeId,int iAction,int iNetId,const char *sFlow,const char *pExpand,const char *pData,ThreeLogGoupData* p);
    int  getClassID(int iLevelID);

 private:
    int  m_iMaxGroupNum;                 
    int  m_iCurUseGroupId;               
    long m_lMaxLogFileSize;              
    long m_lMaxLogDirSize;               
    char m_sBakLogGroupPath[500];        
    char m_sDefaultLogGroupPath[500];    
    char m_sCheckPointPath[500];
    SeqMgrExt* m_poSeqExt;               
    map<string,string> m_mFilePathMap;   
    int  m_iWriteMode;                   
    long m_lInfoDataSize;                
    int  m_iCheckPointTouch;             
 public:

    int m_iLogProid;
    int m_iLogAppid;
    int m_iLogLevel;
    Date m_dDT ;
    char m_ssAreaCode[4+1];

 private:
    HBErrorCode *m_pErrorCode;

};
#line 6 "/cbilling/app/petri/src/threelogapi/ThreeLogGroupMgr.h"
class ThreeLogGroupMgr : public ThreeLogGroupBase
{
 public:
    ThreeLogGroupMgr();
    ~ThreeLogGroupMgr();
 public:
    bool create();
    bool exist();
    bool remove();
    bool setGroupNum(int iNum);
    bool setGroupInfoDataCount(long lCount);

    int  GetShmDataTotalCount(int iGroupId);
    int  GetShmIndexTotalCount(int iGroupId);

    int  GetShmDataCount(int iGroupId);
    int  GetShmIndexCount(int iGroupId);
    int  GetShmIndexDataCount(int iGroupId,int iIndex);
    int  GetShmIndexDataTotal(int iGroupId);
	void showShmInfo();

	int getLogGroupNum();

	SHMData_A<LogInfoData> *getLogGroupDataAddr(int iGroupId);
	SHMIntHashIndex_A *getLogGroupIndexAddr (int iGroupId);

    bool init();
 private:    
    int m_iMaxGroup;                     
    long m_lInfoDataCount;               
};
#line 29 "/cbilling/app/petri/src/app_init/SysParamDefine.h"
using namespace std;

typedef enum { OP_NEW=1,OP_FIX,OP_DEL} OP_FLAG;
typedef struct
{
     char sSectionName[64];
     char sKeyName[512];
     char sKeyValue[3][512];
    char sEffDate[16];
     OP_FLAG flag;
}stIniCompKey;
typedef	struct _SYS_PARAM_INFO_
{
	char sSectionName[32];
	char sParamName[32];				 
	char sParamValue[32];					 
	char sParamOrValue[32];			 
	char sDate[16];								 
}SysParamInfo;

class SysParamHis
{
public:
	SysParamHis();
	SysParamHis(const SysParamHis& param);
	SysParamHis& operator = (const SysParamHis& param);
	char sSectionName[64];
	char sParamName[64];				 
	char sParamValue[64];					 
	char sParamOrValue[64];			 
	char sDate[16];								 
};
	bool splitParamInfo(string& strContent,string& strSection,
					string& strParam,string& strValue);
void TransIniKeyToSysParamHis(SysParamHis& oSysParamHis,
							  stIniCompKey& oIniCompKey);

void badalloc(bad_alloc &ba);
#line 13 "/usr/vacpp/include/stack"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 40
#pragma object_model(compat)
#line 45
  #pragma namemangling(v7)
#line 13 "/usr/vacpp/include/deque"
#pragma info(none)

#  pragma report(level, E)

#pragma info(restore)
#line 40
#pragma object_model(compat)
#line 45
  #pragma namemangling(v7)
#line 70
namespace std {
#line 76
template<class _Ty, class _A>
        class _Deque_map {
protected:
        _Deque_map(_A _Al)
                : _Almap(_Al) {}
        typedef typename _A::template
                rebind<_Ty>::other::pointer _Tptr;
        typename _A::template rebind<_Tptr>::other _Almap;
        };
#line 87
template<class _Ty, class _A>
        class _Deque_val : public _Deque_map<_Ty, _A> {
protected:
        _Deque_val(_A _Al = _A())
                : _Deque_map<_Ty, _A>(_Al), _Alval(_Al) {}
        typedef typename _A::template
                rebind<_Ty>::other _Alty;
        _Alty _Alval;
        };
#line 98
template<class _Ty, class _Ax = allocator<_Ty> >
        class deque
                : public _Deque_val<_Ty, _Ax> {
public:
        typedef deque<_Ty, _Ax> _Myt;
        typedef _Deque_val<_Ty, _Ax> _Mybase;
        typedef typename _Mybase::_Alty _A;
        typedef _A allocator_type;
        typedef typename _A::size_type size_type;
        typedef typename _A::difference_type _Dift;
        typedef _Dift difference_type;
        typedef typename _A::pointer _Tptr;
        typedef typename _A::const_pointer _Ctptr;
        typedef _Tptr pointer;
        typedef _Ctptr const_pointer;
        typedef typename _A::template rebind<_Tptr>::other::pointer _Mapptr;
        typedef typename _A::reference _Reft;
        typedef _Tptr pointer;
        typedef _Ctptr const_pointer;
        typedef _Reft reference;
        typedef typename _A::const_reference const_reference;
        typedef typename _A::value_type value_type;

        class const_iterator;
        class iterator : public _Ranit<_Ty, _Dift, _Tptr, _Reft> {
        public:
                typedef _Ranit<_Ty, _Dift, _Tptr, _Reft> _Mybase;
                typedef typename _Mybase::iterator_category
                        iterator_category;
                typedef typename _Mybase::value_type value_type;
                typedef typename _Mybase::difference_type
                        difference_type;
                typedef typename _Mybase::pointer pointer;
                typedef typename _Mybase::reference reference;
                friend class deque<_Ty, _A>;
                friend class const_iterator;
                iterator()
                        : _First(0), _Last(0), _Next(0), _Map(0) {}
                iterator(_Tptr _P, _Mapptr _M)
                        : _First(*_M), _Last(*_M + (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty))),
                                _Next(_P), _Map(_M) {}
                reference operator*() const
                        {return (*_Next); }
                _Tptr operator->() const
                        {return (&**this); }
                iterator& operator++()
                        {if (_Next != _Last && ++_Next == _Last
                                && _Map[1] != 0)
                                {_First = *++_Map;
                                _Last = _First + (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty));
                                _Next = _First; }
                        return (*this); }
                iterator operator++(int)
                        {iterator _Tmp = *this;
                        ++*this;
                        return (_Tmp); }
                iterator& operator--()
                        {if (_Next != _First)
                                --_Next;
                        else if (_Map[-1] != 0)
                                {_First = *--_Map;
                                _Last = _First + (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty));
                                _Next = _Last - 1; }
                        return (*this); }
                iterator operator--(int)
                        {iterator _Tmp = *this;
                        --*this;
                        return (_Tmp); }
                iterator& operator+=(difference_type _N)
                        {_Add(_N);
                        return (*this); }
                iterator& operator-=(difference_type _N)
                        {return (*this += -_N); }
                iterator operator+(difference_type _N) const
                        {iterator _Tmp = *this;
                        return (_Tmp += _N); }
                iterator operator-(difference_type _N) const
                        {iterator _Tmp = *this;
                        return (_Tmp -= _N); }
                difference_type operator-(const iterator& _X) const
                        {return (_Map == _X._Map ? _Next - _X._Next
                                : (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty)) * (_Map - _X._Map - 1)
                                + (_Next - _First) + (_X._Last - _X._Next)); }
                difference_type operator-(const const_iterator& _X) const
                        {return (_Map == _X._Map ? _Next - _X._Next
                                : (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty)) * (_Map - _X._Map - 1)
                                + (_Next - _First) + (_X._Last - _X._Next)); }
                reference operator[](difference_type _N) const
                        {return (*(*this + _N)); }
                bool operator==(const iterator& _X) const
                        {return (_Next == _X._Next); }
                bool operator==(const const_iterator& _X) const
                        {return (_Next == _X._Next); }
                bool operator!=(const iterator& _X) const
                        {return (!(*this == _X)); }
                bool operator!=(const const_iterator& _X) const
                        {return (!(*this == _X)); }
                bool operator<(const iterator& _X) const
                        {return (_Map < _X._Map
                                || _Map == _X._Map && _Next < _X._Next); }
                bool operator<(const const_iterator& _X) const
                        {return (_Map < _X._Map
                                || _Map == _X._Map && _Next < _X._Next); }
                bool operator<=(const iterator& _X) const
                        {return (!(_X < *this)); }
                bool operator<=(const const_iterator& _X) const
                        {return (!(_X < *this)); }
                bool operator>(const iterator& _X) const
                        {return (_X < *this); }
                bool operator>(const const_iterator& _X) const
                        {return (_X < *this); }
                bool operator>=(const iterator& _X) const
                        {return (!(*this < _X)); }
                bool operator>=(const const_iterator& _X) const
                        {return (!(*this < _X)); }
        protected:
                void _Add(difference_type _N);
        protected:
                _Tptr _First, _Last, _Next;
                _Mapptr _Map;
                };

        class const_iterator
                : public _Ranit<_Ty, _Dift, _Ctptr, const_reference> {
        public:
                typedef _Ranit<_Ty, _Dift, _Ctptr, const_reference>
                        _Mybase;
                typedef typename _Mybase::iterator_category
                        iterator_category;
                typedef typename _Mybase::value_type value_type;
                typedef typename _Mybase::difference_type
                        difference_type;
                typedef typename _Mybase::pointer pointer;
                typedef typename _Mybase::reference reference;
                friend class deque<_Ty, _A>;
                friend class iterator;
                const_iterator()
                        : _First(0), _Last(0), _Next(0), _Map(0) {}
                const_iterator(_Tptr _P, _Mapptr _M)
                        : _First(*_M), _Last(*_M + (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty))),
                                _Next(_P), _Map(_M) {}
                const_iterator(const iterator& _X)
                        : _First(_X._First), _Last(_X._Last),
                                _Next(_X._Next), _Map(_X._Map) {}
                const_reference operator*() const
                        {return (*_Next); }
                _Ctptr operator->() const
                        {return (&**this); }
                const_iterator& operator++()
                        {if (_Next != _Last && ++_Next == _Last
                                && _Map[1] != 0)
                                {_First = *++_Map;
                                _Last = _First + (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty));
                                _Next = _First; }
                        return (*this); }
                const_iterator operator++(int)
                        {const_iterator _Tmp = *this;
                        ++*this;
                        return (_Tmp); }
                const_iterator& operator--()
                        {if (_Next != _First)
                                --_Next;
                        else if (_Map[-1] != 0)
                                {_First = *--_Map;
                                _Last = _First + (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty));
                                _Next = _Last - 1; }
                        return (*this); }
                const_iterator operator--(int)
                        {const_iterator _Tmp = *this;
                        --*this;
                        return (_Tmp); }
                const_iterator& operator+=(difference_type _N)
                        {_Add(_N);
                        return (*this); }
                const_iterator& operator-=(difference_type _N)
                        {return (*this += -_N); }
                const_iterator operator+(difference_type _N) const
                        {const_iterator _Tmp = *this;
                        return (_Tmp += _N); }
                const_iterator operator-(difference_type _N) const
                        {const_iterator _Tmp = *this;
                        return (_Tmp -= _N); }
                difference_type operator-(
                        const const_iterator& _X) const
                        {return (_Map == _X._Map ? _Next - _X._Next
                                : (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty)) * (_Map - _X._Map - 1)
                                + (_Next - _First) + (_X._Last - _X._Next)); }
                const_reference operator[](difference_type _N) const
                        {return (*(*this + _N)); }
                bool operator==(const const_iterator& _X) const
                        {return (_Next == _X._Next); }
                bool operator!=(const const_iterator& _X) const
                        {return (!(*this == _X)); }
                bool operator<(const const_iterator& _X) const
                        {return (_Map < _X._Map
                                || _Map == _X._Map && _Next < _X._Next); }
                bool operator<=(const const_iterator& _X) const
                        {return (!(_X < *this)); }
                bool operator>(const const_iterator& _X) const
                        {return (_X < *this); }
                bool operator>=(const const_iterator& _X) const
                        {return (!(*this < _X)); }
        protected:
                void _Add(difference_type _N);
        protected:
                _Tptr _First, _Last, _Next;
                _Mapptr _Map;
                };
        typedef typename std::reverse_iterator<iterator>
                reverse_iterator;
        typedef typename std::reverse_iterator<const_iterator>
                const_reverse_iterator;

        deque()
                : _Mybase(), _First(), _Last(),
                        _Map(0), _Mapsize(0), _Size(0)
                {}
        explicit deque(const _A& _Al)
                : _Mybase(_Al), _First(), _Last(),
                        _Map(0), _Mapsize(0), _Size(0)
                {}
        explicit deque(size_type _N)
                : _Mybase(), _First(), _Last(),
                        _Map(0), _Mapsize(0), _Size(0)
                {insert(begin(), _N, _Ty()); }
        deque(size_type _N, const _Ty& _V)
                : _Mybase(), _First(), _Last(),
                        _Map(0), _Mapsize(0), _Size(0)
                {insert(begin(), _N, _V); }
        deque(size_type _N, const _Ty& _V, const _A& _Al)
                : _Mybase(_Al), _First(), _Last(),
                        _Map(0), _Mapsize(0), _Size(0)
                {insert(begin(), _N, _V); }
        deque(const _Myt& _X)
                : _Mybase(_X._Alval), _First(), _Last(),
                        _Map(0), _Mapsize(0), _Size(0)
                {insert(begin(), _X.begin(), _X.end()); }
        template<class _It>
                deque(_It _F, _It _L)
                : _Mybase(), _First(), _Last(),
                        _Map(0), _Mapsize(0), _Size(0)
                {_Construct(_F, _L, _Iter_cat(_F)); }
        template<class _It>
                deque(_It _F, _It _L, const _A& _Al)
                : _Mybase(_Al), _First(), _Last(),
                        _Map(0), _Mapsize(0), _Size(0)
                {_Construct(_F, _L, _Iter_cat(_F)); }
        template<class _It>
                void _Construct(_It _F, _It _L, _Int_iterator_tag)
                {insert(begin(), (size_type)_F, (_Ty)_L); }
        template<class _It>
                void _Construct(_It _F, _It _L, input_iterator_tag)
                {insert(begin(), _F, _L); }
        ~deque()
                {while (!empty())
                        pop_front(); }
        _Myt& operator=(const _Myt& _X)
                {if (this != &_X)
                        {iterator _S;
                        if (_X.size() <= size())
                                {_S = copy(_X.begin(), _X.end(), begin());
                                erase(_S, end()); }
                        else
                                {const_iterator _Sx = _X.begin() + size();
                                _S = copy(_X.begin(), _Sx, begin());
                                insert(end(), _Sx, _X.end()); }}
                return (*this); }
        iterator begin()
                {return (_First); }
        const_iterator begin() const
                {return ((const_iterator)_First); }
        iterator end()
                {return (_Last); }
        const_iterator end() const
                {return ((const_iterator)_Last); }
        reverse_iterator rbegin()
                {return (reverse_iterator(end())); }
        const_reverse_iterator rbegin() const
                {return (const_reverse_iterator(end())); }
        reverse_iterator rend()
                {return (reverse_iterator(begin())); }
        const_reverse_iterator rend() const
                {return (const_reverse_iterator(begin())); }
        void resize(size_type _N)
                {resize(_N, _Ty()); }
        void resize(size_type _N, _Ty _X)
                {if (size() < _N)
                        insert(end(), _N - size(), _X);
                else if (_N < size())
                        erase(begin() + _N, end()); }
        size_type size() const
                {return (_Size); }
        size_type max_size() const
                {return (_Mybase::_Alval.max_size()); }
        bool empty() const
                {return (size() == 0); }
        allocator_type get_allocator() const
                {return (_Mybase::_Alval); }
        const_reference at(size_type _P) const
                {if (size() <= _P)
                        _Xran();
                return (*(begin() + _P)); }
        reference at(size_type _P)
                {if (size() <= _P)
                        _Xran();
                return (*(begin() + _P)); }
        const_reference operator[](size_type _P) const
                {return (*(begin() + _P)); }
        reference operator[](size_type _P)
                {return (*(begin() + _P)); }
        reference front()
                {return (*begin()); }
        const_reference front() const
                {return (*begin()); }
        reference back()
                {return (*(end() - 1)); }
        const_reference back() const
                {return (*(end() - 1)); }
        void push_front(const _Ty& _X);
        void pop_front()
                {if (!empty())
                        {_Mybase::_Alval.destroy(_First._Next);
                        _Popfront(); }}
        void push_back(const _Ty& _X);
        void pop_back()
                {if (!empty())
                        {iterator _P = _Last - 1;
                        _Mybase::_Alval.destroy(_P._Next);
                        _Popback(); }}
        template<class _It>
                void assign(_It _F, _It _L)
                {_Assign(_F, _L, _Iter_cat(_F)); }
        template<class _It>
                void _Assign(_It _F, _It _L, _Int_iterator_tag)
                {assign((size_type)_F, (_Ty)_L); }
        template<class _It>
                void _Assign(_It _F, _It _L, input_iterator_tag)
                {erase(begin(), end());
                insert(begin(), _F, _L); }
        void assign(size_type _N, const _Ty& _X)
                {_Ty _Tx = _X;
                erase(begin(), end());
                insert(begin(), _N, _Tx); }
        iterator insert(iterator _P, const _Ty& _X);
        void insert(iterator _P, size_type _M, const _Ty& _X);
        template<class _It>
                void insert(iterator _P, _It _F, _It _L)
                {_Insert(_P, _F, _L, _Iter_cat(_F)); }
        template<class _It>
                void _Insert(iterator _P, _It _F, _It _L,
                        _Int_iterator_tag)
                {insert(_P, (size_type)_F, (_Ty)_L); }
        template<class _It>
                void _Insert(iterator _P, _It _F, _It _L,
                        input_iterator_tag)
                {size_type _Off = _P - begin();
                for (; _F != _L; ++_F, ++_Off)
                        insert(begin() + _Off, *_F); }
        template<class _It>
                void _Insert(iterator _P, _It _F, _It _L,
                        bidirectional_iterator_tag);
        iterator erase(iterator _P)
                {return (erase(_P, _P + 1)); }
        iterator erase(iterator _F, iterator _L)
                {size_type _N = _L - _F;
                size_type _M = _F - begin();
                if (_M < (size_type)(end() - _L))
                        {copy_backward(begin(), _F, _L);
                        for (; 0 < _N; --_N)
                                pop_front(); }
                else
                        {copy(_L, end(), _F);
                        for (; 0 < _N; --_N)
                                pop_back(); }
                return (_M == 0 ? begin() : begin() + _M); }
        void clear()
                {while(!empty())
                        pop_back(); }
        void swap(_Myt& _X)
                {if (_Mybase::_Alval == _X._Alval)
                        {std::swap(_First, _X._First);
                        std::swap(_Last, _X._Last);
                        std::swap(_Map, _X._Map);
                        std::swap(_Mapsize, _X._Mapsize);
                        std::swap(_Size, _X._Size); }
                else
                        {_Myt _Ts = *this; *this = _X, _X = _Ts; }}
protected:
        void _Buyback();
        void _Buyfront();
        void _Freelast()
                {
                _Freeptr(_First._Map);
                _First = iterator();
                _Last = _First;
                _Freemap(); }
        void _Popfront()
                {_Mapptr _M = _First._Map;
                ++_First;
                --_Size;
                if (empty())
                        _Freelast();
                else if (_M != _First._Map)
                        {_Freeptr(_M);
                        _Setptr(_M, 0); }}
        void _Popback()
                {_Mapptr _M = _Last._Map;
                --_Last;
                --_Size;
                if (empty())
                        _Freelast();
                else if (_M != _Last._Map)
                        {_Freeptr(_M);
                        _Setptr(_M, 0); }}
        void _Xlen() const
                {throw length_error(""); }
        void _Xran() const
                {throw out_of_range(""); }
        void _Freemap()
                {_Mybase::_Almap.deallocate(_Map, _Mapsize); }
        void _Freeptr(_Mapptr _M)
                {_Mybase::_Alval.deallocate(*_M, (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty)));
                _Mybase::_Almap.destroy(_M); }
        void _Getmap(_Tptr _P, int _Off)
                {_Mapsize = 8;
                _Map = _Mybase::_Almap.allocate(_Mapsize, (void *)0);
                size_type _N = _Mapsize / 2;
                _Setptr(_Map + _N - 1, 0);
                _Setptr(_Map + _N, _P);
                _Setptr(_Map + _N + 1, 0);
                _First = iterator(_P + ((4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty)) / 2 + _Off),
                        _Map + _N);
                _Last = _First; }
        _Mapptr _Growmap(size_type _Oldsize);
        void _Setptr(_Mapptr _M, _Tptr _P)
                {_Mybase::_Almap.construct(_M, _P); }
        iterator _First, _Last;
        _Mapptr _Map;
        size_type _Mapsize, _Size;
        };
#line 540
template<class _Ty, class _A> inline
        void swap(deque<_Ty, _A>& _X, deque<_Ty, _A>& _Y)
        {_X.swap(_Y); }

template<class _Ty, class _A> inline
        bool operator==(const deque<_Ty, _A>& _X,
                const deque<_Ty, _A>& _Y)
        {return (_X.size() == _Y.size()
                && equal(_X.begin(), _X.end(), _Y.begin())); }
template<class _Ty, class _A> inline
        bool operator!=(const deque<_Ty, _A>& _X,
                const deque<_Ty, _A>& _Y)
        {return (!(_X == _Y)); }
template<class _Ty, class _A> inline
        bool operator<(const deque<_Ty, _A>& _X,
                const deque<_Ty, _A>& _Y)
        {return (lexicographical_compare(_X.begin(), _X.end(),
                _Y.begin(), _Y.end())); }
template<class _Ty, class _A> inline
        bool operator<=(const deque<_Ty, _A>& _X,
                const deque<_Ty, _A>& _Y)
        {return (!(_Y < _X)); }
template<class _Ty, class _A> inline
        bool operator>(const deque<_Ty, _A>& _X,
                const deque<_Ty, _A>& _Y)
        {return (_Y < _X); }
template<class _Ty, class _A> inline
        bool operator>=(const deque<_Ty, _A>& _X,
                const deque<_Ty, _A>& _Y)
        {return (!(_X < _Y)); }
};

#pragma implementation("deque.t")
#line 31 "/usr/vacpp/include/deque.t"
namespace std {

template<class _Ty, class _Ax>
inline
void deque<_Ty, _Ax>::iterator::_Add(difference_type _N)
        {difference_type _Off = _N + _Next - _First;
        difference_type _Moff = (0 <= _Off)
                ? _Off / (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty))
                : 0 - (((4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty)) - 1 - _Off) / (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty)));
        if (_Moff == 0)
                _Next += _N;
        else
                {_Map += _Moff;
                if (_Map[0] != 0)
                        {_First = _Map[0];
                        _Next = _First
                        + (_Off - _Moff * (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty))); }
                else
                        {if (_Moff < 0)
                                {_First = _Map[1];
                                _Next = _First; }
                        else
                                {_First = _Map[-1];
                                _Next = _First + (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty)); }
                        _Map -= ((_Off % (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty))) ? 0 : 1); }
                _Last = _First + (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty)); }}
#line 59
template<class _Ty, class _Ax>
inline
void deque<_Ty, _Ax>::const_iterator::_Add(difference_type _N)
        {difference_type _Off = _N + _Next - _First;
        difference_type _Moff = (0 <= _Off)
                ? _Off / (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty))
                : 0 - (((4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty)) - 1 - _Off) / (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty)));
        if (_Moff == 0)
                _Next += _N;
        else
                {_Map += _Moff;
                if (_Map[0] != 0)
                        {_First = _Map[0];
                        _Next = _First
                                + (_Off - _Moff * (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty))); }
                else
                        {if (_Moff < 0)
                                {_First = _Map[1];
                                _Next = _First; }
                        else
                                {_First = _Map[-1];
                                _Next = _First + (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty)); }
                        _Map -= ((_Off % (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty))) ? 0 : 1); }
                _Last = _First + (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty)); }}
#line 85
template<class _Ty, class _Ax>
inline
void deque<_Ty, _Ax>::push_front(const _Ty& _X)
        {if (max_size() - 1 <= _Size)
                _Xlen();
        if (empty() || _First._Next == _First._First)
                _Buyfront();
        --_First;
        try {
        _Mybase::_Alval.construct(_First._Next, _X);
        } catch (...) {
        _Popfront();
        throw;
        }
        ++_Size; }

template<class _Ty, class _Ax>
inline
void deque<_Ty, _Ax>::push_back(const _Ty& _X)
        {if (max_size() - 1 <= _Size)
                _Xlen();
        if (empty() || _Last._Next == _Last._Last)
                _Buyback();
        ++_Last;
        try {
        iterator _P = _Last - 1;
        _Mybase::_Alval.construct(_P._Next, _X);
        } catch (...) {
        _Popback();
        throw;
        }
        ++_Size; }

template<class _Ty, class _Ax>
inline
typename deque<_Ty, _Ax>::iterator deque<_Ty, _Ax>::insert(
        iterator _P, const _Ty& _X)
        {if (_P == begin())
                {push_front(_X);
                return (begin()); }
        else if (_P == end())
                {push_back(_X);
                return (end() - 1); }
        else
                {iterator _S;
                size_type _Off = _P - begin();
                _Ty _Tx = _X;
                if (_Off < size() / 2)
                        {push_front(front());
                        _S = begin() + _Off;
                        copy(begin() + 2, _S + 1, begin() + 1); }
                else
                        {push_back(back());
                        _S = begin() + _Off;
                        copy_backward(_S, end() - 2, end() - 1); }
                *_S = _Tx;
                return (_S); }}

template<class _Ty, class _Ax>
inline
void deque<_Ty, _Ax>::insert(iterator _P, size_type _M, const _Ty& _X)
        {iterator _S;
        size_type _I;
        size_type _Off = _P - begin();
        size_type _Rem = _Size - _Off;
        if (_Off < _Rem)
                if (_Off < _M)
                        {for (_I = _M - _Off; 0 < _I; --_I)
                                push_front(_X);
                        for (_I = _Off; 0 < _I; --_I)
                                push_front(begin()[_M - 1]);
                        _S = begin() + _M;
                        fill(_S, _S + _Off, _X); }
                else
                        {for (_I = _M; 0 < _I; --_I)
                                push_front(begin()[_M - 1]);
                        _S = begin() + _M;
                        _Ty _Tx = _X;
                        copy(_S + _M, _S + _Off, _S);
                        fill(begin() + _Off, _S + _Off, _Tx); }
        else
                if (_Rem < _M)
                        {for (_I = _M - _Rem; 0 < _I; --_I)
                                push_back(_X);
                        for (_I = 0; _I < _Rem; ++_I)
                                push_back(begin()[_Off + _I]);
                        _S = begin() + _Off;
                        fill(_S, _S + _Rem, _X); }
                else
                        {for (_I = 0; _I < _M; ++_I)
                                push_back(begin()[_Off + _Rem - _M + _I]);
                        _S = begin() + _Off;
                        _Ty _Tx = _X;
                        copy_backward(_S, _S + _Rem - _M, _S + _Rem);
                        fill(_S, _S + _M, _Tx); }}

template<class _Ty, class _Ax>  template<class _It>
inline
void deque<_Ty, _Ax>::_Insert(iterator _P, _It _F, _It _L,
        bidirectional_iterator_tag)
        {size_type _M = 0;
        _Distance(_F, _L, _M);
        size_type _I;
        size_type _Off = _P - begin();
        size_type _Rem = _Size - _Off;
        if (_Off < _Rem)
                if (_Off < _M)
                        {_It _Qx = _F;
                        advance(_Qx, _M - _Off);
                        for (_It _Q = _Qx; _F != _Q; )
                                push_front(*--_Q);
                        for (_I = _Off; 0 < _I; --_I)
                                push_front(begin()[_M - 1]);
                        copy(_Qx, _L, begin() + _M); }
                else
                        {for (_I = _M; 0 < _I; --_I)
                                push_front(begin()[_M - 1]);
                        iterator _S = begin() + _M;
                        copy(_S + _M, _S + _Off, _S);
                        copy(_F, _L, begin() + _Off); }
        else
                if (_Rem < _M)
                        {_It _Qx = _F;
                        advance(_Qx, _Rem);
                        for (_It _Q = _Qx; _Q != _L; ++_Q)
                                push_back(*_Q);
                        for (_I = 0; _I < _Rem; ++_I)
                                push_back(begin()[_Off + _I]);
                        copy(_F, _Qx, begin() + _Off); }
                else
                        {for (_I = 0; _I < _M; ++_I)
                                push_back(begin()[_Off + _Rem - _M + _I]);
                        iterator _S = begin() + _Off;
                        copy_backward(_S, _S + _Rem - _M, _S + _Rem);
                        copy(_F, _L, _S); }}

template<class _Ty, class _Ax>
inline
void deque<_Ty, _Ax>::_Buyback()
        {_Tptr _P = _Mybase::_Alval.allocate((4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty)), (void *)0);
        try {
        if (empty())
                _Getmap(_P, 0);
        else if (_Last._Map < _Map + (_Mapsize - 2))
                {_Setptr(++_Last._Map, _P);
                _Setptr(_Last._Map + 1, 0);
                _Last = iterator(_P, _Last._Map); }
        else
                {difference_type _I = _Last._Map - _First._Map + 1;
                _Mapptr _M = _Growmap(_I);
                _Setptr(_M + _I, _P);
                _Setptr(_M + _I + 1, 0);
                _First = iterator(_First._Next, _M);
                _Last = iterator(_P, _M + _I); }
        } catch (...) {
        _Mybase::_Alval.deallocate(_P, (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty)));
        throw;
        } }

template<class _Ty, class _Ax>
inline
void deque<_Ty, _Ax>::_Buyfront()
        {_Tptr _P = _Mybase::_Alval.allocate((4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty)), (void *)0);
        try {
        if (empty())
                _Getmap(_P, 1);
        else if (_Map + 1 < _First._Map)
                {_Setptr(--_First._Map - 1, 0);
                _Setptr(_First._Map, _P);
                _First = iterator(_P + (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty)), _First._Map); }
        else
                {difference_type _I = _Last._Map - _First._Map + 1;
                _Mapptr _M = _Growmap(_I);
                _Setptr(--_M - 1, 0);
                _Setptr(_M, _P);
                _First = iterator(_P + (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty)), _M);
                _Last = iterator(_Last._Next, _M + _I); }
        } catch (...) {
        _Mybase::_Alval.deallocate(_P, (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty)));
        throw;
        } }

template<class _Ty, class _Ax>
inline
typename deque<_Ty, _Ax>::_Mapptr deque<_Ty, _Ax>::_Growmap(size_type _Oldsize)
        {size_type _Newsize = 2 * _Oldsize + 2;
        if (_Newsize < 8)
                _Newsize = 8;
        _Mapptr _Mo, _Mt, _Mx;
        if (_Newsize <= _Mapsize && _Mapsize / 4 < _Newsize)
                {_Mx = _Map + _Mapsize / 4;
                if (_Mx < _First._Map - 1)
                        for (_Mo = _First._Map - 1, _Mt = _Mx;
                                _Mo != _Last._Map + 2; ++_Mo, ++_Mt)
                                {_Mybase::_Almap.construct(_Mt, *_Mo);
                                _Mybase::_Almap.destroy(_Mo); }
                else
                        for (_Mo = _Last._Map + 2,
                                _Mt = _Mx + _Oldsize + 2;
                                _Mo != _First._Map - 1; )
                                {_Mybase::_Almap.construct(--_Mt, *--_Mo);
                                _Mybase::_Almap.destroy(_Mo); }}
        else
                {_Mapptr _M = _Mybase::_Almap.allocate(_Newsize,
                              (void *)0);
                _Mx = _M + _Newsize / 4;
                for (_Mo = _First._Map - 1, _Mt = _Mx;
                        _Mo != _Last._Map + 2; ++_Mo, ++_Mt)
                        {_Mybase::_Almap.construct(_Mt, *_Mo);
                        _Mybase::_Almap.destroy(_Mo); }
                _Mybase::_Almap.deallocate(_Map, _Mapsize);
                _Map = _M;
                _Mapsize = _Newsize; }
        return (_Mx + 1); }

};
#line 577 "/usr/vacpp/include/deque"
#pragma namemangling()

#pragma object_model(pop)
#line 586
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 69 "/usr/vacpp/include/stack"
namespace std {

template<class _Ty, class _C = deque<_Ty> >
        class stack {
public:
        typedef _C container_type;
        typedef typename _C::value_type value_type;
        typedef typename _C::size_type size_type;
        explicit stack(const _C& _Cont)
                : c(_Cont) {}
        stack()
                : c() {}
        bool empty() const
                {return (c.empty()); }
        size_type size() const
                {return (c.size()); }
        value_type& top()
                {return (c.back()); }
        const value_type& top() const
                {return (c.back()); }
        void push(const value_type& _X)
                {c.push_back(_X); }
        void pop()
                {c.pop_back(); }
        bool _Eq(const stack<_Ty, _C>& _X) const
                {return (c == _X.c); }
        bool _Lt(const stack<_Ty, _C>& _X) const
                {return (c < _X.c); }
protected:
        _C c;
        };

template<class _Ty, class _C> inline
        bool operator==(const stack<_Ty, _C>& _X,
                const stack<_Ty, _C>& _Y)
        {return (_X._Eq(_Y)); }
template<class _Ty, class _C> inline
        bool operator!=(const stack<_Ty, _C>& _X,
                const stack<_Ty, _C>& _Y)
        {return (!(_X == _Y)); }
template<class _Ty, class _C> inline
        bool operator<(const stack<_Ty, _C>& _X,
                const stack<_Ty, _C>& _Y)
        {return (_X._Lt(_Y)); }
template<class _Ty, class _C> inline
        bool operator>(const stack<_Ty, _C>& _X,
                const stack<_Ty, _C>& _Y)
        {return (_Y < _X); }
template<class _Ty, class _C> inline
        bool operator<=(const stack<_Ty, _C>& _X,
                const stack<_Ty, _C>& _Y)
        {return (!(_Y < _X)); }
template<class _Ty, class _C> inline
        bool operator>=(const stack<_Ty, _C>& _X,
                const stack<_Ty, _C>& _Y)
        {return (!(_X < _Y)); }
};

#pragma namemangling()

#pragma object_model(pop)
#line 136
#pragma info(none)

#  pragma report(pop)

#pragma info(restore)
#line 8 "/usr/vacpp/include/assert.h"
    extern "C" void __assert(const char *, const char *, int);
extern "C" {
#line 52 "/usr/include/pwd.h"
extern "C" {
#line 65
struct passwd {
	char	*pw_name;
	char	*pw_passwd;
	uid_t	pw_uid;
	gid_t	pw_gid;
	char    *pw_gecos;
	char	*pw_dir;
	char	*pw_shell;
};
#line 108
	extern struct passwd	*getpwuid(uid_t);
	extern struct passwd	*getpwnam(const char *);

	extern void		endpwent(void);
	extern struct passwd	*getpwent(void);
	extern void		setpwent(void);
#line 116
	static int getpwuid_r(uid_t __aptr, struct passwd *__bptr, char *__cptr,
						int __dint, struct passwd **__eptr)
	{
		extern int _posix_getpwuid_r(uid_t, struct passwd *, char *,
								int, struct passwd **);
		return(_posix_getpwuid_r(__aptr, __bptr, __cptr, __dint, __eptr));
	}
	static int getpwnam_r(const char *__fptr, struct passwd *__gptr,
					  char *__hptr, int __iint, struct passwd **__jptr)
	{
		extern int _posix_getpwnam_r(const char *, struct passwd *, char *,
						  int, struct passwd **);
		return(_posix_getpwnam_r(__fptr, __gptr, __hptr, __iint, __jptr));
	}
#line 140
	extern void	endpwent_r(FILE **);
	extern int	getpwent_r(struct passwd *, char *, int, FILE **);
	extern int	setpwent_r(FILE **);
#line 160
	extern int		putpwent(struct passwd *, FILE *);
	extern struct passwd *	fgetpwent(FILE *);

	extern int	fgetpwent_r(FILE *, struct passwd *, char *, int);
#line 173
}
}
#line 15 "/cbilling/app/petri/src/app_init/WriteIni.h"
class WriteIni{
private:

public:
	WriteIni();
	~WriteIni();
	char *trim( char *str );
	char *TruncStr( char *sp , char *sDst , int len);
	int SectionAndIdentCheck(char  const *IniFile,char const *Section,char const *Ident,
		int &length1,int &length2,int &length3,int &length4);
	int WriteIniString(char const *IniFile,char const *Section, char const *Ident, const char *sItem);
	int DelIniBySection(char const *IniFile,char const *Section);
	int DelIniByIdent(char const*IniFile,char const *Section,char const *Ident);
};
#line 4 "/cbilling/app/petri/libsrc/lib/CRWLock.h"
class CRWLock
{
	public:
		CRWLock(const char * sem_name,bool bLock=false);
		CRWLock(int iSemKey,bool bLock=false);	
		~CRWLock();
		bool readLock(void);
		bool readUnLock(void);
		bool writeLock(void);
		bool writeUnLock(void);
	private:
		CRWLock(const CRWLock&);
		CRWLock& operator=(const CRWLock&);
		CSemaphore m_Lock;
		bool b;
		bool m_bRW; 
};
#line 9 "/cbilling/app/petri/libsrc/framework/GlobalTools.h"
class GlobalTools
{
public:
	static bool CheckDateString(const char* sDate);
	static char* upperLowerConvert( char* srcStr , const int flag );
};
#line 21 "/cbilling/app/petri/src/app_init/IniFileMgr.h"
using namespace std;
class CDBAccessIF;
class SysParamHis;
class CIniSection{
	public :
		CIniSection()
		{
			memset(sSectionName,0,sizeof(sSectionName));
			memset(sKeyName,0,sizeof(sKeyName));
			memset(sKeyValue,0,sizeof(sKeyValue));
			memset(sEffDate,0,sizeof(sEffDate));
		};
	char sSectionName[64];
	char sKeyName[512];
	char sKeyValue[3][512];
	char sEffDate[16];
};
#line 40
class BaseRuleMgr;
class CIniFileMgr
{
public:
	CIniFileMgr(void);
	~CIniFileMgr(void);

	bool ClearShm(void);
#line 50
	bool LoadIniFromFile(const char* cpsFileName);

	bool ReLoadIniFromFile(void);

	bool SaveToFile(const char* cpsFileName);
#line 57
	void Clear(void);
	bool IsRestart(const char* pSectionName,const char* pParamName);
	bool Init(const char* pFileName);
	bool reLoad(void);
#line 64
	bool GetIniKey(const char* sSectionName,const char* sParamName,
		CIniSection& oIniCompKey);

	bool GetIniKey(const char* sSectionName,const char* sParamName,
		stIniCompKey& oIniCompKey);
#line 71
	bool CopyToShm(const char * cpsKey,unsigned int iShmSize=0);
	bool CopyToShm(const char * cpsKey,const char* cpsLockKey,long lShmSize=0){return true;};
#line 75
	bool GetDataFromShm(const char* cpsKey);

	bool Compare(CIniFileMgr* pIniFileMgr,vector<stIniCompKey>& vtCompKey,bool bLock=true);

	bool SaveKey(const char* cpsFileName,stIniCompKey & oIniKey);

	bool AddKey(CIniSection& oIniKey,OP_FLAG flag);
	bool AddKey(stIniCompKey& Key);
	bool ReplaceKey(stIniCompKey &oIniKey);
	void FlashIt(void);
	bool FlashMemory(SysParamHis ** ppSysParamHis, int& iCnt);  	
	bool FlashMemoryEx(SysParamHis ** ppSysParamHis, int& iCnt,SysParamHis **ppSysParamHisEx,int& iCntEx);  	
	void SetLockKey(const char* sLockKey) { m_strMemLockKey=sLockKey;};

	bool GetIniKeyByString(string& strLine,CIniSection& oIniCompKey);
	bool GetIniKeyByString(string& strLine,stIniCompKey& oIniCompKey);
	bool InsertSection(CIniSection* pIniSection);
	bool getAllSection(SysParamHis ** ppSysParamHis,int& iCnt);
	bool getAllSections(SysParamHis ** ppSysParamHis,int& iCnt);
	bool sectionExist(vector<string> vec_sect,char *section);
	bool getSectionParams(const char* pSection,const char* pParamName,
					SysParamHis** ppstParamHis,int& iCnt);
	bool getSectionParam(const char* pSection,const char* pParamName,
					SysParamHis& stParamHis);
	bool getSection(const char* pSection,SysParamHis** ppSysParamHis,
					int& iCnt);
	bool changeSectionKey(string strContent);
	void setCfgFileName(string& strFileName){ m_strFileName=strFileName;};
	string m_strFileName;

	unsigned int LoadFromStream(istream& inputStream);

	bool AttachIniShm(const char* cpsKey);

	bool AnalysisLine(string &strLine ,string& strSection,string& strKey,string& strValue);

	string m_strSection;

	unsigned int m_iIniKeyNum;

	void ShiftRight(char sParamValue[3][512] ,int iPos=1);
#line 118
	bool MergeSection(CIniSection* pSectionDest,CIniSection* pSectionSource1);
	bool MergeSection(CIniSection* pSectionDest,CIniSection* pSectionSource1,
			CIniSection* pSectionSource2);
#line 123
	int ExtendSectionMem(CIniSection** ppSection,int iSectionCnt);

	unsigned int GetUseNum(void) {return m_iUseNum;};
	unsigned int GetTotalNum(void) {return m_iTotalNum;};
private:
	bool AddKey(const char* pSection,const char* pParamName,const char* pParamValue,
			OP_FLAG flag);
	void ChangeSHMDataCount(unsigned int iCnt);
	static string m_strUserName;
	string m_strPID;
	char username[64];
public :
	CIniSection* m_pIniKey;
	static SHMData<CIniSection>* m_poIniSection;
	unsigned int m_iTotalNum; 
	unsigned int m_iUseNum; 
	string m_strMemKey;
	string m_strMemLockKey;
	int m_iMemLockKey;
	char m_sTmp[512+16];
	CRWLock* m_prwLock;
	BaseRuleMgr* m_pRuleMgr;
	CDBAccessIF *m_pDBAccessIF;
	static ThreeLogGroup *m_pLogg;
	map<string,int> m_mapString2Int;
	bool m_bParamUse;
};
#line 13 "/cbilling/app/petri/src/app_init/CommandCom.h"
using namespace std;
#line 20
using namespace std;
#line 23
class ThreeLogGroup ;
class CommandCom
{
public:
#line 29
	CommandCom(void);
#line 32
	virtual ~CommandCom(void);

	bool Logout();

	bool InitClient(unsigned int iCmdID=0,const char* cstrAppName=0);
	bool GetInitParam(const char* pSection,const char* pKeyName=0);
#line 40
	char *readIniString( char const *Section, char const *Ident, 
            char *sItem, char *defstr );
	long readIniInteger( char const *Section, char const *Ident,
			int defint );
	bool reLoad(void);
protected :

	bool Register(unsigned int iTimeOut=10,const char* cstrAppName=0);
	static	bool m_bRegister;

public:

	static void SetAppName(char* cstrAppName);
	static char * g_strAppName;
	static ThreeLogGroup *m_poLogg;
#line 58
private:

	bool AttachShm(void);
	char toLower(const char ch);
    bool Chang2Lower(char *sSrc);
	static CIniFileMgr *m_pIniFileMgr;
	string m_strFileName;

public:
	bool FlashMemory(SysParamHis ** ppSysParamHis, int& iCnt);  
	bool FlashMemoryEx(SysParamHis ** ppSysParamHis, int& iCnt,SysParamHis **ppSysParamHisEx,int& iCntEx);  
	bool GetIniKeyByString(string& strLine,CIniSection& oIniCompKey);
	bool getAllSection(SysParamHis ** ppSysParamHis,int& iCnt);
	bool getAllSections(SysParamHis ** ppSysParamHis,int& iCnt);
	bool getSectionParams(const char* pSection,const char* pParamName,
		SysParamHis **ppstParamHis,int& iCnt);
	bool getSectionParam(const char* pSection,const char* pParamName,
								SysParamHis& stParamHis);
	bool getSection(const char* pSection,SysParamHis** ppSysParamHis,
								int& iCnt);
	bool changeSectionKey(string strContent);
	void setParamUse(bool flag);
};
#line 10 "../app_tools/CheckPointInfo.h"
class CheckPointInfo
{
	  public:
	  		  CheckPointInfo();
			  ~CheckPointInfo();
	  public:  
	  	      char *getChkPointBatchPath(char *batch);
			  char *getNowBatch();
			  bool createBatchID();
	  public:  

			  bool getCheckPointPath(char *sRootPath);

			  char *getCharBatchID();

			  int  CheckFilePath (char * filepath);	
			  void getBatch(); 

              void showBatchBaseInfo(char *sBatch);  
#line 34
			  CSemaphore *lock;
			  int m_iLockKey;
			  bool P(bool Real=false); 
			  bool V(); 
#line 40
			  int waitTimer(int &iTimer,int iMaxTimeNum); 

			  bool recordBatchInfo(char * sBatch, char* sTime, char *sDataType,char*desc=0,char *tablename=0); 
			  bool getNeedState();
	  private:
	          char m_sBatchID[32];
			  char m_sPath[2048];
              long m_lBatchID;
			  CommandCom *m_poCommandCom;
#line 51
};
#line 5 "/usr/vacpp/include/stdarg.h"
extern "C" {

}
#line 12 "/cbilling/app/petri/libsrc/lib/SGWException.h"
using namespace std;
#line 15
struct ExceptMsg {
    char m_sFileName[32];        
    int  m_iLineNo;             
	char m_sTime[32];          
    char m_sMsg[1024];             
};
#line 32
class SGWException {
public:
    SGWException() {
        m_oErrBuf.resize (16);
        m_oErrBuf.clear ();
    }
#line 40
    void clear() {
        m_oErrBuf.clear ();
		memset(m_sFileName,0,sizeof(m_sFileName));
    }
#line 46
    vector<ExceptMsg> const * getErrs() {
        return &m_oErrBuf;
    }
#line 52
    void printErr(char *sLineHead=0,int _iSign = 0);
#line 55
    void addErr(char const *sFile,int const iLine, char const *sFormat, ...);

	void setFileName(const char *_sFileName,long _lParam=0) {
#line 61
		char *p = getenv("TIBS_HOME");

		if (p == 0) {
			snprintf(m_sFileName,sizeof(m_sFileName),"%s_%d.log",_sFileName,((_lParam==0)?getpid():_lParam));
		} else {
			char _sTempDIR[200] = {0};
			snprintf(_sTempDIR,sizeof(_sTempDIR),"%s/log",p);

			if (opendir(_sTempDIR) == 0) {

				if (errno ==2) { 
					if (mkdir(_sTempDIR,0666)==0) {
						snprintf(m_sFileName,sizeof(m_sFileName),"%s/%s_%d.log",_sTempDIR,_sFileName,((_lParam==0)?getpid():_lParam));
						return;
					}
				} 
			} 
			snprintf(m_sFileName,sizeof(m_sFileName),"%s/%s_%d.log",_sTempDIR,_sFileName,((_lParam==0)?getpid():_lParam));
			return;
		}
		snprintf(m_sFileName,sizeof(m_sFileName),"%s_%d.log",_sFileName,((_lParam==0)?getpid():_lParam));
	}

private:
    vector<ExceptMsg> m_oErrBuf;
	char m_sFileName[256];

};
#line 1 "/cbilling/app/petri/src/app_shmmgr/SHMDataMgr.h"
#pragma once
#line 30 "/cbilling/app/petri/libsrc/lib/SHMStringTreeIndex.h"
class SHMStringList
{
    friend class SHMStringTreeIndex;
#line 35
    unsigned int m_iValue;
#line 38
    unsigned int m_iNext;
#line 41
    char m_sKey[8];

};
#line 46
class SHMStringTree
{
    friend class SHMStringTreeIndex;
#line 51
    unsigned int m_iNext[10];
#line 54
    unsigned int m_iValue;

    char m_chDateTime[14+1];

};
#line 65
class SHMStringTreeIndex : public SHMAccess
{
  public:

    SHMStringTreeIndex(char *shmname);
#line 72
    SHMStringTreeIndex(long shmkey);
#line 75
    ~SHMStringTreeIndex();
#line 78
    void add(char *key, unsigned int value);
#line 81
    bool get(char *key, unsigned int *pvalue);

    bool getMax(char *key, unsigned int *pvalue);
#line 88
    void create(
#line 91
        unsigned int itemnumber, 
#line 94
        unsigned int keylen, 
#line 97
        unsigned int multiple = 3) ;
        void empty();
        time_t getLoadTime();

   		 unsigned long *m_piIndexTime;

	unsigned int getCount()
	{
		if (*m_piTreeUsed)
			return (*m_piTreeUsed);

		return 0;
	};

	unsigned int getTotal()
	{
		if (*m_piTreeTotal)
			return (*m_piTreeTotal);

		return 0;
	};

	unsigned int getlCount()
	{
		if (*m_piListUsed)
			return (*m_piListUsed);

		return 0;		
	};

	unsigned int getlTotal()
	{
		if (*m_piListTotal)
			return (*m_piListTotal);

		return 0;
	};
	int  getMemSize();

	int getUsedSize();

	unsigned long getMemAdress();

  private:

    void open();

    inline SHMStringList *getList(unsigned int offset);
#line 148
    unsigned int *m_piListTotal;
#line 151
    unsigned int *m_piListUsed;
#line 154
    unsigned int *m_piTreeTotal;
#line 157
    unsigned int *m_piTreeUsed;
#line 162
    unsigned int *m_piListLen;
      unsigned long  *m_pimemAdr;
#line 166
    char *m_poList;
#line 169
    SHMStringTree *m_poTree;

    unsigned int *m_piKeyLen;
#line 174
};
#line 1 "/cbilling/app/petri/src/app_shmmgr/SHMParamCfg.h"
#pragma once
#line 7
class SHMParamCfg
{
public:
#line 21
	static bool setValue(const char *_sValue) {
		CommandCom _pCommandComm;
		_pCommandComm.InitClient();
		return _pCommandComm.changeSectionKey(_sValue);
	}

	static int getValue( char const *_sTab, char const *_sValue,int _iValue = -22222222) {
		ReadIni reader;
		char sFileName[1024] = {0};
		char *penv = getenv("SGW_HOME");

		if (!penv) {
			return -1;
		}

		if (penv[strlen(penv)-1] != '/') {
			snprintf (sFileName, sizeof(sFileName)-1, "%s/etc/sgwconfig", penv);
		} else {
			snprintf (sFileName, sizeof(sFileName)-1, "%setc/sgwconfig", penv);
		}

		_iValue = reader.readIniInteger(sFileName,_sTab,_sValue,_iValue);

		if (_iValue == -22222222) {
			ThreeLogGroup _oLogObj;
			_oLogObj.sgwlog(167,-1,-1,-1,2,2,-1,0,"%s.%s",_sTab,_sValue);
			throw Exception((167), errno, 47, "/cbilling/app/petri/src/app_shmmgr/SHMParamCfg.h");
		} else if (_iValue < 0) {
			ThreeLogGroup _oLogObj;
			_oLogObj.sgwlog(MBC_PARAM_THREAD_VALUE_ERROR,-1,-1,-1,2,2,-1,0,"%s.%s",_sTab);
			throw Exception((MBC_PARAM_THREAD_VALUE_ERROR), errno, 51, "/cbilling/app/petri/src/app_shmmgr/SHMParamCfg.h");
		}
		return _iValue;
	}

	static char *getString( char const *_sTab, char const *_sValue,char *defstr) {
		ReadIni reader;
		char sFileName[1024] = {0};
		char sIniHeader[32] = {0};
		char *penv = getenv("BILLDIR");

		if (!penv) {
			return 0;
		}

		if (penv[strlen(penv)-1] != '/') {
			snprintf (sFileName, sizeof(sFileName)-1, "%s/etc/sgwconfig", penv);
		} else {
			snprintf (sFileName, sizeof(sFileName)-1, "%setc/sgwconfig", penv);
		}
		return reader.readIniString (sFileName, _sTab,_sValue,defstr,0);
	}

};
#line 610 "/cbilling/app/petri/src/app_shmmgr/ShmParamDef.h"
typedef struct _SHMQueryInfo
{
	char m_sKey[16];  
	long m_lKey;      
	char m_sOwner[32];  
	char m_sIPCType[32];  
	char m_sDataFrom[128];  
	unsigned int m_iUsed;       
	unsigned int m_iAllSize;     
	char m_sUseRate[32];    
	int m_iNattch;    
	int m_iTotal;
	char m_sDataNbr[32];
	char  m_sLoadTime[24];  
}SHMInfo;
#line 34 "/cbilling/app/petri/src/app_shmmgr/SHMSGWInfoBase.h"
class SHMSGWInfoBase
{
public:
	SHMSGWInfoBase(){};

	~SHMSGWInfoBase(){};
#line 42
	static int attachALL();
	static int verifyParamAll();
	static void freeAll();
	static void bindData();
#line 48
	static int contentfiltering_init();
	static int streamctrldata_init();
	static int msgmap_init();
	static int servicetxtlist_init();
	static int userinfo_init();
	static int congestleve_init();
	static int session_init();
	static int sessionclear_init();
	static int netinfo_init();
	static int sgwslaquerel_init();
	static int streamctrl_init();
	static int servicetxtlistbase_init();
	static int loadbalancedata_init();
	static int basemethod_init();
	static int packetsession_init();
	static int servicepackage_init();
	static int servicepackageroute_init();
	static int servicepackagerouteCCR_init();
	static int servicepackagejudge_init();
	static int servicepackagecca_init();
	static int servicepackagefunc_init();
	static int servicepackagevariable_init();
	static int scongestmsg_init();
	static int wfprocessmq_init();
	static int portInfo_init();
	static int sgworgroute_init();
	static int sgworghead_init();
	static int channelinfo_init();
	static int userstaff_init();
	static int globalmap_init();
	static int orgrouterule_init();
	static int sgwareaorg_init();
	static int sgwtuxrelain_init();
	static int sgwtuxrelaout_init();
	static int sgwsvrlist_init();
	static int sgwsrvsparamrela_init();
	static int sgwsrvsparamlist_init();
	static int sgwsrvsregister_init();
	static int sgwparaminslist_init();
	static int sgwenumarea_init();
#line 90
	static void contentfiltering_free();
	static void streamctrldata_free();
	static void msgmap_free();
	static void servicetxtlist_free();
	static void userinfo_free();
	static void congestleve_free();
	static void session_free();
	static void sessionclear_free();
	static void netinfo_free();
	static void sgwslaquerel_free();
	static void streamctrl_free();
	static void servicetxtlistbase_free();
	static void loadbalancedata_free();
	static void basemethod_free();
	static void packetsession_free();
	static void servicepackage_free();
	static void servicepackageroute_free();
	static void servicepackagerouteCCR_free();
	static void servicepackagejudge_free();
	static void servicepackagecca_free();
	static void servicepackagefunc_free();
	static void servicepackagevariable_free();
	static void scongestmsg_free();
	static void wfprocessmq_free();
	static void portInfo_free();
	static void sgworgroute_free();
	static void sgworghead_free();
	static void channelinfo_free();
	static void userstaff_free();
	static void globalmap_free();
	static void orgrouterule_free();
	static void sgwareaorg_free();
	static void sgwtuxrelain_free();
	static void sgwtuxrelaout_free();
	static void sgwsvrlist_free();
	static void sgwsrvsparamrela_free();
	static void sgwsrvsparamlist_free();
	static void sgwsrvsregister_free();
	static void sgwparaminslist_free();
	static void sgwenumarea_free();

public:

	static SHMData<StreamControlData> *m_pSHMMgrStreamCtrlData;
	static SHMIntHashIndex_A  *m_pSHMMgrStreamCtrlDataIndex;
	static StreamControlData *m_pMgrStreamCtrlData;
	static CSemaphore* m_pSHMMgrStreamCtrlDataLock;
#line 139
	static SHMData<ContextData> *m_pSHMMgrContextData;

	static ContextData *m_pMgrContextData;
	static CSemaphore* m_pSHMMgrContextDataLock;
#line 145
	static SHMData<SMsgMapInfo> *m_pSHMMgrMsgMapInfoData;
	static SHMIntHashIndex_A  *m_pSHMMgrMsgMapInfoIndex;
	static SMsgMapInfo *m_pMgrMsgMapInfoData;
	static CSemaphore* m_pSHMMgrMsgMapInfoLock;
#line 151
	static SHMData<ServiceContextListData> *m_pSHMMgrServiceTxtListData;
	static SHMIntHashIndex_A  *m_pSHMMgrServiceTxtListIndex;
	static SHMIntHashIndex_A  *m_pSHMMgrSrvTxtListIDIndex;
	static ServiceContextListData *m_pMgrServiceTxtListData;
	static CSemaphore* m_pSHMMgrServiceTxtListLock;
#line 158
	static SHMData<StreamControlInfo> *m_pSHMMgrStreamCtrlInfoData;
	static SHMIntHashIndex_A  *m_pSHMMgrStreamCtrlInfoIndex;
	static StreamControlInfo *m_pMgrStreamCtrlInfoData;
	static CSemaphore* m_pSHMMgrStreamCtrlInfoLock;
#line 164
	static SHMData<UserInfoData> *m_pSHMMgrUserInfoData;
	static SHMIntHashIndex_A  *m_pSHMMgrUserInfoIndex;
	static SHMIntHashIndex_A  *m_pSHMMgrUserInfoIndex_A;
	static UserInfoData *m_pMgrUserInfoData;
	static CSemaphore* m_pSHMMgrUserInfoDataLock;
#line 171
	static SHMData<SgwSlaQueue> *m_pSHMMgrSgwSlaqueRelData;
	static SHMIntHashIndex_A  *m_pSHMMgrSgwSlaqueRelIndex;
	static SgwSlaQueue *m_pMgrSgwSlaqueRelData;
	static CSemaphore* m_pSHMMgrSgwSlaqueRelLock;
#line 177
	static SHMData<NetInfoData> *m_pSHMMgrNetInfoData;
	static SHMIntHashIndex_A  *m_pSHMMgrNetInfoIndex;
	static SHMIntHashIndex_A  *m_pSHMMgrNetInfoIndex_S;
	static NetInfoData *m_pMgrNetInfoData;
	static CSemaphore* m_pSHMMgrNetInfoLock;

	static SHMData<SessionData> *m_pSHMMgrSessionData;
	static SHMIntHashIndex_A  *m_pSHMMgrSessionIndex;
	static SessionData *m_pMgrSessionData;
	static CSemaphore* m_pSHMMgrSessionLock;

	static SHMData<SessionClearData> *m_pSHMMgrSessionClearData;
	static SHMIntHashIndex_A  *m_pSHMMgrSessionClearIndex;
	static SessionClearData *m_pMgrSessionClearData;
	static SessionHead *m_pMgrSessionHeadSign;
	static CSemaphore* m_pSHMMgrSessionClearLock;

	static SHMData<CongestLevel> *m_pSHMMgrCongestLevelData;
	static CongestLevel *m_pMgrCongestLevel;
	static CSemaphore* m_pSHMMgrCongestLevelLock;

	static SHMData<ServiceContextListBaseData> *m_pSHMMgrServiceTxtListBaseData;
	static SHMIntHashIndex_A  *m_pSHMMgrServiceTxtListBaseIndex;
	static ServiceContextListBaseData *m_pMgrServiceTxtListBaseData;
	static CSemaphore* m_pSHMMgrServiceTxtListBaseLock;

	static SHMData<LoadBalanceData> *m_pSHMMgrLoadBalanceData;
	static SHMIntHashIndex_A  *m_pSHMMgrLoadBalanceIndex;
	static LoadBalanceData *m_pMgrLoadBalanceData;
	static CSemaphore* m_pSHMMgrLoadBalanceLock;
#line 209
	static SHMData<CBaseMethod> *m_pSHMMgrBaseMethodData;
	static SHMIntHashIndex_A  *m_pSHMMgrBaseMethodindex;
	static CBaseMethod *m_pMgrBaseMethodData;
	static CSemaphore* m_pSHMMgrBaseMethodLock;
#line 215
	static SHMData<SPacketSession> *m_pSHMMgrPacketSessionData;
	static SHMIntHashIndex_A  *m_pSHMMgrPacketSessionindex;
	static SHMIntHashIndex_A  *m_pSHMMgrPacketSubSessionindex;
	static SPacketSession *m_pMgrPacketSessionData;
	static CSemaphore* m_pSHMMgrPacketSessionLock;
#line 222
	static SHMData<ServicePackageNode> *m_pSHMMgrServicePackageData;
	static SHMIntHashIndex_A  *m_pSHMMgrServicePackageindex;
	static SHMIntHashIndex_A  *m_pSHMMgrSrvPackageNodeSeqIndex;
	static ServicePackageNode *m_pMgrServicePackageData;
	static CSemaphore* m_pSHMMgrServicePackageLock;
#line 229
	static SHMData<ServicePackageRoute> *m_pSHMMgrServicePackageRouteData;
	static SHMIntHashIndex_A  *m_pSHMMgrServicePackageRouteindex;
	static SHMIntHashIndex_A  *m_pSHMMgrSrvPackageRouteSeqIndex;
	static ServicePackageRoute *m_pMgrServicePackageRouteData;
	static CSemaphore* m_pSHMMgrServicePackageRouteLock;
#line 236
	static SHMData<CServicePackageRouteCCR> *m_pSHMMgrServicePackageRouteCCRData;
	static SHMIntHashIndex_A  *m_pSHMMgrSrvPackageRouteCCRSeqindex;
	static SHMIntHashIndex_A  *m_pSHMMgrSrvPackageRouteSeqindex;
	static CServicePackageRouteCCR *m_pMgrServicePackageRouteCCRData;
	static CSemaphore* m_pSHMMgrServicePackageRouteCCRLock;
#line 243
	static SHMData<CServicePackageJudge> *m_pSHMMgrServicePackageJudgeData;
	static SHMIntHashIndex_A  *m_pSHMMgrServicePackageJudgeindex;
	static SHMIntHashIndex_A  *m_pSHMMgrSrvPackageJudgeNodeSeqIndex;
	static CServicePackageJudge *m_pMgrServicePackageJudgeData;
	static CSemaphore* m_pSHMMgrServicePackageJudgeLock;
#line 250
	static SHMData< CServicePackageCCA> *m_pSHMMgrServicePackageCCAData;
	static SHMIntHashIndex_A  *m_pSHMMgrServicePackageCCAindex;
	static SHMIntHashIndex_A  *m_pSHMMgrSrvPackageCCASeqIndex;
	static  CServicePackageCCA *m_pMgrServicePackageCCAData;
	static CSemaphore* m_pSHMMgrServicePackageCCALock;
#line 257
	static SHMData<CServicePackageFunc> *m_pSHMMgrServicePackageFuncData;
	static SHMIntHashIndex_A  *m_pSHMMgrServicePackageFuncindex;
	static  CServicePackageFunc *m_pMgrServicePackageFuncData;
	static CSemaphore* m_pSHMMgrServicePackageFuncLock;
#line 263
	static SHMData< CServicePackageVariable> *m_pSHMMgrServicePackageVariableData;
	static SHMIntHashIndex_A  *m_pSHMMgrServicePackageVariableindex;
	static   CServicePackageVariable *m_pMgrServicePackageVariableData;
	static CSemaphore* m_pSHMMgrServicePackageVariableLock;
#line 269
	static SHMData< StatisticsCongestMsg> *m_pSHMMgrSCongestMsgData;
	static SHMIntHashIndex_A  *m_pSHMMgrSCongestMsgindex;
	static   StatisticsCongestMsg *m_pMgrSCongestMsgData;
	static CSemaphore* m_pSHMMgrSCongestMsgLock;
#line 275
	static SHMData< ST_WF_PROCESS_MQ> *m_pSHMMgrWfprocessMqData;
	static SHMIntHashIndex  *m_pSHMMgrWfprocessMqindex;
	static ST_WF_PROCESS_MQ *m_pMgrWfprocessMqData;
	static CSemaphore* m_pSHMMgrWfprocessMqLock;
#line 281
	static SHMData< PortInfo> *m_pSHMMgrPortInfoData;
	static SHMIntHashIndex_A  *m_pSHMMgrPortInfoindex;
	static PortInfo *m_pMgrPortInfoData;
	static CSemaphore* m_pSHMMgrPortInfoLock;

	static SHMData<Sgw_Org_Route> *m_pSHMMgrOrgRouteData;
	static SHMIntHashIndex_A  *m_pSHMMgrOrgRouteindex;
	static Sgw_Org_Route *m_pMgrOrgRouteData;
	static CSemaphore* m_pSHMMgrOrgRouteLock;

	static SHMData<Sgw_Org_Head> *m_pSHMMgrOrgHeadData;
	static SHMIntHashIndex_A  *m_pSHMMgrOrgHeadindex;
	static Sgw_Org_Head *m_pMgrOrgHeadData;
	static CSemaphore* m_pSHMMgrOrgHeadLock;

	static SHMData<SgwChannelInfo> *m_pSHMMgrChannelData;
	static SHMIntHashIndex_A  *m_pSHMMgrChannelindex;
	static SgwChannelInfo *m_pMgrChannelData;
	static CSemaphore* m_pSHMMgrChannelLock;
#line 314
	static SHMData<SgwUserStaff> *m_pSHMMgrUserStaffData;
	static SHMIntHashIndex_A  *m_pSHMMgrUserStaffIDindex;
	static SHMIntHashIndex_A  *m_pSHMMgrStaffIDindex;
	static SHMIntHashIndex_A  *m_pSHMMgrUserStaffChannelIDindex;
	static SgwUserStaff *m_pMgrUserStaffData;
	static CSemaphore* m_pSHMMgrUserStaffLock;
#line 322
	static SHMData< SgwGlobalMap> *m_pSHMMgrGlobalMapData;
	static SHMIntHashIndex_A  *m_pSHMMgrGlobalMapindex;
	static CSemaphore* m_pSHMMgrGlobalMapLock;
	static SgwGlobalMap *m_pMgrGlobalMapData;
#line 328
	static SHMData<SgwOrgRouteRule> *m_pSHMMgrOrgRoutRuleData;
	static SHMIntHashIndex_A  *m_pSHMMgrOrgRouteIDindex;
	static SHMIntHashIndex_A  *m_pSHMMgrOrgIDindex;
	static SgwOrgRouteRule *m_pMgrOrgRoutRuleData;
	static CSemaphore* m_pSHMMgrOrgRoutRuleLock;
#line 335
	static SHMData<SgwAreaOrg> *m_pSHMMgrAreaOrgData;
	static SHMIntHashIndex_A  *m_pSHMMgrAreaOrgSeqindex;
	static SgwAreaOrg *m_pMgrAreaOrgData;
	static CSemaphore* m_pSHMMgrAreaOrgLock;
#line 341
	static SHMData<SgwTuxedoRelationIn> *m_pSHMMgrTuxRelaInData;
	static SHMIntHashIndex_A  *m_pSHMMgrTuxInSvrsIDindex;
	static SgwTuxedoRelationIn *m_pMgrTuxRelaInData;
	static CSemaphore* m_pSHMMgrTuxRelaInLock;
#line 347
	static SHMData<SgwTuxedoRelationOut> *m_pSHMMgrTuxRelaOutData;
	static SHMIntHashIndex_A  *m_pSHMMgrTuxOutSvrTxtIDindex;
	static SHMIntHashIndex_A  *m_pSHMMgrTuxOutRelaIDindex;
	static SgwTuxedoRelationOut *m_pMgrTuxRelaOutData;
	static CSemaphore* m_pSHMMgrTuxRelaOutLock;
#line 354
	static SHMData<SgwServicesList> *m_pSHMMgrSrvsListData;
	static SHMIntHashIndex_A  *m_pSHMMgrSrvsListIDindex;
	static SHMIntHashIndex_A  *m_pSHMMgrSrvsListServicesNameindex;
	static SgwServicesList *m_pMgrSrvsListData;
	static CSemaphore* m_pSHMMgrSrvsListLock;
#line 361
	static SHMData<SgwServicesParamRelation> *m_pSHMMgrSrvsParamRelaData;
	static SHMIntHashIndex_A  *m_pSHMMgrSrvsParamRelaindex;
	static SHMIntHashIndex_A  *m_pSHMMgrSrvsParamRelaMappingIDIndex;
	static SgwServicesParamRelation *m_pMgrSrvsParamRelaData;
	static CSemaphore* m_pSHMMgrSrvsParamRelaLock;
#line 368
	static SHMData<SgwServicesParamList> *m_pSHMMgrSrvsParamListData;
	static SHMIntHashIndex_A  *m_pSHMMgrSrvsParamListindex;
	static SgwServicesParamList *m_pMgrSrvsParamListData;
	static CSemaphore* m_pSHMMgrSrvsParamListLock;
#line 374
	static SHMData<SgwServiceRegister> *m_pSHMMgrSrvsRegisterData;
	static SHMIntHashIndex_A  *m_pSHMMgrSrvsRegisterindex;
	static SHMIntHashIndex_A  *m_pSHMMgrSrvsRegisterSvrInsIDIndex;
	static SgwServiceRegister *m_pMgrSrvsRegisterData;
	static CSemaphore* m_pSHMMgrSrvsRegisterLock;
#line 381
	static SHMData<SgwParamInstanceList> *m_pSHMMgrParamInsListData;
	static SHMIntHashIndex_A  *m_pSHMMgrParamInsListindex;
	static SHMIntHashIndex_A  *m_pSHMMgrParamInsListMapIDindex;
	static SgwParamInstanceList *m_pMgrParamInsListData;
	static CSemaphore* m_pSHMMgrParamInsListLock;
#line 388
	static SHMData<SgwEnumArea> *m_pSHMMgrSgwEnumAreaData;
	static SHMIntHashIndex_A  *m_pSHMMgrSgwEnumAreaindex;
	static SHMIntHashIndex_A  *m_pSHMMgrSgwEnumAreaOrgIDindex;
	static SgwEnumArea *m_pMgrSgwEnumAreaData;
	static CSemaphore* m_pSHMMgrSgwEnumAreaLock;
#line 395
private:
	static bool m_bAttached;
	static ThreeLogGroup m_oLogObj;
};
#line 9 "/cbilling/app/petri/src/app_shmmgr/SHMDataMgr.h"
int  GETVALUE(int X,int Y);

class SHMDataMgr:public SHMSGWInfoBase
{
public:
#line 16
	static int createContentFilteringSHM(int _iExtenSzie = 0);

	static void unloadContentFilteringSHM();

	static int loadContentFiltering();

	static void clearContentFilteringSHM() {
		m_pSHMMgrContextData->clear();

	};

	static int detachContentFiltering() {
		m_pSHMMgrContextData->close();

	};

	static int queryContentFilteringData(SHMInfo &_oShmInfo);
#line 38
	static int createMsgMapSHM(int _iExtenSzie = 0);
#line 42
	static void unloadMsgMapSHM();

	static int loadMsgMap();

	static void clearMsgMapSHM() {
		m_pSHMMgrMsgMapInfoData->clear();
		m_pSHMMgrMsgMapInfoIndex->empty();
	};

	static int detachMsgMap() {
		m_pSHMMgrMsgMapInfoData->close();
		m_pSHMMgrMsgMapInfoIndex->close();
	};

	static int queryMsgMapData(SHMInfo &_oShmInfo);

	static int queryMsgMapIndex(SHMInfo &_oShmInfo);
#line 62
	static int createServiceTxtListSHM(int _iExtenSzie = 0);
#line 66
	static void unloadServiceTxtListSHM();

	static int loadServiceTxtList();

	static void clearServiceTxtListSHM() {
		m_pSHMMgrServiceTxtListData->clear();
		m_pSHMMgrServiceTxtListIndex->empty();
		m_pSHMMgrSrvTxtListIDIndex->empty();
	}

	static int detachServiceTxtList() {
		m_pSHMMgrServiceTxtListData->close();
		m_pSHMMgrServiceTxtListIndex->close();
		m_pSHMMgrSrvTxtListIDIndex->close();
	};

	static int queryServiceTxtListData(SHMInfo &_oShmInfo);

	static int queryServiceTxtListIndex(SHMInfo &_oShmInfo);

	static int querySrvTxtListIDIndex(SHMInfo &_oShmInfo);
#line 90
	static int createStreamCtrlSHM(int _iExtenSzie = 0);

	static void unloadStreamCtrlSHM();

	static int loadStreamCtrl();

	static void clearStreamCtrlSHM() {
		m_pSHMMgrStreamCtrlInfoData->clear();
		m_pSHMMgrStreamCtrlInfoIndex->empty();
	};

	static int detachStreamCtrl() {
		m_pSHMMgrStreamCtrlInfoData->close();
		m_pSHMMgrStreamCtrlInfoIndex->close();
	};

	static int queryStreamCtrlData(SHMInfo &_oShmInfo);

	static int queryStreamCtrlIndex(SHMInfo &_oShmInfo);
#line 112
	static int createStreamCtrlDataSHM(int _iExtenSzie = 0);
#line 116
	static void unloadStreamCtrlDataSHM();

	static int loadStreamCtrlData();

	static void clearStreamCtrlDataSHM() {
		m_pSHMMgrStreamCtrlData->clear();
		m_pSHMMgrStreamCtrlDataIndex->empty();
	};

	static int detachStreamCtrlData() {
		m_pSHMMgrStreamCtrlData->close();
		m_pSHMMgrStreamCtrlDataIndex->close();
	};

	static int queryStreamCtrlDataData(SHMInfo &_oShmInfo);

	static int queryStreamCtrlDataIndex(SHMInfo &_oShmInfo);
#line 136
	static int createUserInfoSHM(int _iExtenSzie = 0);
#line 140
	static void unloadUserInfoSHM();

	static int loadUserInfo();

	static void clearUserInfoSHM() {
		m_pSHMMgrUserInfoData->clear();
		m_pSHMMgrUserInfoIndex->empty();
		m_pSHMMgrUserInfoIndex_A->empty();
	}

	static int detachUserInfo() {
		m_pSHMMgrUserInfoData->close();
		m_pSHMMgrUserInfoIndex->close();
		m_pSHMMgrUserInfoIndex_A->close();
	};

	static int queryUserInfoData(SHMInfo &_oShmInfo);

	static int queryUserInfoIndex(SHMInfo &_oShmInfo);

	static int queryUserInfoIndex_A(SHMInfo &_oShmInfo);
#line 164
	static int createSgwSlaqueRelSHM(int _iExtenSzie = 0);

	static void unloadSgwSlaqueRelSHM();

	static int loadSgwSlaqueRel();

	static void clearSgwSlaqueRelSHM() {
		m_pSHMMgrSgwSlaqueRelData->clear();
		m_pSHMMgrSgwSlaqueRelIndex->empty();
	};

	static int detachSgwSlaqueRel() {
		m_pSHMMgrSgwSlaqueRelData->close();
		m_pSHMMgrSgwSlaqueRelIndex->close();
	};

	static int querySgwSlaqueRelData(SHMInfo &_oShmInfo);

	static int querySgwSlaqueRelIndex(SHMInfo &_oShmInfo);
#line 185
	static int createNetSHM(int _iExtenSzie = 0);
#line 189
	static void unloadNetSHM();

	static int loadNet();

	static void clearNetSHM() {
		m_pSHMMgrNetInfoData->clear();
		m_pSHMMgrNetInfoIndex->empty();
		m_pSHMMgrNetInfoIndex_S->empty();
	};

	static int detachNet() {
		m_pSHMMgrNetInfoData->close();
		m_pSHMMgrNetInfoIndex->close();
		m_pSHMMgrNetInfoIndex_S->close();
	};

	static int queryNetData(SHMInfo &_oShmInfo);

	static int queryNetIndex(SHMInfo &_oShmInfo);

	static int queryNetIndex_s(SHMInfo &_oShmInfo);
#line 213
	static int createSessionSHM(int _iExtenSzie = 0);

	static void unloadSessionSHM();

	static void clearSessionSHM() {
		m_pSHMMgrSessionData->clear();
		m_pSHMMgrSessionIndex->empty();
	};

	static int detachSession() {
		m_pSHMMgrSessionData->close();
		m_pSHMMgrSessionIndex->close();
	};

	static int querySessionData(SHMInfo &_oShmInfo);

	static int querySessionIndex(SHMInfo &_oShmInfo);
#line 232
	static int createSessionClearSHM(int _iExtenSzie = 0);

	static void unloadSessionClearSHM();

	static void clearSessionClearSHM() {
		m_pSHMMgrSessionClearData->clear();
		m_pSHMMgrSessionClearIndex->empty();
		m_pMgrSessionClearData = (SessionClearData *)(*m_pSHMMgrSessionClearData);
		m_pMgrSessionHeadSign = (SessionHead *)(char *)m_pMgrSessionClearData;
		m_pMgrSessionHeadSign[0].m_iFree = 1; 
		int iTotal = m_pSHMMgrSessionClearData->getTotal();
		for(int i=1; i<iTotal; i++){
			m_pMgrSessionClearData[i].m_iNext = i+1;
			m_pMgrSessionClearData[i].m_iIndexNext = 0;
		}
#line 249
		m_pMgrSessionClearData[iTotal].m_iNext = 1;
		m_pMgrSessionClearData[iTotal].m_iIndexNext = 0;
		m_pMgrSessionHeadSign[0].m_iPreDeal =1;
	};

	static int querySessionClearData(SHMInfo &_oShmInfo);

	static int querySessionClearIndex(SHMInfo &_oShmInfo);
#line 260
	static int createCongestLeveSHM(int _iExtenSzie = 0);
#line 264
	static void unloadCongestLeveSHM();

	static void clearCongestLeveSHM() {
		m_pSHMMgrCongestLevelData->clear();
	};

	static int detachCongestLeve() {
		m_pSHMMgrCongestLevelData->close();
	};

	static int queryCongestLeveData(SHMInfo &_oShmInfo);

	static int queryCongestLeveIndex(SHMInfo &_oShmInfo);
#line 280
	static int createServiceTxtListBaseSHM(int _iExtenSzie = 0);

	static void unloadServiceTxtListBaseSHM();

	static int loadServiceTxtListBase();

	static void clearServiceTxtListBaseSHM() {
		m_pSHMMgrServiceTxtListBaseData->clear();
		m_pSHMMgrServiceTxtListBaseIndex->empty();
	};

	static int detachServiceTxtListBase() {
		m_pSHMMgrServiceTxtListBaseData->close();
		m_pSHMMgrServiceTxtListBaseIndex->close();
	};

	static int queryServiceTxtListBaseData(SHMInfo &_oShmInfo);

	static int queryServiceTxtListBaseIndex(SHMInfo &_oShmInfo);
#line 302
	static int createloadbalanceSHM(int _iExtenSzie = 0);

	static void unloadloadbalanceSHM();

	static int loadBalance();

	static void clearloadbalanceSHM() {
		m_pSHMMgrLoadBalanceData->clear();
		m_pSHMMgrLoadBalanceIndex->empty();
	};

	static int detachloadbalance() {
		m_pSHMMgrLoadBalanceData->close();
		m_pSHMMgrLoadBalanceIndex->close();
	};

	static int queryloadbalanceData(SHMInfo &_oShmInfo);

	static int queryloadbalanceIndex(SHMInfo &_oShmInfo);
#line 323
	static int createbasemethodSHM(int _iExtenSzie = 0);

	static void unloadbasemethodSHM();

	static void clearbasemethodSHM() {
		m_pSHMMgrBaseMethodData->clear();
		m_pSHMMgrBaseMethodindex->empty();
	};

	static int loadbasemethod();

	static int detachbasemethod() {
		m_pSHMMgrBaseMethodData->close();
		m_pSHMMgrBaseMethodindex->close();
	};

	static int querybasemethodData(SHMInfo &_oShmInfo);

	static int querybasemethodIndex(SHMInfo &_oShmInfo);
#line 344
	static int createpacketsessionSHM(int _iExtenSzie = 0);

	static void unloadpacketsessionSHM();

	static void clearpacketsessionSHM() {
		m_pSHMMgrPacketSessionData->clear();
		m_pSHMMgrPacketSessionindex->empty();
		m_pSHMMgrPacketSubSessionindex->empty();
	};

	static int detachpacketsession() {
		m_pSHMMgrPacketSessionData->close();
		m_pSHMMgrPacketSessionindex->close();
		m_pSHMMgrPacketSubSessionindex->close();
	};

	static int querypacketsessionData(SHMInfo &_oShmInfo);

	static int querypacketsessionIndex(SHMInfo &_oShmInfo);

	static int querypacketsubsessionIndex(SHMInfo &_oShmInfo);
#line 367
	static int createpackagerouteSHM(int _iExtenSzie = 0);

	static void unloadpackagerouteSHM();

	static void clearpackagerouteSHM() {
		m_pSHMMgrServicePackageRouteData->clear();
		m_pSHMMgrServicePackageRouteindex->empty();
		m_pSHMMgrSrvPackageRouteSeqIndex->empty();
	};

	static int detachpackageroute() {
		m_pSHMMgrServicePackageRouteData->close();
		m_pSHMMgrServicePackageRouteindex->close();
		m_pSHMMgrSrvPackageRouteSeqIndex->close();
	};

	static int loadpackageroute();

	static int querypackagerouteData(SHMInfo &_oShmInfo);

	static int querypackagerouteIndex(SHMInfo &_oShmInfo);
	static int querypackagerouteIndex_a(SHMInfo &_oShmInfo);
#line 391
	static int createservicepackageSHM(int _iExtenSzie = 0);

	static void unloadservicepackageSHM();

	static int loadservicepackage();

	static void clearservicepackageSHM() {
		m_pSHMMgrServicePackageData->clear();
		m_pSHMMgrServicePackageindex->empty();
		m_pSHMMgrSrvPackageNodeSeqIndex->empty();
	};

	static int detachservicepackage() {
		m_pSHMMgrServicePackageData->close();
		m_pSHMMgrServicePackageindex->close();
		m_pSHMMgrSrvPackageNodeSeqIndex->close();
	};

	static int queryservicepackageData(SHMInfo &_oShmInfo);

	static int queryservicepackageIndex(SHMInfo &_oShmInfo);
	static int queryservicepackageIndex_a(SHMInfo &_oShmInfo);
#line 415
	static int createservicepackageCCRSHM(int _iExtenSzie = 0);

	static void unloadservicepackageCCRSHM();

	static int loadservicepackageCCR();

	static void clearservicepackageCCRSHM() {
		m_pSHMMgrServicePackageRouteCCRData->clear();
		m_pSHMMgrSrvPackageRouteCCRSeqindex->empty();
		m_pSHMMgrSrvPackageRouteSeqindex->empty();
	};

	static int detachservicepackageCCR() {
		m_pSHMMgrServicePackageRouteCCRData->close();
		m_pSHMMgrSrvPackageRouteCCRSeqindex->close();
		m_pSHMMgrSrvPackageRouteSeqindex->close();
	};

	static int queryservicepackageCCRData(SHMInfo &_oShmInfo);

	static int queryservicepackageCCRIndex(SHMInfo &_oShmInfo);
	static int queryservicepackageCCRIndex_a(SHMInfo &_oShmInfo);
#line 439
	static int createpackagejudgeSHM(int _iExtenSzie = 0);

	static void unloadpackagejudgeSHM();

	static int loadpackagejudge();

	static void clearpackagejudgeSHM() {
		m_pSHMMgrServicePackageJudgeData->clear();
		m_pSHMMgrServicePackageJudgeindex->empty();
		m_pSHMMgrSrvPackageJudgeNodeSeqIndex->empty();
	};

	static int detachpackagejudge() {
		m_pSHMMgrServicePackageJudgeData->close();
		m_pSHMMgrServicePackageJudgeindex->close();
		m_pSHMMgrSrvPackageJudgeNodeSeqIndex->close();
	};

	static int querypackagejudgeData(SHMInfo &_oShmInfo);

	static int querypackagejudgeIndex(SHMInfo &_oShmInfo);
	static int querypackagejudgeIndex_a(SHMInfo &_oShmInfo);
#line 463
	static int createpackageccaSHM(int _iExtenSzie = 0);

	static void unloadpackageccaSHM();

	static int loadpackagecca();

	static void clearpackageccaSHM() {
		m_pSHMMgrServicePackageCCAData->clear();
		m_pSHMMgrServicePackageCCAindex->empty();
		m_pSHMMgrSrvPackageCCASeqIndex->empty();
	};

	static int detachpackagecca() {
		m_pSHMMgrServicePackageCCAData->close();
		m_pSHMMgrServicePackageCCAindex->close();
		m_pSHMMgrSrvPackageCCASeqIndex->close();
	};

	static int querypackageccaData(SHMInfo &_oShmInfo);

	static int querypackageccaIndex(SHMInfo &_oShmInfo);
	static int querypackageccaIndex_a(SHMInfo &_oShmInfo);
#line 487
	static int createpackagevleSHM(int _iExtenSzie = 0);

	static void unloadpackagevleSHM();

	static int loadpackagevle();

	static void clearpackagevleSHM() {
		m_pSHMMgrServicePackageVariableData->clear();
		m_pSHMMgrServicePackageVariableindex->empty();
	};

	static int detachpackagevle() {
		m_pSHMMgrServicePackageVariableData->close();
		m_pSHMMgrServicePackageVariableindex->close();
	};

	static int querypackagevleData(SHMInfo &_oShmInfo);

	static int querypackagevleIndex(SHMInfo &_oShmInfo);
#line 508
	static int createpackagefuncSHM(int _iExtenSzie = 0);

	static void unloadpackagefuncSHM();

	static int loadpackagefunc();

	static void clearpackagefuncSHM() {
		m_pSHMMgrServicePackageFuncData->clear();
		m_pSHMMgrServicePackageFuncindex->empty();
	};

	static int detachpackagefunc() {
		m_pSHMMgrServicePackageFuncData->close();
		m_pSHMMgrServicePackageFuncindex->close();
	};

	static int querypackagefuncData(SHMInfo &_oShmInfo);

	static int querypackagefuncIndex(SHMInfo &_oShmInfo);
#line 529
	static int createscongestmsgSHM(int _iExtenSzie = 0);

	static void unloadscongestmsgSHM();

	static void clearscongestmsgSHM() {
		m_pSHMMgrSCongestMsgData->clear();
		m_pSHMMgrSCongestMsgindex->empty();
	};

	static int detachscongestmsg() {
		m_pSHMMgrSCongestMsgData->close();
		m_pSHMMgrSCongestMsgindex->close();
	};

	static int queryscongestmsgData(SHMInfo &_oShmInfo);

	static int queryscongestmsgIndex(SHMInfo &_oShmInfo);
#line 548
	static int createwfprocessmqSHM(int _iExtenSzie = 0);

	static void unloadwfprocessmqSHM();

	static int loadwfprocessmq();

	static void clearwfprocessmqSHM() {
		m_pSHMMgrWfprocessMqData->clear();
		m_pSHMMgrWfprocessMqindex->empty();
	};

	static int detachwfprocessmq() {
		m_pSHMMgrWfprocessMqData->close();
		m_pSHMMgrWfprocessMqindex->close();
	};

	static int querywfprocessmqData(SHMInfo &_oShmInfo);

	static int querywfprocessmqIndex(SHMInfo &_oShmInfo);
#line 569
	static int createportinfoSHM(int _iExtenSzie = 0);

	static void unloadportinfoSHM();

	static void clearportinfoSHM() {
		m_pSHMMgrPortInfoData->clear();
		m_pSHMMgrPortInfoindex->empty();
	};

	static int detachportinfo() {
		m_pSHMMgrPortInfoData->close();
		m_pSHMMgrPortInfoindex->close();
	};

	static int queryportinfoData(SHMInfo &_oShmInfo);

	static int queryportinfoIndex(SHMInfo &_oShmInfo);
#line 588
	static int createOrgRouteSHM(int _iExtenSzie = 0);

	static void unloadOrgRouteSHM();

	static int loadOrgRouteData();

	static void clearOrgRouteSHM() {
		m_pSHMMgrOrgRouteData->clear();
		m_pSHMMgrOrgRouteindex->empty();
	};

	static int detachOrgRouteSHM() {
		m_pSHMMgrOrgRouteData->close();
		m_pSHMMgrOrgRouteindex->close();
	};

	static int queryOrgRouteData(SHMInfo &_oShmInfo);

	static int queryOrgRouteIndex(SHMInfo &_oShmInfo);
#line 609
	static int createOrgHeadSHM(int _iExtenSzie = 0);

	static void unloadOrgHeadSHM();

	static void clearOrgHeadSHM() {
		m_pSHMMgrOrgHeadData->clear();
		m_pSHMMgrOrgHeadindex->empty();
	};

	static int detachOrgHeadSHM() {
		m_pSHMMgrOrgHeadData->close();
		m_pSHMMgrOrgHeadindex->close();
	};
	static int loadOrgHeadData();

	static int queryOrgHeadData(SHMInfo &_oShmInfo);

	static int queryOrgHeadIndex(SHMInfo &_oShmInfo);
#line 629
	static int createGlobalMapSHM(int _iExtenSzie = 0);

	static void unloadGlobalMapSHM();

	static int loadGlobalMapData();

	static void clearGlobalMapSHM() {
		m_pSHMMgrGlobalMapData->clear();
		m_pSHMMgrGlobalMapindex->empty();
	};

	static int detachGlobalMapSHM() {
		m_pSHMMgrGlobalMapData->close();
		m_pSHMMgrGlobalMapindex->close();
	};

	static int queryGlobalMapData(SHMInfo &_oShmInfo);

	static int queryGlobalMapIndex(SHMInfo &_oShmInfo);
#line 650
	static int createChannelSHM(int _iExtenSzie = 0);

	static void unloadChannelSHM();

	static int loadChannelData();

	static void clearChannelSHM() {
		m_pSHMMgrChannelData->clear();
		m_pSHMMgrChannelindex->empty();
	}

	static int detachChannelSHM() {
		m_pSHMMgrChannelData->close();
		m_pSHMMgrChannelindex->close();
	};

	static int queryChannelData(SHMInfo &_oShmInfo);

	static int queryChannelIndex(SHMInfo &_oShmInfo);
#line 671
	static int createUserStaffSHM(int _iExtenSzie = 0);

	static void unloadUserStaffSHM();

	static int loadUserStaffData();

	static void clearUserStaffSHM() {
		m_pSHMMgrUserStaffData->clear();
		m_pSHMMgrUserStaffIDindex->empty();
		m_pSHMMgrStaffIDindex->empty();
		m_pSHMMgrUserStaffChannelIDindex->empty();
	}

	static int detachUserStaffSHM() {
		m_pSHMMgrUserStaffData->close();
		m_pSHMMgrUserStaffIDindex->close();
		m_pSHMMgrStaffIDindex->close();
		m_pSHMMgrUserStaffChannelIDindex->close();
	};

	static int queryUserStaffData(SHMInfo &_oShmInfo);

	static int queryUserStaffIndex_a(SHMInfo &_oShmInfo);

	static int queryUserStaffIndex_b(SHMInfo &_oShmInfo);

	static int queryUserStaffIndex_c(SHMInfo &_oShmInfo);
#line 700
	static int createRouteRuleSHM(int _iExtenSzie = 0);

	static void unloadRouteRuleSHM();

	static int loadRouteRuleData();

	static void clearRouteRuleSHM() {
		m_pSHMMgrOrgRoutRuleData->clear();
		m_pSHMMgrOrgRouteIDindex->empty();
		m_pSHMMgrOrgIDindex->empty();
	}

	static int detachRouteRuleSHM() {
		m_pSHMMgrOrgRoutRuleData->close();
		m_pSHMMgrOrgRouteIDindex->close();
		m_pSHMMgrOrgIDindex->close();
	};

	static int queryRouteRuleData(SHMInfo &_oShmInfo);

	static int queryRouteRuleIndex_a(SHMInfo &_oShmInfo);

	static int queryRouteRuleIndex_b(SHMInfo &_oShmInfo);
#line 725
	static int createAreaOrgSHM(int _iExtenSzie = 0);

	static void unloadAreaOrgSHM();

	static int loadAreaOrgData();

	static void clearAreaOrgSHM() {
		m_pSHMMgrAreaOrgData->clear();
		m_pSHMMgrAreaOrgSeqindex->empty();
	}

	static int detachAreaOrgSHM() {
		m_pSHMMgrAreaOrgData->close();
		m_pSHMMgrAreaOrgSeqindex->close();
	};

	static int queryAreaOrgData(SHMInfo &_oShmInfo);

	static int queryAreaOrgIndex(SHMInfo &_oShmInfo);
#line 747
	static int createTuxRelaInSHM(int _iExtenSzie = 0);

	static void unloadTuxRelaInSHM();

	static int loadTuxRelaInData();

	static void clearTuxRelaInSHM() {
		m_pSHMMgrTuxRelaInData->clear();
		m_pSHMMgrTuxInSvrsIDindex->empty();
	}

	static int detachTuxRelaInSHM() {
		m_pSHMMgrTuxRelaInData->close();
		m_pSHMMgrTuxInSvrsIDindex->close();
	};

	static int queryTuxRelaInData(SHMInfo &_oShmInfo);

	static int queryTuxRelaInIndex(SHMInfo &_oShmInfo);
#line 769
	static int createTuxRelaOutSHM(int _iExtenSzie = 0);

	static void unloadTuxRelaOutSHM();

	static int loadTuxRelaOutData();

	static void clearTuxRelaOutSHM() {
		m_pSHMMgrTuxRelaOutData->clear();
		m_pSHMMgrTuxOutSvrTxtIDindex->empty();
		m_pSHMMgrTuxOutRelaIDindex->empty();
	}

	static int detachTuxRelaOutSHM() {
		m_pSHMMgrTuxRelaOutData->close();
		m_pSHMMgrTuxOutSvrTxtIDindex->close();
		m_pSHMMgrTuxOutRelaIDindex->close();
	};

	static int queryTuxRelaOutData(SHMInfo &_oShmInfo);

	static int queryTuxRelaOutIndex(SHMInfo &_oShmInfo);
	static int queryTuxRelaOutRelaIDIndex(SHMInfo &_oShmInfo);
#line 793
	static int createSvrListSHM(int _iExtenSzie = 0);

	static void unloadSvrListSHM();

	static int loadSvrListData();

	static void clearSvrListSHM() {
		m_pSHMMgrSrvsListData->clear();
		m_pSHMMgrSrvsListIDindex->empty();
		m_pSHMMgrSrvsListServicesNameindex->empty();
	}

	static int detachSvrListSHM() {
		m_pSHMMgrSrvsListData->close();
		m_pSHMMgrSrvsListIDindex->close();
		m_pSHMMgrSrvsListServicesNameindex->close();
	};

	static int querySvrListData(SHMInfo &_oShmInfo);

	static int querySvrListIndex(SHMInfo &_oShmInfo);
	static int querySvrListServicesNameIndex(SHMInfo &_oShmInfo);
#line 818
	static int createSvrsParamRelaSHM(int _iExtenSzie = 0);

	static void unloadSvrsParamRelaSHM();

	static int loadSvrsParamRelaData();

	static void clearSvrsParamRelaSHM() {
		m_pSHMMgrSrvsParamRelaData->clear();
		m_pSHMMgrSrvsParamRelaindex->empty();
		m_pSHMMgrSrvsParamRelaMappingIDIndex->empty();
	}

	static int detachSvrsParamRelaSHM() {
		m_pSHMMgrSrvsParamRelaData->close();
		m_pSHMMgrSrvsParamRelaindex->close();
		m_pSHMMgrSrvsParamRelaMappingIDIndex->close();
	};

	static int querySvrsParamRelaData(SHMInfo &_oShmInfo);

	static int querySvrsParamRelaIndex(SHMInfo &_oShmInfo);

	static int querySvrsParamRelaMappingIDIndex(SHMInfo &_oShmInfo);
#line 843
	static int createSvrsParamListSHM(int _iExtenSzie = 0);

	static void unloadSvrsParamListSHM();

	static int loadSvrsParamListData();

	static void clearSvrsParamListSHM() {
		m_pSHMMgrSrvsParamListData->clear();
		m_pSHMMgrSrvsParamListindex->empty();
	}

	static void detachSvrsParamListSHM() {
		m_pSHMMgrSrvsParamListData->close();
		m_pSHMMgrSrvsParamListindex->close();
	}

	static int querySvrsParamListData(SHMInfo &_oShmInfo);

	static int querySvrsParamListIndex(SHMInfo &_oShmInfo);
#line 864
	static int createSvrsRegisterSHM(int _iExtenSzie = 0);

	static void unloadSvrsRegisterSHM();

	static int loadSvrsRegisterData();

	static void clearSvrsRegisterSHM() {
		m_pSHMMgrSrvsRegisterData->clear();
		m_pSHMMgrSrvsRegisterindex->empty();
		m_pSHMMgrSrvsRegisterSvrInsIDIndex->empty();
	}

	static int detachSvrsRegisterSHM() {
		m_pSHMMgrSrvsRegisterData->close();
		m_pSHMMgrSrvsRegisterindex->close();
		m_pSHMMgrSrvsRegisterSvrInsIDIndex->close();
	};

	static int querySvrsRegisterData(SHMInfo &_oShmInfo);

	static int querySvrsRegisterIndex(SHMInfo &_oShmInfo);
	static int querySvrsRegisterInsIDIndex(SHMInfo &_oShmInfo);
#line 889
	static int createParamInsListSHM(int _iExtenSzie = 0);

	static void unloadParamInsListSHM();

	static int loadParamInsListData();

	static void clearParamInsListSHM() {
		m_pSHMMgrParamInsListData->clear();
		m_pSHMMgrParamInsListindex->empty();
		m_pSHMMgrParamInsListMapIDindex->empty();
	}

	static int detachParamInsListSHM() {
		m_pSHMMgrParamInsListData->close();
		m_pSHMMgrParamInsListindex->close();
		m_pSHMMgrParamInsListMapIDindex->close();
	};

	static int queryParamInsListData(SHMInfo &_oShmInfo);

	static int queryParamInsListIndex(SHMInfo &_oShmInfo);

	static int queryParamInsListMapIDIndex(SHMInfo &_oShmInfo);
#line 914
	static int createSgwEnumAreaSHM(int _iExtenSzie = 0);

	static void unloadSgwEnumAreaSHM();

	static int loadSgwEnumAreaData();

	static void clearSgwEnumAreaSHM() {
		m_pSHMMgrSgwEnumAreaData->clear();
		m_pSHMMgrSgwEnumAreaindex->empty();
		m_pSHMMgrSgwEnumAreaOrgIDindex->empty();
	}

	static int detachSgwEnumAreaSHM() {
		m_pSHMMgrSgwEnumAreaData->close();
		m_pSHMMgrSgwEnumAreaindex->close();
		m_pSHMMgrSgwEnumAreaOrgIDindex->close();
	};

	static int querySgwEnumAreaData(SHMInfo &_oShmInfo);

	static int querySgwEnumAreaIndex(SHMInfo &_oShmInfo);

	static int querySgwEnumAreaOrgIDIndex(SHMInfo &_oShmInfo);

public:

	static long changekey(const char *_skey,int _iModValue);

	static unsigned long trim(const char *sHead);

};
#line 16 "/cbilling/app/petri/src/app_dataio/SHMParamStruct.h"
using namespace std;
#line 42
class DataIOBase{
public:
		void trimN( string& str )
		{
		     if(str.size() <= 0)
		        return;
		     string::iterator pos = str.end()-1;
		     for( ; pos >= str.begin() ; )
		     {
		        if( *pos == ' ' || *pos == '\t' || *pos == '\n' || *pos == '\r' )
		        {
		           str.erase(pos);
		           pos = str.end()-1;
		        }
		        else
		           break;
		     }
		     pos = str.begin();
		     for( ; pos < str.end() ; )
		     {
		        if(*pos == ' '||*pos == '\t'||*pos == '\n'||*pos == '\r')
		        {
		           str.erase(pos);
		           pos = str.begin();
		        }
		        else
		           break;
		     }
		}    
		bool getUsrName(char *m_sUsrName){     
		     memset(m_sUsrName,'\0',strlen(m_sUsrName));
		     FILE *pFile;
		     if( (pFile = popen("whoami", "r")) == 0){
		        return false;
		     }
		     if(!fgets(m_sUsrName, sizeof(m_sUsrName), pFile)){
		        return false;
		     }
		     pclose(pFile);
		     if(m_sUsrName[0] != '\0'){
		            string str(m_sUsrName);
		            trimN(str);
		            memset(m_sUsrName,'\0',strlen(m_sUsrName));
		            strcpy(m_sUsrName,(char*)str.c_str());
		     }
		     if(m_sUsrName[0] != '\0')
		            return true;
		     else
		            return false;
		}   
};
#line 9 "/cbilling/app/petri/src/app_dataio/DataExportor.h"
class DataExportor:DataIOBase
{
public:
    int g_argc;
    char **g_argv;
    char* m_sMemTable;               
    char* m_sDbTable;                
    char* m_sFileName;               
    char m_sUsrName[512];            
    int m_iMode;                     
    bool m_bIgnore;                  
    int m_iTableType;
    HashList<int> *m_phList;         
    ThreeLogGroup *m_poLogGroup;
    CommandCom *m_poCommandCom;
public:
    DataExportor(int argc, char **argv);
    ~DataExportor();
    int run();

private:
    void reset();
    void init();
    void printUsage();
    bool prepare();
};
#line 19 "/cbilling/app/petri/src/app_dataio/SHMParamInfo.h"
class SHMParamInfo:DataIOBase
{
public:

    SHMParamInfo();

    ~SHMParamInfo();    
    static int openSHM(int iTableType,bool lShow,bool bIfCrt=false);
    static int closeSHM();

private:
    static int openStreamControl(bool lShow, bool bIfCrt);
    static int openContext(bool lShow, bool bIfCrt);
    static int openS_MSG_MAP_INFO(bool lShow, bool bIfCrt);
    static int openServiceContextList(bool lShow, bool bIfCrt);
    static int openStreamControlInfo(bool lShow, bool bIfCrt);
    static int openUserInfo(bool lShow, bool bIfCrt);
    static int openSgwSlaQueue(bool lShow, bool bIfCrt);
    static int openNetInfo(bool lShow, bool bIfCrt);
    static int openSession(bool lShow, bool bIfCrt);
    static int openShmCongestLevel(bool lShow, bool bIfCrt);

    static int openBaseMethod(bool lShow, bool bIfCrt);
    static int openSPCCA(bool lShow, bool bIfCrt);    
    static int openS_PACKET_SESSION(bool lShow, bool bIfCrt);   
    static int openSPNode(bool lShow, bool bIfCrt);   
    static int openSPRoute(bool lShow, bool bIfCrt);    
    static int openSPRouteCCR(bool lShow, bool bIfCrt);     
    static int openSPJudge(bool lShow, bool bIfCrt);   

    static int openSCMsg(bool lShow, bool bIfCrt);	 
    static int openCSPVariable(bool lShow, bool bIfCrt);
    static int openCSPFunc(bool lShow, bool bIfCrt);  

    static int openServiceCLBaseData(bool lShow, bool bIfCrt); 
    static int openLoadBalanceData(bool lShow, bool bIfCrt); 
    static int openST_WF_PROCESS_MQ(bool lShow, bool bIfCrt);  
    static int openPortInfo(bool lShow, bool bIfCrt);      
public:    

    static SHMData<StreamControlData> *m_poStreamControlData;
    static SHMIntHashIndex_A       *m_poStreamControlIndex;
    static CSemaphore* m_poStreamControlLock;
#line 64
    static SHMData<ContextData> *m_poContextData;

    static CSemaphore* m_poContextLock;
#line 69
    static SHMData<SMsgMapInfo> *m_poS_MSG_MAP_INFOData;
    static SHMIntHashIndex       *m_poS_MSG_MAP_INFOIndex;
    static CSemaphore* m_poS_MSG_MAP_INFOLock;
#line 74
    static SHMData<ServiceContextListData> *m_poServiceContextListData;
    static SHMIntHashIndex_A       *m_poServiceContextListIndex;
    static CSemaphore* m_poServiceContextListLock;
#line 79
    static SHMData<StreamControlInfo> *m_poStreamControlInfoData;
    static SHMIntHashIndex_A       *m_poStreamControlInfoIndex;  
    static CSemaphore* m_poStreamControlInfoLock;
#line 84
    static SHMData<UserInfoData> *m_poUserInfoData;
    static SHMIntHashIndex_A       *m_poUserInfoIndex;  
    static SHMIntHashIndex_A  *m_poUserInfoIndex_A;  
    static CSemaphore* m_poUserInfoLock;
#line 90
    static SHMData<SgwSlaQueue> *m_poSgwSlaQueueData;
    static SHMIntHashIndex_A       *m_poSgwSlaQueueIndex;    
    static CSemaphore* m_poSgwSlaQueueLock;
#line 95
    static SHMData<NetInfoData> *m_poNetInfoData;
    static SHMIntHashIndex       *m_poNetInfoIndex;     
    static SHMIntHashIndex_A  *m_poNetInfoIndex_S;
    static CSemaphore* m_poNetInfoLock;
#line 101
    static SHMData<SessionData> *m_poSessionData;
    static SHMIntHashIndex_A       *m_poSessionIndex;   
    static CSemaphore* m_poSessionLock;
#line 106
    static SHMData<CongestLevel> *m_poShmCongestLevelData;

    static CSemaphore* m_poShmCongestLevelLock;
#line 111
    static SHMData<CBaseMethod> *m_poShmBaseMethodData;
    static SHMIntHashIndex_A  *m_poShmBaseMethodIndex;
    static CSemaphore* m_poShmBaseMethodLock;
#line 116
    static SHMData<CServicePackageCCA> *m_poShmSPCCAData;
    static SHMIntHashIndex_A       *m_poShmSPCCAIndex;    
    static SHMIntHashIndex  *m_poShmSPCCAIndex_A;
    static CSemaphore* m_poShmSPCCALock;
#line 122
    static SHMData<SPacketSession> *m_poShmS_PACKET_SESSIONData;
    static SHMIntHashIndex_A      *m_poShmS_PACKET_SESSIONIndex;  
	  static SHMIntHashIndex_A  *m_poShmS_PACKET_SUB_SESSIONIndex;  
    static CSemaphore* m_poShmS_PACKET_SESSIONLock;
#line 128
    static SHMData<ServicePackageNode> *m_poShmSPNodeData;
	  static SHMIntHashIndex_A  *m_poShmSPNodeIndex;
	  static SHMIntHashIndex     *m_poShmSPNodeIndex_A;    
    static CSemaphore* m_poShmSPNodeLock;
#line 134
    static SHMData<ServicePackageRoute> *m_poShmSPRouteData;
	  static SHMIntHashIndex_A  *m_poShmSPRouteIndex;
	  static SHMIntHashIndex     *m_poShmSPRouteIndex_A;    
    static CSemaphore* m_poShmSPRouteLock;
#line 140
    static SHMData<CServicePackageRouteCCR> *m_poShmSPRouteCCRData;
	  static SHMIntHashIndex  *m_poShmSPRouteCCRIndex;
	  static SHMIntHashIndex  *m_poShmSPRouteCCRIndex_A;   
    static CSemaphore* m_poShmSPRouteCCRLock;
#line 146
    static SHMData<CServicePackageJudge> *m_poShmSPJudgeData;
	  static SHMIntHashIndex  *m_poShmSPJudgeIndex;
	  static SHMIntHashIndex  *m_poShmSPJudgeIndex_A;    
    static CSemaphore* m_poShmSPJudgeLock;
#line 152
    static SHMData<CServicePackageFunc> *m_poShmCSPFuncData;
	  static SHMIntHashIndex  *m_poShmCSPFuncIndex;	  
    static CSemaphore* m_poShmCSPFuncLock;
#line 157
    static SHMData<StatisticsCongestMsg> *m_poShmSCMsgData;
	  static SHMIntHashIndex_A  *m_poShmSCMsgIndex;	
    static CSemaphore* m_poShmSCMsgLock;
#line 162
    static SHMData<CServicePackageVariable> *m_poShmCSPVariableData;
	  static SHMIntHashIndex  *m_poShmCSPVariableIndex;		  	 
    static CSemaphore* m_poShmCSPVariableLock;
#line 167
    static SHMData<ServiceContextListBaseData> *m_poShmServiceCLBaseData;
	  static SHMIntHashIndex_A  *m_poShmServiceCLBaseIndex;		  	 
    static CSemaphore* m_poShmServiceCLBaseLock;   

    static SHMData<ST_WF_PROCESS_MQ> *m_poShmWf_Process_MqData;
	  static SHMIntHashIndex  *m_poShmWf_Process_MqIndex;		  	 
    static CSemaphore* m_poShmWf_Process_MqLock;   
#line 179
    static SHMData<PortInfo> *m_poShmPortInfoData;
	  static SHMIntHashIndex_A  *m_poShmPortInfoIndex;		  	 
    static CSemaphore* m_poShmPortInfoLock;    
};
#line 9 "/cbilling/app/petri/src/app_dataio/SHMInfoCtl.h"
struct MinNbrStruct
{
    char m_sMinNbr[16];    
};

class SHMInfoCtl:DataIOBase
{
public:
    static unsigned int getCount(int iTableType);
    static bool getStreamControlData(StreamControlData **pData,int iPos)
    {
        *pData = (*(SHMParamInfo::m_poStreamControlData)) + iPos;
	  		return true;
    };
    static bool getContextData(ContextData **pData,int iPos)
    {
        *pData = (*(SHMParamInfo::m_poContextData)) + iPos;
	  		return true;
    };
    static bool getS_MSG_MAP_INFOData(SMsgMapInfo **pData,int iPos)
    {
        *pData = (*(SHMParamInfo::m_poS_MSG_MAP_INFOData)) + iPos;
	  		return true;
    };
    static bool getServiceContextListData(ServiceContextListData **pData,int iPos)
    {
        *pData = (*(SHMParamInfo::m_poServiceContextListData)) + iPos;
	  		return true;
    };	
     static bool getStreamControlInfoData(StreamControlInfo **pData,int iPos)
    {
        *pData = (*(SHMParamInfo::m_poStreamControlInfoData)) + iPos;
	  		return true;
    };
    static bool getUserInfoData(UserInfoData **pData,int iPos)
    {
        *pData = (*(SHMParamInfo::m_poUserInfoData)) + iPos;
	  		return true;
    };
    static bool getSgwSlaQueueData(SgwSlaQueue **pData,int iPos)
    {
        *pData = (*(SHMParamInfo::m_poSgwSlaQueueData)) + iPos;
	  		return true;
    };
    static bool getNetInfoData(NetInfoData **pData,int iPos)
    {
        *pData = (*(SHMParamInfo::m_poNetInfoData)) + iPos;
	  		return true;
    };
    static bool getSessionData(SessionData **pData,int iPos)
    {
        *pData = (*(SHMParamInfo::m_poSessionData)) + iPos;
	  		return true;
    };
    static bool getShmCongestLevelData(CongestLevel **pData,int iPos)
    {
        *pData = (*(SHMParamInfo::m_poShmCongestLevelData)) + iPos;
	  		return true;
    };	   
    static bool getShmBaseMethodData(CBaseMethod **pData,int iPos)
    {
        *pData = (*(SHMParamInfo::m_poShmBaseMethodData)) + iPos;
	  		return true;
	  }
    static bool getShmSPCCAData(CServicePackageCCA **pData,int iPos)
    {
        *pData = (*(SHMParamInfo::m_poShmSPCCAData)) + iPos;
	  		return true;
	  }
    static bool getShmS_PACKET_SESSIONData(SPacketSession **pData,int iPos)
    {
        *pData = (*(SHMParamInfo::m_poShmS_PACKET_SESSIONData)) + iPos;
	  		return true;
	  }
    static bool getShmSPNodeData(ServicePackageNode **pData,int iPos)
    {
        *pData = (*(SHMParamInfo::m_poShmSPNodeData)) + iPos;
	  		return true;
	  }
    static bool getShmSPRouteData(ServicePackageRoute **pData,int iPos)
    {
        *pData = (*(SHMParamInfo::m_poShmSPRouteData)) + iPos;
	 			return true;
	  }
    static bool getShmSPRouteCCRData(CServicePackageRouteCCR **pData,int iPos)
    {
        *pData = (*(SHMParamInfo::m_poShmSPRouteCCRData)) + iPos;
	  		return true;
	  }
    static bool getShmSPJudgeData(CServicePackageJudge **pData,int iPos)
    {
        *pData = (*(SHMParamInfo::m_poShmSPJudgeData)) + iPos;
	  		return true;	 
	  }
    static bool getShmStatisticsCongestMsgData(StatisticsCongestMsg **pData,int iPos)
    {
        *pData = (*(SHMParamInfo::m_poShmSCMsgData)) + iPos;
	  		return true;	 
	  }
    static bool getShmCSPVariableData(CServicePackageVariable **pData,int iPos)
    {
        *pData = (*(SHMParamInfo::m_poShmCSPVariableData)) + iPos;
	  		return true;	 
	  }
    static bool getShmCSPFuncData(CServicePackageFunc **pData,int iPos)
    {
        *pData = (*(SHMParamInfo::m_poShmCSPFuncData)) + iPos;
	  		return true;	 
	  }
    static bool getShmServiceCLBaseData(ServiceContextListBaseData **pData,int iPos)
    {
        *pData = (*(SHMParamInfo::m_poShmServiceCLBaseData)) + iPos;
	  		return true;
    };
#line 130
    static bool getShmST_WF_PROCESS_MQData(ST_WF_PROCESS_MQ **pData,int iPos)
    {
        *pData = (*(SHMParamInfo::m_poShmWf_Process_MqData)) + iPos;
	  		return true;
    };	  
    static bool getShmPortInfoData(PortInfo **pData,int iPos)
    {
        *pData = (*(SHMParamInfo::m_poShmPortInfoData)) + iPos;
	  		return true;
    };	      	  	  	  	  	          
public:
		static int create();    
		static void showStreamControlData(StreamControlData &pData);
		static void showContextData(ContextData &pData);
		static void showS_MSG_MAP_INFOData(SMsgMapInfo &pData);
		static void showServiceContextListData(ServiceContextListData &pData);
		static void showStreamControlInfoData(StreamControlInfo &pData);
		static void showUserInfoData(UserInfoData &pData);
		static void showSgwSlaQueueData(SgwSlaQueue &pData);
		static void showNetInfoData(NetInfoData &pData);
		static void showSessionData(SessionData &pData);
		static void showShmCongestLevelData(CongestLevel &pData);	

		static void showBaseMethodData(CBaseMethod &pData);	
		static void showSPCCAData(CServicePackageCCA &pData);			
		static void showS_PACKET_SESSIONData(SPacketSession &pData);	
		static void showSPNodeData(ServicePackageNode &pData);	
		static void showSPRouteData(ServicePackageRoute &pData);	
		static void showSPRouteCCRData(CServicePackageRouteCCR &pData);	
		static void showSPJudgeData(CServicePackageJudge &pData);

		static void showSCMsgData(StatisticsCongestMsg &pData);
		static void showCSPVariableData(CServicePackageVariable &pData);
		static void showCSPFuncData(CServicePackageFunc &pData);

    static void showST_WF_PROCESS_MQData(ST_WF_PROCESS_MQ &pData);	

    static void showServiceCLBaseData(ServiceContextListBaseData &pData);	
    static void showPortInfoData(PortInfo &pData);				

		static bool loadStreamControl(StreamControlData *pData,bool *bNew,bool bReplace);
		static bool loadContext(ContextData *pData,bool *bNew,bool bReplace);
		static bool loadS_MSG_MAP_INFO(SMsgMapInfo *pData,bool *bNew,bool bReplace);
		static bool loadServiceContextList(ServiceContextListData *pData,bool *bNew,bool bReplace);
		static bool loadStreamControlInfo(StreamControlInfo *pData,bool *bNew,bool bReplace);
		static bool loadUserInfo(UserInfoData *pData,bool *bNew,bool bReplace);
		static bool loadSgwSlaQueue(SgwSlaQueue *pData,bool *bNew,bool bReplace);
		static bool loadNetInfo(NetInfoData *pData,bool *bNew,bool bReplace);
		static bool loadSession(SessionData *pData,bool *bNew,bool bReplace);
		static bool loadShmCongestLevel(CongestLevel *pData,bool *bNew,bool bReplace);

		static bool loadBaseMethod(CBaseMethod *pData,bool *bNew,bool bReplace);
		static bool loadSPCCA(CServicePackageCCA *pData,bool *bNew,bool bReplace);			
		static bool loadS_PACKET_SESSION(SPacketSession *pData,bool *bNew,bool bReplace);
		static bool loadSPNode(ServicePackageNode *pData,bool *bNew,bool bReplace);		
		static bool loadSPRoute(ServicePackageRoute *pData,bool *bNew,bool bReplace);		
		static bool loadSPRouteCCR(CServicePackageRouteCCR *pData,bool *bNew,bool bReplace);		
		static bool loadSPJudge(CServicePackageJudge *pData,bool *bNew,bool bReplace);	

		static bool loadStatisticsCongestMsg(StatisticsCongestMsg *pData,bool *bNew,bool bReplace);	
		static bool loadCSPVariable(CServicePackageVariable *pData,bool *bNew,bool bReplace);	
		static bool loadCSPFunc(CServicePackageFunc *pData,bool *bNew,bool bReplace);		

		static bool loadST_WF_PROCESS_MQ(ST_WF_PROCESS_MQ *pData,bool *bNew,bool bReplace);

    static bool loadServiceCLBaseData(ServiceContextListBaseData *pData,bool *bNew,bool bReplace);		

    static bool loadPortInfo(PortInfo *pData,bool *bNew,bool bReplace);		
};
#line 16 "/cbilling/app/petri/src/app_dataio/FileMgr.h"
const char  FILEMGR_TRANS_NULL     ='0';
const char  FILEMGR_TRANS_CHAR     ='1';
const char  FILEMGR_TRANS_INT      ='2';
const char  FILEMGR_TRANS_LONG     ='3';
const char  FILEMGR_TRANS_FLOAT    ='4';
const char  FILEMGR_TRANS_DOUBLE   ='5';
const char  FILEMGR_TRANS_STRING   ='6';
const char  FILEMGR_TRANS_EVTDATE  ='7';
const char  FILEMGR_TRANS_BOOL     ='8';

class FileMgr:DataIOBase {
public:
    FileMgr(int iMode);
    ~FileMgr();
    int  m_iTotalCnt;                            
    char m_sFilePath[500];                       
    char m_sFileName[256];                       
    char m_sMemName[256];                        
    char m_sUsrName[512];                        
    char m_sDivChar;                             
    char m_sChaChar;                             
    int  m_iTableType ;                          
    bool m_iLogType;                             
    int  m_iMode;                                
#line 42
    int m_iFileFieldCnt;
    char m_sFileTransType[128];             
    int m_iFileFieldOffSet[128];            
    int m_iFileFieldLen[128];               
    char m_sFileFieldInfo[4096];                  
    unsigned int m_iDataStructSize ;
    char *m_sData;                                
    FILE *fp;                                     
    ThreeLogGroup *m_poLogGroup;

public:
    int create(int iTableType,bool lShow);
    int attach(int iTableType,bool lShow);
    void resetInfo();
    bool setColumnInfo(const char *sColumn, const int iTableType);
    void writeFieldBuf(const char* sColumn, const char cTransType,
                  unsigned int iFieldOffset, unsigned int iFieldMaxLen);

    void init(int iMode);
    bool openPath(const char* sPathName);
    bool openFile(const char *sFullFileName, char *sMode);                       
    bool closeFile();
    bool getLine(char *sLine, const size_t iSize, const char cFlag);

    bool setColumnInfo(const int iTableType);
    bool checkColumn(char *sColumn);
    bool fileToMem(const char * sFileName, const int iTableType,bool bShow,bool bReplace = false,bool lShow = true);
    bool flushToMem(char *sData, bool bShow,bool *bNew,bool bReplace);
    bool parseString(char *sData);
    bool writePair(void **sDes, const char *sSrc, const char cTransType, 
                   const int iOffSet, const int iFieldLen);

    bool memToFile(const char * sFileName, const int iTableType,bool bShow,bool lShow = true);     
    bool openDbFile(const char* sFullFileName);
    bool writeHeadInfo();
    bool writeFileData(char * sData, int iDataLen );
    bool addData(char *sData, int iCnt);
    void setDataStructSize(size_t iSize){
        m_iDataStructSize = iSize;
    };
    void trimN( string& str );
    void setMemName(int m_iTableType);
    void setFilePath(char * sFilePath){
        strcpy(m_sFilePath, sFilePath);
    };
    char* getFilePath(){
        return m_sFilePath;
    };
    void setLogType(){
    	  m_iLogType = true;
    }
    void setFileName(const char * sFileName){
        strcpy(m_sFileName, sFileName);
    };
    char* getFileName(){
        return m_sFileName;
    };

    void setTableType(const int iTableType){
        m_iTableType = iTableType;
    };

    char getDivChar() {
        return m_sDivChar ;
    };
};
#line 19 "../app_tools/CheckPointMgr.h"
class ThreeLogGroup;
class ThreeLogGroupMgr;
#line 25
class CheckPointMgr
{
    public:
            CheckPointMgr();
            ~CheckPointMgr();
			bool touchInfoDown();
            bool touchInfoDown(bool Show,bool RealTime=false); 
			char *getCharBatchID();

			bool touchInfoDown(int iAppID); 
            bool touchInfoDown(char *sBatchID); 
#line 39
			bool touchInfoLoad(char *sBatch);
#line 43
			bool touchInfoLoad(char *sBatch, int iAppID);
#line 46
			bool getCheckPointPath(char *sRootPath);

			bool getDatePath(char *sBatch);

			bool  CheckFilePath (char * filepath,bool Show,char *m_sUsrName);
			bool FlushBatach(char * sBatch);
	public:  
			long getLongBatchID();
			long getBatchID(); 	
			bool getWebFlag(int iFdFront)
			{
				m_iFdFront = iFdFront;
			}
    public: 

            void showBatchBaseInfo(char *sBatch);

			bool FileExist(char *sFileName);   
			void getBatch();      
    private:
            FileMgr *m_poFileMgr;
            ThreeLogGroupMgr *m_poLogGroup;
            char m_sBatchID[32];  
			char m_sPath[1024];
            long m_lBatchID;
            int m_iFdFront;
#line 74
			char sHFKey[128];
			char sHFKeyName[128];
			char sHFFileName[1024];			      

			void formatInt(int iNum,char *sStdInt);
			char sStdInt[4+1];
			ThreeLogGroup *m_poLog;
			CheckPointInfo *m_poCheckPointInfo;     		     
};
#line 12 "Logg.h"
class LoggMgr
{
 public:

    LoggMgr();
    ~LoggMgr();

    int run();

 private:

    bool init();
    bool deal();
    bool prepare();

    bool AnalyzesParam(char *sParam,char *sReturn);
    bool CheckParamName();
    bool DisplayInfo(int iMode);

    void printUsage();

    static bool GetField(int iSeq,char *sBuf,char *sParam);
    static bool GreaterMark(const string & s1, const string & s2);

    bool CheckProcessId(int iProcessID);
    bool CheckAppId(int iAppID);

    int  m_iMode;
    int  m_iGroupId;

    char m_sPath[500];
    char m_sParam[100];
    char m_sFileName[500];
    char m_sParamFile[500];

    bool m_bPigeonhole;                      
    bool m_bParamErr;

    ThreeLogGroup * m_poLogg;                
    ThreeLogGroupMgr * m_poLoggMgr;          
    ReadIni * m_RD;                          
   CommandCom *m_pCommandComm;              

    int m_iNum;
    CheckPointMgr *pPoint;
};
#line 5 "Logg.cpp"
int g_argc;
char ** g_argv;

LoggMgr::LoggMgr():m_iMode(0),m_iGroupId(-1),m_poLoggMgr(0),m_poLogg(0)
                    ,m_bPigeonhole(false),m_bParamErr(false),m_RD(0)
{
    memset(m_sParam,'\0',sizeof(m_sParam));
    memset(m_sPath,'\0',sizeof(m_sPath));
    memset(m_sFileName,'\0',sizeof(m_sFileName));
    memset(m_sParamFile,'\0',sizeof(m_sParamFile));

    m_RD = new ReadIni();
    m_iNum=0;
#line 21
   pPoint = 0;
}

LoggMgr::~LoggMgr()
{
    if(m_poLoggMgr)
    {
        delete m_poLoggMgr;
        m_poLoggMgr = 0;
    }
    if(m_poLogg)
    {
        delete m_poLogg;
        m_poLogg = 0;
    }
    if(m_RD)
    {
        delete m_RD;
        m_RD = 0;
    }
    if(pPoint)
    {
    	delete pPoint;
    	pPoint=0;
    }
    DisplayLogg::m_vAppInfo.clear();
    DisplayLogg::m_vProInfo.clear();
    DisplayLogg::m_vAlarmInfo.clear();
    DisplayLogg::m_vParamInfo.clear();
    DisplayLogg::m_vSystemInfo.clear();
    DisplayLogg::m_vSysOperInfo.clear();
}
#line 62
void LoggMgr::printUsage()
{
    cout << endl << endl;
    cout << "*********************************************************************************" << endl;
    cout << "                                  :                                    " <<endl;  
    cout << "sgwlog" << " "  << "-param   [parameter] :                    []"<<endl;
    cout << "sgwlog" << " "  << "-process [process] :                      [ID]"<<endl;
    cout << "sgwlog" << " "  << "-module  [module] :                       [ID]"<<endl;
    cout << "sgwlog" << " "  << "-class   [class] :                        [ID]"<<endl;
    cout << "sgwlog" << " "  << "-level   [level] :                        [ID]"<<endl;

    cout << endl;
    cout << "                                  :                                    " <<endl;
    cout << "sgwlog" << " "  << "-c :                                      " << endl;
    cout << "sgwlog" << " "  << "-f :                                      " << endl;
    cout << "sgwlog" << " "  << "-a :                                      " << endl;
    cout << "sgwlog" << " "  << "-b groupid path() :   " << endl;
    cout << "sgwlog" << " "  << "-d groupid filename :                     " << endl;
    cout << "sgwlog" << " "  << "-e param :                                " << endl;
    cout << "sgwlog" << " "  << "-i groupid path() :         " << endl;

    cout << "sgwlog" << " "  << "-l (groupid)(groupid) :     (/)" << endl;
    cout << "sgwlog" << " "  << "-s groupid() :        " << endl;
    cout << "*********************************************************************************" << endl;
    cout << endl << endl;
    return ;
}
#line 97
bool LoggMgr::AnalyzesParam(char * sParam, char * sReturn)
{
    if(!sParam)
        return true;
    char *p = strchr(sParam,'[');
    if(!p)
    {
        char *m = strchr(sParam,'-');
        if(!m)
            strcpy(sReturn,sParam);
        return true;
    }
    p++;
    char *q = strchr(sParam,']');
    if(!q)
        return false;
    strncpy(sReturn,p,q-p);
    return true;
}
#line 124
bool LoggMgr::CheckParamName()
{
  if(!m_pCommandComm )
    {
        m_pCommandComm = new CommandCom();
        if(!m_pCommandComm->InitClient())
        {
            Log::log(0,"");
        }	
    }
    char ParamSec[50],ParamKey[50];

    memset(ParamSec,0,sizeof(ParamSec));
    memset(ParamKey,0,sizeof(ParamKey));

    char *p = strchr(m_sParam,'.');
    if(!p)
    {
        return false;
    }
    strncpy(ParamSec,m_sParam,p-m_sParam);
    p++;
    strncpy(ParamKey,p,strlen(p));

    if(!m_pCommandComm)
    {
        return false;
    }
#line 155
    char sStr[128]={0};
    m_pCommandComm->readIniString(ParamSec,ParamKey,sStr,0);

	if(!strlen(sStr))return false;

    return true;
}
#line 170
bool LoggMgr::GetField(int iSeq, char *sBuf,char *sParam)
{
    if(!sBuf)
        return false;
    char *p = strchr((char *)sBuf,'|');
    char *p1= sBuf;
    int cnt = 1;
    while(p)
    {
        if(cnt==iSeq)
        {
            strncpy(sParam,p1,p-p1);
            break;
        }
        cnt++;
		p++;
		p1=p;
		p=strchr(p1,'|');
    }
    return true;
}
#line 199
bool LoggMgr::GreaterMark(const string & s1, const string & s2)
{
    char sFile1[320+1],sFile2[320+1];
    memset(sFile1,0,sizeof(sFile1));
    memset(sFile2,0,sizeof(sFile2));
    GetField(9,(char *)s1.c_str(),sFile1);
    GetField(9,(char *)s2.c_str(),sFile2);
    if(strcmp(sFile1,sFile2)>=0)
        return true;
    else 
        return false;
}
#line 219
bool LoggMgr::DisplayInfo(int iMode)
{
    int iLogType = 0,iLogClass = 0,iLevelId = 0;
    int iCondId=-1;
    switch(iMode)
    {
    case GROUPPARAM:
        iLogType = LOG_TYPE_PARAM;

        m_poLogg->GetInfoFromMem(DisplayLogg::m_vTypeParam,iMode,LOG_TYPE_PARAM,m_sParam);  
        break;

    case GROUPINFOLV:
        if(strlen(m_sParam))
        {
            iCondId = atoi(m_sParam);
            if(iCondId==LOG_LEVEL_FATAL)
               m_poLogg->GetInfoFromMem(DisplayLogg::m_vLevFatal,iMode,LOG_LEVEL_FATAL,m_sParam);  
            else if(iCondId==LOG_LEVEL_ERROR)
               m_poLogg->GetInfoFromMem(DisplayLogg::m_vLevError,iMode,LOG_LEVEL_ERROR,m_sParam);  
            else if(iCondId==LOG_LEVEL_WARNING)
              m_poLogg->GetInfoFromMem(DisplayLogg::m_vLevWarn,iMode,LOG_LEVEL_WARNING,m_sParam); 
            else if(iCondId==LOG_LEVEL_INFO)
               m_poLogg->GetInfoFromMem(DisplayLogg::m_vLevInfo,iMode,LOG_LEVEL_INFO,m_sParam);  
            else if(iCondId==LOG_LEVEL_DEBUG)
              m_poLogg->GetInfoFromMem(DisplayLogg::m_vLevDebug,iMode,LOG_LEVEL_DEBUG,m_sParam);                	 
            else
            	{
            	 printf("!\n\n");
            	 printf("    1:FATAL  2:ERROR  3:WARNGING  4:INFO  5:DEBUG \n");
               return false;   
              }     	
        }else{
             m_poLogg->GetInfoFromMem(DisplayLogg::m_vLevFatal,iMode,LOG_LEVEL_FATAL,m_sParam);  
             m_poLogg->GetInfoFromMem(DisplayLogg::m_vLevError,iMode,LOG_LEVEL_ERROR,m_sParam);  
             m_poLogg->GetInfoFromMem(DisplayLogg::m_vLevWarn,iMode,LOG_LEVEL_WARNING,m_sParam); 
             m_poLogg->GetInfoFromMem(DisplayLogg::m_vLevInfo,iMode,LOG_LEVEL_INFO,m_sParam);  
             m_poLogg->GetInfoFromMem(DisplayLogg::m_vLevDebug,iMode,LOG_LEVEL_DEBUG,m_sParam); 
        }
        break;    	    	
    case GROUPTYPE:
        if(strlen(m_sParam))
        {
            iCondId = atoi(m_sParam);
            if(iCondId==LOG_TYPE_BUSI)
               m_poLogg->GetInfoFromMem(DisplayLogg::m_vTypeBusi,iMode,LOG_TYPE_BUSI,m_sParam);  
            else if(iCondId==LOG_TYPE_PARAM)
               m_poLogg->GetInfoFromMem(DisplayLogg::m_vTypeParam,iMode,LOG_TYPE_PARAM,m_sParam);  
            else if(iCondId==LOG_TYPE_SYSTEM)
              m_poLogg->GetInfoFromMem(DisplayLogg::m_vTypeSystem,iMode,LOG_TYPE_SYSTEM,m_sParam); 
            else if(iCondId==LOG_TYPE_PROC)
               m_poLogg->GetInfoFromMem(DisplayLogg::m_vTypeStart,iMode,LOG_TYPE_PROC,m_sParam);  
            else if(iCondId==LOG_TYPE_DATEDB)
              m_poLogg->GetInfoFromMem(DisplayLogg::m_vTypeOracle,iMode,LOG_TYPE_DATEDB,m_sParam);                	 
            else
            	{
            	 printf("!\n \n");

            	 printf("    1:  2:  3:  4:  5: \n");
               return false;   
              }     	     	
        }else{
           m_poLogg->GetInfoFromMem(DisplayLogg::m_vTypeBusi,iMode,LOG_TYPE_BUSI,m_sParam);  
           m_poLogg->GetInfoFromMem(DisplayLogg::m_vTypeParam,iMode,LOG_TYPE_PARAM,m_sParam);  
           m_poLogg->GetInfoFromMem(DisplayLogg::m_vTypeSystem,iMode,LOG_TYPE_SYSTEM,m_sParam); 
           m_poLogg->GetInfoFromMem(DisplayLogg::m_vTypeStart,iMode,LOG_TYPE_PROC,m_sParam);  
           m_poLogg->GetInfoFromMem(DisplayLogg::m_vTypeOracle,iMode,LOG_TYPE_DATEDB,m_sParam);   
        }
        break;
    case GROUPMODULE:
    case GROUPPROCESS:        
       m_poLogg->GetInfoFromMem(DisplayLogg::m_vClaError,iMode,LOG_CLASS_ERROR,m_sParam);    
       m_poLogg->GetInfoFromMem(DisplayLogg::m_vClaWarn,iMode,LOG_CLASS_WARNING,m_sParam);    
       m_poLogg->GetInfoFromMem(DisplayLogg::m_vClaInfo,iMode,LOG_CLASS_INFO,m_sParam);  
       	break ;
    case GROUPCLASS:       	         	       		
        if(strlen(m_sParam))
        { 
            iCondId = atoi(m_sParam);
            if(iCondId==LOG_CLASS_ERROR)
               m_poLogg->GetInfoFromMem(DisplayLogg::m_vClaError,iMode,LOG_CLASS_ERROR,m_sParam);  
            else if(iCondId==LOG_CLASS_WARNING)
               m_poLogg->GetInfoFromMem(DisplayLogg::m_vClaWarn,iMode,LOG_CLASS_WARNING,m_sParam);  
            else if(iCondId==LOG_CLASS_INFO)
              m_poLogg->GetInfoFromMem(DisplayLogg::m_vClaInfo,iMode,LOG_CLASS_INFO,m_sParam);  
            else
            	{
            	 printf(".\n \n");
            	 printf("1:FATAL/ERROR  2:WARNGING  3:INFO/DEBUG\n");
               return false;   
              }    

        }
        else
        { 
            m_poLogg->GetInfoFromMem(DisplayLogg::m_vClaError,iMode,LOG_CLASS_ERROR,m_sParam);
            m_poLogg->GetInfoFromMem(DisplayLogg::m_vClaWarn,iMode,LOG_CLASS_WARNING,m_sParam);
            m_poLogg->GetInfoFromMem(DisplayLogg::m_vClaInfo,iMode,LOG_CLASS_INFO,m_sParam);
        }
        break;
    default:
        return false;
    }
#line 344
    DisplayLogg::LoggProcessMain(iMode,m_sParam);
    return true;
}
#line 355
bool LoggMgr::prepare()
{
    int i = 0;
    bool bErrParam = false,bHasNone = false,bNoSup = false;
    bool bFind = false;

    if(g_argc == 1)
    {
        printUsage();
        return true;
    }
    while(i<g_argc)
    {
        if(g_argv[i][0]!='-')
        {
            i++;
            continue;
        }
        bFind = true;
        int ilen = strlen(g_argv[i]);
        switch(g_argv[i][1])
        {
            case 'a':
                {
                    if(strcmp(g_argv[i],"-a")!=0)
                        bNoSup = true;
                    m_iMode = PIGEONHOLE;
                }
                break;
            case 'b':
                {
                    if(strcmp(g_argv[i],"-b")!=0)
                        bNoSup = true;
                    m_iMode = GROUPBAK;
                    if(g_argv[++i])
                    {
                         m_iGroupId = atoi(g_argv[i]);
                         if(m_iGroupId<1 ||m_iGroupId>6)
                            bErrParam= true;
                    }
                    else
                        m_iGroupId = -1;
                    if(g_argv[++i])
                        strcpy(m_sPath,g_argv[i]);
                }
                break;
            case 'c':
                {
                    if(strcmp(g_argv[i],"-c")==0)
                        m_iMode = GROUPCREAT;
                    else if(strncmp(g_argv[i],"-class",6)==0)
                    {
#line 409
                        m_iMode = GROUPTYPE;

                        AnalyzesParam(g_argv[g_argc-1],m_sParam);
                    }
                    else
                        bNoSup = true;
                    i++;
                }
                break;
            case 'd':
                {
                    if(strcmp(g_argv[i],"-d")!=0)
                        bNoSup = true;
                    m_iMode = GROUPDELETE;
                    if(g_argv[++i])
                    {
                        m_iGroupId = atoi(g_argv[i]);
                        if(m_iGroupId<1 ||m_iGroupId>6)
                            bErrParam = true;
                    }
                    else
                        bHasNone = true;
                    if(g_argv[++i])
                        strcpy(m_sFileName,g_argv[i]);
                    else
                        bHasNone = true;
                }
                break;
            case 'e':
                {
                    if(strcmp(g_argv[i],"-e")!=0)
                        bNoSup = true;
                    m_iMode = GROUPSET;
                    if(g_argv[++i])
                    {
                        m_bPigeonhole = atoi(g_argv[i]);
                        int phole = atoi(g_argv[i]);
                        if(phole<0 || phole>1)
                            bErrParam = true;
                    }
                    else
                        bHasNone = true;
                }
                break;
            case 'f':
                {
                    if(strcmp(g_argv[i],"-f")!=0)
                        bNoSup = true;
                    m_iMode = GROUPFREE;
                }
                break;
            case 'i':
                {
                    if(strcmp(g_argv[i],"-i")!=0)
                        bNoSup = true;
                    m_iMode = GROUPFILEADD;
                    if(g_argv[++i])
                    {
                        if(strcmp(g_argv[i],"all"))
                        {
                            m_iGroupId = atoi(g_argv[i]);
                            if(m_iGroupId<1 ||m_iGroupId>6)
                                bErrParam = true;
                        }
                        else
                            m_iGroupId = 0;
                    }
                    else
                        bHasNone = true;
                    if(g_argv[++i])
                        strcpy(m_sPath,g_argv[i]);
                }
                break;

            case 'g':
                {
                    if(strcmp(g_argv[i],"-g")!=0)
                        bNoSup = true;
                    m_iMode = GROUPADD;
                }
                break;
            case 'l':
                {
                    if(strncmp(g_argv[i],"-level",6)==0)
                    {
                        m_iMode = GROUPINFOLV;
                        AnalyzesParam(g_argv[g_argc-1],m_sParam);
                    }
                    else if(strcmp(g_argv[i],"-l")==0)
                    {
                        m_iMode = GROUPPRINTF;
                        if(g_argv[++i])
                        {
                        	if(i<g_argc) {
                            	m_iGroupId = atoi(g_argv[i]);
                            	if(m_iGroupId<1 ||m_iGroupId>6)
                                	bErrParam = true;   
                        	}
                        } 
                    }
                    else
                        bNoSup = true;
                    i++;
                }
                break;
            case 'p':
                {
                    if(strncmp(g_argv[i],"-param",6)==0)
                    {
                        m_iMode = GROUPPARAM;
                        AnalyzesParam(g_argv[g_argc-1],m_sParam);
                    }
                    else if(strncmp(g_argv[i],"-process",8)==0)
                    {
                        m_iMode = GROUPPROCESS;
                        AnalyzesParam(g_argv[g_argc-1],m_sParam);
                    }
                    else
                        bNoSup = true;
                    i++;
                }
                break;
            case 'r':
                {
                    if(strcmp(g_argv[i],"-reset")==0)
                       m_iMode = GROUPRESET;
                    if(g_argv[++i])
                    {
                         m_iGroupId = atoi(g_argv[i]);
                    }else{
                         m_iGroupId=0;
                     } 
#line 543
                }
                break;                
            case 's':
                {
                    if(strcmp(g_argv[i],"-s")==0)
                    {
                        m_iMode = GROUPQUIT;
                        if(g_argv[++i])
                        {
                            m_iGroupId = atoi(g_argv[i]);
                            if(m_iGroupId<1 ||m_iGroupId>6)
                                bErrParam = true;    
                        }                        
                    }
                    else if(strncmp(g_argv[i],"-stat",5)==0)
                        m_iMode = GROUPSTAT;
                    else
                        bNoSup = true;

                }
                break;
            case 'm':
                {
                    if(strncmp(g_argv[i],"-module",7)==0)
                    {
                        m_iMode = GROUPMODULE;
                        AnalyzesParam(g_argv[g_argc-1],m_sParam);
                    }
                    else
                        bNoSup = true;
                    i++;
                }
                break;
            case 't':
                {
                	if(strncmp(g_argv[i],"-type",6)==0)
                    {
                        m_iMode = GROUPTYPE;
                        AnalyzesParam(g_argv[g_argc-1],m_sParam);
                    }
                    else{
                      m_iMode = GROUPTEST;
                      AnalyzesParam(g_argv[g_argc-1],m_sParam);
                    }
                }
                break;
            default:
                {
                    Log::log(0,"");
                    printUsage();
                    return false;
                }
                break;
        }
        if(bHasNone==true)
        {
            Log::log(0,"()");
            return false;
        }
        if(bNoSup==true)
        {
            Log::log(0,"");
            return false;
        }
        if(bErrParam==true)
        {
            Log::log(0,"");
            return false; 
        }
        i++;
    }

    if(bFind==false)
    {
        printUsage();
        Log::log(0,"");
        return false;
    }
#line 623
    if(m_iMode == GROUPQUIT || m_iMode == PIGEONHOLE)
    {
    	pPoint= new CheckPointMgr();
    }

    return true;
}
#line 638
bool LoggMgr::init()
{
#line 642
        if(!m_RD)
        {
            Log::log(0,"");
            return false;
        }
        char *p;
        char sHome[500];
        memset(sHome,'\0',sizeof(sHome));
        if ((p=getenv ("SGW_HOME")) == 0)
            sprintf (sHome, "/opt/opthb/etc");
        else
            sprintf (sHome, "%s/etc", p);
        if(sHome[strlen(sHome)-1] == '/') 
            sprintf (m_sParamFile, "%ssgwconfig", sHome);
        else
            sprintf (m_sParamFile, "%s/sgwconfig", sHome);
#line 660
    if(m_iMode==GROUPCREAT || m_iMode==GROUPFREE || m_iMode==GROUPSTAT)
    {
        if(!m_poLoggMgr)
            m_poLoggMgr = new ThreeLogGroupMgr();

        long lCount = 0;

        m_iNum = m_RD->readIniInteger(m_sParamFile,"log","group_num",0);;

        lCount =  m_RD->readIniInteger(m_sParamFile,"memory","log_data_size",0);

        if(m_iNum<3)
        {
            Log::log(0,"");
            return false;
        }
        if(lCount<=0)
        {
            Log::log(0,"");
            return false;                    
        }
        m_poLoggMgr->setGroupNum(m_iNum);
        m_poLoggMgr->setGroupInfoDataCount(lCount);
    }
    else
    {
        if(!m_poLogg)
            m_poLogg = new ThreeLogGroup();
    }
#line 717
    return true;
}
#line 728
bool LoggMgr::deal()
{
    switch(m_iMode)
    {
        case GROUPCREAT:
            {
                if(m_poLoggMgr->create())
                    Log::log(0,"!");
                else
                    Log::log(0,"");

                if(!m_poLogg)
                    m_poLogg = new ThreeLogGroup(true);
                m_poLogg->InitLogGroup();
            }
            break;
        case GROUPFILEADD:
            {
                if(m_iGroupId==0)
                { 
                    int iGroupNum = m_poLogg->GetGroupNum();
                    for(int num=1;num<=iGroupNum;++num)
                    {
                        if(!m_poLogg->AddLogGroupFile(num,m_sPath,true))
                            Log::log(0,"");
                        if(!m_poLogg->AddLogGroupFile(num,m_sPath,true))
                            Log::log(0,"");
                    }
                    Log::log(0,"");
                }
                else
                {
                    if(m_poLogg->AddLogGroupFile(m_iGroupId,m_sPath,true))
                        Log::log(0,"");
                    else
                        Log::log(0,"");
                }
            }
            break;
        case GROUPBAK:
            {
                if(strlen(m_sPath)==0)
                {
                    char *pPath = m_poLogg->GetGroupBakPath();
                    strcpy(m_sPath,pPath);
                }
                m_poLogg->bakGroupFile(m_iGroupId,m_sPath);            
                Log::log(0,"");
            }
            break;
        case GROUPDELETE:
            {
                if(m_poLogg->ClearGroupFile(m_iGroupId,m_sFileName,true))
                    Log::log(0,"");
                else
                {
                    Log::log(0,"");
                    return false;
                }
            }
            break;
        case GROUPFREE:
            {
                if(m_poLoggMgr->remove())
                    Log::log(0,"!");
                else
                {
                    Log::log(0,"!");
                    return false;
                }
            }
            break;
        case GROUPPRINTF:
            {
                m_poLogg->DisplayLogGroup(m_iGroupId);
            }
            break;
        case GROUPQUIT:
            {
                int iGroupId = m_poLogg->GetUseGroup();
                if(m_poLogg->ChangeLogGroup(false,m_iGroupId)==true)
                {
                    Log::log(0,"!");
                    char stemp[200]={0};
                    int itempId = m_poLogg->GetUseGroup();
                    sprintf(stemp,"[logg] %d%d",iGroupId,itempId);
					Log::log(0,"%s",stemp);

                }
                else
                {
                    Log::log(0,"");

                    return false;
                }
                pPoint->touchInfoDown();
                printf("CHECKPOINT\n");
                m_poLogg->DisplayLogGroup(m_iGroupId); 
            }
            break;
        case GROUPSET:
            {
                if(m_poLogg->SetLogGroupPigeonhole(m_bPigeonhole))
                {
                    if(m_bPigeonhole==true)
                        Log::log(0,"");
                    else
                        Log::log(0,"");
                }
            }
            break;
        case PIGEONHOLE:
            {
                if(m_poLogg->ChangeLogGroup(true,m_iGroupId)==false)
                {
                    Log::log(0,"");
					m_poLogg->log(90101,LOG_LEVEL_WARNING,LOG_TYPE_SYSTEM,"sgwlog -a ");
                    return false;
                }
                else
                {
                	m_poLogg->log(90101,LOG_LEVEL_INFO,LOG_TYPE_SYSTEM,"sgwlog -a ");
                    Log::log(0,"");
                }
            }
                pPoint->touchInfoDown();
                printf("CHECKPOINT\n");
            break;
        case GROUPPARAM:
            {
                if(strlen(m_sParam))
                {
                    if(!CheckParamName())
                    {
                        printf("%s,sgwparam -list\n",m_sParam);
                        return false;
                    }
                }

                if(!DisplayInfo(m_iMode))
                {

                    return false;
                }
            }
            break;

        case GROUPMODULE:
        	    if(strlen(m_sParam))
                { 
                	 int iAppid=atoi(m_sParam) ;
                    if(!CheckAppId(iAppid))
                    {
                        printf("ModuleID%s,sgwstat -ses\n",m_sParam);
                        return false;
                    }
                }
                DisplayInfo(m_iMode);
               break ;
        case GROUPPROCESS:
        	    if(strlen(m_sParam))
                {
                	  int iProcessid=atoi(m_sParam) ;
                    if(!CheckProcessId(iProcessid))
                    {
                        printf("ProcessID%s,sgwstat -ses\n",m_sParam);
                        return false;
                    }
                }
                DisplayInfo(m_iMode);
               break ;        	
        case GROUPCLASS:        	
        case GROUPINFOLV:
        case GROUPTYPE:
            {
                if(!DisplayInfo(m_iMode))
                {

                    return false;
                }
            }
            break;
        case GROUPSTAT:
            {
#line 943
			m_poLoggMgr->showShmInfo();
            }
            break;
        case GROUPTEST:
            {
                int cnt = atoi(m_sParam);
                for(int i=0;i!=cnt;i++)
                {                
                    m_poLogg->log(1000,7,2,LOG_TYPE_PROC,0,"","7|1000|2|1|10|0|888|OcpTranMgr.cpp|20110628151814|||0|0||\n");
                    m_poLogg->log(1000,7,2,LOG_TYPE_PROC,0,"LOG.log_info_level","7|1000|2|2|10|0|888|OcpTranMgr.cpp|20110628151814|LOG.log_info_level||0|0||\n");
                    m_poLogg->log(1000,7,2,LOG_TYPE_PROC,0,"","7|1000|2|3|10|0|888|OcpTranMgr.cpp|20110628151815|||0|0||\n");
                    m_poLogg->log(1000,7,2,LOG_TYPE_PROC,0,"","7|1000|2|4|10|0|888|OcpTranMgr.cpp|20110628151812|||0|0||\n");
                    m_poLogg->log(1000,7,2,LOG_TYPE_PROC,0,"","7|1000|2|5|10|0|888|OcpTranMgr.cpp|20110628151816|||0|0||\n");
                }
            }
            break;
        case GROUPRESET:
            {
                if(m_iGroupId==0)
                { 
                    int iGroupNum = m_poLogg->GetGroupNum();
                    for(int num=1;num<=iGroupNum;++num)
                    {
                        if(!m_poLogg->CallBackInfo(num))
                            printf("[%d]\n",num);
                    }
                    printf("\n");
                }
                else
                {
                     if(!m_poLogg->CallBackInfo(m_iGroupId))
                         printf("[%d]\n",m_iGroupId);
                    else
                         printf("\n");
                }
            }
        	 break ;
        default:
            break;
    }
    return true;
}
#line 993
int LoggMgr::run()
{
    if(!prepare())
    {
        Log::log(0,"sgwlog");
        return -2;
    }
    if(m_iMode==0)
        return 0;
    if(!init())
    {
        Log::log(0,"sgwlog");
        return -1;
    }
    if(!deal())
    {
        Log::log(0,"sgwlog");
        return -3;
    }
    return 0;
}
#line 1040
bool LoggMgr::CheckProcessId(int iProcessID)
{
	try{
		char sSqlcode[512]={0};

	  TOCIQuery qry (Environment::getDBConn());
	  sprintf (sSqlcode, "select a.process_id "
  						         "from wf_process a "
 						           "where  a.Process_Id =%d ",iProcessID);
	  qry.setSQL(sSqlcode);
	  qry.open();
	  if (qry.next()) return true ;

	  return false;
	}
	catch(TOCIException &e) 
	{
		ThreeLogGroup Log;
		if(e.getErrCode()==12)
			Log.log(12,LOG_LEVEL_FATAL,LOG_TYPE_SYSTEM,e.getErrMsg());
		if(e.getErrCode()==141)
			Log.log(141,LOG_LEVEL_FATAL,LOG_TYPE_SYSTEM,e.getErrMsg());
	}

}	
#line 1073
bool LoggMgr::CheckAppId(int iAppID)
{
	try{
		char sSqlcode[512]={0};

	  TOCIQuery qry (Environment::getDBConn());
	  sprintf (sSqlcode, "select a.app_id "
  						         "from wf_application a "
 						           "where  a.app_id =%d ",iAppID);
	  qry.setSQL(sSqlcode);
	  qry.open();
	  if (qry.next()) return true ;

	  return false;
	}
	catch(TOCIException &e) 
	{
		ThreeLogGroup Log;
		if(e.getErrCode()==12)
			Log.log(12,LOG_LEVEL_FATAL,LOG_TYPE_SYSTEM,e.getErrMsg());
		if(e.getErrCode()==141)
			Log.log(141,LOG_LEVEL_FATAL,LOG_TYPE_SYSTEM,e.getErrMsg());
	}

}	
