#line 1 "Application.cpp"
#line 1 "/opt/aCC/include_std/stdio.h"



#line 1 "/opt/aCC/include_std/cstdio"



#pragma push binding
#pragma binding default
#line 1 "/usr/include/stdio.h"
 
 



#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/stdsyms.h"
 









  



















 





#line 51 "/usr/include/sys/stdsyms.h"

#line 115 "/usr/include/sys/stdsyms.h"



 

#line 137 "/usr/include/sys/stdsyms.h"




 
#line 156 "/usr/include/sys/stdsyms.h"


 










 

#line 188 "/usr/include/sys/stdsyms.h"


 

#line 226 "/usr/include/sys/stdsyms.h"


 








#line 319 "/usr/include/sys/stdsyms.h"
 

#line 327 "/usr/include/sys/stdsyms.h"






 








 








 







 
 







 







 







 







 

#line 401 "/usr/include/sys/stdsyms.h"






  
#line 416 "/usr/include/sys/stdsyms.h"










 

#line 438 "/usr/include/sys/stdsyms.h"











#line 462 "/usr/include/sys/stdsyms.h"










#line 489 "/usr/include/sys/stdsyms.h"

 
#line 497 "/usr/include/sys/stdsyms.h"

 






 






 








 
#line 541 "/usr/include/sys/stdsyms.h"




#line 556 "/usr/include/sys/stdsyms.h"

 
#line 565 "/usr/include/sys/stdsyms.h"



 














#pragma pop
#line 8 "/usr/include/stdio.h"


#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/_inttypes.h"
















































 




 






#line 81 "/usr/include/sys/_inttypes.h"
typedef char int8_t; 			  

typedef unsigned char uint8_t; 		  
typedef short int16_t; 			  
typedef unsigned short uint16_t;	  
typedef int  int32_t; 			 
typedef unsigned int uint32_t;		 

typedef int intfast_t; 			 
typedef unsigned int uintfast_t;	 




typedef long int64_t;                    
typedef unsigned long uint64_t;          







typedef int64_t  intmax_t; 		  
typedef uint64_t uintmax_t;	 	 

#line 113 "/usr/include/sys/_inttypes.h"

typedef long  intptr_t;			 
typedef unsigned long uintptr_t; 	 







 

 
typedef char int_least8_t;

 
typedef unsigned char uint_least8_t; 

 
typedef int int_fast8_t;

 
typedef unsigned int uint_fast8_t; 

 
typedef short int_least16_t;

 
typedef unsigned short uint_least16_t; 

 
typedef int int_fast16_t;

 
typedef unsigned int uint_fast16_t; 

 
typedef int int_least32_t;

 
typedef unsigned int uint_least32_t; 

 
typedef int int_fast32_t;

 
typedef unsigned int uint_fast32_t; 



 
typedef int64_t int_least64_t;

 
typedef int64_t int_fast64_t;

 
typedef uint64_t uint_least64_t;

 
typedef uint64_t uint_fast64_t; 












 



typedef uint32_t ptr32_t;

typedef uint64_t ptr64_t;




#pragma pop
#line 11 "/usr/include/stdio.h"

#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/types.h"
 












 








 
#pragma push binding
#pragma binding default
#line 1 "/usr/include/machine/vm/vmtypes.h"
 




 











 
typedef uintptr_t		paddr_t;	 





 




 
typedef intptr_t		page_t;		 

typedef int64_t			pgcnt_t;	 
typedef uint64_t		upgcnt_t;	 
						 
						 
						 
#line 45 "/usr/include/machine/vm/vmtypes.h"
typedef uintptr_t		physpfn_t;	 
typedef uintptr_t		iophyspfn_t;	 
typedef uintptr_t		pgaddr_t;	 

typedef uint32_t		prot_t;		 













 

typedef uint64_t space_t;    



typedef uint32_t rid_t;	    
 


#pragma pop
#line 25 "/usr/include/sys/types.h"

#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/_fd_macros.h"

































 
























 

#line 78 "/usr/include/sys/_fd_macros.h"







 

typedef int32_t __fd_mask;








   typedef struct fd_set {
     long fds_bits[(((2048)+(((sizeof(long) * 8))-1))/((sizeof(long) * 8)))];
     } fd_set;



	extern "C" {


#line 146 "/usr/include/sys/_fd_macros.h"


	}






#pragma pop
#line 28 "/usr/include/sys/types.h"



#line 43 "/usr/include/sys/types.h"

extern "C" {  







 



 



typedef int32_t		dev_t;		 




typedef int32_t		gid_t;		 




typedef unsigned long	ino_t;




typedef uint16_t	mode_t;		 




     typedef uint16_t nlink_t;		 


#line 89 "/usr/include/sys/types.h"
typedef long		off_t;		





typedef int32_t		pid_t;		 


#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/_size_t.h"
 











 











typedef unsigned long size_t;



#pragma pop
#line 99 "/usr/include/sys/types.h"



typedef long		ssize_t;


#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/_time_t.h"
 











 














typedef long time_t;




#pragma pop
#line 106 "/usr/include/sys/types.h"



typedef int32_t		uid_t;		 





 
#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/_clock_t.h"
 














 








	typedef unsigned int clock_t;



#pragma pop
#line 117 "/usr/include/sys/types.h"







typedef long		fpos_t;		






 


typedef int32_t		fpos32_t;	 





typedef int64_t		fpos64_t;	 





typedef uint32_t	ino32_t;





typedef uint64_t	ino64_t;





     typedef int32_t   off32_t;		 





        typedef int64_t  off64_t;	 





 


typedef int32_t		key_t;		 





 



 


typedef int32_t		id_t;	 




typedef uint32_t	useconds_t;	 





 
#line 206 "/usr/include/sys/types.h"
typedef unsigned long	rlim_t;





 


typedef uint32_t	rlim32_t;





typedef uint64_t	rlim64_t;





     typedef uint16_t __site_t;		 


 
typedef __site_t	site_t;




 


typedef enum __clockid {
	__CLOCK_INVALID		= 0,
	__CLOCK_REALTIME	= 1,
	__CLOCK_VIRTUAL		= 2,
	__CLOCK_PROFILE		= 4,
	__RTTIMER0		= 8,
	__RTTIMER1		= 16
}			clockid_t;




typedef unsigned long	timer_t;


 



typedef int		mqd_t;	 




 












 





 





typedef int		pthread_t;




typedef int		pthread_attr_t;


typedef int		pthread_mutexattr_t;
typedef int		pthread_condattr_t;
typedef int		pthread_rwlockattr_t;
typedef int		pthread_key_t;



#line 397 "/usr/include/sys/types.h"





 
#line 409 "/usr/include/sys/types.h"
typedef long		blkcnt_t;	





typedef long		blksize_t;         


#line 424 "/usr/include/sys/types.h"
typedef unsigned long	fsblkcnt_t;	






 



typedef long		suseconds_t;	 




 


typedef int32_t		blkcnt32_t;	 





typedef int64_t		blkcnt64_t;	 





typedef uint32_t	fsblkcnt32_t;	 





typedef uint64_t	fsblkcnt64_t;	 



 









 



typedef size_t		socklen_t;




 




 
typedef char *		__caddr_t;	 


typedef int32_t		aid_t;


#line 502 "/usr/include/sys/types.h"
typedef long		sbsize_t;
typedef unsigned long	bsize_t;





     typedef __caddr_t		caddr_t;




typedef int32_t		cid_t;		 
typedef cid_t		cmpt_t;


#line 524 "/usr/include/sys/types.h"
typedef unsigned long	fsfilcnt_t;	



typedef int		ldom_t;



typedef int32_t		lwpid_t;	 




typedef int32_t		priv_t;		 




struct __privset;
typedef struct __privset	privset_t;	 
typedef privset_t	priv_set_t;




typedef int		psetid_t;	 


typedef int		spu_t;



 


typedef uint16_t	__cnode_t;	 


typedef int32_t 	__daddr_t;	 

typedef int64_t		__swblk_t;




typedef unsigned short	__ushort;	 



typedef int32_t		sbsize32_t;
typedef uint32_t	bsize32_t;





typedef int64_t		sbsize64_t; 
typedef uint64_t	bsize64_t;



typedef uint32_t	cdno_t;

   typedef __cnode_t		cnode_t;

   typedef int16_t		cnt_t;

     typedef short cpu_t;

typedef __daddr_t	daddr_t;






 


typedef int32_t		dir_off_t;





typedef uint32_t	fsfilcnt32_t;	 





typedef uint64_t	fsfilcnt64_t;	 



typedef unsigned long   pl_t;

   typedef pid_t		sid_t;	    



typedef int32_t		sysid_t;	 


typedef __swblk_t	swblk_t;



typedef int32_t		tid_t;		 


typedef unsigned char	uchar_t;

typedef unsigned int	uint_t;



typedef unsigned long	ulong_t;


typedef uint16_t	use_t;

typedef unsigned short	ushort_t;




 










    


      





     typedef __fd_mask  fd_mask;


typedef unsigned char	u_char;		 
typedef unsigned short	u_short;	 
typedef unsigned int	u_int;		 
typedef unsigned long	u_long;		 
typedef unsigned int	uint;		 
typedef unsigned short	ushort;		 
typedef unsigned char  	ubit8;		 
typedef unsigned short 	ubit16;		 
typedef uint32_t  	ubit32;		 
typedef char           	sbit8;		 
typedef short          	sbit16;		 
typedef int32_t       	sbit32;		 

#line 700 "/usr/include/sys/types.h"

typedef struct _physadr {
	intptr_t	r[1];
} *physadr;



 
typedef struct lkinfo {
	char    *lk_name;
	int      lk_flags;
	long     lk_pad[2];
}			lkinfo_t;

#line 722 "/usr/include/sys/types.h"

}  

#pragma pop
#line 15 "/usr/include/stdio.h"









extern "C" {







 


#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/_mbstate_t.h"


 






      typedef struct {
	 unsigned char __parse_size:3;
	 unsigned char __dummy:4;
	 unsigned char __shift_state:1;
	 char __parse_buf[7];
      } mbstate_t;


#pragma pop
#line 38 "/usr/include/stdio.h"



  
   typedef struct {
	int		 __cnt;
	unsigned char	*__ptr;
	unsigned char	*__base;
	unsigned short	 __flag;
	unsigned char 	 __fileL;		 
	unsigned char 	 __fileH;		 
   } FILE;
  

   typedef struct {
	int		 __cnt;
	unsigned char	*__ptr;
	unsigned char	*__base;
	unsigned short	 __flag;
	unsigned char 	 __fileL;		 
	unsigned char 	 __fileH;		 
	unsigned char	*__bufendp;		 
	unsigned char	*__newbase;
	unsigned char	 __smbuf[8+2*4];	 

	void		*__lock;		 




        int             __orientation ;
        mbstate_t       __state ;




   } _FILEX;





 
#line 92 "/usr/include/stdio.h"



 




#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/_null.h"
 


 
 
 

 
#line 16 "/usr/include/sys/_null.h"

#line 24 "/usr/include/sys/_null.h"

 
#pragma pop
#line 102 "/usr/include/stdio.h"






#line 118 "/usr/include/stdio.h"

#line 129 "/usr/include/stdio.h"





        typedef __va_list__ __va_list;


#line 148 "/usr/include/stdio.h"





















   





    
#  pragma extern __iob

   extern FILE __iob[];




         
#      pragma builtin fclose, fflush, scanf, fscanf, sscanf, fprintf 
#      pragma builtin printf, sprintf, fgetc, fputc
#      pragma extern remove, tmpnam, fclose, fflush, setbuf, setvbuf, fprintf
#      pragma extern fscanf, printf, scanf, sprintf, sscanf, fgetc, fgets, fputc
#      pragma extern fputs, getc, getchar, gets, putc, putchar, puts, ungetc
#      pragma extern fseek, ftell, rewind, clearerr, feof, ferror, perror
      








#line 245 "/usr/include/stdio.h"


  
     extern int remove(const char *);


      
#    pragma extern rename

     extern int rename(const char *, const char *);

     extern char *tmpnam(char *);
     extern int fclose(FILE *);
     extern int fflush(FILE *);
     extern void setbuf(FILE *, char *);
     extern int setvbuf(FILE *, char *, int, size_t);
     extern int fprintf(FILE *, const char *, ...);
     extern int fscanf(FILE *, const char *,...);
     extern int printf(const char *,...);
     extern int scanf(const char *,...);
     extern int sprintf(char *, const char *,...);
     extern int sscanf(const char *, const char *,...);
     extern int fgetc(FILE *);
     extern char *fgets(char *, int, FILE *);
     extern int fputc(int, FILE *);
     extern int fputs(const char *, FILE *);
     extern int getc(FILE *);
     extern int getchar(void);
     extern char *gets(char *);
     extern int putc(int, FILE *);
     extern int putchar(int);
     extern int puts(const char *);
     extern int ungetc(int, FILE *);


      
#    pragma builtin fopen
#    pragma extern tmpfile, fgetpos, fsetpos, fopen, freopen

     extern FILE *tmpfile(void);
     extern int fgetpos(FILE *, fpos_t *);
     extern int fsetpos(FILE *, const fpos_t *);
     extern FILE *fopen(const char *, const char *);
     extern FILE *freopen(const char *, const char *, FILE *);
#line 298 "/usr/include/stdio.h"
     extern int fseek(FILE *, long int, int);
     extern long int ftell(FILE *);
     extern void rewind(FILE *);
     extern void clearerr(FILE *);
     extern int feof(FILE *);
     extern int ferror(FILE *);
     extern void perror(const char *);
  

#line 387 "/usr/include/stdio.h"


     
#    pragma builtin fread, fwrite
#    pragma extern fread, fwrite
#line 400 "/usr/include/stdio.h"






  
       extern size_t fread(void *, size_t, size_t, FILE *);
       extern size_t fwrite(const void *, size_t, size_t, FILE *);
  












 

      
#      pragma extern __flsbuf, __filbuf 


#line 436 "/usr/include/stdio.h"
     extern int __flsbuf(unsigned char, FILE *);
     extern int __filbuf(FILE *);




  
#line 460 "/usr/include/stdio.h"

#line 470 "/usr/include/stdio.h"
 









#line 489 "/usr/include/stdio.h"

#line 514 "/usr/include/stdio.h"








        
#    pragma extern ctermid, fileno, fdopen 


#line 534 "/usr/include/stdio.h"
     extern char *ctermid(char *);
     extern int fileno(FILE *);
     extern FILE *fdopen(int, const char *);
#line 543 "/usr/include/stdio.h"





        





  
           typedef __va_list__ va_list;             
  




#line 569 "/usr/include/stdio.h"

#line 581 "/usr/include/stdio.h"


         

#        pragma extern optarg, opterr, optind, optopt
#        pragma extern getopt, cuserid




     extern char *optarg;
     extern int optind;
     extern int opterr;



     extern int optopt;

#line 606 "/usr/include/stdio.h"
       extern int getopt (int, char * const [], const char *);
       extern char *cuserid (char *);







        
#      pragma extern pclose, popen, tempnam

#        pragma extern getw, putw



#line 629 "/usr/include/stdio.h"

#line 638 "/usr/include/stdio.h"
     
     extern int getw (FILE *);
     extern int putw (int, FILE *);


     extern int pclose (FILE *);
     extern FILE *popen (const char *, const char *);
     extern char *tempnam (const char *, const char *);












 


     
#  pragma builtin vprintf, vfprintf, vsprintf
#  pragma extern vprintf, vfprintf, vsprintf



  

     extern int vprintf(const char *, va_list);
     extern int vfprintf(FILE *, const char *, va_list);
     extern int vsprintf(char *, const char *, va_list);





  









       
#    pragma builtin snprintf, vsnprintf
#    pragma extern snprintf, vsnprintf


extern int snprintf (char * , size_t, const char * ,...);
extern int vsnprintf (char * , size_t, const char * , __va_list);






       
#    pragma extern funlockfile, flockfile
#    pragma extern ftrylockfile
#    pragma extern getc_unlocked, getchar_unlocked
#    pragma extern putc_unlocked, putchar_unlocked


#line 714 "/usr/include/stdio.h"

extern void flockfile (FILE *);
extern int ftrylockfile (FILE *);
extern void funlockfile (FILE *);
extern int getc_unlocked (FILE *);
extern int getchar_unlocked (void);
extern int putc_unlocked (int, FILE *);
extern int putchar_unlocked (int);






      
#    pragma builtin vscanf, vfscanf, vsscanf
#    pragma extern vscanf, vfscanf, vsscanf


extern int vscanf (const char * , __va_list);
extern int vfscanf (FILE * , const char * , __va_list);


extern int vsscanf (char *, const char *, __va_list);








#line 754 "/usr/include/stdio.h"
#      pragma extern setlinebuf


#line 764 "/usr/include/stdio.h"


     extern void setlinebuf(FILE *);
#line 784 "/usr/include/stdio.h"

#line 805 "/usr/include/stdio.h"


     
#  pragma extern __bufendtab


   extern unsigned char *__bufendtab[];
















 
#line 875 "/usr/include/stdio.h"

#line 944 "/usr/include/stdio.h"



       
#      pragma extern ftello, fseeko


#line 958 "/usr/include/stdio.h"
     extern off_t ftello (FILE *);
     extern int fseeko (FILE *, off_t, int);





}






 
#line 996 "/usr/include/stdio.h"

#pragma pop
#line 5 "/opt/aCC/include_std/cstdio"



#line 15 "/opt/aCC/include_std/cstdio"




namespace std
{




using ::FILE;
using ::fpos_t;
using ::size_t;




using ::fclose;
using ::fflush;
using ::fgetc;
using ::fgetpos;
using ::fgets;
using ::fopen;
using ::fprintf;
using ::fputc;
using ::fputs;
using ::fread;
using ::freopen;
using ::fscanf;
using ::fseek;
using ::fsetpos;
using ::ftell;
using ::fwrite;
using ::gets;
using ::perror;
using ::printf;
using ::puts;
using ::remove;
using ::rename;
using ::rewind;
using ::scanf;
using ::setbuf;
using ::setvbuf;
using ::sprintf;
using ::sscanf;
using ::tmpfile;
using ::tmpnam;
using ::ungetc;
using ::vfprintf;
using ::vprintf;
using ::vsprintf;

using ::clearerr;
using ::feof;
using ::ferror;
using ::getc;
using ::putc;
using ::getchar;
using ::putchar;
}


#line 5 "/opt/aCC/include_std/stdio.h"

#line 64 "/opt/aCC/include_std/stdio.h"

#line 2 "Application.cpp"
#pragma push binding
#pragma binding default
#line 1 "/usr/include/unistd.h"
 







 


#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/unistd.h"
 










 










 












 










#pragma push binding
#pragma binding default
#line 1 "/usr/include/utime.h"
 












extern "C" {








   struct utimbuf {
	time_t actime;
	time_t modtime;
   };



          
#       pragma extern utime


           extern int utime(const char *, const struct utimbuf *);






#line 52 "/usr/include/utime.h"


}


#pragma pop
#line 52 "/usr/include/sys/unistd.h"



 



   extern "C" {




     
#pragma extern _exit, access, chdir, chown, close, ctermid
#pragma extern dup, dup2, execl, execle, execlp, execv, execve, execvp
#pragma extern fpathconf, getcwd, getgroups, getlogin 

#pragma extern cuserid


#     pragma extern getlogin_r

#pragma extern  isatty, link

#     pragma extern lseek

#pragma builtin read
#pragma extern pathconf, pause, pipe, read, rmdir, setgid, setpgid
#pragma extern setsid, setuid, sleep, sysconf, tcgetpgrp, tcsetpgrp
#pragma extern ttyname  

#        pragma extern ttyname_r 

#pragma builtin write
#pragma extern unlink, write, alarm, fork, getuid, geteuid, getgid
#pragma extern getegid, getpid, getpgrp, getppid 


     extern void _exit (int);
     extern int access (const char *, int);
     extern int chdir (const char *);
     extern int chown (const char *, uid_t, gid_t);
     extern int close (int);
     extern char *ctermid (char *);

     extern char *cuserid (char *);

     extern int dup (int);
     extern int dup2 (int, int);
     extern int execl (const char *, const char *, ...);
     extern int execle (const char *, const char *, ...);
     extern int execlp (const char *, const char *, ...);
     extern int execv (const char *, char *const []);
     extern int execve (const char *, char *const [], char *const []);
     extern int execvp (const char *, char *const []);
     extern long fpathconf (int, int);
     extern char *getcwd (char *, size_t);
     extern int getgroups (int, gid_t []);
     extern char *getlogin (void);


        extern int getlogin_r (char *, size_t);




     extern int isatty (int);
     extern int link (const char *, const char *);

     extern off_t lseek (int, off_t, int); 

     extern long pathconf (const char *, int);
     extern int pause (void);
     extern int pipe (int *);
     extern ssize_t read (int, void *, size_t);
     extern int rmdir (const char *);
     extern int setgid (gid_t);
     extern int setpgid (pid_t, pid_t);
     extern pid_t setsid (void);
     extern int setuid (uid_t);
     extern unsigned int sleep (unsigned int);
     extern long sysconf (int);
     extern pid_t tcgetpgrp (int);
     extern int tcsetpgrp (int, pid_t);
     extern char *ttyname (int);


        extern int ttyname_r (int, char *, size_t);




     extern int unlink (const char *);
     extern ssize_t write (int, const void *, size_t);

#line 158 "/usr/include/sys/unistd.h"
     extern unsigned int alarm (unsigned int);
     extern pid_t fork (void);
     extern gid_t getegid (void);
     extern uid_t geteuid (void);
     extern gid_t getgid (void);
     extern pid_t getpgrp (void);
     extern pid_t getpid (void);
     extern pid_t getppid (void);
     extern uid_t getuid (void);






     
#  pragma extern optarg, opterr, optind, optopt, getopt, confstr


     extern char *optarg;
     extern int opterr;
     extern int optind;
     extern int optopt;
      
     extern int getopt (int, char * const [], const char *); 
     extern size_t confstr (int, char *, size_t);




       
#    pragma extern pthread_atfork


     extern int pthread_atfork(void (*)(void), void (*)(void),
               				                   void (*)(void));









#    pragma extern crypt, encrypt, fsync, nice

#      pragma extern chroot, getpass


#      pragma extern rename 



#        pragma builtin_milli swab

#      pragma extern swab




        extern int chroot (const char *);
        extern char *getpass (const char *);

        extern char *crypt (const char *, const char *);
        extern void encrypt (char [64], int);
        extern int fsync (int);
        extern int nice (int);
#line 233 "/usr/include/sys/unistd.h"
        extern int rename (const char *, const char *);	 



        extern void swab (const void * , void * , ssize_t);






      

         
#      pragma extern environ

     extern char **environ;



       
#    pragma extern readlink, fchown, symlink 




         extern int readlink (const char *, char *, size_t);   
#line 266 "/usr/include/sys/unistd.h"
     extern int fchown (int, uid_t, gid_t);


           
#        pragma extern ftruncate, truncate

     extern int ftruncate (int, off_t);
     extern int truncate (const char *, off_t);


        

          
#        pragma extern setgroups

       extern int setgroups (int, gid_t []);

     extern int symlink (const char *, const char *);





         
#      pragma extern setpgrp

	extern pid_t setpgrp (void);
#line 307 "/usr/include/sys/unistd.h"


     
#  pragma extern vfork




	extern pid_t vfork (void);


#line 325 "/usr/include/sys/unistd.h"
           
#        pragma extern mkstemp, mktemp, ttyslot

		extern int mkstemp (char *);
		extern char *mktemp (char *);
		extern int ttyslot (void);




     
#  pragma extern fchdir, gethostid, gethostname
#  pragma extern getpgid, getsid, getwd

#      pragma extern lockf

#  pragma extern lchown, setregid, setreuid, sync
#  pragma extern ualarm, usleep

#    pragma extern brk, sbrk, getdtablesize, getpagesize




	extern int brk (void *);
        extern int getdtablesize (void);
        extern int getpagesize (void);

	extern int fchdir (int);

	extern long gethostid (void);



	extern int gethostname (char *, size_t);
	extern pid_t getpgid (pid_t);
	extern pid_t getsid (pid_t);
	extern char *getwd (char *);

 	extern int lockf (int, int, off_t);

	extern int lchown (const char *, uid_t, gid_t);





	 extern void *sbrk (int);





	extern int setregid (gid_t, gid_t); 
	extern int setreuid (uid_t, uid_t); 
	extern void sync (void);

	extern useconds_t ualarm (useconds_t, useconds_t);
	extern int usleep (useconds_t);








      
#    pragma extern fdatasync

#      pragma extern pread, pwrite



     extern ssize_t pread (int, void *, size_t, off_t);
     extern ssize_t pwrite (int, const void *, size_t, off_t);

     extern int fdatasync (int);
#line 417 "/usr/include/sys/unistd.h"




    
#   pragma extern setegid, seteuid

     extern int setegid (gid_t);
     extern int seteuid (uid_t);





       
#    pragma extern endusershell, fsctl, getcdf, gethcwd, getpgrp2
#    pragma extern getusershell, getresgid, getresuid, hidecdf, initgroups



#    pragma extern logname, lsync

#      pragma extern prealloc 

#    pragma extern sethostname, setpgrp2, setresgid, setresuid 
#    pragma extern setusershell, sgetl, sputl, swapon, swapoff, ttyname

#      pragma extern __sysconfx 



#        pragma extern ttyname_r 





#    pragma extern set_userthreadid


     extern void endusershell (void);
     extern int fsctl (int, int, void *, size_t);
     extern char *getcdf (const char *, char *, size_t);
     extern char *gethcwd (char *, size_t);
     extern int getpgrp2 (pid_t);
     extern char *getusershell (void);
     extern int getresgid (gid_t *, gid_t *, gid_t *);
     extern int getresuid (uid_t *, uid_t *, uid_t *);
     extern char *hidecdf (const char *, char *, size_t);
     extern int initgroups (const char *, gid_t);



     extern char *logname (void);
     extern void lsync (void);

     extern int prealloc (int, off_t);

     extern int sethostname (const char *, size_t);
     extern int setpgrp2 (pid_t, pid_t);
     extern int setresgid (gid_t, gid_t, gid_t);
     extern int setresuid (uid_t, uid_t, uid_t);
     extern void setusershell (void);
     extern long sgetl (const char *);
     extern void sputl (long, char *);
     extern int swapon (const char *, ...);
     extern int swapoff (const char *, int);
     extern char *ttyname (int);

     extern int64_t __sysconfx (int, int);



        extern int ttyname_r (int, char *, size_t);
#line 498 "/usr/include/sys/unistd.h"
     extern int set_userthreadid (int);


     



#    pragma extern setpgrp3 



#line 521 "/usr/include/sys/unistd.h"
	   extern pid_t setpgrp3 (void);




#line 546 "/usr/include/sys/unistd.h"

#line 572 "/usr/include/sys/unistd.h"


   }


#line 596 "/usr/include/sys/unistd.h"




 



 
 
#line 612 "/usr/include/sys/unistd.h"

 






 






#line 644 "/usr/include/sys/unistd.h"





 
#line 659 "/usr/include/sys/unistd.h"
 
#line 687 "/usr/include/sys/unistd.h"

#line 697 "/usr/include/sys/unistd.h"

#line 707 "/usr/include/sys/unistd.h"

#line 714 "/usr/include/sys/unistd.h"







 





 
#line 734 "/usr/include/sys/unistd.h"




#line 779 "/usr/include/sys/unistd.h"

#line 786 "/usr/include/sys/unistd.h"




 


 

#line 806 "/usr/include/sys/unistd.h"

 

#line 815 "/usr/include/sys/unistd.h"

 

#line 835 "/usr/include/sys/unistd.h"

 

#line 856 "/usr/include/sys/unistd.h"

     






 
#line 871 "/usr/include/sys/unistd.h"
 
#line 882 "/usr/include/sys/unistd.h"

#line 892 "/usr/include/sys/unistd.h"

 
#line 903 "/usr/include/sys/unistd.h"

#line 970 "/usr/include/sys/unistd.h"

 
#line 1003 "/usr/include/sys/unistd.h"

 

#line 1018 "/usr/include/sys/unistd.h"

 






 














 





 


 

#line 1084 "/usr/include/sys/unistd.h"

 




#line 1097 "/usr/include/sys/unistd.h"





 




#line 1114 "/usr/include/sys/unistd.h"



 








 

 
#line 1136 "/usr/include/sys/unistd.h"



#line 1147 "/usr/include/sys/unistd.h"

 








 
                                                                                                                            
#line 1166 "/usr/include/sys/unistd.h"



 









#line 1188 "/usr/include/sys/unistd.h"



     



    
 







 











 



        

        
#line 1235 "/usr/include/sys/unistd.h"

 


 


 


 


 


 


 


 





 





 



 



 







 







 








 





 



 






 






 







 






 

#line 1349 "/usr/include/sys/unistd.h"

 










 






 
 








 







 
#line 1398 "/usr/include/sys/unistd.h"



 






 




#line 1421 "/usr/include/sys/unistd.h"

#line 1429 "/usr/include/sys/unistd.h"

#line 1436 "/usr/include/sys/unistd.h"

#line 1450 "/usr/include/sys/unistd.h"

 





 





 




 
 



 

#line 1484 "/usr/include/sys/unistd.h"

 





 







 







 
	 

     
#pragma extern serialize

extern int serialize (int, pid_t);





#line 1532 "/usr/include/sys/unistd.h"



#pragma pop
#line 13 "/usr/include/unistd.h"

#pragma pop
#line 3 "Application.cpp"
#line 1 "/opt/aCC/include_std/string.h"



#line 1 "/opt/aCC/include_std/cstring"






#line 17 "/opt/aCC/include_std/cstring"

#pragma push binding
#pragma binding default
#line 1 "/usr/include/string.h"
 















extern "C" {




#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/_null.h"
 


 
 
 

 
#line 16 "/usr/include/sys/_null.h"

#line 24 "/usr/include/sys/_null.h"

 
#pragma pop
#line 24 "/usr/include/string.h"





 







      
#    pragma builtin_milli memcmp, strncat, strncmp, memmove, strcpy
#    pragma builtin_milli strncpy, strcat, strcmp, __strchr_keep_out, __strrchr_keep_out, __strstr_keep_out 
#    pragma builtin __strpbrk_keep_out, strcoll, strxfrm, strtok
#    pragma extern memcmp, strncat, strncmp, memmove, strcpy, strncpy, strcat
#    pragma extern strcmp, strcoll, strxfrm, __strchr_keep_out, __strpbrk_keep_out, __strrchr_keep_out, __strstr_keep_out 
#    pragma extern strtok, strerror

#      pragma builtin strtok_r
#      pragma extern strtok_r

#        pragma extern strerror_r




#line 78 "/usr/include/string.h"

  
     extern int memcmp(const void *, const void *, size_t);
     extern char *strncat(char *, const char *, size_t);
     extern int strncmp(const char *, const char *, size_t);
     extern void *memmove(void *, const void *, size_t);
     extern char *strcpy(char *, const char *);
     extern char *strncpy(char *, const char *, size_t);
     extern char *strcat(char *, const char *);
     extern int strcmp(const char *, const char *);
     extern int strcoll(const char *, const char *);
     extern size_t strxfrm(char *, const char *, size_t);
#line 99 "/usr/include/string.h"
 

     extern char *strtok(char *, const char *);
     extern char *strerror(int);
  
#line 112 "/usr/include/string.h"
       extern char *strtok_r(char *, const char *, char **);




           extern int strerror_r(int, char *, size_t);
#line 175 "/usr/include/string.h"


      
#    pragma builtin_milli __memchr_keep_out, memcpy, memset, strcspn, strlen
#    pragma extern memcpy, __memchr_keep_out, memset, strcspn, strspn, strlen


#line 223 "/usr/include/string.h"
  
       extern void *memcpy(void *, const void *, size_t);
#line 231 "/usr/include/string.h"
 

       extern void *memset(void *, int, size_t);
       extern size_t strcspn(const char *, const char *);
       extern size_t strspn(const char *, const char *);
  



  
         extern size_t strlen(const char *);
  
#line 270 "/usr/include/string.h"




       
#    pragma builtin_milli memccpy 
#    pragma extern memccpy


#line 290 "/usr/include/string.h"
       extern void *memccpy(void *, const void *, int, size_t);







#line 312 "/usr/include/string.h"



       
#    pragma builtin strdup 
#    pragma extern strdup


#line 328 "/usr/include/string.h"
     extern char *strdup(const char *);







       
#    pragma builtin strcasecmp, strncasecmp 
#    pragma extern strrstr, strcasecmp, strncasecmp 


#line 358 "/usr/include/string.h"
     extern char *strrstr(const char *, const char *);
     extern int strcasecmp(const char *, const char *);
     extern int strncasecmp(const char *, const char *, size_t);
#line 367 "/usr/include/string.h"


}


#pragma pop
#line 19 "/opt/aCC/include_std/cstring"

#line 30 "/opt/aCC/include_std/cstring"
#pragma builtin_milli strchr, strrchr, strstr, memchr
#pragma builtin strpbrk
#pragma extern strchr, strpbrk, strrchr, strstr, memchr











    
    
    extern "C" const char* strpbrk(const char *, const char *);
    extern "C" const char* strstr(const char *, const char *);
    extern "C" const char* strrchr(const char *, int);
    extern "C" const char* strchr(const char *, int);
    extern "C" const void* memchr(const void *, int, size_t);

    inline char* strpbrk(char *s, const char *p) {
        return const_cast<char*> (strpbrk(const_cast<const char*>(s), p));
    }
    inline char* strstr(char *s, const char *p) {
        return const_cast<char*> (strstr(const_cast<const char*>(s), p));
    }
    inline char* strrchr(char *s, int c) {
        return const_cast<char*> (strrchr(const_cast<const char*>(s), c));
    }
    inline char* strchr(char *s, int c) {
        return const_cast<char*> (strchr(const_cast<const char*>(s), c));
    }
    inline void* memchr(void *s, int c, size_t n) {
        return const_cast<void*> (memchr(const_cast<const void*>(s), c, n));
    }









namespace std
{

using ::size_t;





using ::memchr;
using ::memcmp;
using ::memcpy;
using ::memmove;
using ::memset;
using ::strcat;
using ::strchr;
using ::strcmp;
using ::strcoll;
using ::strcpy;
using ::strcspn;
using ::strerror;
using ::strlen;
using ::strncat;
using ::strncmp;
using ::strncpy;
using ::strpbrk;
using ::strrchr;
using ::strspn;
using ::strstr;
using ::strtok;
using ::strxfrm;

}



#line 5 "/opt/aCC/include_std/string.h"

#line 38 "/opt/aCC/include_std/string.h"

#line 4 "Application.cpp"
#pragma push binding
#pragma binding default
#line 1 "/usr/include/memory.h"
        









#pragma pop
#line 5 "Application.cpp"
#pragma push binding
#pragma binding default
#line 1 "/usr/include/fcntl.h"
 







#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/fcntl.h"
 


 



















 







 







    
#line 48 "/usr/include/sys/fcntl.h"

#line 58 "/usr/include/sys/fcntl.h"


















   

 









 










 












    


  




    
    
#line 129 "/usr/include/sys/fcntl.h"











 

    





    
    
#line 156 "/usr/include/sys/fcntl.h"

    

    












    
#line 179 "/usr/include/sys/fcntl.h"
    




 






    









 
#line 208 "/usr/include/sys/fcntl.h"

    
    















#line 232 "/usr/include/sys/fcntl.h"




#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/_flock_body.h"





















 

 
 










 

    

   struct flock {
      short    	l_type;          
      short    	l_whence;        
      off_t 	l_start;         
      off_t  l_len;           
      pid_t     l_pid;          
 
#line 53 "/usr/include/sys/_flock_body.h"
   };

 
#pragma pop
#line 239 "/usr/include/sys/fcntl.h"



#line 250 "/usr/include/sys/fcntl.h"

#line 268 "/usr/include/sys/fcntl.h"





 







 








struct fshare {
	short f_access;
	short f_deny;
	int   f_id;
};




 
#line 306 "/usr/include/sys/fcntl.h"



extern int posix_fadvise  (int, off_t, off_t, int);


extern int posix_fadvise64  (int, off_t, off_t, int);




 

#line 325 "/usr/include/sys/fcntl.h"



    



     extern "C" {



       
#    pragma extern fcntl

#      pragma extern flock



#        pragma builtin creat
#        pragma extern creat



#      pragma builtin open
#      pragma extern open



       extern int fcntl (int, int, ...);


       extern int flock (int, int);



       extern int creat (const char *, mode_t);

        

       extern int open (const char *, int, ...);


#line 380 "/usr/include/sys/fcntl.h"

#line 401 "/usr/include/sys/fcntl.h"


     }


#line 413 "/usr/include/sys/fcntl.h"





#line 431 "/usr/include/sys/fcntl.h"

#pragma pop
#line 10 "/usr/include/fcntl.h"

#pragma pop
#line 6 "Application.cpp"
#line 1 "/opt/aCC/include_std/iostream"
































 

#line 1 "/opt/aCC/include_std/istream"
































 

#line 1 "/opt/aCC/include_std/ios"
































 

#line 1 "/opt/aCC/include_std/rw/rwstderr.h"






























 


   
#line 1 "/opt/aCC/include_std/rw/stddefs.h"
































 

#line 1 "/opt/aCC/include_std/stdcomp.h"
































 

































 



 









 

 
 



 













 






 
 



 

 


 

 


 





 

 


 




 

 




 

 





 

 

 






 

 




 

 






 

 




 

 


 




 

 






 

 





 

 




 

 




 

 




 

 




 

 




 

 




 

 




 

 




 

 




 

 

 




 

 






 

 




 

 




 

 




 

 




 

 







 

 

 



 

 


 






 

 





 

 







 

 






 

 






 

 



 

 




 

 




 

 



 

 


 




 

 





 

 





 

 




 

 




 

 




 

 





 

 




 

 




 

 



 

 







 

 








 

 







 

 




 

 




 

 




 

 




 

 




 

 




 

 




 

 





 

 




 

 




 

 





 

 




 

 




 

 




 

 




 

 




 

 




 

 




 

 




 

 





 

 




 

 




 

 




 

 




 

 




 

 





 

 





 

 




 

 




 

 




 

 





 

 




 

 




 

 





 

 




 

 




 

 





 

 




 

 



 

 



 

 




 

 




 

 



 

 



 

 



 

 



 

 




  
 



  

 





 

 



 

 



 

 



 

 




 

 



 

 



 

 



 

 



 

 



 

 



 

 




 

 



 

 



 

 



 

 



 

 



 

 




 

 




 

 

 






 

 










 




 


 





 

 










  

 













 

 






 




  

 





 

 




  

 




 

 




 

 



 

 









 

#line 1229 "/opt/aCC/include_std/stdcomp.h"

 

#line 1331 "/opt/aCC/include_std/stdcomp.h"


 

#line 1374 "/opt/aCC/include_std/stdcomp.h"




 
 
 
 
 



 
 



 
 
 



 

#line 1408 "/opt/aCC/include_std/stdcomp.h"

 



 
 
 
 



 



 
 
 
 
 
 
 
 
 
 
 
 
 




 
 
 
 
 
 
 
 
 
 




 
 




 
 
 
 
 
 
 



 
 
 
 




 
 
 
 
 
 
 
 




 
 
 
 
 
 
 
 




 
 
 
 
 
 
 
 
 
 
 
 
 
 
 







 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 






 
 
 
 
 
 
 
 
 
 
 
 
 
 




 
 
 
 
 
 
 
 
 
 
 
 




 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 






 
 
 
 
 
 
 
 
 
 
 
 
















 
 
 
 
 
 
 
 
 
 
 
 






 
 








 
 




 
 


 

#line 1719 "/opt/aCC/include_std/stdcomp.h"


 

#line 1735 "/opt/aCC/include_std/stdcomp.h"



 

 








 




#line 1765 "/opt/aCC/include_std/stdcomp.h"






 









#line 1800 "/opt/aCC/include_std/stdcomp.h"

 





 














#line 1830 "/opt/aCC/include_std/stdcomp.h"













 







 





































 




 









 

#line 1913 "/opt/aCC/include_std/stdcomp.h"


#line 1926 "/opt/aCC/include_std/stdcomp.h"


#line 36 "/opt/aCC/include_std/rw/stddefs.h"








#line 60 "/opt/aCC/include_std/rw/stddefs.h"

#line 76 "/opt/aCC/include_std/rw/stddefs.h"






#line 114 "/opt/aCC/include_std/rw/stddefs.h"


#line 123 "/opt/aCC/include_std/rw/stddefs.h"


#line 131 "/opt/aCC/include_std/rw/stddefs.h"








































#line 183 "/opt/aCC/include_std/rw/stddefs.h"
  





 
#line 196 "/opt/aCC/include_std/rw/stddefs.h"
    























 
#line 227 "/opt/aCC/include_std/rw/stddefs.h"




 

#line 248 "/opt/aCC/include_std/rw/stddefs.h"


























































#line 323 "/opt/aCC/include_std/rw/stddefs.h"







#line 341 "/opt/aCC/include_std/rw/stddefs.h"























#line 371 "/opt/aCC/include_std/rw/stddefs.h"

#line 380 "/opt/aCC/include_std/rw/stddefs.h"





#line 395 "/opt/aCC/include_std/rw/stddefs.h"
     
     
     


















#line 1 "/opt/aCC/include_std/compnent.h"































 

#line 45 "/opt/aCC/include_std/compnent.h"





#line 417 "/opt/aCC/include_std/rw/stddefs.h"







































#line 468 "/opt/aCC/include_std/rw/stddefs.h"












#line 487 "/opt/aCC/include_std/rw/stddefs.h"


#line 501 "/opt/aCC/include_std/rw/stddefs.h"

#line 511 "/opt/aCC/include_std/rw/stddefs.h"



   










#line 536 "/opt/aCC/include_std/rw/stddefs.h"






















#line 573 "/opt/aCC/include_std/rw/stddefs.h"








#line 588 "/opt/aCC/include_std/rw/stddefs.h"



   
   























#line 623 "/opt/aCC/include_std/rw/stddefs.h"



#line 638 "/opt/aCC/include_std/rw/stddefs.h"




#line 648 "/opt/aCC/include_std/rw/stddefs.h"











 






#line 673 "/opt/aCC/include_std/rw/stddefs.h"






namespace __rw {

template <bool b>
struct __rw_compile_assert;

template< >
struct __rw_compile_assert<true> { enum { ok }; };




}   


#line 740 "/opt/aCC/include_std/rw/stddefs.h"



#line 749 "/opt/aCC/include_std/rw/stddefs.h"















































#line 806 "/opt/aCC/include_std/rw/stddefs.h"
















template <class _TypeUnused, bool b>
struct _C_dispatch { };

template <class _TypeUnused>
struct _C_dispatch <_TypeUnused, true> { };



























   







#line 871 "/opt/aCC/include_std/rw/stddefs.h"


#line 886 "/opt/aCC/include_std/rw/stddefs.h"










   
   








#line 915 "/opt/aCC/include_std/rw/stddefs.h"

#line 924 "/opt/aCC/include_std/rw/stddefs.h"

#line 36 "/opt/aCC/include_std/rw/rwstderr.h"



   
   
   




   
   




   










#line 73 "/opt/aCC/include_std/rw/rwstderr.h"













#line 110 "/opt/aCC/include_std/rw/rwstderr.h"






#line 36 "/opt/aCC/include_std/ios"
#line 1 "/opt/aCC/include_std/rw/rwlocale"





























 




#pragma push binding
#pragma binding default
#line 1 "/usr/include/machine/sys/inline.h"









 


typedef enum {
        _SZ_B           = 1,         
        _SZ_H           = 2,         
        _SZ_W           = 4,         
        _SZ_D           = 8          
} _Asm_sz;


typedef enum { 
        _SEM_ACQ        = 1,         
        _SEM_REL        = 2          
} _Asm_sem;


typedef enum { 
        _FASZ_W         = 4,         
        _FASZ_D         = 8          
} _Asm_fasz;


typedef enum { 
        _MBTYPE_REV     = 1,         
        _MBTYPE_MIX     = 2,         
        _MBTYPE_SHUF    = 3,         
        _MBTYPE_ALT     = 4,         
        _MBTYPE_BRCST   = 5          
} _Asm_mbtype;


typedef enum {
        _LDHINT_NONE    = 0,         
        _LDHINT_NT1     = 1,         
        _LDHINT_NTA     = 2          
} _Asm_ldhint;


typedef enum {
        _STHINT_NONE    = 0,         
        _STHINT_NTA     = 1          
} _Asm_sthint;


typedef enum {
        _LFTYPE_NONE    = 0,         
        _LFTYPE_FAULT   = 1          
} _Asm_lftype;


typedef enum {
        _LFHINT_NONE    = 0,         
        _LFHINT_NT1     = 1,         
        _LFHINT_NT2     = 2,         
        _LFHINT_NTA     = 3          
} _Asm_lfhint;


typedef enum {
        _REG_BANK_ZERO  = 0,         
        _REG_BANK_ONE   = 1          
} _Asm_reg_bank;


typedef enum {
        _PC_S           = 1,         
        _PC_D           = 2,         
        _PC_NONE        = 3          
} _Asm_pc;


typedef enum {
        _FP_NAT         = (1<<8),    
        _FP_QNAN        = (1<<7),    
        _FP_SNAN        = (1<<6),    
        _FP_POS         = (1<<0),    
        _FP_NEG         = (1<<1),    
        _FP_ZERO        = (1<<2),    
        _FP_UNNORM      = (1<<3),    
        _FP_NORM        = (1<<4),    
        _FP_INF         = (1<<5)     
} _Asm_fclass_type;


typedef enum {
        _FP_EQ          = 1,         
        _FP_LT          = 2,         
        _FP_LE          = 3,         
        _FP_GT          = 4,         
        _FP_GE          = 5,         
        _FP_UNORD       = 6,         
        _FP_NEQ         = 7,         
        _FP_NLT         = 8,         
        _FP_NLE         = 9,         
        _FP_NGT         = 10,        
        _FP_NGE         = 11,        
        _FP_ORD         = 12         
} _Asm_frel;


typedef enum {
        _FX_S           = 1,         
        _FX_ST          = 2,         
        _FX_U           = 3,         
        _FX_UT          = 4          
} _Asm_fx_type;

 
typedef enum {
        _FM_NS          = 1,         
        _FM_S           = 2,         
        _FM_SE          = 3          
} _Asm_fm_type;



typedef enum {
        _FR_S           = 1,         
        _FR_D           = 2,         
        _FR_EXP         = 3,         
        _FR_SIG         = 4          
} _Asm_fr_access;


typedef enum {
        _XM_L           = 1,         
        _XM_LU          = 2,         
        _XM_H           = 3,         
        _XM_HU          = 4          
} _Asm_xm_type; 


typedef enum {
        _SF0            = 0,         
        _SF1            = 1,         
        _SF2            = 2,         
        _SF3            = 3          
} _Asm_sf;


typedef enum {
        _PREL_EQ        = 1,         
        _PREL_GT        = 2          
} _Asm_prel;


typedef enum {
        _XSZ_1          = 1,         
        _XSZ_2          = 2,         
        _XSZ_4          = 4          
} _Asm_xsz;


typedef enum {
        _AREG0, _AREG1, _AREG2, _AREG3, _AREG4, _AREG5, _AREG6, _AREG7, _AREG8, 
        _AREG9, _AREG10, _AREG11, _AREG12, _AREG13, _AREG14, _AREG15, _AREG16, 
        _AREG17, _AREG18, _AREG19, _AREG20, _AREG21, _AREG22, _AREG23, _AREG24, 
        _AREG25, _AREG26, _AREG27, _AREG28, _AREG29, _AREG30, _AREG31, _AREG32, 
        _AREG33, _AREG34, _AREG35, _AREG36, _AREG37, _AREG38, _AREG39, _AREG40, 
        _AREG41, _AREG42, _AREG43, _AREG44, _AREG45, _AREG46, _AREG47, _AREG48, 
        _AREG49, _AREG50, _AREG51, _AREG52, _AREG53, _AREG54, _AREG55, _AREG56, 
        _AREG57, _AREG58, _AREG59, _AREG60, _AREG61, _AREG62, _AREG63, _AREG64, 
        _AREG65, _AREG66, _AREG67, _AREG68, _AREG69, _AREG70, _AREG71, _AREG72, 
        _AREG73, _AREG74, _AREG75, _AREG76, _AREG77, _AREG78, _AREG79, _AREG80, 
        _AREG81, _AREG82, _AREG83, _AREG84, _AREG85, _AREG86, _AREG87, _AREG88, 
        _AREG89, _AREG90, _AREG91, _AREG92, _AREG93, _AREG94, _AREG95, _AREG96, 
        _AREG97, _AREG98, _AREG99, _AREG100, _AREG101, _AREG102, _AREG103, 
        _AREG104, _AREG105, _AREG106, _AREG107, _AREG108, _AREG109, _AREG110, 
        _AREG111, _AREG112, _AREG113, _AREG114, _AREG115, _AREG116, _AREG117, 
        _AREG118, _AREG119, _AREG120, _AREG121, _AREG122, _AREG123, _AREG124, 
        _AREG125, _AREG126, _AREG127,

        _AREG_KR0       = _AREG0,    
        _AREG_KR1       = _AREG1,    
        _AREG_KR2       = _AREG2,    
        _AREG_KR3       = _AREG3,    
        _AREG_KR4       = _AREG4,    
        _AREG_KR5       = _AREG5,    
        _AREG_KR6       = _AREG6,    
        _AREG_KR7       = _AREG7,    
        _AREG_RSC       = _AREG16,   
        _AREG_BSP       = _AREG17,   
        _AREG_BSPSTORE  = _AREG18,   
        _AREG_RNAT      = _AREG19,   
        _AREG_CCV       = _AREG32,   
        _AREG_UNAT      = _AREG36,   
        _AREG_FPSR      = _AREG40,   
        _AREG_ITC       = _AREG44,   
        _AREG_PFS       = _AREG64,   
        _AREG_LC        = _AREG65,   
        _AREG_EC        = _AREG66,   


        _AREG_IOBASE    = _AREG_KR0, 
        _AREG_TSS       = _AREG_KR1, 
        _AREG_TSSD      = _AREG_KR2, 
        _AREG_Eflags    = _AREG24,   
        _AREG_CSD       = _AREG25,   
        _AREG_SSD       = _AREG26,   
        _AREG_CFLG      = _AREG27,   
        _AREG_FSR       = _AREG28,   
        _AREG_FIR       = _AREG29,   
        _AREG_FDR       = _AREG30    
} _Asm_app_reg;


typedef enum {
        _CREG0, _CREG1, _CREG2, _CREG3, _CREG4, _CREG5, _CREG6, _CREG7, _CREG8, 
        _CREG9, _CREG10, _CREG11, _CREG12, _CREG13, _CREG14, _CREG15, _CREG16, 
        _CREG17, _CREG18, _CREG19, _CREG20, _CREG21, _CREG22, _CREG23, _CREG24, 
        _CREG25, _CREG26, _CREG27, _CREG28, _CREG29, _CREG30, _CREG31, _CREG32, 
        _CREG33, _CREG34, _CREG35, _CREG36, _CREG37, _CREG38, _CREG39, _CREG40, 
        _CREG41, _CREG42, _CREG43, _CREG44, _CREG45, _CREG46, _CREG47, _CREG48, 
        _CREG49, _CREG50, _CREG51, _CREG52, _CREG53, _CREG54, _CREG55, _CREG56, 
        _CREG57, _CREG58, _CREG59, _CREG60, _CREG61, _CREG62, _CREG63, _CREG64, 
        _CREG65, _CREG66, _CREG67, _CREG68, _CREG69, _CREG70, _CREG71, _CREG72,
        _CREG73, _CREG74, _CREG75, _CREG76, _CREG77, _CREG78, _CREG79, _CREG80, 
        _CREG81, _CREG82, _CREG83, _CREG84, _CREG85, _CREG86, _CREG87, _CREG88, 
        _CREG89, _CREG90, _CREG91, _CREG92, _CREG93, _CREG94, _CREG95, _CREG96, 
        _CREG97, _CREG98, _CREG99, _CREG100, _CREG101, _CREG102, _CREG103, 
        _CREG104, _CREG105, _CREG106, _CREG107, _CREG108, _CREG109, _CREG110, 
        _CREG111, _CREG112, _CREG113, _CREG114, _CREG115, _CREG116, _CREG117, 
        _CREG118, _CREG119, _CREG120, _CREG121, _CREG122, _CREG123, _CREG124, 
        _CREG125, _CREG126, _CREG127,

        _CREG_DCR       = _CREG0,    
        _CREG_ITM       = _CREG1,    
        _CREG_IVA       = _CREG2,    
        _CREG_PTA       = _CREG8,    
        _CREG_GPTA      = _CREG9,    
        _CREG_IPSR      = _CREG16,   
        _CREG_ISR       = _CREG17,   
        _CREG_IIP       = _CREG19,   
        _CREG_IFA       = _CREG20,   
        _CREG_ITIR      = _CREG21,   
        _CREG_IIPA      = _CREG22,   
        _CREG_IFS       = _CREG23,   
        _CREG_IIM       = _CREG24,   
        _CREG_IHA       = _CREG25,   
        _CREG_LID       = _CREG64,   
        _CREG_IVR       = _CREG65,   
        _CREG_TPR       = _CREG66,   
        _CREG_EOI       = _CREG67,   
        _CREG_IRR0      = _CREG68,   
        _CREG_IRR1      = _CREG69,   
        _CREG_IRR2      = _CREG70,   
        _CREG_IRR3      = _CREG71,   
        _CREG_ITV       = _CREG72,   
        _CREG_PMV       = _CREG73,   
        _CREG_CMCV      = _CREG74,   
        _CREG_LRR0      = _CREG80,   
        _CREG_LRR1      = _CREG81    
} _Asm_cntl_reg;


typedef enum {
        _NO_FENCE       =  0x0,      
        _UP_MEM_FENCE   =  0x1,      
        _UP_ALU_FENCE   =  0x2,      
        _UP_FLOP_FENCE  =  0x4,      
        _UP_SYS_FENCE   =  0x8,      
        _UP_CALL_FENCE  =  0x10,     
        _UP_BR_FENCE    =  0x20,     

        _DOWN_MEM_FENCE =  0x100,    
        _DOWN_ALU_FENCE =  0x200,    
        _DOWN_FLOP_FENCE=  0x400,    
        _DOWN_SYS_FENCE =  0x800,    
        _DOWN_CALL_FENCE=  0x1000,   
        _DOWN_BR_FENCE  =  0x2000    
} _Asm_fence;



typedef enum {
	_HINT_PAUSE = 0x0      	     
} _Asm_hint_imm;

typedef enum {
    _TF_CLZ   = 32,
    _TF_SHRP4 = _TF_CLZ
} _Asm_tf_bit;

typedef enum {
    _UNGUARDED = 0,
    _GUARDED = 1
} _Asm_guarded;

#pragma pop
#line 37 "/opt/aCC/include_std/rw/rwlocale"
#line 43 "/opt/aCC/include_std/rw/rwlocale"

#line 1 "/opt/aCC/include_std/string"





























 







#line 1 "/opt/aCC/include_std/rw/iterator"














































 



#line 1 "/opt/aCC/include_std/cstddef"



#pragma push binding
#pragma binding default
#line 1 "/usr/include/stddef.h"
 














 

#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/_null.h"
 


 
 
 

 
#line 16 "/usr/include/sys/_null.h"

#line 24 "/usr/include/sys/_null.h"

 
#pragma pop
#line 21 "/usr/include/stddef.h"








#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/_wchar_t.h"
 













 







 

#line 32 "/usr/include/sys/_wchar_t.h"







#pragma pop
#line 31 "/usr/include/stddef.h"


  
    typedef long ptrdiff_t;
  

#pragma pop
#line 5 "/opt/aCC/include_std/cstddef"



namespace std
{




using ::ptrdiff_t;
using ::size_t;

}








#line 52 "/opt/aCC/include_std/rw/iterator"





#line 63 "/opt/aCC/include_std/rw/iterator"







namespace std {


struct input_iterator_tag { };
struct output_iterator_tag { };
struct forward_iterator_tag : public input_iterator_tag { };
struct bidirectional_iterator_tag : public forward_iterator_tag { };
struct random_access_iterator_tag : public bidirectional_iterator_tag { };


template <class _Category, class _TypeT,  
          class _Distance = ptrdiff_t, 
          class _Pointer = _TypeT*, 
          class _Reference = _TypeT& >
struct iterator
{
    typedef _TypeT     value_type;
    typedef _Distance  difference_type;
    typedef _Pointer   pointer;
    typedef _Reference reference;
    typedef _Category  iterator_category;
};




template <class _Iterator>
struct iterator_traits
{
    typedef typename _Iterator::value_type        value_type;
    typedef typename _Iterator::difference_type   difference_type;
    typedef typename _Iterator::pointer           pointer;
    typedef typename _Iterator::reference         reference;
    typedef typename _Iterator::iterator_category iterator_category;
};


template <class _TypeT>
struct iterator_traits<_TypeT*>
{
    typedef _TypeT                     value_type;
    typedef ptrdiff_t                  difference_type;
    typedef value_type*                pointer;
    typedef value_type&                reference;
    typedef random_access_iterator_tag iterator_category;
};


template <class _TypeT>
struct iterator_traits<const _TypeT*>
{
    typedef _TypeT                     value_type;
    typedef ptrdiff_t                  difference_type;
    typedef const value_type*          pointer;
    typedef const value_type&          reference;
    typedef random_access_iterator_tag iterator_category;
};


template <class _ForwardIterator>
inline typename iterator_traits<_ForwardIterator>::difference_type
distance (_ForwardIterator __first, _ForwardIterator __last)
{
    typename iterator_traits<_ForwardIterator>::difference_type __n = 0;

    __distance (__first, __last, __n,
                typename iterator_traits< _ForwardIterator > ::iterator_category ());

    return __n;
}


template <class _ForwardIterator, class _Distance>
inline void advance (_ForwardIterator& __i, _Distance __n)
{
    __advance (__i, __n, typename iterator_traits< _ForwardIterator > ::iterator_category ());
}








#line 176 "/opt/aCC/include_std/rw/iterator"

template <class _Iterator>
inline typename iterator_traits<_Iterator>::iterator_category
__iterator_category(const _Iterator&) {
   typedef typename iterator_traits<_Iterator>::iterator_category _IterCategory;
   return _IterCategory();
}






template <class _Tag>
inline bool __is_input_iterator (_Tag)
{
    return false;
}

template <class _Tag>
inline bool __is_bidirectional_iterator (_Tag)
{
    return false;
}

template <class _Tag>
inline bool __is_random_access_iterator (_Tag)
{
    return false;
}

template< > 
inline bool __is_input_iterator (input_iterator_tag)
{
    return true;
}

template< > 
inline bool __is_bidirectional_iterator (bidirectional_iterator_tag)
{
    return true;
}

template< > 
inline bool __is_bidirectional_iterator (random_access_iterator_tag)
{
    return true;
}

template< > 
inline bool __is_random_access_iterator (random_access_iterator_tag)
{
    return true;
}











template <class _Iterator>
inline typename iterator_traits<_Iterator>::value_type*
__value_type (_Iterator)
{ 
    return 0;
}

#line 269 "/opt/aCC/include_std/rw/iterator"









template <class _Iterator>
inline typename iterator_traits<_Iterator>::difference_type*
__distance_type (_Iterator)
{ 
    return 0;
}

#line 303 "/opt/aCC/include_std/rw/iterator"





template <class _InputIterator, class _Distance>
inline void __advance (_InputIterator &__i, _Distance __n, input_iterator_tag)
{
    while (__n > 0) {
        --__n;
        ++__i;
    }
}


template <class _ForwardIterator, class _Distance>
inline void __advance (_ForwardIterator &__i, _Distance __n,
                       forward_iterator_tag)
{
    __advance (__i, __n, input_iterator_tag ());
}


template <class _BidirectionalIterator, class _Distance>
inline void __advance (_BidirectionalIterator &__i, _Distance __n, 
                       bidirectional_iterator_tag)
{
    if (__n > 0)
        __advance (__i, __n, input_iterator_tag ());
    else
        while (__n) {
            ++__n;
            --__i;
        }
}


template <class _InputIterator, class _Distance>
inline void __distance (const _InputIterator &__first,
                        const _InputIterator &__last,
                        _Distance            &__n,
                        input_iterator_tag)
{
    for (_InputIterator __it = __first; __it != __last; ++__it)
        ++__n;
}


template <class _ForwardIterator, class _Distance>
inline void __distance (const _ForwardIterator &__first,
                        const _ForwardIterator &__last,
                        _Distance              &__n,
                        forward_iterator_tag)
{
    __distance (__first, __last, __n, input_iterator_tag ());
}

template <class _BidirectionalIterator, class _Distance>
inline void __distance (const _BidirectionalIterator &__first,
                        const _BidirectionalIterator &__last, 
                        _Distance                    &__n,
                        bidirectional_iterator_tag)
{
    __distance (__first, __last, __n, input_iterator_tag ());
}


template <class _RandomAccessIterator, class _Distance>
inline void __distance (const _RandomAccessIterator &__first,
                        const _RandomAccessIterator &__last, 
                        _Distance                   &__n,
                        random_access_iterator_tag)
{
    __n = __last - __first;
}


template <class _RandomAccessIterator, class _Distance>
inline void __advance (_RandomAccessIterator& __i, _Distance __n, 
                       random_access_iterator_tag)
{
    __i += __n;
}


template <class _ForwardIterator, class _Distance>
inline void distance (const _ForwardIterator &__first,
                      const _ForwardIterator &__last,
                      _Distance              &__n)
{
    __distance (__first, __last, __n,
                typename iterator_traits< _ForwardIterator > ::iterator_category ());
}


} 

namespace __rw {

using namespace std;






template <class _ForwardIterator, class _Distance>
inline _Distance
__rw_distance (const _ForwardIterator &__first,
               const _ForwardIterator &__last,
               _Distance               __n)
{
    std::__distance (__first, __last, __n,
                      typename iterator_traits< _ForwardIterator > ::iterator_category ());
    return __n;
}


} 

namespace std {

    
#line 435 "/opt/aCC/include_std/rw/iterator"









#line 457 "/opt/aCC/include_std/rw/iterator"




template <class _Iterator>
class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category, 
                      typename iterator_traits<_Iterator>::value_type, 
                      typename iterator_traits<_Iterator>::difference_type,
                      typename iterator_traits<_Iterator>::pointer, 
                      typename iterator_traits<_Iterator>::reference>
{
    typedef iterator_traits<_Iterator>  traits_type;
public:
    typedef typename traits_type::difference_type difference_type;
    typedef typename traits_type::value_type value_type;
    typedef typename traits_type::pointer pointer;
    typedef typename traits_type::reference reference;

#line 493 "/opt/aCC/include_std/rw/iterator"

    typedef _Iterator iterator_type;

    reverse_iterator () { }

    explicit reverse_iterator (iterator_type __rhs) : current (__rhs) { }
 




      template <class _TypeU>
      reverse_iterator (const reverse_iterator<_TypeU>& __rhs)
          : current (__rhs.base ()) { }

#line 518 "/opt/aCC/include_std/rw/iterator"


    iterator_type base () const {
        return current;
    }

    reference operator* () const {
        iterator_type __tmp = base ();
        return *--__tmp;
    }

    pointer operator->() const { return & * *this; };

    reverse_iterator& operator++ () {
        return --current, *this;
    }

    reverse_iterator operator++ (int) {
        reverse_iterator __tmp = *this;
        ++*this;
        return __tmp;
    }

    reverse_iterator& operator-- () {
        return ++current, *this;
    }

    reverse_iterator operator-- (int) {
        reverse_iterator __tmp = *this;
        --*this;
        return __tmp;
    }

    reverse_iterator& operator+= (difference_type __n) {
        return current -= __n, *this;
    }

    reverse_iterator& operator-= (difference_type __n) {
        return *this += -__n;
    }

    reverse_iterator operator+ (difference_type __n) const {
        return reverse_iterator (*this) += __n;
    }

    reverse_iterator operator- (difference_type __n) const {
        return reverse_iterator (*this) -= __n;
    }

    reference operator[] (difference_type __n) const {
        return *(*this + __n);
    }

protected:

    iterator_type current;
};


template <class _Iterator>
inline bool operator== (const reverse_iterator <_Iterator> & __x,
                        const reverse_iterator <_Iterator> & __y)
{
    return __x.base () == __y.base ();
}


template <class _Iterator>
inline bool operator< (const reverse_iterator <_Iterator> & __x,
                       const reverse_iterator <_Iterator> & __y)
{
    return __y.base() < __x.base();
}


template <class _Iterator>
inline bool operator!= (const reverse_iterator <_Iterator> & __x, 
                        const reverse_iterator <_Iterator> & __y)
{
    return !(__x == __y);
}


template <class _Iterator>
inline bool operator> (const reverse_iterator <_Iterator> & __x, 
                       const reverse_iterator <_Iterator> & __y)
{
    return __y < __x;
}


template <class _Iterator>
inline bool operator<= (const reverse_iterator <_Iterator> & __x,
                        const reverse_iterator <_Iterator> & __y)
{
    return !(__y < __x);
}


template <class _Iterator>
inline bool operator>= (const reverse_iterator <_Iterator> & __x, 
                        const reverse_iterator <_Iterator> & __y)
{
    return !(__x < __y);
}


template <class _Iterator>
inline typename iterator_traits<_Iterator> ::difference_type
operator- (const reverse_iterator <_Iterator> & __x, 
           const reverse_iterator <_Iterator> & __y)
{
    return __y.base () - __x.base ();
}


template <class _Iterator>
inline reverse_iterator <_Iterator>
operator+ (typename iterator_traits<_Iterator> ::difference_type __n, 
           const reverse_iterator <_Iterator> &     __x)
{
    return __x + __n;
}



#line 750 "/opt/aCC/include_std/rw/iterator"


#line 764 "/opt/aCC/include_std/rw/iterator"


template <class _Container>
class back_insert_iterator: public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef _Container container_type;

    explicit back_insert_iterator (container_type& __rhs)
        : container (&__rhs) { }

    back_insert_iterator&
    operator= (typename container_type::const_reference __x) {
        return container->push_back (__x), *this;
    }

    back_insert_iterator& operator*  () {
        return *this;
    }

    back_insert_iterator& operator++ () {
        return *this;
    }

    back_insert_iterator operator++ (int) {
        return *this;
    }

protected:

    container_type* container;
};


template <class _Container>
inline back_insert_iterator<_Container> back_inserter (_Container& __x)
{
    return back_insert_iterator<_Container>(__x);
}


template <class _Container>
class front_insert_iterator: public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef _Container container_type;

    explicit front_insert_iterator (container_type& __rhs)
        : container (&__rhs) { }

    front_insert_iterator&
    operator= (typename container_type::const_reference __x) { 
        return container->push_front (__x), *this;
    }

    front_insert_iterator& operator* () {
        return *this;
    }

    front_insert_iterator& operator++ () {
        return *this;
    }

    front_insert_iterator operator++ (int) {
        return *this;
    }

protected:

    container_type* container;
};


template <class _Container>
inline front_insert_iterator<_Container> front_inserter (_Container& __x)
{
    return front_insert_iterator<_Container>(__x);
}


template <class _Container>
class insert_iterator: public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef _Container container_type;

    insert_iterator (container_type& __x,
                     typename container_type::iterator __i)
      : iter (__i), container (&__x) { }

    insert_iterator&
    operator= (typename container_type::const_reference __x) { 
        iter = container->insert (iter, __x);
        return ++iter, *this;
    }

    insert_iterator& operator* () {
        return *this;
    }

    insert_iterator& operator++ () {
        return *this;
    }

    insert_iterator& operator++ (int) {
        return *this;
    }

protected:

    typename container_type::iterator iter;
    container_type*                    container;
};


template <class _Container, class _Iterator>
inline insert_iterator<_Container> inserter (_Container& __x, _Iterator __i)
{
    return insert_iterator<_Container> (__x,
                                        typename _Container::iterator (__i));
}


}   

#line 1253 "/opt/aCC/include_std/rw/iterator"

#line 39 "/opt/aCC/include_std/string"

#line 1 "/opt/aCC/include_std/stdexcept"































 

#line 1 "/opt/aCC/include_std/rw/exception.h"






























 

#line 1 "/opt/aCC/include_std/exception"










 











#line 30 "/opt/aCC/include_std/exception"








#line 45 "/opt/aCC/include_std/exception"

extern const char* __no_named_exception;
extern const char* __bad_exception;


namespace std {


  class exception {
  public:
    exception() throw() {}
    exception(const exception&) throw() {}
    exception& operator=(const exception&) throw() { return *this; }
    virtual ~exception() throw();
    virtual const char* what() const throw() {
      return __no_named_exception;
    }
  };
 

#pragma vtable OFF_IF_NO_KEY_BEGIN


  class bad_exception : public exception {
  public:
    bad_exception() throw() {}
    virtual ~bad_exception() throw() {}
    virtual const char* what() const throw() {
      return __bad_exception;
    }
  };

#pragma vtable OFF_IF_NO_KEY_END


  typedef void (*unexpected_handler)();
  unexpected_handler set_unexpected(unexpected_handler f) throw();
  void unexpected();
  typedef void (*terminate_handler)();
  terminate_handler set_terminate(terminate_handler f) throw();
  void terminate();
  bool uncaught_exception() throw();


} 


#line 104 "/opt/aCC/include_std/exception"

#line 34 "/opt/aCC/include_std/rw/exception.h"

#line 1 "/opt/aCC/include_std/cstdarg"



#pragma push binding
#pragma binding default
#line 1 "/usr/include/stdarg.h"
 







#pragma push binding
#pragma binding default
#line 1 "/usr/include/varargs.h"
 






 

#line 297 "/usr/include/varargs.h"




 







    
#line 324 "/usr/include/varargs.h"

#line 331 "/usr/include/varargs.h"

#line 355 "/usr/include/varargs.h"

 












 




#pragma pop
#line 10 "/usr/include/stdarg.h"

#pragma pop
#line 5 "/opt/aCC/include_std/cstdarg"



namespace std
{




using ::va_list;

}



#line 37 "/opt/aCC/include_std/rw/exception.h"



namespace std {



template <class _CharT, class _Traits, class _Allocator>
class  basic_string;

template <class _CharT>
struct  char_traits;

template <class _TypeT>
class  allocator;


typedef basic_string<char, char_traits<char>, allocator<char> > string;


#pragma vtable OFF_IF_NO_KEY_BEGIN



class  __rw_exception: public exception
{
    char *_C_what;   

    __rw_exception& _C_assign (const char*,
                              size_t __len = (size_t)~0) throw();

    __rw_exception& _C_vformat (const char*,
                                va_list) throw();

    __rw_exception& _C_vformat (int, va_list) throw();

public:

    __rw_exception () throw()
    : exception (), _C_what (0) { }

    __rw_exception (const __rw_exception &__rhs) throw()
    : exception (__rhs), _C_what (0) {
        *this = __rhs;
    }

    explicit __rw_exception (const string& __what) throw();
    
    explicit __rw_exception (const char* __what) throw()
    : exception (), _C_what (0) {
        _C_assign (__what);
    }

    explicit __rw_exception (int __id)  throw()
    : _C_what (0) {
        _C_format (__id);
    }

    virtual ~__rw_exception () throw() {
        delete[] _C_what;
    }

    __rw_exception&
    operator= (const __rw_exception &__rhs) throw() {
        return _C_assign (__rhs.what ()), *this;
    }

    virtual const char* what () const throw() {
        return _C_what;
    }

    
    inline __rw_exception& _C_format (const char*, ...) throw();

    
    inline __rw_exception& _C_format (int, ...) throw();
};


#pragma vtable OFF_IF_NO_KEY_END


inline __rw_exception&
__rw_exception::_C_format (const char *__fmat, ...) throw()
{
    va_list __arg;
    __va_start__(__arg);

    _C_vformat (__fmat, __arg);

    (void)0;

    return *this;
}


inline __rw_exception&
__rw_exception::_C_format (int __fmat_id, ...) throw()
{
    va_list __arg;
    __va_start__(__arg);

    _C_vformat (__fmat_id, __arg);

    (void)0;

    return *this;
}


}   


#line 35 "/opt/aCC/include_std/stdexcept"



namespace std {


#pragma vtable OFF_IF_NO_KEY_BEGIN





class logic_error: public __rw_exception
{
public:
    explicit logic_error (const string& __str) throw()
    : __rw_exception (__str) { }

    
    explicit logic_error (const char *__s = 0) throw()
    : __rw_exception (__s) { }
};



#line 85 "/opt/aCC/include_std/stdexcept"



class domain_error : public logic_error
{
public:
    explicit domain_error (const string &__str) throw()
    : logic_error (__str) { }

    
    explicit domain_error (const char *__s = 0) throw()
    : logic_error (__s) { }
};



class invalid_argument : public logic_error
{
public:
    explicit invalid_argument (const string &__str) throw()
    : logic_error (__str) { }

    
    explicit invalid_argument (const char *__s = 0) throw()
    : logic_error (__s) { }
};



class length_error : public logic_error
{
public:
    explicit length_error (const string &__str) throw()
    : logic_error (__str) { }

    
    explicit length_error (const char *__s = 0) throw()
    : logic_error (__s) { }
};



class out_of_range : public logic_error
{
public:
    explicit out_of_range (const string &__str) throw()
    : logic_error (__str) { }

    
    explicit out_of_range (const char *__s = 0) throw()
    : logic_error (__s) { }
};






class runtime_error : public __rw_exception
{
public:
    explicit runtime_error (const string &__str) throw()
    : __rw_exception (__str) { }

    
    explicit runtime_error (const char *__s = 0) throw()
    : __rw_exception (__s) { }
};



class range_error : public runtime_error
{
public:
    explicit range_error (const string &__str) throw() 
    : runtime_error (__str) { }

    
    explicit range_error (const char *__s = 0) throw() 
    : runtime_error (__s) { }
};



class overflow_error : public runtime_error
{
public:
    explicit overflow_error (const string &__str) throw() 
    : runtime_error (__str) { }

    
    explicit overflow_error (const char *__s = 0) throw() 
    : runtime_error (__s) { }
};



class underflow_error : public runtime_error
{
public:
    explicit underflow_error (const string &__str) throw() 
    : runtime_error (__str) { }

    
    explicit underflow_error (const char *__s = 0) throw() 
    : runtime_error (__s) { }
};


#pragma vtable OFF_IF_NO_KEY_END


}   


#line 41 "/opt/aCC/include_std/string"
#line 1 "/opt/aCC/include_std/limits"





























 

#line 1 "/opt/aCC/include_std/rw/math.h"




























 













#line 1 "/opt/aCC/include_std/cmath"



#pragma push binding
#pragma binding default
#line 1 "/usr/include/math.h"

































#line 43 "/usr/include/math.h"


extern "C" {


 







#pragma builtin acos, asin, atan, atan2, cos, sin, tan, cosh, sinh, tanh,                 exp, frexp, ldexp, log, log10, modf, pow, sqrt, ceil,                 fabs, floor, fmod  




   extern double acos(double);
   extern double asin(double);
   extern double atan(double);
   extern double atan2(double, double);
   extern double cos(double);
   extern double sin(double);
   extern double tan(double);
   extern double cosh(double);
   extern double sinh(double);
   extern double tanh(double);
   extern double exp(double);
   extern double frexp(double, int *);
   extern double ldexp(double, int);
   extern double log(double);
   extern double log10(double);
   extern double modf(double, double *);
   extern double pow(double, double);
   extern double sqrt(double);
   extern double ceil(double);
   extern double fabs(double);
   extern double floor(double);
   extern double fmod(double, double);

#pragma builtin acosf, asinf, atanf, atan2f, cosf, sinf, tanf, coshf,                 sinhf, tanhf, expf, frexpf, ldexpf, logf, log10f, modff,                 powf, sqrtf, ceilf, fabsf, floorf, fmodf  


extern float acosf(float);
extern float asinf(float);
extern float atanf(float);
extern float atan2f(float, float);
extern float cosf(float);
extern float sinf(float);
extern float tanf(float);
extern float coshf(float);
extern float sinhf(float);
extern float tanhf(float);
extern float expf(float);
extern float frexpf(float, int *);
extern float ldexpf(float, int);
extern float logf(float);
extern float log10f(float);
extern float modff(float, float *);
extern float powf(float, float);
extern float sqrtf(float);
extern float ceilf(float);
extern float fabsf(float);
extern float floorf(float);
extern float fmodf(float, float);

#pragma builtin acosl, asinl, atanl, atan2l, cosl, sinl, tanl, coshl,                 sinhl, tanhl, expl, frexpl, ldexpl, logl, log10l, modfl,                 powl, sqrtl, ceill, fabsl, floorl, fmodl  


extern long double acosl(long double);
extern long double asinl(long double);
extern long double atanl(long double);
extern long double atan2l(long double, long double);
extern long double cosl(long double);
extern long double sinl(long double);
extern long double tanl(long double);
extern long double coshl(long double);
extern long double sinhl(long double);
extern long double tanhl(long double);
extern long double expl(long double);
extern long double frexpl(long double, int *);
extern long double ldexpl(long double, int);
extern long double logl(long double);
extern long double log10l(long double);
extern long double modfl(long double, long double *);
extern long double powl(long double, long double);
extern long double sqrtl(long double);
extern long double ceill(long double);
extern long double fabsl(long double);
extern long double floorl(long double);
extern long double fmodl(long double, long double);


  



#line 173 "/usr/include/math.h"

     extern int signgam;



#    pragma builtin isnan, j0, j1, jn, y0, y1, yn 

#      pragma builtin gamma


       extern double gamma(double);

     extern int    isnan(double);
     extern double j0(double);
     extern double j1(double);
     extern double jn(int, double);
     extern double y0(double);
     extern double y1(double);
     extern double yn(int, double);

#  pragma builtin erf, erfc, hypot, lgamma
   extern double erf(double);
   extern double erfc(double);
   extern double hypot(double, double);
   extern double lgamma(double);






#    pragma builtin scalb 
     extern double scalb(double,double);

#  pragma builtin acosh, asinh, atanh, cbrt, expm1, ilogb, log1p, logb,                   nextafter, remainder, rint 

   extern double acosh(double);
   extern double asinh(double);
   extern double atanh(double);
   extern double cbrt(double);
   extern double expm1(double);
   extern int    ilogb(double);
   extern double log1p(double);
   extern double logb(double);
   extern double nextafter(double, double);
   extern double remainder(double, double);
   extern double rint(double);




 





       typedef float float_t;
       typedef double double_t;
#line 243 "/usr/include/math.h"

#line 273 "/usr/include/math.h"

#line 281 "/usr/include/math.h"

#line 288 "/usr/include/math.h"

#line 296 "/usr/include/math.h"

#line 311 "/usr/include/math.h"







#line 328 "/usr/include/math.h"

#line 338 "/usr/include/math.h"

#line 354 "/usr/include/math.h"


#    pragma builtin _iround, cosd, sind, tand, exp10, pown, compound,                     annuity, acosd, asind, atand, atan2d, _iceil, _ifloor,                     rsqrt, sincos, sincosd, sinhcosh, cot, cotd
#line 363 "/usr/include/math.h"
#      pragma builtin finite, drem, significand, invsqrt, gamma_r 

     extern double lgamma_r(double, int *);
     extern double cosd(double);
     extern double sind(double);
     extern double tand(double);
     extern double    exp10(double);
     extern double    pown(double, int);
     extern int	_iround(double);
     extern int	_iceil(double);
     extern int	_ifloor(double);





     extern double    compound(double, double);
     extern double    annuity(double, double);
     extern double    rsqrt(double);
     extern void      sincos(double, double *, double *);
     extern void      sincosd(double, double *, double *);
     extern void      sinhcosh(double, double *, double *);
     extern double    cot(double);
     extern double    cotd(double);

       extern int    finite(double);
       extern double significand(double);
       extern double invsqrt(double);
       extern double drem(double, double);
       extern double gamma_r(double, int *);

     extern double acosd(double);
     extern double asind(double);
     extern double atand(double);
     extern double atan2d(double, double);
#    pragma builtin cosdf, sindf,                     tandf, acosdf, asindf, atandf, atan2df, exp10f,                     pownf, scalbf, compoundf, annuityf, gammaf, _iroundf,                     _iceilf, _ifloorf, rsqrtf, sincosf, sincosdf, sinhcoshf,                     cotf, cotdf, j0f, j1f, jnf, y0f, y1f, ynf
#line 407 "/usr/include/math.h"
#      pragma builtin isnanf, finitef, dremf, significandf, invsqrtf, gammaf_r

     extern float cosdf(float);
     extern float sindf(float);
     extern float tandf(float);
     extern float acosdf(float);
     extern float asindf(float);
     extern float atandf(float);
     extern float atan2df(float, float);
     extern float exp10f(float);
     extern float pownf(float, int);



     extern float scalbf(float, float);
     extern float compoundf(float, float);
     extern float annuityf(float, float);
     extern float gammaf(float);
     extern float lgammaf_r(float, int *);
     extern int   _iroundf(float);
     extern int   _iceilf(float);
     extern int   _ifloorf(float);




     extern float rsqrtf(float);
     extern void  sincosf(float, float *, float *);
     extern void  sincosdf(float, float *, float *);
     extern void  sinhcoshf(float, float *, float *);
     extern float cotf(float);
     extern float cotdf(float);
     extern float j0f(float);
     extern float j1f(float);
     extern float jnf(int, float);
     extern float y0f(float);
     extern float y1f(float);
     extern float ynf(int, float);

       extern int   isnanf(float);
       extern int   finitef(float);
       extern float significandf(float);
       extern float invsqrtf(float);
       extern float dremf(float, float);
       extern float gammaf_r(float, int *);


#line 579 "/usr/include/math.h"

#    pragma builtin acosdl, asindl, atandl, atan2dl,                      cosdl, sindl, tandl, exp10l,                     scalbl,                     pownl, compoundl,                     annuityl, gammal,                     _iroundl,                     _iceill, _ifloorl, rsqrtl, sincosl, sincosdl, 		    sinhcoshl, cotl, cotdl, 	            j0l, j1l, jnl, y0l, y1l, ynl
#line 589 "/usr/include/math.h"





#      pragma builtin isnanl, finitel, dreml, significandl, invsqrtl, gammal_r

     extern long double acosdl(long double);
     extern long double asindl(long double);
     extern long double atandl(long double);
     extern long double atan2dl(long double, long double);
     extern long double cosdl(long double);
     extern long double sindl(long double);
     extern long double tandl(long double);
     extern long double exp10l(long double);
     extern long double scalbl(long double, long double);
     extern long double pownl(long double, int);



     extern long double compoundl(long double, long double);
     extern long double annuityl(long double, long double);
     extern long double gammal(long double);
     extern long double lgammal_r(long double, int *);
     extern int        _iroundl(long double);
     extern int        _iceill(long double);
     extern int        _ifloorl(long double);




     extern long double rsqrtl(long double);
     extern void        sincosl(long double, long double *, long double *);
     extern void        sincosdl(long double, long double *, long double *);
     extern void        sinhcoshl(long double, long double *, long double *);
     extern long double cotl(long double);
     extern long double cotdl(long double);

       extern int         isnanl(long double);
       extern int         finitel(long double);
       extern long double dreml(long double, long double);
       extern long double significandl(long double);
       extern long double invsqrtl(long double);
       extern long double gammal_r(long double, int *);
       extern long double j0l(long double);
       extern long double j1l(long double);
       extern long double jnl(int, long double);
       extern long double y0l(long double);
       extern long double y1l(long double);
       extern long double ynl(int, long double);
#line 768 "/usr/include/math.h"



#  pragma builtin copysign, log2, exp2, fdim, fmax, fmin, nan,                   scalbn, nearbyint, round, trunc, lrint, lround,                   fma, scalbln, tgamma, nexttoward






   extern double copysign(double, double);
   extern double log2(double);
   extern double exp2(double);
   extern double fdim(double, double);
   extern double fmax(double, double);
   extern double fmin(double, double);
   extern double nan(const char *);
   extern double scalbn(double, int);
   extern double nearbyint(double);
   extern double round(double);
   extern double trunc(double);
   extern double remquo(double, double, int *);
   extern long   lrint(double);
   extern long   lround(double);

     extern long long llrint(double);
     extern long long llround(double);

   extern double fma(double, double, double);
   extern double scalbln(double, long);
   extern double tgamma(double);
   extern double nexttoward(double, long double);

#  pragma builtin cbrtf, copysignf, nextafterf, log2f, exp2f,                   expm1f, log1pf, fmaf, acoshf, asinhf, atanhf, logbf,                   scalbnf, scalblnf, ilogbf, hypotf, erff, erfcf, lgammaf,                   tgammaf, nearbyintf, rintf, roundf, lrintf, lroundf,                   llrintf, llroundf, truncf, nanf, remainderf, fdimf,                   fmaxf, fminf, nexttowardf






   extern float cbrtf(float);
   extern float copysignf(float, float);
   extern float nextafterf(float, float);
   extern float log2f(float);
   extern float exp2f(float);
   extern float expm1f(float);
   extern float log1pf(float);
   extern float fmaf(float, float, float);
   extern float acoshf(float);
   extern float asinhf(float);
   extern float atanhf(float);
   extern float logbf(float);
   extern float scalbnf(float, int);
   extern float scalblnf(float, long);
   extern int   ilogbf(float);
   extern float hypotf(float, float);
   extern float erff(float);
   extern float erfcf(float);
   extern float lgammaf(float);
   extern float tgammaf(float);
   extern float nearbyintf(float);
   extern float rintf(float);
   extern float roundf(float);
   extern long  lrintf(float);
   extern long  lroundf(float);

     extern long long llrintf(float);
     extern long long llroundf(float);

   extern float truncf(float);
   extern float nanf(const char *);
   extern float remainderf(float, float);
   extern float remquof(float, float, int *);
   extern float fdimf(float, float);
   extern float fmaxf(float, float);
   extern float fminf(float, float);
   extern float nexttowardf(float, long double);

#  pragma builtin acoshl, asinhl,                   atanhl, exp2l, expm1l,                   log2l, log1pl, logbl, scalbnl, scalblnl,                   ilogbl, hypotl, cbrtl,                   erfl, erfcl, lgammal,                   tgammal, nearbyintl, rintl, roundl, lrintl, lroundl,                   truncl, nanl, remainderl, copysignl,                   nextafterl, nexttowardl, fdiml, fmaxl, fminl, fmal
#line 857 "/usr/include/math.h"
   extern long double acoshl(long double);
   extern long double asinhl(long double);
   extern long double atanhl(long double);
   extern long double exp2l(long double);
   extern long double expm1l(long double);
   extern long double log2l(long double);
   extern long double log1pl(long double);
   extern long double logbl(long double);
   extern long double scalbnl(long double, int);
   extern long double scalblnl(long double, long);
   extern int         ilogbl(long double);
   extern long double hypotl(long double, long double);
   extern long double cbrtl(long double);
   extern long double erfl(long double);
   extern long double erfcl(long double);
   extern long double lgammal(long double);
   extern long double tgammal(long double);
   extern long double nearbyintl(long double);
   extern long double rintl(long double);
   extern long double roundl(long double);
   extern long      lrintl(long double);
   extern long      lroundl(long double);

     extern long long llrintl(long double);
     extern long long llroundl(long double);

   extern long double truncl(long double);
   extern long double nanl(const char *);
   extern long double remainderl(long double, long double);
   extern long double remquol(long double, long double, int *);
   extern long double copysignl(long double, long double);
   extern long double nextafterl(long double, long double);
   extern long double nexttowardl(long double, long double);
   extern long double fdiml(long double, long double);
   extern long double fmaxl(long double, long double);
   extern long double fminl(long double, long double);
   extern long double fmal(long double, long double, long double);



#line 1191 "/usr/include/math.h"


 






#  pragma extern _DINFINITY

extern const double _DINFINITY;


#  pragma builtin _Kpow, _Kpowf, _Kpow_4, _Kpowf_4
   double _Kpow(double,int);
   float _Kpowf(float,int);
   double _Kpow_4(double,int);
   float _Kpowf_4(float,int);

#    pragma builtin _Kpoww, _Kpoww_4
     __float80 _Kpoww(__float80,int);
     __float80 _Kpoww_4(__float80,int);





#line 1233 "/usr/include/math.h"






#    pragma extern _SINFINITY, _LINFINITY, _WINFINITY, _SQNAN


   extern const float _SINFINITY;

     extern const __float128 _LINFINITY;


       extern const __float80 _WINFINITY;


#    pragma builtin _pown, _pownf, _pownl
     extern double _pown(double,int);
     extern float _pownf(float,int);
     extern long double _pownl(long double,int);
#line 1279 "/usr/include/math.h"
   extern const float _SQNAN;
#line 1291 "/usr/include/math.h"
       inline float fabsf(float __x) { return _Asm_fabs(__x); }
       inline float copysignf(float __x, float __y) { 
         return _Asm_fmerge(_FM_S,__y,__x);
       }
       inline float fmaf(float __x, float __y, float __z) { 
#        pragma STDC FENV_ACCESS ON
         return _Asm_fma(_PC_S,__x,__y,__z); 
       }
       inline float fmaxf(float __x, float __y) {
         return _Asm_fclass(__y,_FP_QNAN|_FP_SNAN)?__x:_Asm_fmax(__x,__y,_SF1);
       }
       inline float fminf(float __x, float __y) {
         return _Asm_fclass(__y,_FP_QNAN|_FP_SNAN)?__x:_Asm_fmin(__x,__y,_SF1);
       }
       inline float nanf(const char *) { return _Nan; }
#line 1313 "/usr/include/math.h"
         inline long lrintf(float __x) {
#          pragma STDC FENV_ACCESS ON
           return _Asm_getf(_FR_SIG,_Asm_fcvt_fx(_FX_S,__x));
         }
#line 1377 "/usr/include/math.h"
          
#line 1560 "/usr/include/math.h"
     extern int _Isfinite(double);
     extern int _Isinf(double);
     extern int _Isnormal(double);
     extern int _Signbit(double);
     extern int _Isunordered(double, double);
     extern int _Isless(double, double);
     extern int _Islessequal(double, double);
     extern int _Isgreater(double, double);
     extern int _Isgreaterequal(double, double);
     extern int _Isnanf(float);
     extern int _Isfinitef(float);
     extern int _Isinff(float);
     extern int _Isnormalf(float);
     extern int _Signbitf(float);
     extern int _Isunorderedf(float, float);
     extern int _Islessf(float, float);
     extern int _Islessequalf(float, float);
     extern int _Isgreaterf(float, float);
     extern int _Isgreaterequalf(float, float);

   extern int _Islessgreater(double, double);
   extern int _Islessgreaterf(float, float);
   extern int _Fpclass(double);
   extern int _Fpclassf(float);
#line 1617 "/usr/include/math.h"
       extern int _Isnanw(__float80);
       extern int _Isfinitew(__float80);
       extern int _Isinfw(__float80);
       extern int _Isnormalw(__float80);
       extern int _Signbitw(__float80);
       extern int _Isunorderedw(__float80, __float80);
       extern int _Islessw(__float80, __float80);
       extern int _Islessequalw(__float80, __float80);
       extern int _Isgreaterw(__float80, __float80);
       extern int _Isgreaterequalw(__float80, __float80);

     extern int _Islessgreaterw(__float80, __float80);
     extern int _Fpclassw(__float80);


     extern int _Isnanf128(__float128);
     extern int _Isfinitef128(__float128);
     extern int _Isinff128(__float128);
     extern int _Isnormalf128(__float128);
     extern int _Signbitf128(__float128);
     extern int _Isunorderedf128(__float128,__float128);
     extern int _Islessf128(__float128,__float128);
     extern int _Islessequalf128(__float128,__float128);
     extern int _Isgreaterf128(__float128,__float128);
     extern int _Isgreaterequalf128(__float128,__float128);
     extern int _Islessgreaterf128(__float128,__float128);
     extern int _Fpclassf128(__float128);




#line 1699 "/usr/include/math.h"


}



 

#line 1716 "/usr/include/math.h"

#pragma pop
#line 5 "/opt/aCC/include_std/cmath"












inline int abs(int d) { return (d>=0)?d:-d; }





extern "C" {
inline double fabs(double x) { return _Asm_fabs(x); }
}
inline double abs (double x) { return _Asm_fabs(x); }



inline double pow(double x, int y) { 
#       pragma STDC FENV_ACCESS ON

	return pown(x, y);



}







inline float acos (float x) { 

#       pragma STDC FENV_ACCESS ON

	return acosf(x); 
}
inline float asin (float x) { 

#       pragma STDC FENV_ACCESS ON

	return asinf(x); 
}
inline float atan (float x) { 

#       pragma STDC FENV_ACCESS ON

	return atanf(x); 
}
inline float atan2(float x, float y) { 

#       pragma STDC FENV_ACCESS ON

	return atan2f(x, y); 
}
inline float cos  (float x) { 

#       pragma STDC FENV_ACCESS ON

	return cosf(x); 
}
inline float cosh (float x) { 

#       pragma STDC FENV_ACCESS ON

	return coshf(x); 
}
inline float exp  (float x) { 

#       pragma STDC FENV_ACCESS ON

	return expf(x); 
}
inline float fmod (float x, float y) { 

#       pragma STDC FENV_ACCESS ON

	return fmodf(x, y); 
}
inline float log  (float x) { 

#       pragma STDC FENV_ACCESS ON

	return logf(x); 
}
inline float log10(float x) { 

#       pragma STDC FENV_ACCESS ON

	return log10f(x); 
}
inline float pow  (float x, float y) { 

#       pragma STDC FENV_ACCESS ON

	return powf(x, y); 
}
inline float sin  (float x) { 

#       pragma STDC FENV_ACCESS ON

	return sinf(x); 
}
inline float sinh (float x) { 

#       pragma STDC FENV_ACCESS ON

	return sinhf(x); 
}
inline float tan  (float x) { 

#       pragma STDC FENV_ACCESS ON

	return tanf(x); 
}
inline float tanh (float x) { 

#       pragma STDC FENV_ACCESS ON

	return tanhf(x); 
}
inline float sqrt (float x) { 

#	pragma STDC FENV_ACCESS ON

	return sqrtf(x); 
}




inline float fabs (float x) { return _Asm_fabs(x); }
inline float abs  (float x) { return _Asm_fabs(x); }




inline float ceil (float x) { return ceilf(x); }
inline float floor(float x) { return floorf(x); }
inline float ldexp(float x, int e) { 
#       pragma STDC FENV_ACCESS ON
	return ldexpf(x, e); 
}
inline float modf (float x, float *iptr) { return modff(x, iptr); }
inline float pow  (float x, int y) {
#       pragma STDC FENV_ACCESS ON

	return pownf(x, y);



}
inline float frexp(float x, int *eptr) { return frexpf(x, eptr); }
#line 185 "/opt/aCC/include_std/cmath"


inline long double fabs (long double x) { return fabsl(x); }
inline long double acos (long double x) { 
#       pragma STDC FENV_ACCESS ON
	return acosl(x); 
}
inline long double asin (long double x) { 
#       pragma STDC FENV_ACCESS ON
	return asinl(x); 
}
inline long double cosh (long double x) { 
#       pragma STDC FENV_ACCESS ON
return coshl(x); 
}
inline long double exp  (long double x) { 
#       pragma STDC FENV_ACCESS ON
	return expl(x); 
}
inline long double ldexp(long double x, int e) { 
#       pragma STDC FENV_ACCESS ON
	return ldexpl(x, e); 
}
inline long double log  (long double x) { 
#       pragma STDC FENV_ACCESS ON
	return logl(x); 
}
inline long double log10(long double x) { 
#       pragma STDC FENV_ACCESS ON
	return log10l(x); 
}
inline long double pow  (long double x, int y) {
#       pragma STDC FENV_ACCESS ON

	return pownl(x, y);



}
inline long double pow  (long double x, long double y) { 
#       pragma STDC FENV_ACCESS ON
	return powl(x, y); 
}
inline long double sqrt (long double x) { 
#       pragma STDC FENV_ACCESS ON
	return sqrtl(x); 
}
inline long double sinh (long double x) { 
#       pragma STDC FENV_ACCESS ON
	return sinhl(x); 
}
inline long double atan (long double x) { 
#       pragma STDC FENV_ACCESS ON
	return atanl(x); 
}
inline long double atan2(long double x, long double y) { 
#       pragma STDC FENV_ACCESS ON
	return atan2l(x, y); 
}
inline long double ceil (long double x) { return ceill(x); }
inline long double cos  (long double x) { 
#       pragma STDC FENV_ACCESS ON
	return cosl(x); 
}
inline long double floor(long double x) { return floorl(x); }
inline long double modf (long double x, long double *iptr) { return modfl(x,iptr); }
inline long double sin  (long double x) {
#       pragma STDC FENV_ACCESS ON
	return sinl(x); 
}
inline long double tan  (long double x) { 
#       pragma STDC FENV_ACCESS ON
	return tanl(x); 
}
inline long double tanh (long double x) { 
#       pragma STDC FENV_ACCESS ON
	return tanhl(x); 
}
inline long double abs  (long double x) { return fabsl(x); }
inline long double frexp(long double x, int *eptr) { return frexpl(x, eptr); }
#line 297 "/opt/aCC/include_std/cmath"











#line 468 "/opt/aCC/include_std/cmath"


extern "C" {
inline double copysign(double x, double y) { return _Asm_fmerge(_FM_S, y, x); }
inline double fma(double x, double y, double z) {
#   pragma STDC FENV_ACCESS ON
    return _Asm_fma(_PC_D, x, y, z);
}
#line 482 "/opt/aCC/include_std/cmath"
}



inline float copysign(float x, float y) { return _Asm_fmerge(_FM_S, y, x); }
inline float fma(float x, float y, float z) {
#   pragma STDC FENV_ACCESS ON
    return _Asm_fma(_PC_S, x, y, z);
}
#line 497 "/opt/aCC/include_std/cmath"
inline long lrint(float x) {
#   pragma STDC FENV_ACCESS ON

    return _Asm_getf(_FR_SIG, _Asm_fcvt_fx(_FX_S, x));



}
#line 522 "/opt/aCC/include_std/cmath"
inline float cbrt(float x) { 
#       pragma STDC FENV_ACCESS ON
	return cbrtf(x); 
}
inline float nextafter(float x, float y) { 
#       pragma STDC FENV_ACCESS ON
	return nextafterf(x, y); 
}
inline float log2(float x) { 
#       pragma STDC FENV_ACCESS ON
	return log2f(x); 
}
inline float acosd(float x) { 
#       pragma STDC FENV_ACCESS ON
	return acosdf(x); 
}
inline float asind(float x) { 
#       pragma STDC FENV_ACCESS ON
	return asindf(x); 
}
inline float exp2(float x) { 
#       pragma STDC FENV_ACCESS ON
	return exp2f(x); 
}
inline float exp10(float x) { 
#       pragma STDC FENV_ACCESS ON
	return exp10f(x); 
}
inline float expm1(float x) { 
#       pragma STDC FENV_ACCESS ON
	return expm1f(x); 
}
inline float log1p(float x) { 
#       pragma STDC FENV_ACCESS ON
	return log1pf(x); 
}
#pragma builtin sincosf
extern "C" void sincosf(float, float *, float *);
inline void sincos(float x, float *s, float *c) { 
#       pragma STDC FENV_ACCESS ON
	sincosf(x,s,c); 
	return;
}
#pragma builtin sincosdf
extern "C" void sincosdf(float, float *, float *);
inline void sincosd(float x, float *s, float *c) { 
#       pragma STDC FENV_ACCESS ON
	sincosdf(x,s,c); 
	return;
}
#pragma builtin sinhcoshf
extern "C" void sinhcoshf(float, float *, float *);
inline void sinhcosh(float x, float *s, float *c) { 
#       pragma STDC FENV_ACCESS ON
	sinhcoshf(x,s,c); 
	return;
}
inline float acosh(float x) { 
#       pragma STDC FENV_ACCESS ON
	return acoshf(x); 
}
inline float asinh(float x) { 
#       pragma STDC FENV_ACCESS ON
	return asinhf(x); 
}
inline float atanh(float x) { 
#       pragma STDC FENV_ACCESS ON
	return atanhf(x); 
}
inline float logb(float x) { 
#       pragma STDC FENV_ACCESS ON
	return logbf(x); 
}
inline float scalbn(float x, int n) { 
#       pragma STDC FENV_ACCESS ON
	return scalbnf(x, n); 
}
inline float scalbln(float x, long n) { 
#       pragma STDC FENV_ACCESS ON
	return scalblnf(x, n); 
}
inline int ilogb(float x) { 
#       pragma STDC FENV_ACCESS ON
	return ilogbf(x); 
}
inline float hypot(float x, float y) { 
#       pragma STDC FENV_ACCESS ON
	return hypotf(x,y); 
}
inline float rsqrt(float x) { 
#       pragma STDC FENV_ACCESS ON
	return rsqrtf(x); 
}
inline float lgamma(float x) { 
#       pragma STDC FENV_ACCESS ON
	return lgammaf(x); 
}
inline float tgamma(float x) { 
#       pragma STDC FENV_ACCESS ON
	return tgammaf(x); 
}
inline float nearbyint(float x) { 
#       pragma STDC FENV_ACCESS ON
	return nearbyintf(x); 
}
inline float rint(float x) { 
#       pragma STDC FENV_ACCESS ON
	return rintf(x); 
}
inline float round(float x) { return roundf(x); }
inline float trunc(float x) { return truncf(x); }
inline float remainder(float x, float y) { 
#       pragma STDC FENV_ACCESS ON
return remainderf(x, y); 
}
inline float fdim(float x, float y) { 
#       pragma STDC FENV_ACCESS ON
	return fdimf(x, y); 
}
inline float fmax(float x, float y) { return fmaxf(x, y); }
inline float fmin(float x, float y) { return fminf(x, y); }
inline float nexttoward(float x, long double y) { 
#       pragma STDC FENV_ACCESS ON
	return nexttowardf(x, y); 
}
#line 653 "/opt/aCC/include_std/cmath"
inline long lround(float x) { 
#       pragma STDC FENV_ACCESS ON
	return lroundf(x); 
}
#pragma builtin cotf
extern "C" float cotf(float);
inline float cot(float x) { 
#       pragma STDC FENV_ACCESS ON
	return cotf(x); 
}
#pragma builtin cotdf
extern "C" float cotdf(float);
inline float cotd(float x) { 
#       pragma STDC FENV_ACCESS ON
	return cotdf(x); 
}
inline float cosd(float x) { 
#       pragma STDC FENV_ACCESS ON
	return cosdf(x); 
}
inline float sind(float x) { 
#       pragma STDC FENV_ACCESS ON
	return sindf(x); 
}
inline float tand(float x) { 
#       pragma STDC FENV_ACCESS ON
	return tandf(x); 
}
inline float atand(float x) { 
#       pragma STDC FENV_ACCESS ON
	return atandf(x); 
}
inline float atan2d(float x, float y) { 
#       pragma STDC FENV_ACCESS ON
	return atan2df(x, y); 
}
inline float compound(float x, float y) { 
#       pragma STDC FENV_ACCESS ON
	return compoundf(x,y); 
}
inline float annuity(float x, float y) { 
#       pragma STDC FENV_ACCESS ON
	return annuityf(x,y); 
}
inline float erf(float x) { 
#       pragma STDC FENV_ACCESS ON
	return erff(x); 
}
inline float erfc(float x) { 
#       pragma STDC FENV_ACCESS ON
	return erfcf(x); 
}
inline float gamma(float x) { 
#       pragma STDC FENV_ACCESS ON
	return gammaf(x); 
}
inline float lgamma_r(float x, int *p) { 
#       pragma STDC FENV_ACCESS ON
	return lgammaf_r(x, p); 
}
inline float remquo(float x, float y, int *p) { 
#       pragma STDC FENV_ACCESS ON
	return remquof(x, y, p); 
}

#pragma builtin significandf
extern "C" float significandf(float);
inline float significand(float x) { 
#       pragma STDC FENV_ACCESS ON
	return significandf(x); 
}
#pragma builtin j0f
extern "C" float j0f(float);
inline float j0(float x) { 
#       pragma STDC FENV_ACCESS ON
	return j0f(x); 
}
#pragma builtin j1f
extern "C" float j1f(float);
inline float j1(float x) { 
#       pragma STDC FENV_ACCESS ON
	return j1f(x); 
}
#pragma builtin jnf
extern "C" float jnf(int, float);
inline float jn(int n, float x) { 
#       pragma STDC FENV_ACCESS ON
	return jnf(n, x); 
}
#pragma builtin y0f
extern "C" float y0f(float);
inline float y0(float x) { 
#       pragma STDC FENV_ACCESS ON
	return y0f(x); 
}
#pragma builtin y1f
extern "C" float y1f(float);
inline float y1(float x) { 
#       pragma STDC FENV_ACCESS ON
	return y1f(x); 
}
#pragma builtin ynf
extern "C" float ynf(int, float);
inline float yn(int n, float x) { 
#       pragma STDC FENV_ACCESS ON
	return ynf(n, x); 
}


#line 1299 "/opt/aCC/include_std/cmath"

inline long double copysign(long double x, long double y) { return copysignl(x,
y); }
inline long double nextafter(long double x, long double y) {
#       pragma STDC FENV_ACCESS ON
        return nextafterl(x, y);
}
inline long double log2(long double x) {
#       pragma STDC FENV_ACCESS ON
        return log2l(x);
}
inline long double acosd(long double x) {
#       pragma STDC FENV_ACCESS ON
        return acosdl(x);
}
inline long double asind(long double x) {
#       pragma STDC FENV_ACCESS ON
        return asindl(x);
}
inline long double acosh(long double x) { 
#       pragma STDC FENV_ACCESS ON
	return acoshl(x); 
}
inline long double asinh(long double x) { 
#       pragma STDC FENV_ACCESS ON
	return asinhl(x); 
}
inline long double atanh(long double x) { 
#       pragma STDC FENV_ACCESS ON
	return atanhl(x); 
}
inline long double exp2(long double x) { 
#       pragma STDC FENV_ACCESS ON
        return exp2l(x); 
}
inline long double exp10(long double x) { 
#       pragma STDC FENV_ACCESS ON
        return exp10l(x); 
}
inline long double expm1(long double x) { 
#       pragma STDC FENV_ACCESS ON
        return expm1l(x); 
}
inline long double log1p(long double x) { 
#       pragma STDC FENV_ACCESS ON
        return log1pl(x); 
}
#pragma builtin sincosl
extern "C" void sincosl(long double, long double *, long double *);
inline void sincos(long double x, long double *s, long double *c) {
#       pragma STDC FENV_ACCESS ON
        sincosl(x,s,c);
        return;
}
#pragma builtin sincosdl
extern "C" void sincosdl(long double, long double *, long double *);
inline void sincosd(long double x, long double *s, long double *c) {
#       pragma STDC FENV_ACCESS ON
        sincosdl(x,s,c);
        return;
}
#pragma builtin sinhcoshl
extern "C" void sinhcoshl(long double, long double *, long double *);
inline void sinhcosh(long double x, long double *s, long double *c) {
#       pragma STDC FENV_ACCESS ON
        sinhcoshl(x,s,c);
        return;
}
inline long double cbrt(long double x) { 
#       pragma STDC FENV_ACCESS ON
        return cbrtl(x); 
}
inline long double hypot(long double x, long double y) { 
#       pragma STDC FENV_ACCESS ON
        return hypotl(x,y); 
}
inline long double rsqrt(long double x) { 
#       pragma STDC FENV_ACCESS ON
        return rsqrtl(x); 
}
inline long double logb(long double x) { 
#       pragma STDC FENV_ACCESS ON
        return logbl(x); 
}
inline long double scalbn(long double x, int n) { 
#       pragma STDC FENV_ACCESS ON
        return scalbnl(x, n); 
}
inline long double scalbln(long double x, long n) { 
#       pragma STDC FENV_ACCESS ON
        return scalblnl(x, n); 
}
inline int ilogb(long double x) { 
#       pragma STDC FENV_ACCESS ON
        return ilogbl(x); 
}
inline long double nearbyint(long double x) { 
#       pragma STDC FENV_ACCESS ON
        return nearbyintl(x); 
}
inline long double rint(long double x) { 
#       pragma STDC FENV_ACCESS ON
        return rintl(x); 
}
inline long double round(long double x) { return roundl(x); }
inline long double trunc(long double x) { return truncl(x); }
inline long double remainder(long double x, long double y) { 
#       pragma STDC FENV_ACCESS ON
        return remainderl(x, y); 
}
inline long double fmod(long double x, long double y) { 
#       pragma STDC FENV_ACCESS ON
        return fmodl(x, y); 
}
inline long double fdim(long double x, long double y) { 
#       pragma STDC FENV_ACCESS ON
        return fdiml(x, y); 
}
inline long double fmax(long double x, long double y) { return fmaxl(x, y); }
inline long double fmin(long double x, long double y) { return fminl(x, y); }
inline long double fma(long double x, long double y, long double z) { 
#       pragma STDC FENV_ACCESS ON
        return fmal(x, y, z); 
}
inline long double nexttoward(long double x, long double y) { 
#       pragma STDC FENV_ACCESS ON
        return nexttowardl(x, y); 
}
#line 1437 "/opt/aCC/include_std/cmath"
inline long lrint(long double x) { 
#       pragma STDC FENV_ACCESS ON
        return lrintl(x); 
}
inline long lround(long double x) { 
#       pragma STDC FENV_ACCESS ON
        return lroundl(x); 
}
inline long double lgamma(long double x) { 
#       pragma STDC FENV_ACCESS ON
        return lgammal(x); 
}
inline long double tgamma(long double x) { 
#       pragma STDC FENV_ACCESS ON
        return tgammal(x); 
}
#pragma builtin cotl
extern "C" long double cotl(long double);
inline long double cot(long double x) { 
#       pragma STDC FENV_ACCESS ON
        return cotl(x); 
}
#pragma builtin cotdl
extern "C" long double cotdl(long double);
inline long double cotd(long double x) { 
#       pragma STDC FENV_ACCESS ON
        return cotdl(x); 
}
inline long double cosd(long double x) { 
#       pragma STDC FENV_ACCESS ON
        return cosdl(x); 
}
inline long double sind(long double x) { 
#       pragma STDC FENV_ACCESS ON
        return sindl(x); 
}
inline long double tand(long double x) { 
#       pragma STDC FENV_ACCESS ON
        return tandl(x); 
}
inline long double atand(long double x) { 
#       pragma STDC FENV_ACCESS ON
        return atandl(x); 
}
inline long double atan2d(long double x, long double y) { 
#       pragma STDC FENV_ACCESS ON
        return atan2dl(x, y); 
}
inline long double compound(long double x, long double y) { 
#       pragma STDC FENV_ACCESS ON
        return compoundl(x,y); 
}
inline long double annuity(long double x, long double y) { 
#       pragma STDC FENV_ACCESS ON
        return annuityl(x,y); 
}
inline long double remquo(long double x, long double y, int *p) { 
#       pragma STDC FENV_ACCESS ON
        return remquol(x, y, p); 
}
inline long double erf(long double x) { 
#       pragma STDC FENV_ACCESS ON
        return erfl(x); 
}
inline long double erfc(long double x) { 
#       pragma STDC FENV_ACCESS ON
        return erfcl(x); 
}
inline long double gamma(long double x) { 
#       pragma STDC FENV_ACCESS ON
        return gammal(x); 
}
inline long double lgamma_r(long double x, int *p) { 
#       pragma STDC FENV_ACCESS ON
        return lgammal_r(x, p); 
}

#pragma builtin significandl
extern "C" long double significandl(long double);
inline long double significand(long double x) { 
#       pragma STDC FENV_ACCESS ON
	return significandl(x); 
}
#pragma builtin j0l
extern "C" long double j0l(long double);
inline long double j0(long double x) { 
#       pragma STDC FENV_ACCESS ON
	return j0l(x); 
}
#pragma builtin j1l
extern "C" long double j1l(long double);
inline long double j1(long double x) { 
#       pragma STDC FENV_ACCESS ON
	return j1l(x); 
}
#pragma builtin jnl
extern "C" long double jnl(int, long double);
inline long double jn(int n, long double x) { 
#       pragma STDC FENV_ACCESS ON
	return jnl(n, x); 
}
#pragma builtin y0l
extern "C" long double y0l(long double);
inline long double y0(long double x) { 
#       pragma STDC FENV_ACCESS ON
	return y0l(x); 
}
#pragma builtin y1l
extern "C" long double y1l(long double);
inline long double y1(long double x) { 
#       pragma STDC FENV_ACCESS ON
	return y1l(x); 
}
#pragma builtin ynl
extern "C" long double ynl(int, long double);
inline long double yn(int n, long double x) { 
#       pragma STDC FENV_ACCESS ON
	return ynl(n, x); 
}



inline int isnan(float x)                  { return (int)_Asm_fclass(x, _FP_QNAN|_FP_SNAN); }
inline int isinf(float x)                  { return (int)_Asm_fclass(x, _FP_INF|_FP_POS|_FP_NEG); }
inline int signbit(float x)                { return (int)_Asm_getf(_FR_EXP, x)>>17; }
inline int isfinite(float x)               { return (int)_Asm_fclass(x, _FP_NORM|_FP_ZERO|_FP_UNNORM|_FP_POS|_FP_NEG); }
inline int isnormal(float x)               { return (int)_Asm_fclass(x, _FP_NORM|_FP_POS|_FP_NEG); }
inline int fpclassify(float x)             { return _Fpclassf(x); }
inline int isunordered(float x, float y)   { return (int)_Asm_fcmp(_FP_UNORD, x, y); }
inline int isgreater(float x, float y)     { return (int)_Asm_fcmp(_FP_GT, x, y, _SF1); }
inline int isgreaterequal(float x, float y){ return (int)_Asm_fcmp(_FP_GE, x, y, _SF1); }
inline int isless(float x, float y)        { return (int)_Asm_fcmp(_FP_LT, x, y, _SF1); }
inline int islessequal(float x, float y)   { return (int)_Asm_fcmp(_FP_LE, x, y, _SF1); }
inline int islessgreater(float x, float y) { return _Asm_fcmp(_FP_LT, x, y, _SF1) || _Asm_fcmp(_FP_GT, x, y, _SF1); }

extern "C" {
inline int isnan(double x)                   { return (int)_Asm_fclass(x, _FP_QNAN|_FP_SNAN); }
}
inline int isinf(double x)                   { return (int)_Asm_fclass(x, _FP_INF|_FP_POS|_FP_NEG); }
inline int signbit(double x)                 { return (int)_Asm_getf(_FR_EXP, x)>>17; }
inline int isfinite(double x)                { return (int)_Asm_fclass(x, _FP_NORM|_FP_ZERO|_FP_UNNORM|_FP_POS|_FP_NEG); }
inline int isnormal(double x)                { return (int)_Asm_fclass(x, _FP_NORM|_FP_POS|_FP_NEG); }
inline int fpclassify(double x)              { return _Fpclass(x); }
inline int isunordered(double x, double y)   { return (int)_Asm_fcmp(_FP_UNORD, x, y); }
inline int isgreater(double x, double y)     { return (int)_Asm_fcmp(_FP_GT, x, y, _SF1); }
inline int isgreaterequal(double x, double y){ return (int)_Asm_fcmp(_FP_GE, x, y, _SF1); }
inline int isless(double x, double y)        { return (int)_Asm_fcmp(_FP_LT, x, y, _SF1); }
inline int islessequal(double x, double y)   { return (int)_Asm_fcmp(_FP_LE, x, y, _SF1); }
inline int islessgreater(double x, double y) { return _Asm_fcmp(_FP_LT, x, y, _SF1) || _Asm_fcmp(_FP_GT, x, y, _SF1); }

#line 1601 "/opt/aCC/include_std/cmath"


inline int isnan(__float128 x)                        { return _Isnanf128(x); }
inline int isinf(__float128 x)                        { return _Isinff128(x); }
inline int signbit(__float128 x)                      { return _Signbitf128(x); }
inline int isfinite(__float128 x)                     { return _Isfinitef128(x); }
inline int isnormal(__float128 x)                     { return _Isnormalf128(x); }
inline int fpclassify(__float128 x)                   { return _Fpclassf128(x); }
inline int isunordered(__float128 x, __float128 y)   { return _Isunorderedf128(x,y); }
inline int isgreater(__float128 x, __float128 y)     { return _Isgreaterf128(x,y); }
inline int isgreaterequal(__float128 x, __float128 y){ return _Isgreaterequalf128(x,y); }
inline int isless(__float128 x, __float128 y)        { return _Islessf128(x,y); }
inline int islessequal(__float128 x, __float128 y)   { return _Islessequalf128(x,y); }
inline int islessgreater(__float128 x, __float128 y) { return _Islessgreaterf128(x,y); }
#line 1700 "/opt/aCC/include_std/cmath"

#line 1738 "/opt/aCC/include_std/cmath"




namespace std {
using ::abs;
using ::acos;
using ::asin;
using ::atan2;
using ::atan;
using ::ceil;
using ::cos;
using ::cosh;
using ::exp;
using ::fabs;
using ::floor;
using ::fmod;
using ::frexp;
using ::ldexp;
using ::log10;
using ::log;
using ::modf;
using ::pow;
using ::sin;
using ::sinh;
using ::sqrt;
using ::tan;
using ::tanh;
} 


#line 44 "/opt/aCC/include_std/rw/math.h"











#line 34 "/opt/aCC/include_std/limits"

#line 1 "/opt/aCC/include_std/cfloat"



#pragma push binding
#pragma binding default
#line 1 "/usr/include/float.h"
 

































#line 44 "/usr/include/float.h"
 
#line 60 "/usr/include/float.h"

#line 88 "/usr/include/float.h"

#line 110 "/usr/include/float.h"

#line 159 "/usr/include/float.h"




#line 204 "/usr/include/float.h"



#pragma pop
#line 5 "/opt/aCC/include_std/cfloat"

#line 36 "/opt/aCC/include_std/limits"
#line 1 "/opt/aCC/include_std/climits"



#pragma push binding
#pragma binding default
#line 1 "/usr/include/limits.h"
 







#line 48 "/usr/include/limits.h"

#line 58 "/usr/include/limits.h"









 
#line 98 "/usr/include/limits.h"

#line 108 "/usr/include/limits.h"
 
#line 127 "/usr/include/limits.h"






 














 









 
#line 174 "/usr/include/limits.h"

#line 186 "/usr/include/limits.h"

 


#line 207 "/usr/include/limits.h"

#line 236 "/usr/include/limits.h"




#line 263 "/usr/include/limits.h"






#line 276 "/usr/include/limits.h"





#line 293 "/usr/include/limits.h"

#line 301 "/usr/include/limits.h"


#line 312 "/usr/include/limits.h"

 
#line 326 "/usr/include/limits.h"

  
#line 335 "/usr/include/limits.h"










 
#line 356 "/usr/include/limits.h"







 


#line 372 "/usr/include/limits.h"

#line 386 "/usr/include/limits.h"

#line 417 "/usr/include/limits.h"



















 







 





 





 




 




 


 



 






 






 




 






 








#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/param.h"








  










 
#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/sysmacros.h"
 


































 

















 








 




 




 


#line 82 "/usr/include/sys/sysmacros.h"

 



 
 
 
 
 
 




 
#line 108 "/usr/include/sys/sysmacros.h"












 
#line 131 "/usr/include/sys/sysmacros.h"

#pragma pop
#line 24 "/usr/include/sys/param.h"
#pragma push binding
#pragma binding default
#line 1 "/usr/include/machine/sys/param.h"







 








#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/debug.h"




 



 




#pragma pop
#line 19 "/usr/include/machine/sys/param.h"




#line 61 "/usr/include/machine/sys/param.h"



#pragma pop
#line 26 "/usr/include/sys/param.h"
#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/time.h"


 



















 









extern "C" {

 

 

 



 

#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/_timeval.h"
 











 










struct timeval {

	time_t	tv_sec;		 




	long		tv_usec;	 



};
#pragma pop
#line 47 "/usr/include/sys/time.h"



 
struct	itimerval {
	struct timeval	it_interval;	 
	struct timeval	it_value;	 
};

 






 


#      pragma extern getitimer

extern int getitimer (int, struct itimerval *);


#      pragma extern setitimer

extern int setitimer (int, const struct itimerval * , struct itimerval * );



#      pragma extern gettimeofday

extern int gettimeofday (struct timeval * , void * );




#        pragma extern select

extern int select (int, fd_set * , fd_set * , fd_set * , struct timeval * );




#      pragma extern utimes

extern int utimes (const char *, const struct timeval[2]);



 



 











 




 
#line 125 "/usr/include/sys/time.h"





 
















 

















#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/_timespec.h"
 









 






struct timespec {
	time_t	tv_sec;		 
	long		tv_nsec;	 
};
typedef struct timespec timestruc_t;


#pragma pop
#line 167 "/usr/include/sys/time.h"


 
struct timezone {
	int	tz_minuteswest;	 
	int	tz_dsttime;	 
};


 
typedef struct __cycles {	 
	uint32_t hi;		 
	uint32_t lo;		 
} cycles_t;



 
struct ki_timeval {
	uint32_t	pad1;		
	uint32_t	pad2;	
};










 

 



typedef uint64_t kt_t;





 




#      pragma extern  adjtime

extern int adjtime (const struct timeval *, struct timeval *);


#      pragma extern  settimeofday

extern int settimeofday (const struct timeval *, const struct timezone *);


#      pragma extern  stime

extern int stime (const time_t *);


#      pragma extern  profil

extern void profil (void *, size_t, size_t, int);





}



#pragma pop
#line 27 "/usr/include/sys/param.h"



 






 


















 









 





 






#line 87 "/usr/include/sys/param.h"









#line 105 "/usr/include/sys/param.h"







 
#line 124 "/usr/include/sys/param.h"













 





 






 




 




 




 





 

#line 185 "/usr/include/sys/param.h"



 

#line 196 "/usr/include/sys/param.h"



 





 




 





 




 







 









 



 



















 













 






 


 				 
 				 
 				 
 				 




















 













 











#line 345 "/usr/include/sys/param.h"

#line 355 "/usr/include/sys/param.h"








 















 








 














 




 







 







 





 




 



#line 452 "/usr/include/sys/param.h"

#line 466 "/usr/include/sys/param.h"

#pragma pop
#line 509 "/usr/include/limits.h"



#line 519 "/usr/include/limits.h"

#line 532 "/usr/include/limits.h"


#line 550 "/usr/include/limits.h"

#line 559 "/usr/include/limits.h"

 



#line 577 "/usr/include/limits.h"





 





 








#pragma pop
#line 5 "/opt/aCC/include_std/climits"

#line 37 "/opt/aCC/include_std/limits"























 





#line 79 "/opt/aCC/include_std/limits"


#line 87 "/opt/aCC/include_std/limits"







#line 100 "/opt/aCC/include_std/limits"

#line 109 "/opt/aCC/include_std/limits"









extern const float _FLT_NANS;         
extern const float _FLT_DMIN;         





extern const double _DBL_NANS;        
extern const double _DBL_DMIN;        

#line 134 "/opt/aCC/include_std/limits"





extern const long double _LDBL_NANS;  
extern const long double _LDBL_DMIN;  

#line 166 "/opt/aCC/include_std/limits"















#line 226 "/opt/aCC/include_std/limits"















namespace std {


enum float_round_style
{
    round_indeterminate       = -1,
    round_toward_zero         =  0,
    round_to_nearest          =  1,
    round_toward_infinity     =  2,
    round_toward_neg_infinity =  3
};

enum float_denorm_style
{
    denorm_indeterminate = -1,
    denorm_absent        =  0,
    denorm_present       =  1
};

template <class _TypeT>
class numeric_limits
{
public:
    
    
    

    static const bool is_specialized = false;

    static _TypeT min () throw() { return 0; }
    static _TypeT max () throw() { return 0; }

    static const int digits = 0;
    static const int digits10 = 0;

    static const bool is_signed = false;
    static const bool is_integer = false;
    static const bool is_exact = false;

    static const int radix = 0;

    static _TypeT epsilon () throw() { return 0; }
    static _TypeT round_error () throw() { return 0; }

    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;

    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;

    static _TypeT infinity () throw() { return 0; }
    static _TypeT quiet_NaN () throw() { return 0; }
    static _TypeT signaling_NaN () throw() { return 0; }
    static _TypeT denorm_min () throw() { return 0; }

    static const bool is_iec559 = false;
    static const bool is_bounded = false;
    static const bool is_modulo = false;
    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
};


}   









namespace std {



template< > class numeric_limits<float> { public:

    static const bool  is_specialized = (true);

    static float min () throw() { return 1.17549435082228750797E-38F; }
    static float max () throw() { return 3.40282346638528859812E+38F; }

    static const int  digits = (24);
    static const int  digits10 = (6);

    static const bool  is_signed = (true);
    static const bool  is_integer = (false);
    static const bool  is_exact = (false);
    static const int  radix = (2);

    static float epsilon () throw() { return 1.19209289550781250000E-07F; }
    static float round_error () throw() { return 0.5f; }

    static const int  min_exponent = ((-125));
    static const int  min_exponent10 = ((-37));
    static const int  max_exponent = (128);
    static const int  max_exponent10 = (38);

    static const bool  has_infinity = (true);         
    static const bool  has_quiet_NaN = (true);         
    static const bool  has_signaling_NaN = (true);         
    static const float_denorm_style  has_denorm = (denorm_present);                               

    static const bool  has_denorm_loss = (false);          


    static float infinity () throw() { return _Infinity; };               
    static float quiet_NaN () throw() { return _Nan; };                   




    static float signaling_NaN () throw() { return _FLT_NANS; };          
    static float denorm_min () throw() { return _FLT_DMIN; };             

    static const bool  is_iec559 = (true);                
    static const bool  is_bounded = (true);
    static const bool  is_modulo = (false);               

    static const bool  traps = (true);                     
    static const bool  tinyness_before = (true);           

    static const float_round_style  round_style = (static_cast< float_round_style >(1));

     
    typedef double _C_convertible;

};   


template< > class numeric_limits<double> { public:

    static const bool  is_specialized = (true);

    static double min () throw() { return 2.22507385850720138309E-308; }
    static double max () throw() { return 1.79769313486231570815E+308; }

    static const int  digits = (53);
    static const int  digits10 = (15);

    static const bool  is_signed = (true);
    static const bool  is_integer = (false);
    static const bool  is_exact = (false);
    static const int  radix = (2);

    static double epsilon () throw() { return 2.22044604925031308085E-16; }
    static double round_error () throw() { return 0.5; }

    static const int  min_exponent = ((-1021));
    static const int  min_exponent10 = ((-307));
    static const int  max_exponent = (1024);
    static const int  max_exponent10 = (308);

    static const bool  has_infinity = (true);             
    static const bool  has_quiet_NaN = (true);            
    static const bool  has_signaling_NaN = (true);        
    static const float_denorm_style  has_denorm = (denorm_present);                               

    static const bool  has_denorm_loss = (false);       


    static double infinity () throw() { return ((double)_Infinity); };    
    static double quiet_NaN () throw() { return ((double)_Nan); };        




    static double signaling_NaN () throw() { return _DBL_NANS; };         
    static double denorm_min () throw() { return _DBL_DMIN; };            

    static const bool  is_iec559 = (true);               
    static const bool  is_bounded = (true);
    static const bool  is_modulo = (false);              

    static const bool  traps = (true);                    
    static const bool  tinyness_before = (true);          

    static const float_round_style  round_style = (static_cast< float_round_style >(1));

     

    typedef __float80 _C_convertible;




};   




#line 492 "/opt/aCC/include_std/limits"







template< > class numeric_limits<long double> { public:

    static const bool  is_specialized = (true);

    static long double min () throw() { return 3.36210314311209350626267781732175261E-4932L; } 
    static long double max () throw() { return 1.18973149535723176508575932662800702E+4932L; } 

    static const int  digits = (113);
    static const int  digits10 = (33);

    static const bool  is_signed = (true);
    static const bool  is_integer = (false);
    static const bool  is_exact = (false);
    static const int  radix = (2);

    static long double epsilon () throw() { return 1.92592994438723585305597794258492732E-34L; } 
    static long double round_error () throw() { return 0.5L; } 

    static const int  min_exponent = ((-16381));
    static const int  min_exponent10 = ((-4931));
    static const int  max_exponent = (16384);
    static const int  max_exponent10 = (4932);

    static const bool  has_infinity = (true);   
    static const bool  has_quiet_NaN = (true);   
    static const bool  has_signaling_NaN = (true);   
    static const float_denorm_style  has_denorm = (denorm_present);                               

    static const bool  has_denorm_loss = (false);  


    static long double infinity () throw() { return ((long double)_Infinity); };                 

    static long double quiet_NaN () throw() { return ((long double)_Nan); };                      





    static long double signaling_NaN () throw() { return _LDBL_NANS; };   
    static long double denorm_min () throw() { return _LDBL_DMIN; };      

    static const bool  is_iec559 = (true);          
    static const bool  is_bounded = (true);
    static const bool  is_modulo = (false);         

    static const bool  traps = (true);               
    static const bool  tinyness_before = (true);     

    static const float_round_style  round_style = (static_cast< float_round_style >(1));


     
    typedef long double _C_convertible;

};    











#line 577 "/opt/aCC/include_std/limits"






















#line 605 "/opt/aCC/include_std/limits"

#line 615 "/opt/aCC/include_std/limits"


template< > class numeric_limits<char> { public: static const bool  is_specialized = (true); static char min () throw() { return (-128); } static char max () throw() { return 127; } static const bool  is_signed = ((-128) != 0); static const bool  is_integer = (true); static const bool  is_exact = (true); static const int  digits = (1 == 127 ? 1 : (8 * sizeof (char) - is_signed)); static const int  digits10 = ((((digits) * 301) / 1000)); static const int  radix = (2); static char epsilon () throw() { return 0; } static char round_error () throw() { return 0; } static const int  min_exponent = (0); static const int  min_exponent10 = (0); static const int  max_exponent = (0); static const int  max_exponent10 = (0); static const bool  has_infinity = (false); static const bool  has_quiet_NaN = (false); static const bool  has_signaling_NaN = (false); static const float_denorm_style  has_denorm = (denorm_absent); static const bool  has_denorm_loss = (false); static char infinity () throw() { return 0; } static char quiet_NaN () throw() { return 0; } static char signaling_NaN () throw() { return 0; } static char denorm_min () throw() { return 0; } static const bool  is_iec559 = (false); static const bool  is_bounded = (true); static const bool  is_modulo = (1 != 127); static const bool  traps = (false); static const bool  tinyness_before = (false); static const float_round_style  round_style = (round_toward_zero); typedef int _C_convertible; };


template< > class numeric_limits<unsigned char> { public: static const bool  is_specialized = (true); static unsigned char min () throw() { return 0; } static unsigned char max () throw() { return 0377; } static const bool  is_signed = (0 != 0); static const bool  is_integer = (true); static const bool  is_exact = (true); static const int  digits = (1 == 0377 ? 1 : (8 * sizeof (unsigned char) - is_signed)); static const int  digits10 = ((((digits) * 301) / 1000)); static const int  radix = (2); static unsigned char epsilon () throw() { return 0; } static unsigned char round_error () throw() { return 0; } static const int  min_exponent = (0); static const int  min_exponent10 = (0); static const int  max_exponent = (0); static const int  max_exponent10 = (0); static const bool  has_infinity = (false); static const bool  has_quiet_NaN = (false); static const bool  has_signaling_NaN = (false); static const float_denorm_style  has_denorm = (denorm_absent); static const bool  has_denorm_loss = (false); static unsigned char infinity () throw() { return 0; } static unsigned char quiet_NaN () throw() { return 0; } static unsigned char signaling_NaN () throw() { return 0; } static unsigned char denorm_min () throw() { return 0; } static const bool  is_iec559 = (false); static const bool  is_bounded = (true); static const bool  is_modulo = (1 != 0377); static const bool  traps = (false); static const bool  tinyness_before = (false); static const float_round_style  round_style = (round_toward_zero); typedef unsigned int _C_convertible; };

template< > class numeric_limits<signed char> { public: static const bool  is_specialized = (true); static signed char min () throw() { return (-128); } static signed char max () throw() { return 127; } static const bool  is_signed = ((-128) != 0); static const bool  is_integer = (true); static const bool  is_exact = (true); static const int  digits = (1 == 127 ? 1 : (8 * sizeof (signed char) - is_signed)); static const int  digits10 = ((((digits) * 301) / 1000)); static const int  radix = (2); static signed char epsilon () throw() { return 0; } static signed char round_error () throw() { return 0; } static const int  min_exponent = (0); static const int  min_exponent10 = (0); static const int  max_exponent = (0); static const int  max_exponent10 = (0); static const bool  has_infinity = (false); static const bool  has_quiet_NaN = (false); static const bool  has_signaling_NaN = (false); static const float_denorm_style  has_denorm = (denorm_absent); static const bool  has_denorm_loss = (false); static signed char infinity () throw() { return 0; } static signed char quiet_NaN () throw() { return 0; } static signed char signaling_NaN () throw() { return 0; } static signed char denorm_min () throw() { return 0; } static const bool  is_iec559 = (false); static const bool  is_bounded = (true); static const bool  is_modulo = (1 != 127); static const bool  traps = (false); static const bool  tinyness_before = (false); static const float_round_style  round_style = (round_toward_zero); typedef int _C_convertible; };

template< > class numeric_limits<short int> { public: static const bool  is_specialized = (true); static short int min () throw() { return (-32768); } static short int max () throw() { return 32767; } static const bool  is_signed = ((-32768) != 0); static const bool  is_integer = (true); static const bool  is_exact = (true); static const int  digits = (1 == 32767 ? 1 : (8 * sizeof (short int) - is_signed)); static const int  digits10 = ((((digits) * 301) / 1000)); static const int  radix = (2); static short int epsilon () throw() { return 0; } static short int round_error () throw() { return 0; } static const int  min_exponent = (0); static const int  min_exponent10 = (0); static const int  max_exponent = (0); static const int  max_exponent10 = (0); static const bool  has_infinity = (false); static const bool  has_quiet_NaN = (false); static const bool  has_signaling_NaN = (false); static const float_denorm_style  has_denorm = (denorm_absent); static const bool  has_denorm_loss = (false); static short int infinity () throw() { return 0; } static short int quiet_NaN () throw() { return 0; } static short int signaling_NaN () throw() { return 0; } static short int denorm_min () throw() { return 0; } static const bool  is_iec559 = (false); static const bool  is_bounded = (true); static const bool  is_modulo = (1 != 32767); static const bool  traps = (false); static const bool  tinyness_before = (false); static const float_round_style  round_style = (round_toward_zero); typedef int _C_convertible; };


template< > class numeric_limits<unsigned short> { public: static const bool  is_specialized = (true); static unsigned short min () throw() { return 0; } static unsigned short max () throw() { return 0177777; } static const bool  is_signed = (0 != 0); static const bool  is_integer = (true); static const bool  is_exact = (true); static const int  digits = (1 == 0177777 ? 1 : (8 * sizeof (unsigned short) - is_signed)); static const int  digits10 = ((((digits) * 301) / 1000)); static const int  radix = (2); static unsigned short epsilon () throw() { return 0; } static unsigned short round_error () throw() { return 0; } static const int  min_exponent = (0); static const int  min_exponent10 = (0); static const int  max_exponent = (0); static const int  max_exponent10 = (0); static const bool  has_infinity = (false); static const bool  has_quiet_NaN = (false); static const bool  has_signaling_NaN = (false); static const float_denorm_style  has_denorm = (denorm_absent); static const bool  has_denorm_loss = (false); static unsigned short infinity () throw() { return 0; } static unsigned short quiet_NaN () throw() { return 0; } static unsigned short signaling_NaN () throw() { return 0; } static unsigned short denorm_min () throw() { return 0; } static const bool  is_iec559 = (false); static const bool  is_bounded = (true); static const bool  is_modulo = (1 != 0177777); static const bool  traps = (false); static const bool  tinyness_before = (false); static const float_round_style  round_style = (round_toward_zero); typedef unsigned int _C_convertible; };

template< > class numeric_limits<int> { public: static const bool  is_specialized = (true); static int min () throw() { return (-2147483647 - 1); } static int max () throw() { return 2147483647; } static const bool  is_signed = ((-2147483647 - 1) != 0); static const bool  is_integer = (true); static const bool  is_exact = (true); static const int  digits = (1 == 2147483647 ? 1 : (8 * sizeof (int) - is_signed)); static const int  digits10 = ((((digits) * 301) / 1000)); static const int  radix = (2); static int epsilon () throw() { return 0; } static int round_error () throw() { return 0; } static const int  min_exponent = (0); static const int  min_exponent10 = (0); static const int  max_exponent = (0); static const int  max_exponent10 = (0); static const bool  has_infinity = (false); static const bool  has_quiet_NaN = (false); static const bool  has_signaling_NaN = (false); static const float_denorm_style  has_denorm = (denorm_absent); static const bool  has_denorm_loss = (false); static int infinity () throw() { return 0; } static int quiet_NaN () throw() { return 0; } static int signaling_NaN () throw() { return 0; } static int denorm_min () throw() { return 0; } static const bool  is_iec559 = (false); static const bool  is_bounded = (true); static const bool  is_modulo = (1 != 2147483647); static const bool  traps = (false); static const bool  tinyness_before = (false); static const float_round_style  round_style = (round_toward_zero); typedef long _C_convertible; };


template< > class numeric_limits<unsigned int> { public: static const bool  is_specialized = (true); static unsigned int min () throw() { return 0; } static unsigned int max () throw() { return 4294967295U; } static const bool  is_signed = (0 != 0); static const bool  is_integer = (true); static const bool  is_exact = (true); static const int  digits = (1 == 4294967295U ? 1 : (8 * sizeof (unsigned int) - is_signed)); static const int  digits10 = ((((digits) * 301) / 1000)); static const int  radix = (2); static unsigned int epsilon () throw() { return 0; } static unsigned int round_error () throw() { return 0; } static const int  min_exponent = (0); static const int  min_exponent10 = (0); static const int  max_exponent = (0); static const int  max_exponent10 = (0); static const bool  has_infinity = (false); static const bool  has_quiet_NaN = (false); static const bool  has_signaling_NaN = (false); static const float_denorm_style  has_denorm = (denorm_absent); static const bool  has_denorm_loss = (false); static unsigned int infinity () throw() { return 0; } static unsigned int quiet_NaN () throw() { return 0; } static unsigned int signaling_NaN () throw() { return 0; } static unsigned int denorm_min () throw() { return 0; } static const bool  is_iec559 = (false); static const bool  is_bounded = (true); static const bool  is_modulo = (1 != 4294967295U); static const bool  traps = (false); static const bool  tinyness_before = (false); static const float_round_style  round_style = (round_toward_zero); typedef unsigned long _C_convertible; };

template< > class numeric_limits<long int> { public: static const bool  is_specialized = (true); static long int min () throw() { return (-9223372036854775807L - 1); } static long int max () throw() { return 9223372036854775807L; } static const bool  is_signed = ((-9223372036854775807L - 1) != 0); static const bool  is_integer = (true); static const bool  is_exact = (true); static const int  digits = (1 == 9223372036854775807L ? 1 : (8 * sizeof (long int) - is_signed)); static const int  digits10 = ((((digits) * 301) / 1000)); static const int  radix = (2); static long int epsilon () throw() { return 0; } static long int round_error () throw() { return 0; } static const int  min_exponent = (0); static const int  min_exponent10 = (0); static const int  max_exponent = (0); static const int  max_exponent10 = (0); static const bool  has_infinity = (false); static const bool  has_quiet_NaN = (false); static const bool  has_signaling_NaN = (false); static const float_denorm_style  has_denorm = (denorm_absent); static const bool  has_denorm_loss = (false); static long int infinity () throw() { return 0; } static long int quiet_NaN () throw() { return 0; } static long int signaling_NaN () throw() { return 0; } static long int denorm_min () throw() { return 0; } static const bool  is_iec559 = (false); static const bool  is_bounded = (true); static const bool  is_modulo = (1 != 9223372036854775807L); static const bool  traps = (false); static const bool  tinyness_before = (false); static const float_round_style  round_style = (round_toward_zero); typedef long long _C_convertible; };


template< > class numeric_limits<unsigned long int> { public: static const bool  is_specialized = (true); static unsigned long int min () throw() { return 0; } static unsigned long int max () throw() { return 18446744073709551615UL; } static const bool  is_signed = (0 != 0); static const bool  is_integer = (true); static const bool  is_exact = (true); static const int  digits = (1 == 18446744073709551615UL ? 1 : (8 * sizeof (unsigned long int) - is_signed)); static const int  digits10 = ((((digits) * 301) / 1000)); static const int  radix = (2); static unsigned long int epsilon () throw() { return 0; } static unsigned long int round_error () throw() { return 0; } static const int  min_exponent = (0); static const int  min_exponent10 = (0); static const int  max_exponent = (0); static const int  max_exponent10 = (0); static const bool  has_infinity = (false); static const bool  has_quiet_NaN = (false); static const bool  has_signaling_NaN = (false); static const float_denorm_style  has_denorm = (denorm_absent); static const bool  has_denorm_loss = (false); static unsigned long int infinity () throw() { return 0; } static unsigned long int quiet_NaN () throw() { return 0; } static unsigned long int signaling_NaN () throw() { return 0; } static unsigned long int denorm_min () throw() { return 0; } static const bool  is_iec559 = (false); static const bool  is_bounded = (true); static const bool  is_modulo = (1 != 18446744073709551615UL); static const bool  traps = (false); static const bool  tinyness_before = (false); static const float_round_style  round_style = (round_toward_zero); typedef unsigned long long _C_convertible; };


#line 649 "/opt/aCC/include_std/limits"

#line 659 "/opt/aCC/include_std/limits"



#line 668 "/opt/aCC/include_std/limits"
                        
#line 679 "/opt/aCC/include_std/limits"


template< > class numeric_limits<wchar_t> { public: static const bool  is_specialized = (true); static wchar_t min () throw() { return ( wchar_t (0) - 1 > 0 ? 0 : sizeof (wchar_t) == sizeof (short) ? (-32768) : sizeof (wchar_t) == sizeof (int) ? (-2147483647 - 1) : sizeof (wchar_t) == sizeof (long) ? (-9223372036854775807L - 1) : (-128)); } static wchar_t max () throw() { return ( wchar_t (0) - 1 > 0 ? ( sizeof (wchar_t) == sizeof (short) ? 0177777 : sizeof (wchar_t) == sizeof (int) ? 4294967295U : sizeof (wchar_t) == sizeof (long) ? 18446744073709551615UL : 127) : ( sizeof (wchar_t) == sizeof (short) ? 32767 : sizeof (wchar_t) == sizeof (int) ? 2147483647 : sizeof (wchar_t) == sizeof (long) ? 9223372036854775807L : 0377)); } static const bool  is_signed = (( wchar_t (0) - 1 > 0 ? 0 : sizeof (wchar_t) == sizeof (short) ? (-32768) : sizeof (wchar_t) == sizeof (int) ? (-2147483647 - 1) : sizeof (wchar_t) == sizeof (long) ? (-9223372036854775807L - 1) : (-128)) != 0); static const bool  is_integer = (true); static const bool  is_exact = (true); static const int  digits = (1 == ( wchar_t (0) - 1 > 0 ? ( sizeof (wchar_t) == sizeof (short) ? 0177777 : sizeof (wchar_t) == sizeof (int) ? 4294967295U : sizeof (wchar_t) == sizeof (long) ? 18446744073709551615UL : 127) : ( sizeof (wchar_t) == sizeof (short) ? 32767 : sizeof (wchar_t) == sizeof (int) ? 2147483647 : sizeof (wchar_t) == sizeof (long) ? 9223372036854775807L : 0377)) ? 1 : (8 * sizeof (wchar_t) - is_signed)); static const int  digits10 = ((((digits) * 301) / 1000)); static const int  radix = (2); static wchar_t epsilon () throw() { return 0; } static wchar_t round_error () throw() { return 0; } static const int  min_exponent = (0); static const int  min_exponent10 = (0); static const int  max_exponent = (0); static const int  max_exponent10 = (0); static const bool  has_infinity = (false); static const bool  has_quiet_NaN = (false); static const bool  has_signaling_NaN = (false); static const float_denorm_style  has_denorm = (denorm_absent); static const bool  has_denorm_loss = (false); static wchar_t infinity () throw() { return 0; } static wchar_t quiet_NaN () throw() { return 0; } static wchar_t signaling_NaN () throw() { return 0; } static wchar_t denorm_min () throw() { return 0; } static const bool  is_iec559 = (false); static const bool  is_bounded = (true); static const bool  is_modulo = (1 != ( wchar_t (0) - 1 > 0 ? ( sizeof (wchar_t) == sizeof (short) ? 0177777 : sizeof (wchar_t) == sizeof (int) ? 4294967295U : sizeof (wchar_t) == sizeof (long) ? 18446744073709551615UL : 127) : ( sizeof (wchar_t) == sizeof (short) ? 32767 : sizeof (wchar_t) == sizeof (int) ? 2147483647 : sizeof (wchar_t) == sizeof (long) ? 9223372036854775807L : 0377))); static const bool  traps = (false); static const bool  tinyness_before = (false); static const float_round_style  round_style = (round_toward_zero); typedef long _C_convertible; };












template< > class numeric_limits<bool> { public: static const bool  is_specialized = (true); static bool min () throw() { return false; } static bool max () throw() { return true; } static const bool  is_signed = (false != 0); static const bool  is_integer = (true); static const bool  is_exact = (true); static const int  digits = (1 == true ? 1 : (8 * sizeof (bool) - is_signed)); static const int  digits10 = ((((digits) * 301) / 1000)); static const int  radix = (2); static bool epsilon () throw() { return 0; } static bool round_error () throw() { return 0; } static const int  min_exponent = (0); static const int  min_exponent10 = (0); static const int  max_exponent = (0); static const int  max_exponent10 = (0); static const bool  has_infinity = (false); static const bool  has_quiet_NaN = (false); static const bool  has_signaling_NaN = (false); static const float_denorm_style  has_denorm = (denorm_absent); static const bool  has_denorm_loss = (false); static bool infinity () throw() { return 0; } static bool quiet_NaN () throw() { return 0; } static bool signaling_NaN () throw() { return 0; } static bool denorm_min () throw() { return 0; } static const bool  is_iec559 = (false); static const bool  is_bounded = (true); static const bool  is_modulo = (1 != true); static const bool  traps = (false); static const bool  tinyness_before = (false); static const float_round_style  round_style = (round_toward_zero); typedef int _C_convertible; };















#line 724 "/opt/aCC/include_std/limits"








template< > class numeric_limits<long long> { public: static const bool  is_specialized = (true); static long long min () throw() { return (-9223372036854775807LL -1); } static long long max () throw() { return 9223372036854775807LL; } static const bool  is_signed = ((-9223372036854775807LL -1) != 0); static const bool  is_integer = (true); static const bool  is_exact = (true); static const int  digits = (1 == 9223372036854775807LL ? 1 : (8 * sizeof (long long) - is_signed)); static const int  digits10 = ((((digits) * 301) / 1000)); static const int  radix = (2); static long long epsilon () throw() { return 0; } static long long round_error () throw() { return 0; } static const int  min_exponent = (0); static const int  min_exponent10 = (0); static const int  max_exponent = (0); static const int  max_exponent10 = (0); static const bool  has_infinity = (false); static const bool  has_quiet_NaN = (false); static const bool  has_signaling_NaN = (false); static const float_denorm_style  has_denorm = (denorm_absent); static const bool  has_denorm_loss = (false); static long long infinity () throw() { return 0; } static long long quiet_NaN () throw() { return 0; } static long long signaling_NaN () throw() { return 0; } static long long denorm_min () throw() { return 0; } static const bool  is_iec559 = (false); static const bool  is_bounded = (true); static const bool  is_modulo = (1 != 9223372036854775807LL); static const bool  traps = (false); static const bool  tinyness_before = (false); static const float_round_style  round_style = (round_toward_zero); typedef long long _C_convertible; };


template< > class numeric_limits<unsigned long long> { public: static const bool  is_specialized = (true); static unsigned long long min () throw() { return 0; } static unsigned long long max () throw() { return 18446744073709551615ULL; } static const bool  is_signed = (0 != 0); static const bool  is_integer = (true); static const bool  is_exact = (true); static const int  digits = (1 == 18446744073709551615ULL ? 1 : (8 * sizeof (unsigned long long) - is_signed)); static const int  digits10 = ((((digits) * 301) / 1000)); static const int  radix = (2); static unsigned long long epsilon () throw() { return 0; } static unsigned long long round_error () throw() { return 0; } static const int  min_exponent = (0); static const int  min_exponent10 = (0); static const int  max_exponent = (0); static const int  max_exponent10 = (0); static const bool  has_infinity = (false); static const bool  has_quiet_NaN = (false); static const bool  has_signaling_NaN = (false); static const float_denorm_style  has_denorm = (denorm_absent); static const bool  has_denorm_loss = (false); static unsigned long long infinity () throw() { return 0; } static unsigned long long quiet_NaN () throw() { return 0; } static unsigned long long signaling_NaN () throw() { return 0; } static unsigned long long denorm_min () throw() { return 0; } static const bool  is_iec559 = (false); static const bool  is_bounded = (true); static const bool  is_modulo = (1 != 18446744073709551615ULL); static const bool  traps = (false); static const bool  tinyness_before = (false); static const float_round_style  round_style = (round_toward_zero); typedef unsigned long long _C_convertible; };














}   


#line 1 "/opt/aCC/include_std/limits.cc"




























 



namespace std {


    
template <class _TypeT>
const bool numeric_limits<_TypeT>::is_specialized;

template <class _TypeT>
const int numeric_limits<_TypeT>::digits;

template <class _TypeT>
const int numeric_limits<_TypeT>::digits10;

template <class _TypeT>
const bool numeric_limits<_TypeT>::is_signed;

template <class _TypeT>
const bool numeric_limits<_TypeT>::is_integer;

template <class _TypeT>
const bool numeric_limits<_TypeT>::is_exact;

template <class _TypeT>
const int numeric_limits<_TypeT>::radix;

template <class _TypeT>
const int numeric_limits<_TypeT>::min_exponent;

template <class _TypeT>
const int numeric_limits<_TypeT>::min_exponent10;

template <class _TypeT>
const int numeric_limits<_TypeT>::max_exponent;

template <class _TypeT>
const int numeric_limits<_TypeT>::max_exponent10;

template <class _TypeT>
const bool numeric_limits<_TypeT>::has_infinity;

template <class _TypeT>
const bool numeric_limits<_TypeT>::has_quiet_NaN;

template <class _TypeT>
const bool numeric_limits<_TypeT>::has_signaling_NaN;

template <class _TypeT>
const float_denorm_style numeric_limits<_TypeT>::has_denorm;

template <class _TypeT>
const bool numeric_limits<_TypeT>::has_denorm_loss;

template <class _TypeT>
const bool numeric_limits<_TypeT>::is_iec559;

template <class _TypeT>
const bool numeric_limits<_TypeT>::is_bounded;

template <class _TypeT>
const bool numeric_limits<_TypeT>::is_modulo;

template <class _TypeT>
const bool numeric_limits<_TypeT>::traps;

template <class _TypeT>
const bool numeric_limits<_TypeT>::tinyness_before;

template <class _TypeT>
const float_round_style numeric_limits<_TypeT>::round_style;



}   
#line 755 "/opt/aCC/include_std/limits"


#line 42 "/opt/aCC/include_std/string"
#line 1 "/opt/aCC/include_std/algorithm"













































 



#line 1 "/opt/aCC/include_std/cstdlib"





#pragma push binding
#pragma binding default
#line 1 "/usr/include/errno.h"
 










extern "C" {



    
#  pragma extern __errno



extern int *__errno(void);







}


#line 49 "/usr/include/errno.h"

#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/errno.h"









 







    



     extern "C" {



	 
#line 34 "/usr/include/sys/errno.h"


     }



    






 
#line 85 "/usr/include/sys/errno.h"

 




 






 
#line 107 "/usr/include/sys/errno.h"

 





 

 
#line 128 "/usr/include/sys/errno.h"

         
#line 140 "/usr/include/sys/errno.h"





#line 155 "/usr/include/sys/errno.h"
 



 


 
#line 171 "/usr/include/sys/errno.h"

#line 178 "/usr/include/sys/errno.h"




 


 


 

 



	 










	 



 

#line 220 "/usr/include/sys/errno.h"




 

#line 239 "/usr/include/sys/errno.h"

#pragma pop
#line 51 "/usr/include/errno.h"


    
#  pragma extern perror, strerror
#  pragma extern sys_nerr, sys_errlist  





extern "C" {
  
    extern void perror(const char*);
    extern char *strerror (int);
  
    extern int sys_nerr;
    extern char *sys_errlist[];
}




#pragma pop
#line 7 "/opt/aCC/include_std/cstdlib"
#pragma push binding
#pragma binding default
#line 1 "/usr/include/stdlib.h"
 















        
#    pragma builtin_milli abs
#    pragma extern  abs


#line 44 "/usr/include/stdlib.h"


extern "C" {






       
#    pragma extern setenv, unsetenv
#    pragma extern posix_openpt


extern int setenv (const char *, const char *, int);
extern int unsetenv (const char *);
extern int posix_openpt (int );

 

       
#    pragma builtin_milli div, ldiv, labs
#    pragma builtin rand, srand, atoi, exit, free 
#    pragma extern __nl_char_size  

#      pragma extern  atof

#    pragma extern atoi, atol, strtod, strtol, strtoul, rand
#    pragma extern srand, atexit, exit, getenv, system, div, ldiv, labs 
#    pragma extern mblen, mbtowc, wctomb, mbstowcs, wcstombs, free, qsort 

#      pragma builtin_milli lldiv, llabs
#      pragma extern strtoll, strtoull, lldiv, llabs, atoll


#      pragma extern strtof
#line 87 "/usr/include/stdlib.h"




   extern int __nl_char_size;













   typedef struct {
	int quot;	 
	int rem;	 
   } div_t;
   typedef struct {
	long int quot;	 
	long int rem;	 
   } ldiv_t;

typedef struct {
	long long quot;   
	long long rem;    
	} lldiv_t;











#line 153 "/usr/include/stdlib.h"
extern lldiv_t lldiv (long long, long long);
extern long long atoll (const char *);
extern long long llabs (long long);




         
#       pragma extern _Exit

      void _Exit (int);



extern float strtof (const char * , char * * );


  


       extern double atof (const char *);

extern int atoi (const char *);
extern long int atol (const char *);
extern double strtod (const char *, char * *);
extern long int strtol (const char *, char * *, int);
  


extern long long strtoll (const char *, char * *, int);
extern unsigned long long strtoull (const char *, char * *, int);


#line 198 "/usr/include/stdlib.h"

#line 205 "/usr/include/stdlib.h"

  
extern unsigned long int strtoul (const char *, char * *, int);
extern int rand (void);
extern void srand (unsigned int);
extern int atexit (void (*) (void));
extern void exit (int);
extern char *getenv (const char *);
extern int system (const char *);
extern div_t div (int, int);
extern ldiv_t ldiv (long int, long int);
extern long int labs (long int);
extern int mblen (const char *, size_t);
extern int mbtowc (wchar_t *, const char *, size_t);
extern int wctomb (char *, wchar_t);
extern size_t mbstowcs (wchar_t *, const char *, size_t);
extern size_t wcstombs (char *, const wchar_t *, size_t);
extern void free (void *);
extern void qsort (void *, size_t, size_t, int (*)(const void *, const void *));
  


      
#  pragma builtin abort, calloc, malloc, realloc
#  pragma extern bsearch, abort, calloc, malloc, realloc


#line 241 "/usr/include/stdlib.h"
  
       extern void abort(void);
       extern void *bsearch(const void *, const void *, size_t, size_t, int (*) (const void *, const void *));
       extern void *calloc(size_t, size_t);
       extern void *malloc(size_t);
       extern void *realloc(void *, size_t);
  
#line 256 "/usr/include/stdlib.h"

#line 296 "/usr/include/stdlib.h"



       
#    pragma extern setkey, lcong48 


#line 311 "/usr/include/stdlib.h"
     extern void setkey(const char *);
     extern void lcong48( unsigned short [] );









      
#    pragma extern drand48, erand48, jrand48, lrand48, mrand48, nrand48 
#    pragma extern srand48, seed48, putenv


#line 337 "/usr/include/stdlib.h"


     extern int putenv (const char *);







     extern double drand48(void);
     extern double erand48(unsigned short []);
     extern long jrand48(unsigned short []);
     extern long lrand48(void);
     extern long mrand48(void);
     extern long nrand48(unsigned short []);
     extern void srand48(long);
     extern unsigned short *seed48(unsigned short []);
#line 366 "/usr/include/stdlib.h"



      
#    pragma extern clearenv, getopt, getpass, memalign
#    pragma extern optarg, optind, opterr
#line 381 "/usr/include/stdlib.h"
       extern int clearenv(void);
       extern int getopt(int, char * const [], const char *);
       extern char *getpass(const char *);
       extern void *memalign(size_t, size_t);
#line 391 "/usr/include/stdlib.h"


     extern char *optarg;
     extern int optind;
     extern int opterr;




#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/wait.h"




















 










    










 
#line 51 "/usr/include/sys/wait.h"


    
#line 62 "/usr/include/sys/wait.h"









    extern "C" {



       
#    pragma extern wait, waitpid







       extern pid_t wait(int *);
       extern pid_t waitpid(pid_t, int *, int);







    }





#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/resource.h"

































 



















 


#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/_rlimit_body.h"

































 


 

 



 

struct rlimit {
        rlim_t  rlim_cur;                
        rlim_t  rlim_max;                
};

#pragma pop
#line 60 "/usr/include/sys/resource.h"



#line 72 "/usr/include/sys/resource.h"

#line 84 "/usr/include/sys/resource.h"





 










 




struct	rusage {
	struct timeval ru_utime;	 
	struct timeval ru_stime;	 
					 
	long	ru_maxrss;

	long	ru_ixrss;		 
	long	ru_idrss;		 
	long	ru_isrss;		 
	long	ru_minflt;		 
	long	ru_majflt;		 
	long	ru_nswap;		 
	long	ru_inblock;		 
	long	ru_oublock;		 
	long	ru_ioch;		 
	long	ru_msgsnd;		 
	long	ru_msgrcv;		 
	long	ru_nsignals;		 
	long	ru_nvcsw;		 
	long	ru_nivcsw;		 

};







 




 


 



   extern "C" {



     
#  pragma extern getpriority, getrusage, setpriority 

#    pragma extern getrlimit, setrlimit



   extern int getpriority (int, id_t);
   extern int getrusage (int, struct rusage *);
   extern int setpriority (int, id_t, int);

   extern int getrlimit (int, struct rlimit *);
   extern int setrlimit (int, const struct rlimit *);


#line 178 "/usr/include/sys/resource.h"

#line 198 "/usr/include/sys/resource.h"


   }


#line 211 "/usr/include/sys/resource.h"





 

#line 228 "/usr/include/sys/resource.h"

#line 269 "/usr/include/sys/resource.h"











#line 290 "/usr/include/sys/resource.h"



#pragma pop
#line 102 "/usr/include/sys/wait.h"



 






      extern "C" {





          
#	 pragma extern wait3

       extern pid_t wait3 (int *, int, struct rusage *);
#line 129 "/usr/include/sys/wait.h"


      }




#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/signal.h"

































 





#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/sigevent.h"

































 









#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/stdpad.h"





 










 




#pragma push binding
#pragma binding default
#line 1 "/usr/include/machine/sys/_types.h"































 




















 








 






 



typedef union {
	__fpreg	__for_alignment_only_do_not_use;
	struct {
		uint64_t	__do_not_use[2];
	} __s_do_not_use;
} __opaque128_t;
#line 91 "/usr/include/machine/sys/_types.h"

#pragma pop
#line 24 "/usr/include/sys/stdpad.h"


#pragma pop
#line 46 "/usr/include/sys/sigevent.h"





typedef   union sigval {




	struct {
		uint64_t __svi_pad1a;
		uint32_t	__svi_pad1b;	 
		int       	__svi_int;	 
	} __svi_int_s;
	struct {
		uint64_t __svi_pad2a;
		
		void *    	__svi_ptr;     
	} __svi_ptr_s;
#line 75 "/usr/include/sys/sigevent.h"
   } sigval_t;






#line 88 "/usr/include/sys/sigevent.h"


typedef   struct sigevent {



      int               __sigev_notify;  
      int               __sigev_signo;   
      uint64_t __sigev_reserved0a;
      sigval_t          __sigev_value;   


       
      uint64_t __sigev_pad1a;
      

      void		(*__sigev_notify_function)(sigval_t);



       
      uint64_t __sigev_pad2a;
      

      pthread_attr_t	*__sigev_notify_attributes;
#line 124 "/usr/include/sys/sigevent.h"


	uint64_t __sigev_reserved[8];




   } sigevent_t;


  enum __sigev_types {
	  __SIGEV_NONE = 1,	 
	  __SIGEV_SIGNAL	 

	  ,__SIGEV_THREAD	 

  };

#line 151 "/usr/include/sys/sigevent.h"







#pragma pop
#line 42 "/usr/include/sys/signal.h"
#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/siginfo.h"

































 












 

#line 103 "/usr/include/sys/siginfo.h"







typedef struct __siginfo {					 




	uint32_t __si_version, __si_size; int si_signo; int si_code; int si_errno; uint32_t __si_reserved0b; uint64_t __si_reserved0c; sigval_t si_value; union { struct { uint64_t __pad2a; uint32_t __pad2b; pid_t __pid; union { struct { uint64_t __pad2c; uint32_t __pad2d; uid_t __uid; } __kill; struct { uint64_t __pad2e; uint32_t __pad2f; int __status; } __SIGCLD; } __pdata; } __proc; struct { uint64_t __pad5a;  void *__addr; uint64_t __pad5c; uint32_t __pad5d; unsigned int __imm; } __fault; struct { uint64_t __pad6a; uint32_t __pad6b; int __fd; uint64_t __pad6c;  long __band; } __file; struct { uint64_t __pad7a;  void *__addr; uint64_t __pad7c;  void *__lockpage; uint64_t __pad7e;  long __dev_id; } __gfault; } __data;



	uint64_t __pad[8];




} siginfo_t;







#line 139 "/usr/include/sys/siginfo.h"






 







#pragma push binding
#pragma binding default
#line 1 "/usr/include/machine/sys/siginfo.h"

































 












 


	 
enum __si_codes {						 
	SI_USER   = -1,	 
	SI_QUEUE  = -2,	 
	SI_TIMER  = -3,	 
	SI_ASYNCIO= -4,	 
	SI_MESGQ  = -5,	 
	SI_QUEUE_KERNEL = 500  
};



 
 

	 


	 
#line 78 "/usr/include/machine/sys/siginfo.h"
		 



		 


	 
#line 100 "/usr/include/machine/sys/siginfo.h"

	 





	 




		 


	 




	 
#line 128 "/usr/include/machine/sys/siginfo.h"

	 
#line 137 "/usr/include/machine/sys/siginfo.h"





	 


				    


#pragma pop
#line 154 "/usr/include/sys/siginfo.h"

#pragma pop
#line 43 "/usr/include/sys/signal.h"
#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/newsig.h"


































 













     typedef struct __sigset_t {
          unsigned int sigset[8];
     } sigset_t;
















typedef struct __stack {		 
	
	void	*ss_sp;			 
	uint32_t __ss_pad1;
	int	ss_flags;		 
	
	size_t	ss_size;	 
	uint64_t __ss_reserved[5];
} stack_t;

#pragma push binding
#pragma binding default
#line 1 "/usr/include/machine/sys/newsig.h"
 

 





























 















typedef struct {
	__opaque128_t	__mc_opaque[2976];
} __mcontext_t;



typedef __mcontext_t	mcontext_t;


#line 68 "/usr/include/machine/sys/newsig.h"






 


typedef struct {   

	uint32_t	__uc_version;
	uint32_t	__uc_size;
	int		__uc_syscall;
	char		__uc_syscall_action;
	char		__uc_eosys;
	uint16_t	__uc_errno;
	uint64_t	__uc_pad0a;
#line 92 "/usr/include/machine/sys/newsig.h"
	struct __ucontext *__uc_link;	


 

	uint64_t	__uc_pad4a;
	uint64_t	__uc_rval1;
	uint64_t	__uc_pad5a;
	uint64_t	__uc_rval2;



	sigset_t	__uc_sigmask;	


 
	double		__uc_pad6[4];
	stack_t		__uc_stack;	

 

	uint64_t	__uc_arg[8];
	uint64_t	__uc_pad7[8];
	uint32_t	__uc_created_by_getcontext:1;
	uint32_t	__uc_onstack:1;
	uint32_t	__uc_mxn_ucontext:1; 







 
	uint32_t	__uc_reserved_flags:29;
	uint32_t	__uc_reserved_flags1:32;
	 
	uint64_t	__uc_core_lwpid;
	uint64_t	__uc_core_user_tid;
	uint64_t	__uc_core_sig;
	uint64_t	__uc_core_code;



} __uc_misc_t;




typedef struct __ucontext {   
	__uc_misc_t	__uc_misc;
#line 149 "/usr/include/machine/sys/newsig.h"
	double		__uc_reserved[((1024 - sizeof(__uc_misc_t)) / sizeof(double))];






 
	mcontext_t	__uc_mcontext;	 
} ucontext_t;









 



 
#pragma pop
#line 79 "/usr/include/sys/newsig.h"



#pragma pop
#line 44 "/usr/include/sys/signal.h"

 



   
 
#line 62 "/usr/include/sys/signal.h"


   extern "C" {


 



  typedef unsigned int sig_atomic_t;   





    

   

 

   struct sigaction {
      union {
	       


	      void (*__sa_sigaction)(int, siginfo_t *, void *);






	       
	      void (*__sa_handler)(int);
      } __handler;

      sigset_t   sa_mask;	   

 
      int	sa_flags;	   
   };




#line 115 "/usr/include/sys/signal.h"



#line 136 "/usr/include/sys/signal.h"





   struct sigstack {		 

	void	*ss_sp;			 



	int	ss_onstack;		 
   };


   

 




   struct sigvec {		 
      void    (*sv_handler)(int);	 
      int	sv_mask;		 
      int	sv_flags;		 
   };







 





     
#  pragma extern signal, raise




     extern void (*signal(int, void (*) (int)))(int);
     extern int raise(int);









       
#    pragma extern kill, sigemptyset, sigfillset, sigaddset, sigdelset
#    pragma extern sigismember, sigaction, sigprocmask, sigsuspend
#    pragma extern sigpending
#    pragma extern ___sysconf


     extern int kill(pid_t, int);
     extern int sigemptyset(sigset_t *);
     extern int sigfillset(sigset_t *);
     extern int sigaddset(sigset_t *, int);
     extern int sigdelset(sigset_t *, int);
     extern int sigismember(const sigset_t *, int);
     extern int sigaction(int, const struct sigaction * , struct sigaction * );
     extern int sigprocmask(int, const sigset_t * , sigset_t * );
     extern int sigsuspend(const sigset_t *);
     extern int sigpending(sigset_t *);
     extern long ___sysconf(int);
#line 225 "/usr/include/sys/signal.h"



       
#    pragma extern sigwait

#      pragma extern pthread_sigmask, pthread_kill



     extern int sigwait(const sigset_t * , int * );		 

     extern int pthread_sigmask(int, const sigset_t * , sigset_t * );									 
     extern int pthread_kill(pthread_t, int);	 
#line 248 "/usr/include/sys/signal.h"



       
#    pragma extern sigwaitinfo, sigtimedwait, sigqueue


     extern int sigwaitinfo(const sigset_t * , siginfo_t * );      
     extern int sigtimedwait(const sigset_t * ,
                             siginfo_t * ,
             	           const struct timespec * );	 
     extern int sigqueue(pid_t, int, const union sigval);  	 
#line 266 "/usr/include/sys/signal.h"



       
#    pragma extern bsd_signal, killpg, sigaltstack, siginterrupt


#        pragma extern sigstack




	extern void (*bsd_signal(int, void(*)(int)))(int);
	extern int killpg(pid_t, int);


	 extern int sigstack(struct sigstack *, struct sigstack *); 




	extern int sigaltstack(const stack_t * , stack_t * ); 
	extern int siginterrupt(int, int);
#line 296 "/usr/include/sys/signal.h"



         
#      pragma extern sigset, sighold, sigrelse, sigignore, sigpause


	   extern void (*sigset(int, void (*)(int)))(int);
	   extern int sighold(int);
	   extern int sigrelse(int);
	   extern int sigignore(int);
	   extern int sigpause(int);
#line 316 "/usr/include/sys/signal.h"





       
#    pragma extern sigblock, sigsetmask, sigvector, ssignal, sigspace, gsignal





     extern long sigblock(long);
     extern long sigsetmask(long);
     extern int sigvector(int, const struct sigvec *, struct sigvec *);
     extern int (*ssignal(int, int (*) (int)))(int);



     extern ssize_t sigspace(ssize_t);
     extern int gsignal(int);
#line 353 "/usr/include/sys/signal.h"




   }


 

#line 409 "/usr/include/sys/signal.h"

 

#line 426 "/usr/include/sys/signal.h"






#line 439 "/usr/include/sys/signal.h"

 








#line 462 "/usr/include/sys/signal.h"




 














 

   extern "C" {
     typedef void (*__sigaction_function)(int);
   }









#line 519 "/usr/include/sys/signal.h"




 










					 
					 




      





 

#line 557 "/usr/include/sys/signal.h"


 



				 



#pragma push binding
#pragma binding default
#line 1 "/usr/include/machine/sys/signal.h"





























 









 


    








 






#pragma push binding
#pragma binding default
#line 1 "/usr/include/machine/sys/sigcontext.h"






























 










struct sigcontext {
	struct __ucontext	__uc;
};


#pragma pop
#line 60 "/usr/include/machine/sys/signal.h"

 

#line 72 "/usr/include/machine/sys/signal.h"



#pragma pop
#line 568 "/usr/include/sys/signal.h"

 

#line 585 "/usr/include/sys/signal.h"


 








 

#pragma push binding
#pragma binding default
#line 1 "/usr/include/machine/sys/frame.h"

































 















typedef struct frame_marker {
	int __scratch[4];
} frame_marker_t;

#pragma pop
#line 602 "/usr/include/sys/signal.h"




 





     


 






#line 635 "/usr/include/sys/signal.h"

#pragma pop
#line 139 "/usr/include/sys/wait.h"

 






 


 










 


 







 
typedef enum {
	P_PID,		 
	P_PGID,		 
	P_SID,		 
	P_UID,		 
	P_GID,		 
	P_CID,		 
	P_ALL,		 
	P_LWPID		 
} idtype_t;


 


      extern "C" {



      
#    pragma extern waitid



	extern int waitid(idtype_t, id_t, siginfo_t *, int);





      }









 
   union wait	{
	int	w_status;		 
	

 
	struct {
		unsigned short	w_pad;		 
		unsigned int	w_Retcode:8;	 
		unsigned int	w_Coredump:1;	 
		unsigned int	w_Termsig:7;	 
	} w_T;
	



 
	struct {
		unsigned short	w_pad;		 
		unsigned int	w_Stopsig:8;	 
		unsigned int	w_Stopval:8;	 
	} w_S;
   };













      extern "C" {



       
#    pragma extern wait4


   extern pid_t wait4(pid_t,int *, int, struct rusage *);




      }




#line 283 "/usr/include/sys/wait.h"

#pragma pop
#line 402 "/usr/include/stdlib.h"


    
#  pragma extern a64l, l64a, getsubopt, grantpt, ptsname, realpath 
#  pragma extern unlockpt, initstate, setstate 
#  pragma extern srandom, random

#  pragma extern ttyslot, valloc




     
#  pragma extern mkstemp
#  pragma extern mktemp, gcvt
#line 426 "/usr/include/stdlib.h"

#line 436 "/usr/include/stdlib.h"

#line 445 "/usr/include/stdlib.h"


     extern void *valloc (size_t);


#line 464 "/usr/include/stdlib.h"
     extern long a64l(const char *);
     extern char *l64a(long);



        
#      pragma extern fcvt, ecvt 

     extern char *fcvt(double, int, int *, int *);
     extern char *ecvt(double, int, int *, int *);


    extern char *gcvt(double, int, char *);
    extern int getsubopt(char **, char * const *, char **);
    extern int grantpt(int);
    extern char *ptsname(int);
    extern char *realpath(const char *, char *);
    extern int unlockpt(int);
    extern char *initstate(unsigned int, char *, size_t);
    extern char *setstate(const char *);		   	  
    extern void srandom(unsigned int);                
    extern long random(void);
#line 508 "/usr/include/stdlib.h"



   
#      pragma extern rand_r
#line 522 "/usr/include/stdlib.h"
extern int rand_r (unsigned int *);








       
#    pragma extern strtold


#line 544 "/usr/include/stdlib.h"
typedef long double long_double;

extern long double strtold (const char * , char * * );






 
#line 569 "/usr/include/stdlib.h"

 
 









   
  struct mallinfo  {
	int32_t arena;		 
	int32_t ordblks;	 
	int32_t smblks;		 
	int32_t hblks;		 
	int32_t hblkhd;		 
	int32_t usmblks;	 
	int32_t fsmblks;	 
	int32_t uordblks;	 
	int32_t fordblks;	 
	int32_t keepcost;	 
  };	


 
extern volatile unsigned char __debugger_requests_allocation_callback; 

 




 
enum _dm_arena_request {
 AR_ARENA_OPEN=0,             
 AR_ARENA_CLOSE,              
 AR_ARENA_PARAMS,             
 AR_PROC_LEVEL,               
 AR_ARENA_INFO,               
};

enum _dm_heap_block_type {
  HEAP_USR_SBRK = 0,  
  HEAP_NODE_BLK,      
  HEAP_USED_BLK,      
  HEAP_FREE_BLK,      
  HEAP_HLDHEAD_BLK,   
  HEAP_HLD_BLK,       
  HEAP_CACHED_BLK     
};




  struct _dm_heap_block {
    uint64_t addr;                  
    enum _dm_heap_block_type type;  
    uint64_t size;                  
  };

   
  struct _dm_handle {
    uint32_t num_arenas;
    uint32_t expansion_factor;
    uint32_t maxfast;
    uint32_t grain;
    uint32_t is_threaded;
    uint32_t is_32bit;
    uint32_t malloc_header_size;
    uint64_t (**callbacks)();
    uint64_t debug_data_ptr;
    uint64_t arena_id;
    struct _dm_heap_block cur_block;
    char buf[256];
  };

  struct _dm_heap_sba_param {
    int is_sba_enabled;  
    uint64_t maxfast;   
    uint64_t numblks;   
    uint64_t grain;    
 
  };

  struct _dm_malloc_thread_cache_info {
    int is_cache_enabled;  
    uint64_t no_of_cache_miss;  
    uint64_t bucketsize;   
    uint64_t buckets;      
    uint64_t retirement;   
  };

  struct _dm_total_arena_info {
    uint64_t total_space;   
    uint64_t num_bytes_FSB;  
    uint64_t num_bytes_USB;  
    uint64_t num_bytes_FOB;  
    uint64_t num_bytes_UOB;  
    uint64_t num_bytes_HBH;  
    uint64_t num_small_blocks;    
    uint64_t num_ordinary_blocks; 
    uint64_t num_holding_blocks;  
    uint64_t num_free_ordinary_blocks;  
    uint64_t num_free_small_blocks;  
    struct _dm_heap_sba_param SBA_params;
    struct _dm_malloc_thread_cache_info cache_info;
  };

  struct _dm_arena_info {
    int num_blocks;  
    struct _dm_heap_block* block_list;  
    uint64_t start_addr;  
    uint64_t end_addr;  
    uint64_t total_space;   
    uint64_t num_bytes_FSB;  
    uint64_t num_bytes_USB;  
    uint64_t num_bytes_FOB;  
    uint64_t num_bytes_UOB;  
    uint64_t num_bytes_HBH;  
    uint64_t num_small_blocks;    
    uint64_t num_ordinary_blocks; 
    uint64_t num_holding_blocks;  
    uint64_t num_free_ordinary_blocks;  
    uint64_t num_free_small_blocks;  
  };

  struct _dm_arena_params {
    int num_arenas;  
    uint64_t expansion_factor;  
  };


#    pragma extern libc_get_arena_info



     extern int libc_get_arena_info (int, enum _dm_arena_request, void *, int, void * *);






    
#  pragma extern _ldecvt, _ldfcvt, _ldgcvt, _extecvt, _extfcvt, ltostr
#  pragma extern ultostr, ltoa, ultoa, mallinfo, mallopt, ug_display_width







#pragma push binding
#pragma binding default
#line 1 "/usr/include/pwd.h"
 




#line 12 "/usr/include/pwd.h"








extern "C" {




   struct passwd {
	char	*pw_name;
	char 	*pw_passwd;
	uid_t	pw_uid;
	gid_t	pw_gid;
	char 	*pw_age;
	char	*pw_comment;
	char	*pw_gecos;
	char	*pw_dir;
	char	*pw_shell;
	int32_t	pw_audid;
	int	pw_audflg;
   };

     
#  pragma extern getpwuid, getpwnam

#      pragma extern getpwuid_r, getpwnam_r
#line 61 "/usr/include/pwd.h"



     extern struct passwd *getpwuid(uid_t);
     extern struct passwd *getpwnam(const char *);





       extern int getpwuid_r(uid_t, struct passwd *, char *, size_t, struct passwd **);
       extern int getpwnam_r(const char *, struct passwd *, char *, size_t, struct passwd **);
#line 84 "/usr/include/pwd.h"




     
#  pragma extern endpwent, getpwent, setpwent
#line 98 "/usr/include/pwd.h"


     extern void endpwent(void);
     extern struct passwd *getpwent(void);
     extern void setpwent(void);
#line 109 "/usr/include/pwd.h"


   struct s_passwd {
       char    *pw_name;
       char    *pw_passwd;
       char    *pw_age;
       int32_t pw_audid;
       int     pw_audflg;
   };


     
#  pragma extern putpwent, fgetpwent, getspwent, getspwuid, getspwaid
#  pragma extern getspwnam, fgetspwent, setspwent, endspwent

#      pragma extern setpwent_r, endpwent_r, getpwent_r, fgetpwent_r 
#      pragma extern getspwent_r, getspwuid_r, getspwaid_r, getspwnam_r 
#      pragma extern fgetspwent_r, setspwent_r, endspwent_r 



#line 141 "/usr/include/pwd.h"

	 extern int putpwent(const struct passwd *, FILE *);
     extern struct passwd *fgetpwent(FILE *);
     extern struct s_passwd *getspwent(void);
     extern struct s_passwd *getspwuid(uid_t);
     extern struct s_passwd *getspwaid(int32_t);
     extern struct s_passwd *getspwnam(char *);
     extern struct s_passwd *fgetspwent(FILE *);
     extern void setspwent(void);
     extern void endspwent(void);
#line 192 "/usr/include/pwd.h"







}




#pragma pop
#line 735 "/usr/include/stdlib.h"






     extern char *_ldecvt(long_double, int, int *, int *);
     extern char *_ldfcvt(long_double, int, int *, int *);
     extern char *_ldgcvt(long_double, int, char *);

       extern char *_extecvt(__float80, int, int *, int *);
       extern char *_extfcvt(__float80, int, int *, int *);


        
#    pragma extern getpw, l3tol, ltol3

     extern int getpw(int, char *);
     extern void l3tol(long *, const char *, int);
     extern void ltol3(char *, const long *, int);
     extern char *ltostr(long, int);
     extern char *ultostr(unsigned long, int);
     extern char *ltoa(long);
     extern char *ultoa(unsigned long);





     extern struct mallinfo mallinfo(void);
     extern int mallopt(int, int);
     extern int ug_display_width(void);

#line 832 "/usr/include/stdlib.h"





}


#pragma pop
#line 9 "/opt/aCC/include_std/cstdlib"





inline long   abs (long a) { return labs( a ); }
inline ldiv_t div (long a, long b) { return ldiv( a, b ); }







namespace std
{




using ::div_t;
using ::ldiv_t;
using ::size_t;




using ::abort;
using ::abs;
using ::atexit;
using ::atof;
using ::atoi;
using ::atol;
using ::bsearch;
using ::calloc;
using ::div;
using ::exit;
using ::free;
using ::getenv;
using ::labs;
using ::ldiv;
using ::malloc;
using ::mblen;
using ::mbstowcs;
using ::mbtowc;
using ::qsort;
using ::rand;
using ::realloc;
using ::srand;
using ::strtod;
using ::strtol;
using ::strtoul;
using ::system;
using ::wcstombs;
using ::wctomb;

}



#line 52 "/opt/aCC/include_std/algorithm"




#line 1 "/opt/aCC/include_std/memory"














































  

#line 1 "/opt/aCC/include_std/new"









 
















#line 35 "/opt/aCC/include_std/new"

extern const char* __bad_alloc_exception;


namespace std {



#pragma vtable OFF_IF_NO_KEY_BEGIN


  class bad_alloc : public exception {
  public:
    bad_alloc() throw() {}
    virtual ~bad_alloc() throw() {}
    virtual const char* what() const throw() {
      return __bad_alloc_exception;
    }
  };


#pragma vtable OFF_IF_NO_KEY_END


  struct nothrow_t {};
  const nothrow_t nothrow = {};

  typedef void (*new_handler)();

  new_handler set_new_handler(new_handler new_p) throw();


} 


#line 77 "/opt/aCC/include_std/new"

#line 87 "/opt/aCC/include_std/new"


void* operator new(size_t size) throw(std::bad_alloc);
void* operator new(size_t size, const std::nothrow_t&) throw();
void  operator delete(void* ptr) throw();
void  operator delete(void* ptr, const std::nothrow_t&) throw();
void* operator new[](size_t size) throw(std::bad_alloc);
void* operator new[](size_t size, const std::nothrow_t&) throw();
void  operator delete[](void* ptr) throw();
void  operator delete[](void* ptr, const std::nothrow_t&) throw();
 
#line 104 "/opt/aCC/include_std/new"

inline void* operator new  (size_t  , void* ptr) throw() { return ptr; }
inline void* operator new[](size_t  , void* ptr) throw() { return ptr; }
inline void  operator delete  (void*  , void*) throw() {}
inline void  operator delete[](void*  , void*) throw() {}

#line 51 "/opt/aCC/include_std/memory"
#line 1 "/opt/aCC/include_std/utility"












































 




namespace std {







namespace rel_ops {


template <class _TypeT>
inline bool operator!= (const _TypeT& __x, const _TypeT& __y)
{
    return !(__x == __y);
}

template <class _TypeT>
inline bool operator> (const _TypeT& __x, const _TypeT& __y)
{
    return __y < __x;
}

template <class _TypeT>
inline bool operator<= (const _TypeT& __x, const _TypeT& __y)
{
    return !(__y < __x);
}

template <class _TypeT>
inline bool operator>= (const _TypeT& __x, const _TypeT& __y)
{
    return !(__x < __y);
}


}   






template <class _TypeT, class _TypeU>
struct pair
{
    typedef _TypeT first_type;
    typedef _TypeU second_type;

    first_type  first;
    second_type second;

    pair (const first_type &__x, const second_type &__y)
        : first (__x), second (__y) { }

    pair ()

      : first (first_type ()), second (second_type ()) 

    { ; }

    pair (const pair &__rhs): first (__rhs.first), second (__rhs.second) { }



    template <class _TypeX, class _TypeY>
    pair (const pair <_TypeX, _TypeY> &__rhs) 
        : first (__rhs.first), second (__rhs.second) { }



};


template <class _TypeT, class _TypeU>
inline bool
operator== (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
{ 
    return __x.first == __y.first && __x.second == __y.second; 
}


template <class _TypeT, class _TypeU>
inline bool
operator!= (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
{ 
    return !(__x == __y);
}


template <class _TypeT, class _TypeU>
inline bool
operator< (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
{ 
    return    __x.first < __y.first
           || (!(__y.first < __x.first) && __x.second < __y.second); 
}


template <class _TypeT, class _TypeU>
inline bool
operator> (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
{ 
    return __y < __x;
}


template <class _TypeT, class _TypeU>
inline bool
operator>= (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
{ 
    return !(__x < __y);
}


template <class _TypeT, class _TypeU>
inline bool
operator<= (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
{ 
    return !(__y < __x);
}


template <class _TypeT, class _TypeU>
inline pair<_TypeT, _TypeU>



make_pair (const _TypeT &__x, const _TypeU &__y)

{
    return pair<_TypeT, _TypeU>(__x, __y);
}


}   


#line 52 "/opt/aCC/include_std/memory"







#line 1 "/opt/aCC/include_std/rw/stdmutex.h"





































































 





#line 1 "/opt/aCC/include_std/rw/mutexwrpr.h"











class RWReference;
namespace __rw {
class __rw_mutex_base;
}


class _HPMutexWrapper {
  typedef void* pmutex_t;

  friend class __rw::__rw_mutex_base;
  friend class _RWMutex;
  friend class RWMutex;
  friend class RWReference;
  friend class RWQEMutex;

public:
  
  
  
  ~_HPMutexWrapper ();
  int init(int);  
  int init ();
  static int lock (pmutex_t);
  static int unlock (pmutex_t);

private:
  pmutex_t pmutex;

};






class HPTSDWrapper {
  typedef void (*th_destructor_t)(void *);

public:
  typedef int th_key_t;

  static int keycreate (th_key_t *key, th_destructor_t destructor);
  static int keydelete (th_key_t  ){return 0;}
  static int getspecific (th_key_t key, void **value);
  static int setspecific (th_key_t key, void *value);

};

#line 78 "/opt/aCC/include_std/rw/stdmutex.h"














#line 99 "/opt/aCC/include_std/rw/stdmutex.h"

#line 233 "/opt/aCC/include_std/rw/stdmutex.h"


namespace __rw {

using std::exception;


#pragma vtable OFF_IF_NO_KEY_BEGIN


class __rw_thread_error : public exception
{
public:
    __rw_thread_error () throw()
    : exception () { ; }

    virtual const char* what () const throw() {
        return "thread synchronization error";
    }
};                            


#pragma vtable OFF_IF_NO_KEY_END





class __rw_mutex_base
{
public:

    void _C_acquire () {
        ((0 != _C_mutex . lock(_C_mutex . pmutex)) ? throw __rw_thread_error () : (void)0);

    }

    void _C_release ();



    
    

    __rw_mutex_base ();
    __rw_mutex_base(int);

    ~__rw_mutex_base ();

private:

    
    __rw_mutex_base (const __rw_mutex_base&);
    __rw_mutex_base& operator= (const __rw_mutex_base&);



    _HPMutexWrapper _C_mutex;   
};


inline void __rw_mutex_base::_C_release ()
{
    
    
    





    _C_mutex . unlock(_C_mutex . pmutex);

}



class __rw_mutex: public __rw_mutex_base
{
public:

#line 326 "/opt/aCC/include_std/rw/stdmutex.h"

    __rw_mutex() {}
    __rw_mutex(int type) : __rw_mutex_base(type) {}


};


#line 361 "/opt/aCC/include_std/rw/stdmutex.h"

inline __rw_mutex_base::__rw_mutex_base ()


{ 
    ((0 != _C_mutex . init()) ? throw __rw_thread_error () : (void)0);

}

inline __rw_mutex_base::__rw_mutex_base(int type) {
    ((0 != _C_mutex . init(type)) ? throw __rw_thread_error () : (void)0);

}








inline __rw_mutex_base::~__rw_mutex_base () 


{
    ;
}












class _HP_mutex_wrapper_init {
public:
   int __mutex_buf[(sizeof(__rw_mutex_base) + sizeof(int) -1)/sizeof(int)];

   _HP_mutex_wrapper_init() {
      new (reinterpret_cast<__rw_mutex_base*>(__mutex_buf)) __rw_mutex_base;
   }
};


template <class _TypeT>




__rw_mutex_base& __rw_get_static_mutex (_TypeT*)
{
#line 423 "/opt/aCC/include_std/rw/stdmutex.h"

    
    
    
#line 460 "/opt/aCC/include_std/rw/stdmutex.h"
    
    static _HP_mutex_wrapper_init __mutex;
    return reinterpret_cast< __rw_mutex_base& >(__mutex);


}



#line 475 "/opt/aCC/include_std/rw/stdmutex.h"



class __rw_guard
{
    __rw_mutex_base *_C_mutex;

    
    __rw_guard& operator= (const __rw_guard&);
    
public:

    __rw_guard (__rw_guard &__rhs)
        : _C_mutex (__rhs._C_mutex) {
        __rhs._C_mutex = 0;
    }

    __rw_guard (__rw_mutex_base &__mutex): _C_mutex (&__mutex) {
        _C_mutex->_C_acquire ();
    }

    __rw_guard (__rw_mutex_base *__mutex): _C_mutex (__mutex) {
        if (_C_mutex)
            _C_mutex->_C_acquire ();
    }

    ~__rw_guard () {
        if (_C_mutex)
            _C_mutex->_C_release ();
        
    }
};



struct __rw_synchronized
{
    __rw_mutex _C_mutex;

    void _C_lock () {
        _C_mutex._C_acquire ();
    }

    void _C_unlock () {
        _C_mutex._C_release ();
    }

    __rw_guard _C_guard () {
        __rw_guard __guard (_C_mutex);
        return __guard;
    }
};





template <class _TypeT>
inline
_TypeT __rw_atomic_preincrement (_TypeT &__t, __rw_mutex_base &__mutex)
{

    __rw::__rw_guard __rw_mt_temp_guard (__mutex);



    if (sizeof(__t) == 8)       
       return static_cast<_TypeT>(_Asm_fetchadd(_FASZ_D, _SEM_ACQ, (void*)&__t, +1,
                                  _LDHINT_NONE) + 1);
    else if (sizeof(__t) == 4)  
       return static_cast<_TypeT>(_Asm_fetchadd(_FASZ_W, _SEM_ACQ, (void*)&__t, +1,
                                  _LDHINT_NONE) + 1);
    else
       return ++__t;  



}


template <class _TypeT>
inline
_TypeT __rw_atomic_predecrement (_TypeT &__t, __rw_mutex_base &__mutex)
{

    __rw::__rw_guard __rw_mt_temp_guard (__mutex);



    if (sizeof(__t) == 8)       
       return static_cast<_TypeT>(_Asm_fetchadd(_FASZ_D,
                _SEM_ACQ, (void*)&__t, -1, _LDHINT_NONE) - 1);
    else if (sizeof(__t) == 4)  
       return static_cast<_TypeT>(_Asm_fetchadd(_FASZ_W,
                _SEM_ACQ, (void*)&__t, -1, _LDHINT_NONE) - 1);
    else
       return --__t;  



}


template <class _TypeT, class _TypeU>
inline
_TypeT __rw_atomic_exchange (_TypeT &__t, const _TypeU &__u,
			     __rw_mutex_base &__mutex)
{

    __rw::__rw_guard __rw_mt_temp_guard (__mutex);



    if (sizeof(__t) == 8)       
       return (_TypeT)_Asm_xchg(_SZ_D, (void*)&__t, (unsigned long long)__u, _LDHINT_NONE);
    else if (sizeof(__t) == 4)  
       return (_TypeT)_Asm_xchg(_SZ_W, (void*)&__t, (unsigned long long)__u, _LDHINT_NONE);
    else if (sizeof(__t) == 2)
       return (_TypeT)_Asm_xchg(_SZ_H, (void*)&__t, (unsigned long long)__u, _LDHINT_NONE);
    else if (sizeof(__t) == 1)
       return (_TypeT)_Asm_xchg(_SZ_B, (void*)&__t, (unsigned long long)__u, _LDHINT_NONE);
    else

    {
    _TypeT __tmp = __t;
    __t = __u;
    return __tmp;
    }
}










template <class _TypeT>
inline
_TypeT __rw_atomic_preincrement (_TypeT &__t, bool)
{
    return __rw_atomic_preincrement (__t,
                                     __rw_get_static_mutex ((_TypeT*)0));
}


template <class _TypeT>
inline
_TypeT __rw_atomic_predecrement (_TypeT &__t, bool)
{
    return __rw_atomic_predecrement (__t,
                                     __rw_get_static_mutex ((_TypeT*)0));
}


template <class _TypeT, class _TypeU>
inline
_TypeT __rw_atomic_exchange (_TypeT &__t, const _TypeU &__u, bool)
{
    return __rw_atomic_exchange (__t, __u,
                                 __rw_get_static_mutex ((_TypeT*)0));
}


#line 953 "/opt/aCC/include_std/rw/stdmutex.h"


}   


#line 1027 "/opt/aCC/include_std/rw/stdmutex.h"


#line 62 "/opt/aCC/include_std/memory"











namespace __rw {





template <class _Container>
inline size_t __rw_new_capacity (size_t __size, const _Container*)
{
    size_t __cap = static_cast< size_t >(__size * float(1.618));

    return (__size += size_t(32)) > __cap ? __size : __cap;
}                     


#line 139 "/opt/aCC/include_std/memory"










template <class _TypeT>
inline void __rw_destroy (_TypeT &__ref)
{


    __ref.~_TypeT ();






}

#line 181 "/opt/aCC/include_std/memory"


template <class _TypeT, class _TypeU>
inline void __rw_construct (_TypeT* __p, const _TypeU& __val)
{
    new (__p) _TypeT (__val);
}


template <class _ForwardIterator> 
inline void __rw_destroy (_ForwardIterator __first,
                                     _ForwardIterator __last)
{
    for (; __first != __last; ++__first)
        __rw_destroy (*__first);
}





template <class _TypeT> 
inline void __rw_destroy (_TypeT**, _TypeT**)
{ }




}   


namespace std {


template <class _TypeT> class allocator;


template< >
class allocator<void> {  
public:
    typedef void*       pointer;
    typedef const void* const_pointer;
    typedef void        value_type;
   



    template <class _TypeU> 
    struct rebind {
        typedef allocator<_TypeU> other;
    };


    
};


template <class _TypeT>
class allocator
{
public:
    typedef size_t              size_type;
    typedef ptrdiff_t           difference_type;
    typedef _TypeT              value_type;
    typedef value_type*         pointer;
    typedef const value_type*   const_pointer;
    typedef value_type&         reference;
    typedef const value_type&   const_reference;

    allocator () throw() { }

    allocator (const allocator&) throw() { }




    template <class _TypeU> 
    struct rebind {
        typedef allocator<_TypeU> other;
    };

    template <class _TypeU>
    allocator (const allocator<_TypeU>&) throw() { }

    template <class _TypeU>
    allocator&
    operator= (const allocator<_TypeU>& __rhs) throw() { 
        return *this; 
    }




    pointer address (reference __x) const { 
        return &__x; 
    }

    const_pointer address (const_reference __x) const { 
        return &__x;
    }

    pointer allocate (size_type __n, allocator<void>::const_pointer = 0) { 


        pointer __tmp =
            static_cast< pointer >(::operator new (__n * sizeof (value_type)));





        ((0 == __tmp) ? throw bad_alloc () : (void)0);
        return __tmp;
    }


    void deallocate (pointer __p, size_type)



    {
        ::operator delete (__p);
    }

    size_type max_size () const throw() { 

        const size_type __max_elem = (18446744073709551615UL >> 32-16) / sizeof(value_type); 



        return 1 > __max_elem ? size_type(1) : __max_elem;
    }

    void construct (pointer __p, const_reference __val) {
        __rw::__rw_construct (__p, __val);
    }
    
    void destroy (pointer __p) {
        ((void)0);
        __rw::__rw_destroy (*__p);
    }
};















#line 424 "/opt/aCC/include_std/memory"


template <class _TypeT, class _TypeU>
inline bool
operator== (const allocator<_TypeT>&,
            const allocator<_TypeU>&)  throw()
{
    return true;
}




template <class _TypeT, class _TypeU>
inline bool
operator!= (const allocator<_TypeT>& __x,
            const allocator<_TypeU>& __y)  throw()
{
    return !(__x == __y);
}





template <class _OutputIterator, class _TypeT>
class raw_storage_iterator:
    public iterator<output_iterator_tag, void, void, void, void>
{
protected:
    _OutputIterator _C_iter;

public:
    explicit raw_storage_iterator (_OutputIterator __x) : _C_iter (__x) { }

    raw_storage_iterator& operator* () {
        return *this;
    }

    raw_storage_iterator& operator= (const _TypeT& __rhs) {
        ::new (&(*_C_iter)) _TypeT (__rhs);
        return *this;
    }

    raw_storage_iterator& operator++ () {
        ++_C_iter;
        return *this;
    }

    raw_storage_iterator operator++ (int) {
        raw_storage_iterator __tmp = *this;
        ++*this;
        return __tmp;
    }
};


}   


namespace __rw {





template <class _TypeT>
class __rw_indestructible
{
    union _C_data_t {
        char        _C_data;      
        long double _C_padding;   
    };

    enum { _C_n = 1 + sizeof (_TypeT) / sizeof (_C_data_t) };

    _C_data_t _C_data [_C_n];     

public:
    typedef _TypeT            value_type;
    typedef value_type&       reference;
    typedef const value_type& const_reference;
    typedef value_type*       pointer;
    typedef const value_type* const_pointer;

    

    
    operator reference () {
        return reinterpret_cast< reference >(*_C_data);
    }

    operator const_reference () const {
        return reinterpret_cast< const_reference >(*_C_data);
    }

    
    pointer operator& () {
        
        

        return &(reference)*this;
    }
    
    
    const_pointer operator& () const {
        
        

        return &(const_reference)*this;
    }
};


inline  char* __rw_get_static_buf ()
{
    typedef char _CharBuf [0 + 1];

    
    static __rw_indestructible<_CharBuf> __buffer;

    return static_cast< char* >(__buffer);
}







inline std::pair<void*, std::size_t>
__rw_reallocate_temp_buffer (void *ptr, std::size_t __size)
{
    static unsigned long busy  ;   

    typedef char _CharBuf [0 + 1];

    
    static __rw_indestructible<_CharBuf> static_buffer;

    char* const buffer = static_buffer;

    if (ptr == (void*)buffer) {

        
        __rw::__rw_atomic_predecrement (busy, false);

        return std::pair<void*, std::size_t>(0, 0);
    }
    ::operator delete (ptr);

    if (!__size)
        return std::pair<void*, std::size_t>(0, 0);

    if (__size <= 0) {

        if (1 == __rw::__rw_atomic_preincrement (busy, false)) {

            
            return std::pair<void*, std::size_t>(buffer, __size);
        }

        
        __rw::__rw_atomic_predecrement (busy, false);
    }

    try {
        ptr = ::operator new (__size);
    }
    catch (...) {
        ptr    = 0;
        __size = 0;
    }

    return std::pair<void*, std::size_t>(ptr, __size);
}

}   


namespace std {











template <class _TypeT, class _Distance>
inline pair<_TypeT*, _Distance> get_temporary_buffer (_Distance __n, _TypeT*)
{
    pair<void*, size_t> __pair =
        __rw::__rw_reallocate_temp_buffer (0, __n * sizeof (_TypeT));

    return make_pair (static_cast< _TypeT* >(__pair . first),
                      _Distance (__pair.second / sizeof (_TypeT)));
}





template <class _TypeT>
inline pair<_TypeT*, ptrdiff_t> get_temporary_buffer (ptrdiff_t __n)
{
    return get_temporary_buffer (__n, (_TypeT*)0);
}





template <class _TypeT>
inline void return_temporary_buffer (_TypeT *__p)
{
    __rw::__rw_reallocate_temp_buffer (__p, 0);
}



template <class _InputIterator, class _ForwardIterator>
inline
_ForwardIterator uninitialized_copy (_InputIterator   __first,
                                     _InputIterator   __last,
                                     _ForwardIterator __result)
{
    _ForwardIterator __start = __result;

    try {
        for (; __first != __last; ++__first, ++__result)
            __rw::__rw_construct (&*__result, *__first);
    }
    catch (...) {
        __rw::__rw_destroy (__start, __result);
        throw;
    }

    return __result;
}







template <class _InputIterator, class _ForwardIterator, class _Allocator>
inline
_ForwardIterator uninitialized_copy (_InputIterator   __first,
                                     _InputIterator   __last,
                                     _ForwardIterator __result,
                                     _Allocator&      __alloc)
{
    _ForwardIterator __start = __result;

    try {
        for (; __first != __last; ++__first, ++__result)
            __alloc.construct (&*__result, *__first);
    }
    catch (...) {
        for (; __start != __result; ++__start)
            __alloc.destroy (&*__start);
        throw;
    }

    return __result;
}




template <class _ForwardIterator, class _TypeT>
inline
void uninitialized_fill (_ForwardIterator __first, _ForwardIterator __last,
                         const _TypeT& __x)
{
    _ForwardIterator __start = __first;

    try {
        for (; __first != __last; ++__first)
            __rw::__rw_construct (&*__first, __x);
    }
    catch (...) {
        __rw::__rw_destroy (__start, __first);
        throw;
    }
}



template <class _ForwardIterator, class _Size, class _TypeT>
inline
void uninitialized_fill_n (_ForwardIterator __first, _Size __n,
                           const _TypeT& __x)
{
    _ForwardIterator __start = __first;

    try {
        for (; __n; --__n, ++__first)
            __rw::__rw_construct (&*__first, __x);
    }
    catch (...) {
        __rw::__rw_destroy (__start, __first);
        throw;
    }
}







template <class _ForwardIter, class _Size, class _TypeT, class _Allocator>
inline
void uninitialized_fill_n (_ForwardIter __first, _Size __n,
                           const _TypeT& __x, _Allocator& __alloc)
{
    _ForwardIter __start = __first;

    try {
        for (; __n; --__n, ++__first)
            __alloc.construct (&*__first, __x);
    }
    catch (...) {
        for (; __start != __first; ++__start)
            __alloc.destroy (&*__start);
        throw;
    }
}


#line 813 "/opt/aCC/include_std/memory"




template<class _TypeT>
class auto_ptr;




template <class _TypeT>
class auto_ptr_ref 
{
public:
    auto_ptr<_TypeT>& _C_ptr;

    auto_ptr_ref (auto_ptr<_TypeT>& __rhs) : _C_ptr (__rhs) { }
};


template<class _TypeT>
class auto_ptr
{
public:
    typedef _TypeT element_type;

    explicit auto_ptr (element_type* __p = 0) throw()
     : _C_ptr (__p) { }

    auto_ptr (auto_ptr& __rhs) throw()
     : _C_ptr (__rhs.release ()) { }

    auto_ptr& operator= (auto_ptr& __rhs) throw() { 
        reset (__rhs.release ());
        return *this;
    }

    
    auto_ptr&
    operator= (auto_ptr_ref<element_type> __rhs) throw() {
        reset (__rhs._C_ptr.release ());
        return *this;
    }



    template <class _TypeU>
    operator auto_ptr_ref<_TypeU>() throw() {
        return auto_ptr_ref<_TypeU>(*this);
    }

    template <class _TypeU> 
    operator auto_ptr<_TypeU>() throw() {
        return auto_ptr<_TypeU>(release ());
    }

    template <class _TypeU>
    auto_ptr (auto_ptr<_TypeU>& __rhs) throw()
    : _C_ptr (__rhs.release ()) { }

    template <class _TypeU>
    auto_ptr& operator= (auto_ptr<_TypeU>& __rhs)  throw() { 
        reset (__rhs.release ());
        return *this;
    }




    ~auto_ptr () throw() {
        delete _C_ptr;
    }

    element_type* get () const throw() {
        return _C_ptr;
    }

    element_type& operator* () const throw() {
        ((void)0);
        return *get (); 
    }

    element_type* operator-> () const throw() { return & * *this; }


    element_type* release () throw() { 
        element_type* __tmp = _C_ptr;
        _C_ptr = 0;
        return __tmp; 
    }

    void reset (element_type* __p = 0) throw() { 
        if (_C_ptr != __p) {
            delete _C_ptr;
            _C_ptr = __p;
        }
    }

    auto_ptr (auto_ptr_ref<element_type> __r) throw()
    : _C_ptr (__r._C_ptr.release ()) { }

private:
    element_type* _C_ptr;
};


}   





#line 58 "/opt/aCC/include_std/algorithm"




#line 68 "/opt/aCC/include_std/algorithm"


namespace std {




  template <class _OutputIter, class _TypeT>
  class raw_storage_iterator;





  template <class _TypeT>
  inline const _TypeT& min (const _TypeT& __a, const _TypeT& __b);


  template <class _TypeT, class _Compare>
  inline const _TypeT& min (const _TypeT& __a, const _TypeT& __b,
      _Compare __comp);


  template <class _TypeT>
  inline const _TypeT& max (const _TypeT& __a, const _TypeT& __b);


  template <class _TypeT, class _Compare>
  inline const _TypeT& max (const _TypeT& __a, const _TypeT& __b,
      _Compare __comp);



  template <class _BidirIter, class _Distance>
  void __merge_without_buffer (_BidirIter __first,
                               _BidirIter __middle,
                               _BidirIter __last,
                               _Distance __len1, _Distance __len2);

  template <class _BidirIter, class _Distance, class _Compare>
  void __merge_without_buffer (_BidirIter __first,
                               _BidirIter __middle,
                               _BidirIter __last,
                               _Distance __len1, _Distance __len2,
                               _Compare __comp);





  template <class _InputIter, class _Function>
  _Function for_each (_InputIter __first, _InputIter __last, _Function __f);

  template <class _InputIter, class _TypeT>
  _InputIter find (_InputIter __first, _InputIter __last,
                   const _TypeT& __value);

  template <class _InputIter, class _Predicate>
  _InputIter find_if (_InputIter __first, _InputIter __last,
                      _Predicate __pred);

  template <class _FwdIter1, class _FwdIter2, 
  class _Distance>
  _FwdIter1 __find_end (_FwdIter1 __first1,
                               _FwdIter1 __last1,
                               _FwdIter2 __first2,
                               _FwdIter2 __last2,
                               _Distance*);

  template <class _FwdIter1, class _FwdIter2>
  _FwdIter1 find_end (_FwdIter1 __first1,
                             _FwdIter1 __last1,
                             _FwdIter2 __first2,
                             _FwdIter2 __last2);

  template <class _FwdIter1, class _FwdIter2, 
  class _BinaryPredicate, class _Distance>
  _FwdIter1 __find_end (_FwdIter1 __first1,
                               _FwdIter1 __last1,
                               _FwdIter2 __first2,
                               _FwdIter2 __last2,
                               _BinaryPredicate __pred,
                               _Distance*);

  template <class _FwdIter1, class _FwdIter2, 
  class _BinaryPredicate>
  _FwdIter1 find_end (_FwdIter1 __first1,
                             _FwdIter1 __last1,
                             _FwdIter2 __first2,
                             _FwdIter2 __last2,
                             _BinaryPredicate __pred);

  template <class _FwdIter1, class _FwdIter2>
  _FwdIter1 find_first_of (_FwdIter1 __first1, _FwdIter1 __last1,
                                  _FwdIter2 __first2, _FwdIter2 __last2);

  template <class _FwdIter1, class _FwdIter2,
  class _BinaryPredicate>
  _FwdIter1 find_first_of (_FwdIter1 __first1,_FwdIter1 __last1,
                                  _FwdIter2 __first2,_FwdIter2 __last2,
                                  _BinaryPredicate __pred);

  template <class _FwdIter>
  _FwdIter adjacent_find (_FwdIter __first, _FwdIter __last);

  template <class _FwdIter, class _BinaryPredicate>
  _FwdIter adjacent_find (_FwdIter __first, _FwdIter __last,
                                 _BinaryPredicate __binary_pred);


  template <class _InputIter, class _TypeT>
  typename iterator_traits<_InputIter>::difference_type
  count (_InputIter __first, _InputIter __last, const _TypeT& __value);

  template <class _InputIter, class _Predicate>
  typename iterator_traits<_InputIter>::difference_type
  count_if (_InputIter __first, _InputIter __last, _Predicate __pred);



  template <class _InputIter, class _TypeT, class _Size>
  void count (_InputIter __first, _InputIter __last, const _TypeT& __value,
              _Size& __n);

  template <class _InputIter, class _Predicate, class _Size>
  void count_if (_InputIter __first, _InputIter __last, _Predicate __pred, 
                 _Size& __n);


  template <class _InputIter1, class _InputIter2>
  pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,
                                                _InputIter1 __last1,
                                                _InputIter2 __first2);

  template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
  pair<_InputIter1, _InputIter2> mismatch (_InputIter1 __first1,
                                           _InputIter1 __last1,
                                           _InputIter2 __first2,
                                           _BinaryPredicate __binary_pred);

  template <class _InputIter1, class _InputIter2>
  inline bool equal (_InputIter1 __first1, _InputIter1 __last1,
                     _InputIter2 __first2)
  {
    return std::mismatch(__first1, __last1, __first2).first == __last1;
  }

  template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
  inline bool equal (_InputIter1 __first1, _InputIter1 __last1,
                     _InputIter2 __first2, _BinaryPredicate __binary_pred)
  {
    return std::mismatch(__first1, __last1, __first2, __binary_pred).first ==
        __last1;
  }

  template <class _FwdIter1, class _FwdIter2,
  class Distance1, class Distance2>
  _FwdIter1 __search (_FwdIter1 __first1, _FwdIter1 __last1,
                             _FwdIter2 __first2, _FwdIter2 __last2,
                             Distance1*, Distance2*);

  template <class _FwdIter1, class _FwdIter2>
  inline _FwdIter1 search (_FwdIter1 __first1,_FwdIter1 __last1,
                                  _FwdIter2 __first2,_FwdIter2 __last2)
  {
    return __search(__first1, __last1, __first2, __last2,
                    __distance_type(__first1),
                    __distance_type(__first2));
  }

  template <class _FwdIter1, class _FwdIter2,
  class _BinaryPredicate, class Distance1, class Distance2>
  _FwdIter1 __search (_FwdIter1 __first1, _FwdIter1 __last1,
                      _FwdIter2 __first2, _FwdIter2 __last2,
                      _BinaryPredicate __binary_pred,
                      Distance1*, Distance2*);

  template <class _FwdIter1, class _FwdIter2,
  class _BinaryPredicate>
  inline _FwdIter1 search (_FwdIter1 __first1,_FwdIter1 __last1,
                                  _FwdIter2 __first2,_FwdIter2 __last2,
                                  _BinaryPredicate __binary_pred)
  {
    return __search(__first1, __last1, __first2, __last2, __binary_pred,
                    __distance_type(__first1), __distance_type(__first2));
  }

  template <class _FwdIter, class _Distance, class _Size, class _TypeT>
  _FwdIter __search_n (_FwdIter __first, _FwdIter __last,
                       _Distance*, _Size __count, const _TypeT& __value);
 
  template <class _FwdIter, class _Size, class _TypeT>
  inline _FwdIter search_n (_FwdIter __first, _FwdIter __last,
                                   _Size __count, const _TypeT& __value)
  {
    if (__count) 
      return __search_n(__first, __last, __distance_type(__first),
                        __count, __value);
    else
      return __first;
  }

  template <class _FwdIter, class _Distance, class _Size, class _TypeT,
  class _BinaryPredicate>
  _FwdIter __search_n (_FwdIter __first, _FwdIter __last,
                       _Distance*, _Size __count,
                       const _TypeT& __value,
                       _BinaryPredicate __pred);

  template <class _FwdIter, class _Size, class _TypeT, class _BinaryPredicate>
  inline _FwdIter search_n (_FwdIter __first, _FwdIter __last,
                                   _Size __count, const _TypeT& __value,
                                   _BinaryPredicate __pred)
  {
    if (__count) 
      return  __search_n(__first, __last, __distance_type(__first),
                         __count,__value, __pred);
    else
      return __first;
  }





  template <class _InputIter, class _OutputIter>
  _OutputIter copy (_InputIter __first, _InputIter __last,
                       _OutputIter __result);

  template <class _BidirIter1, class _BidirIter2>
  _BidirIter2 copy_backward (_BidirIter1 __first, 
                                        _BidirIter1 __last, 
                                        _BidirIter2 __result);

  template <class _TypeT>
  inline void swap (_TypeT& __a, _TypeT& __b)
  {
    _TypeT __tmp = __a;
    __a = __b;
    __b = __tmp;
  }

  template <class _FwdIter1, class _FwdIter2, class _TypeT>
  inline void __iter_swap (_FwdIter1 __a, _FwdIter2 __b, _TypeT*)
  {
    _TypeT __tmp = *__a;
    *__a = *__b;
    *__b = __tmp;
  }

  template <class _FwdIter1, class _FwdIter2>
  inline void iter_swap (_FwdIter1 __a, _FwdIter2 __b)
  {
    __iter_swap(__a, __b, __value_type (__a));
  }

  template <class _FwdIter1, class _FwdIter2>
  _FwdIter2 swap_ranges (_FwdIter1 __first1, _FwdIter1 __last1,
                                _FwdIter2 __first2);

  template <class _InputIter, class _OutputIter, class _UnaryOperation>
  _OutputIter transform (_InputIter __first, _InputIter __last,
                         _OutputIter __result, _UnaryOperation __unary_op);

  template <class _InputIter1, class _InputIter2, class _OutputIter,
  class _BinaryOperation>
  _OutputIter transform (_InputIter1 __first1, _InputIter1 __last1,
                            _InputIter2 __first2, _OutputIter __result,
                            _BinaryOperation __binary_op);

  template <class _FwdIter, class _TypeT>
  void replace (_FwdIter __first, _FwdIter __last, const _TypeT& __old_value,
                const _TypeT& __new_value);

  template <class _FwdIter, class _Predicate, class _TypeT>
  void replace_if (_FwdIter __first, _FwdIter __last, _Predicate __pred,
                   const _TypeT& __new_value);

  template <class _InputIter, class _OutputIter, class _TypeT>
  _OutputIter replace_copy (_InputIter __first, _InputIter __last,
                            _OutputIter __result,
                            const _TypeT& __old_value,
                            const _TypeT& __new_value);

  template <class _Iter, class _OutputIter, class _Predicate, class _TypeT>
  _OutputIter replace_copy_if (_Iter __first, _Iter __last,
                                  _OutputIter __result, _Predicate __pred,
                                  const _TypeT& __new_value);

  template <class _FwdIter, class _TypeT>



  void fill (_FwdIter __first, _FwdIter __last, const _TypeT& __value);


  template <class _OutputIter, class _Size, class _TypeT>
  void fill_n (_OutputIter __first, _Size __n, const _TypeT& __value);

  template <class _FwdIter, class _Generator>
  void generate (_FwdIter __first, _FwdIter __last, _Generator __gen);

  template <class _OutputIter, class _Size, class _Generator>
  void generate_n (_OutputIter __first, _Size __n, _Generator __gen);

  template <class _InputIter, class _OutputIter, class _TypeT>
  _OutputIter remove_copy (_InputIter __first, _InputIter __last,
                              _OutputIter __result, const _TypeT& __value);

  template <class _InputIter, class _OutputIter, class _Predicate>
  _OutputIter remove_copy_if (_InputIter __first, _InputIter __last,
                                 _OutputIter __result, _Predicate __pred);

  template <class _FwdIter, class _TypeT>
  inline _FwdIter remove (_FwdIter __first, _FwdIter __last,
                                 const _TypeT& __value)
  {
    __first = std::find(__first, __last, __value);
    _FwdIter __next = __first;
    return __first == __last ?
        __first : std::remove_copy(++__next, __last, __first, __value);
  }

  template <class _FwdIter, class _Predicate>
  inline _FwdIter remove_if (_FwdIter __first, _FwdIter __last,
                                    _Predicate __pred)
  {
    __first = std::find_if(__first, __last, __pred);
    _FwdIter __next = __first;
    return __first == __last ?
        __first : std::remove_copy_if(++__next, __last, __first, __pred);
  }

  template <class _InputIter, class _FwdIter>
  _FwdIter __unique_copy (_InputIter __first, _InputIter __last,
                                 _FwdIter __result, forward_iterator_tag);

  template <class _InputIter, class _BidirIter>
  inline _BidirIter __unique_copy (_InputIter __first, 
                                              _InputIter __last,
                                              _BidirIter __result, 
                                              bidirectional_iterator_tag)
  {
    return __unique_copy(__first, __last, __result, forward_iterator_tag());
  }

  template <class _InputIter, class _RandomAccessIter>
  inline _RandomAccessIter __unique_copy (_InputIter __first, 
                                             _InputIter __last,
                                             _RandomAccessIter __result, 
                                             random_access_iterator_tag)
  {
    return __unique_copy(__first, __last, __result, forward_iterator_tag());
  }

  template <class _InputIter, class _OutputIter, class _TypeT>
  _OutputIter __unique_copy (_InputIter __first, _InputIter __last,
                                _OutputIter __result, _TypeT*);

  template <class _InputIter, class _OutputIter>
  inline _OutputIter __unique_copy (_InputIter __first, _InputIter __last,
                                       _OutputIter __result, 
                                       output_iterator_tag)
  {
    return __unique_copy(__first, __last, __result,
                         __value_type (__first));
  }

  template <class _InputIter, class _OutputIter>
  inline _OutputIter unique_copy (_InputIter __first, _InputIter __last,
                                     _OutputIter __result)
  {
    return __first == __last ? __result :


    __unique_copy(__first, __last, __result,
        typename iterator_traits<_OutputIter>::iterator_category());
#line 451 "/opt/aCC/include_std/algorithm"
  }

  template <class _InputIter, class _FwdIter, class _BinaryPredicate>
  _FwdIter __unique_copy (_InputIter __first, _InputIter __last,
                                 _FwdIter __result, 
                                 _BinaryPredicate __binary_pred,
                                 forward_iterator_tag);
  template <class _InputIter, class _BidirIter,
  class _BinaryPredicate>
  inline _BidirIter __unique_copy (_InputIter __first, 
                                              _InputIter __last,
                                              _BidirIter __result, 
                                              _BinaryPredicate __binary_pred,
                                              bidirectional_iterator_tag)
  {
    return __unique_copy(__first, __last, __result, __binary_pred,
                         forward_iterator_tag());
  }

  template <class _InputIter, class _RandomAccessIter,
  class _BinaryPredicate>
  inline _RandomAccessIter __unique_copy (_InputIter __first, 
                                             _InputIter __last,
                                             _RandomAccessIter __result, 
                                             _BinaryPredicate __binary_pred,
                                             random_access_iterator_tag)
  {
    return __unique_copy(__first, __last, __result, __binary_pred, 
                         forward_iterator_tag());
  }

  template <class _InputIter, class _OutputIter, class _BinaryPredicate,
  class _TypeT>
  _OutputIter __unique_copy (_InputIter __first, _InputIter __last,
                                _OutputIter __result,
                                _BinaryPredicate __binary_pred, _TypeT*);

  template <class _InputIter, class _OutputIter, class _BinaryPredicate>
  inline _OutputIter __unique_copy (_InputIter __first, _InputIter __last,
                                       _OutputIter __result,
                                       _BinaryPredicate __binary_pred,
                                       output_iterator_tag)
  {
    return __unique_copy(__first, __last, __result, __binary_pred,
                         __value_type (__first));
  }

  template <class _InputIter, class _OutputIter, class _BinaryPredicate>
  inline _OutputIter unique_copy (_InputIter __first, _InputIter __last,
                                     _OutputIter __result,
                                     _BinaryPredicate __binary_pred)
  {
    return __first == __last ? __result :




    __unique_copy(__first, __last, __result, __binary_pred, 
        typename iterator_traits<_OutputIter>::iterator_category());

#line 521 "/opt/aCC/include_std/algorithm"
  }

  template <class _FwdIter>
  inline _FwdIter unique (_FwdIter __first, _FwdIter __last)
  {
    __first = std::adjacent_find(__first, __last);
    if (__first == __last)
      return __first;

    _FwdIter __next = ++__first;
    while (!(++__next == __last))
        if (!(*__next == *__first))
            break;
    if (__next == __last)
      return __first;

    return __unique_copy (__next, __last, __first,
                          typename iterator_traits< _FwdIter > ::iterator_category ());
  }

  template <class _FwdIter, class _BinaryPredicate>
  inline _FwdIter unique (_FwdIter __first, _FwdIter __last,
                                 _BinaryPredicate __binary_pred)
  {
    __first = std::adjacent_find(__first, __last, __binary_pred);
    if (__first == __last)
        return __first;

    _FwdIter __next = ++__first;
    while (!(++__next == __last))
        if (!__binary_pred(*__next, *__first))
            break;
    if (__next == __last)
      return __first;

    return __unique_copy (__next, __last, __first, __binary_pred,
                          typename iterator_traits< _FwdIter > ::iterator_category ());
  }

  template <class _BidirIter>
  void __reverse (_BidirIter __first, _BidirIter __last, 
                  bidirectional_iterator_tag);

  template <class _RandomAccessIter>
  void __reverse (_RandomAccessIter __first, _RandomAccessIter __last,
                  random_access_iterator_tag);

  template <class _BidirIter>
  inline void reverse (_BidirIter __first, _BidirIter __last)
  {


    __reverse(__first, __last,
        typename iterator_traits<_BidirIter>::iterator_category());
#line 581 "/opt/aCC/include_std/algorithm"
  }

  template <class _BidirIter, class _OutputIter>
  _OutputIter reverse_copy (_BidirIter __first,
                               _BidirIter __last,
                               _OutputIter __result);

  template <class _FwdIter, class _Distance>
  void __rotate (_FwdIter __first, _FwdIter __middle,
                 _FwdIter __last, _Distance*, forward_iterator_tag);

  template <class _BidirIter, class _Distance>
  inline void __rotate (_BidirIter __first, 
                        _BidirIter __middle,
                        _BidirIter __last, _Distance*,
                        bidirectional_iterator_tag)
  {
    std::reverse(__first, __middle);
    std::reverse(__middle, __last);
    std::reverse(__first, __last);
  }

  template <class _EuclideanRingElement>
  _EuclideanRingElement __gcd (_EuclideanRingElement __m,
                               _EuclideanRingElement __n);

  template <class _RandomAccessIter, class _Distance, class _TypeT>
  void __rotate_cycle (_RandomAccessIter __first, _RandomAccessIter __last,
                       _RandomAccessIter __initial,
                       _Distance __shift, _TypeT*);

  template <class _RandomAccessIter, class _Distance>
  void __rotate (_RandomAccessIter __first, _RandomAccessIter __middle,
                 _RandomAccessIter __last, _Distance*,
                 random_access_iterator_tag);

  template <class _FwdIter>
  inline void rotate (_FwdIter __first, _FwdIter __middle,
                      _FwdIter __last)
  {
    if (!(__first == __middle || __middle == __last))
    {



      __rotate(__first, __middle, __last,
        static_cast< typename iterator_traits<_FwdIter> ::difference_type* >(0),
        typename iterator_traits<_FwdIter>::iterator_category());
#line 637 "/opt/aCC/include_std/algorithm"
    }
  }

  template <class _FwdIter, class _OutputIter>
  inline _OutputIter rotate_copy (_FwdIter __first,
                                     _FwdIter __middle,
                                     _FwdIter __last,
                                     _OutputIter __result)
  {
    return std::copy(__first, __middle,
                         std::copy(__middle, __last, __result));
  }

  template <class _RandomAccessIter, class _Distance>
  void __random_shuffle (_RandomAccessIter __first, _RandomAccessIter __last,
                         _Distance*);

  template <class _RandomAccessIter>
  inline void random_shuffle (_RandomAccessIter __first,
                              _RandomAccessIter __last)
  {
    __random_shuffle(__first, __last, __distance_type(__first));
  }

  template <class _RandomAccessIter, class _RandomNumberGenerator>
  void random_shuffle (_RandomAccessIter __first, _RandomAccessIter __last,
                       _RandomNumberGenerator& __rand);

  template <class _BidirIter, class _Predicate>
  _BidirIter partition (_BidirIter __first,
                                   _BidirIter __last, _Predicate __pred);

  template <class _BidirIter, class _Predicate, class _Distance>
  _BidirIter __inplace_stable_partition (_BidirIter __first,
                                                    _BidirIter __last,
                                                    _Predicate __pred,
                                                    _Distance __len);

  template <class _BidirIter, class _Pointer, class _Predicate,
  class _Distance, class _TypeT>
  _BidirIter __stable_partition_adaptive (_BidirIter __first,
                                          _BidirIter __last,
                                          _Predicate __pred,
                                          _Distance __len,
                                          _Pointer __buffer,
                                          _Distance __buffer_size,
                                          _Distance& __fill_pointer, _TypeT*);

  template <class _BidirIter, class _Predicate, class _Pointer,
  class _Distance>
  _BidirIter __stable_partition (_BidirIter __first,
                                            _BidirIter __last,
                                            _Predicate __pred,
                                            _Distance __len,
                                            pair<_Pointer, _Distance> __p);


template <class _BidirIter, class _Predicate, class _Distance>
inline _BidirIter __stable_partition_aux (_BidirIter __first,
                                          _BidirIter __last, 
                                          _Predicate __pred,
                                          _Distance*)
{
    _Distance __len = std::distance (__first, __last);
    
    
    
    return __len == 0 ? __last :
        __stable_partition (__first, __last, __pred, __len,
                          std::get_temporary_buffer (__len,
                                                __value_type (__first)));
}


  template <class _BidirIter, class _Predicate>
  inline _BidirIter stable_partition (_BidirIter __first,
                                                 _BidirIter __last, 
                                                 _Predicate __pred)
  {
    return __stable_partition_aux(__first, __last, __pred,
      __distance_type(__first));
  }





  template <class _TypeT>
  inline const _TypeT& __median (const _TypeT& __a,
                                 const _TypeT& __b,
                                 const _TypeT& __c)
  {
    if (__a < __b)
      if (__b < __c)
        return __b;
      else if (__a < __c)
        return __c;
      else
        return __a;
    else if (__a < __c)
      return __a;
    else if (__b < __c)
      return __c;
    else
      return __b;
  }

  template <class _TypeT, class _Compare>
  inline const _TypeT& __median (const _TypeT& __a, const _TypeT& __b,
                                 const _TypeT& __c, _Compare __comp)
  {
    if (__comp(__a, __b))
      if (__comp(__b, __c))
        return __b;
      else if (__comp(__a, __c))
        return __c;
      else
        return __a;
    else if (__comp(__a, __c))
      return __a;
    else if (__comp(__b, __c))
      return __c;
    else
      return __b;
  }

  template <class _RandomAccessIter, class _TypeT>
  _RandomAccessIter __unguarded_partition (_RandomAccessIter __first, 
                                              _RandomAccessIter __last, 
                                              _TypeT __pivot);

  template <class _RandomAccessIter, class _TypeT, class _Compare>
  _RandomAccessIter __unguarded_partition (_RandomAccessIter __first, 
                                              _RandomAccessIter __last, 
                                              _TypeT __pivot,
                                              _Compare __comp);

  template <class _RandomAccessIter, class _TypeT>
  void __quick_sort_loop_aux (_RandomAccessIter __first,
                              _RandomAccessIter __last, _TypeT*);

  template <class _RandomAccessIter>
  inline void __quick_sort_loop (_RandomAccessIter __first,
                                 _RandomAccessIter __last)
  {
    __quick_sort_loop_aux(__first, __last, __value_type (__first));
  }

  template <class _RandomAccessIter, class _TypeT, class _Compare>
  void __quick_sort_loop_aux (_RandomAccessIter __first, 
                              _RandomAccessIter __last,
                              _TypeT*, _Compare __comp);

  template <class _RandomAccessIter, class _Compare>
  inline void __quick_sort_loop (_RandomAccessIter __first, 
                                 _RandomAccessIter __last, _Compare __comp)
  {
    __quick_sort_loop_aux(__first, __last, __value_type (__first),
                          __comp);
  }

  template <class _RandomAccessIter, class _TypeT>
  void __unguarded_linear_insert (_RandomAccessIter __last, _TypeT __value);

  template <class _RandomAccessIter, class _TypeT, class _Compare>
  void __unguarded_linear_insert (_RandomAccessIter __last,_TypeT __value,
      _Compare __comp);

  template <class _RandomAccessIter, class _TypeT>
  inline void __linear_insert (_RandomAccessIter __first, 
                               _RandomAccessIter __last, _TypeT*)
  {
    _TypeT __value = *__last;
    if (__value < *__first)
    {
      std::copy_backward(__first, __last, __last + 1);
      *__first = __value;
    }
    else
      __unguarded_linear_insert(__last, __value);
  }

  template <class _RandomAccessIter, class _TypeT, class _Compare>
  inline void __linear_insert (_RandomAccessIter __first, 
                               _RandomAccessIter __last, _TypeT*,
                               _Compare __comp)
  {
    _TypeT __value = *__last;
    if (__comp(__value, *__first))
    {
      std::copy_backward(__first, __last, __last + 1);
      *__first = __value;
    }
    else
      __unguarded_linear_insert(__last, __value, __comp);
  }

  template <class _RandomAccessIter>
  void __insertion_sort (_RandomAccessIter __first, _RandomAccessIter __last);

  template <class _RandomAccessIter, class _Compare>
  void __insertion_sort (_RandomAccessIter __first,
                         _RandomAccessIter __last, _Compare __comp);

  template <class _RandomAccessIter, class _TypeT>
  void __unguarded_insertion_sort_aux (_RandomAccessIter __first, 
                                       _RandomAccessIter __last, _TypeT*);

  template <class _RandomAccessIter>
  inline void __unguarded_insertion_sort(_RandomAccessIter __first, 
                                         _RandomAccessIter __last)
  {
    __unguarded_insertion_sort_aux(__first, __last,
      __value_type (__first));
  }

  template <class _RandomAccessIter, class _TypeT, class _Compare>
  void __unguarded_insertion_sort_aux (_RandomAccessIter __first, 
                                       _RandomAccessIter __last,
                                       _TypeT*, _Compare __comp);

  template <class _RandomAccessIter, class _Compare>
  inline void __unguarded_insertion_sort (_RandomAccessIter __first, 
                                          _RandomAccessIter __last,
                                          _Compare __comp)
  {
    __unguarded_insertion_sort_aux(__first, __last,
      __value_type (__first), __comp);
  }

  template <class _RandomAccessIter>
  void __final_insertion_sort (_RandomAccessIter __first, 
                               _RandomAccessIter __last);

  template <class _RandomAccessIter, class _Compare>
  void __final_insertion_sort (_RandomAccessIter __first, 
                               _RandomAccessIter __last, _Compare __comp);

  template <class _RandomAccessIter>
  inline void sort (_RandomAccessIter __first, _RandomAccessIter __last)
  {
    if (!(__first == __last))
    {
      __quick_sort_loop(__first, __last);
      __final_insertion_sort(__first, __last);
    }
  }

  template <class _RandomAccessIter, class _Compare>
  inline void sort (_RandomAccessIter __first, 
                    _RandomAccessIter __last, _Compare __comp)
  {
    if (!(__first == __last))
    {
      __quick_sort_loop(__first, __last, __comp);
      __final_insertion_sort(__first, __last, __comp);
    }
  }

  template <class _RandomAccessIter>
  inline void __inplace_stable_sort (_RandomAccessIter __first,
                                     _RandomAccessIter __last)
  {
    if (__last - __first < 15)
      __insertion_sort(__first, __last);
    else
    {
      _RandomAccessIter __middle = __first + (__last - __first) / 2;
      __inplace_stable_sort(__first, __middle);
      __inplace_stable_sort(__middle, __last);
      __merge_without_buffer(__first, __middle, __last, __middle - __first,
                             __last - __middle);
    }
  }

  template <class _RandomAccessIter, class _Compare>
  inline void __inplace_stable_sort (_RandomAccessIter __first,
                                     _RandomAccessIter __last,
                                     _Compare __comp)
  {
    if (__last - __first < 15)
      __insertion_sort(__first, __last, __comp);
    else
    {
      _RandomAccessIter __middle = __first + (__last - __first) / 2;
      __inplace_stable_sort(__first, __middle, __comp);
      __inplace_stable_sort(__middle, __last, __comp);
      __merge_without_buffer(__first, __middle, __last, __middle - __first,
                             __last - __middle, __comp);
    }
  }

  template <class _RandomAccessIter1, class _RandomAccessIter2,
  class _Distance>
  void __merge_sort_loop (_RandomAccessIter1 __first,
                          _RandomAccessIter1 __last, 
                          _RandomAccessIter2 __result, _Distance __step_size);

  template <class _RandomAccessIter1, class _RandomAccessIter2,
  class _Distance, class _Compare>
  void __merge_sort_loop (_RandomAccessIter1 __first,
                          _RandomAccessIter1 __last, 
                          _RandomAccessIter2 __result, _Distance __step_size,
                          _Compare __comp);

  template <class _RandomAccessIter, class _Distance>
  void __chunk_insertion_sort (_RandomAccessIter __first, 
                               _RandomAccessIter __last,
                               _Distance __chunk_size);

  template <class _RandomAccessIter, class _Distance, class _Compare>
  void __chunk_insertion_sort (_RandomAccessIter __first, 
                               _RandomAccessIter __last,
                               _Distance __chunk_size, _Compare __comp);

  template <class _RandomAccessIter, class _Pointer, class _Distance,
            class _TypeT>
  void __merge_sort_with_buffer (_RandomAccessIter __first, 
                                 _RandomAccessIter __last,
                                 _Pointer __buffer, _Distance*, _TypeT*);

  template <class _RandomAccessIter, class _Pointer, class _Distance,
            class _TypeT,
  class _Compare>
  void __merge_sort_with_buffer (_RandomAccessIter __first, 
                                 _RandomAccessIter __last, _Pointer __buffer,
                                 _Distance*, _TypeT*, _Compare __comp);

  template <class _RandomAccessIter, class _Pointer, class _Distance,
            class _TypeT>
  void __stable_sort_adaptive (_RandomAccessIter __first, 
                               _RandomAccessIter __last, _Pointer __buffer,
                               _Distance __buffer_size, _TypeT*);

  template <class _RandomAccessIter, class _Pointer, class _Distance,
            class _TypeT, class _Compare>
  void __stable_sort_adaptive (_RandomAccessIter __first, 
                               _RandomAccessIter __last, _Pointer __buffer,
                               _Distance __buffer_size, _TypeT*,
                               _Compare __comp);

  template <class _RandomAccessIter, class _Pointer, class _Distance,
            class _TypeT>
  inline void __stable_sort (_RandomAccessIter __first,
                             _RandomAccessIter __last,
                             pair<_Pointer, _Distance>& __p, _TypeT*)
  {
    if (__p.first == 0)
      __inplace_stable_sort(__first, __last);
    else
    {
      _Distance __len = std::min((int)__p.second, (int)(__last - __first));
      copy(__first, __first + __len,
           raw_storage_iterator<_Pointer, _TypeT>(__p.first));
      __stable_sort_adaptive(__first, __last, __p.first, __p.second,
                             static_cast< _TypeT* >(0));
      __rw::__rw_destroy(__p.first, __p.first + __len);
      return_temporary_buffer(__p.first);
    }
  }

  template <class _RandomAccessIter, class _Pointer, class _Distance,
      class _TypeT, class _Compare>
  inline void __stable_sort (_RandomAccessIter __first,
                             _RandomAccessIter __last,
                             pair<_Pointer, _Distance>& __p, _TypeT*,
                             _Compare __comp)
  {
    if (__p.first == 0)
      __inplace_stable_sort(__first, __last, __comp);
    else
    {
      _Distance __len = min((int)__p.second, (int)(__last - __first));
      copy(__first, __first + __len,
           raw_storage_iterator<_Pointer, _TypeT>(__p.first));
      __stable_sort_adaptive(__first, __last, __p.first, __p.second,
               static_cast< _TypeT* >(0), __comp);
      __rw::__rw_destroy(__p.first, __p.first + __len);
      std::return_temporary_buffer(__p.first);
    }
  }


template <class _RandomAccessIter, class _TypeT, class _Distance>
inline void __stable_sort_aux (_RandomAccessIter __first,
                               _RandomAccessIter __last, _TypeT*,
                               _Distance*)
{
    
    
    pair<_TypeT*, _Distance> __buf =
        std::get_temporary_buffer (_Distance (__last - __first),
                                       (_TypeT*)0);

    __stable_sort (__first, __last, __buf, static_cast< _TypeT* >(0));
}


template <class _RandomAccessIter, class _TypeT, class _Distance,
    class _Compare>
inline void __stable_sort_aux (_RandomAccessIter __first,
                               _RandomAccessIter __last, _TypeT*,
                               _Distance*,
                               _Compare __comp)
{
    
    
    pair<_TypeT*, _Distance> __buf =
        std::get_temporary_buffer (_Distance (__last - __first),
                                       (_TypeT*)0);

    __stable_sort (__first, __last, __buf, static_cast< _TypeT* >(0),
                   __comp);
}


  template <class _RandomAccessIter>
  inline void stable_sort (_RandomAccessIter __first,
                           _RandomAccessIter __last)
  {
    if (!(__first == __last))
    {
      __stable_sort_aux(__first, __last, __value_type (__first),
                        __distance_type(__first));
    }
  }

  template <class _RandomAccessIter, class _Compare>
  inline void stable_sort (_RandomAccessIter __first,
                           _RandomAccessIter __last, _Compare __comp)
  {
    if (!(__first == __last))
    {
      __stable_sort_aux(__first, __last, __value_type (__first),
                        __distance_type(__first), __comp);
    }
  }

  template <class _RandomAccessIter, class _TypeT>
  void __partial_sort (_RandomAccessIter __first, _RandomAccessIter __middle,
                       _RandomAccessIter __last, _TypeT*);

  template <class _RandomAccessIter>
  inline void partial_sort (_RandomAccessIter __first,
                            _RandomAccessIter __middle,
                            _RandomAccessIter __last)
  {
    if (!(__first == __middle))
      __partial_sort(__first, __middle, __last, __value_type (__first));
  }

  template <class _RandomAccessIter, class _TypeT, class _Compare>
  void __partial_sort (_RandomAccessIter __first, _RandomAccessIter __middle,
                       _RandomAccessIter __last, _TypeT*, _Compare __comp);

  template <class _RandomAccessIter, class _Compare>
  inline void partial_sort (_RandomAccessIter __first,
                            _RandomAccessIter __middle,
                            _RandomAccessIter __last, _Compare __comp)
  {
    if (!(__first == __middle))
      __partial_sort(__first, __middle, __last, __value_type (__first),
                     __comp);
  }

  template <class _InputIter, class _RandomAccessIter, class _Distance,
      class _TypeT>
  _RandomAccessIter __partial_sort_copy (_InputIter __first,
                                            _InputIter __last,
                                            _RandomAccessIter __result_first,
                                            _RandomAccessIter __result_last, 
                                            _Distance*, _TypeT*);

  template <class _InputIter, class _RandomAccessIter>
  inline _RandomAccessIter
  partial_sort_copy (_InputIter __first, _InputIter __last,
                     _RandomAccessIter __result_first,
                     _RandomAccessIter __result_last)
  {
    return __first == __last ? __result_first :
    __partial_sort_copy(__first, __last, __result_first, __result_last, 
                        __distance_type(__result_first),
                        __value_type (__first));
  }

  template <class _InputIter, class _RandomAccessIter, class _Compare,
  class _Distance, class _TypeT>
  _RandomAccessIter __partial_sort_copy (_InputIter __first,
                                            _InputIter __last,
                                            _RandomAccessIter __result_first,
                                            _RandomAccessIter __result_last,
                                            _Compare __comp, _Distance*,
                                            _TypeT*);

  template <class _InputIter, class _RandomAccessIter, class _Compare>
  inline _RandomAccessIter
  partial_sort_copy (_InputIter __first, _InputIter __last,
                     _RandomAccessIter __result_first,
                     _RandomAccessIter __result_last, _Compare __comp)
  {
    return __first == __last ? __result_first :
    __partial_sort_copy(__first, __last, __result_first, __result_last,
                        __comp,
                        __distance_type(__result_first),
                        __value_type (__first));
  }

  template <class _RandomAccessIter, class _TypeT>
  void __nth_element (_RandomAccessIter __first, _RandomAccessIter __nth,
                      _RandomAccessIter __last, _TypeT*);

  template <class _RandomAccessIter>
  inline void nth_element (_RandomAccessIter __first, _RandomAccessIter __nth,
                           _RandomAccessIter __last)
  {
    if (!(__first == __last))
      __nth_element(__first, __nth, __last, __value_type (__first));
  }

  template <class _RandomAccessIter, class _TypeT, class _Compare>
  void __nth_element (_RandomAccessIter __first, _RandomAccessIter __nth,
                      _RandomAccessIter __last, _TypeT*, _Compare __comp);

  template <class _RandomAccessIter, class _Compare>
  inline void nth_element (_RandomAccessIter __first, _RandomAccessIter __nth,
                           _RandomAccessIter __last, _Compare __comp)
  {
    if (!(__first == __last))
      __nth_element(__first, __nth, __last, __value_type (__first),
                    __comp);
  }





  template <class _FwdIter, class _TypeT, class _Distance>
  _FwdIter __lower_bound (_FwdIter __first, _FwdIter __last,
                                 const _TypeT& __value, _Distance*,
                                 forward_iterator_tag);

  template <class _FwdIter, class _TypeT, class _Distance>
  inline _FwdIter __lower_bound (_FwdIter __first,
                                        _FwdIter __last,
                                        const _TypeT& __value, _Distance*,
                                        bidirectional_iterator_tag)
  {
    return __lower_bound(__first, __last, __value,
                         static_cast< _Distance* >(0),
                         forward_iterator_tag());
  }

  template <class _RandomAccessIter, class _TypeT, class _Distance>
  _RandomAccessIter __lower_bound (_RandomAccessIter __first,
                                      _RandomAccessIter __last,
                                      const _TypeT& __value,
                                      _Distance*, random_access_iterator_tag);

  template <class _FwdIter, class _TypeT>
  inline _FwdIter lower_bound (_FwdIter __first,_FwdIter __last,
                                      const _TypeT& __value)
  {



    return __lower_bound(__first, __last, __value,
        static_cast< typename iterator_traits<_FwdIter> ::difference_type* >(0),
        typename iterator_traits<_FwdIter>::iterator_category());
#line 1213 "/opt/aCC/include_std/algorithm"
  }

  template <class _FwdIter, class _TypeT, class _Compare, class _Distance>
  _FwdIter __lower_bound (_FwdIter __first, _FwdIter __last,
                                 const _TypeT& __value, _Compare __comp,
                                 _Distance*,
                                 forward_iterator_tag);

  template <class _FwdIter, class _TypeT, class _Compare, class _Distance>
  inline _FwdIter __lower_bound (_FwdIter __first,
                                        _FwdIter __last,
                                        const _TypeT& __value,
                                        _Compare __comp, _Distance*,
                                        bidirectional_iterator_tag)
  {
    return __lower_bound(__first, __last, __value, __comp,
                         static_cast< _Distance* >(0),
                         forward_iterator_tag());
  }

  template <class _RandomAccessIter, class _TypeT, class _Compare,
      class _Distance>
  _RandomAccessIter __lower_bound (_RandomAccessIter __first,
                                      _RandomAccessIter __last,
                                      const _TypeT& __value, _Compare __comp,
                                      _Distance*,
                                      random_access_iterator_tag);

  template <class _FwdIter, class _TypeT, class _Compare>
  inline _FwdIter lower_bound (_FwdIter __first,_FwdIter __last,
                                      const _TypeT& __value, _Compare __comp)
  {


    return __lower_bound(__first, __last, __value, __comp,
        static_cast< typename iterator_traits<_FwdIter> ::difference_type* >(0),
        typename iterator_traits<_FwdIter>::iterator_category());
#line 1260 "/opt/aCC/include_std/algorithm"
  }

  template <class _FwdIter, class _TypeT, class _Distance>
  _FwdIter __upper_bound (_FwdIter __first, _FwdIter __last,
                                 const _TypeT& __value, _Distance*,
                                 forward_iterator_tag);

  template <class _FwdIter, class _TypeT, class _Distance>
  inline _FwdIter __upper_bound (_FwdIter __first,
                                        _FwdIter __last,
                                        const _TypeT& __value, _Distance*,
                                        bidirectional_iterator_tag)
  {
    return __upper_bound(__first, __last, __value,
                         static_cast< _Distance* >(0),
                         forward_iterator_tag());
  }

  template <class _RandomAccessIter, class _TypeT, class _Distance>
  _RandomAccessIter __upper_bound (_RandomAccessIter __first,
                                      _RandomAccessIter __last,
                                      const _TypeT& __value,
                                      _Distance*, random_access_iterator_tag);

  template <class _FwdIter, class _TypeT>
  inline _FwdIter upper_bound (_FwdIter __first,_FwdIter __last,
                                      const _TypeT& __value)
  {


    return __upper_bound(__first, __last, __value,
        static_cast< typename iterator_traits<_FwdIter> ::difference_type* >(0),
        typename iterator_traits<_FwdIter>::iterator_category());
#line 1301 "/opt/aCC/include_std/algorithm"
  }

  template <class _FwdIter, class _TypeT, class _Compare, class _Distance>
  _FwdIter __upper_bound (_FwdIter __first, _FwdIter __last,
                                 const _TypeT& __value, _Compare __comp,
                                 _Distance*,
                                 forward_iterator_tag);

  template <class _FwdIter, class _TypeT, class _Compare, class _Distance>
  inline _FwdIter __upper_bound (_FwdIter __first,
                                        _FwdIter __last,
                                        const _TypeT& __value,
                                        _Compare __comp, _Distance*,
                                        bidirectional_iterator_tag)
  {
    return __upper_bound(__first, __last, __value, __comp,
                         static_cast< _Distance* >(0),
                         forward_iterator_tag());
  }

  template <class _RandomAccessIter, class _TypeT, class _Compare,
      class _Distance>
  _RandomAccessIter __upper_bound (_RandomAccessIter __first,
                                      _RandomAccessIter __last,
                                      const _TypeT& __value, _Compare __comp,
                                      _Distance*,
                                      random_access_iterator_tag);

  template <class _FwdIter, class _TypeT, class _Compare>
  inline _FwdIter upper_bound (_FwdIter __first,_FwdIter __last,
                                      const _TypeT& __value, _Compare __comp)
  {


    return __upper_bound(__first, __last, __value, __comp,
        static_cast< typename iterator_traits<_FwdIter> ::difference_type* >(0),
        typename iterator_traits<_FwdIter>::iterator_category());
#line 1348 "/opt/aCC/include_std/algorithm"
  }

  template <class _FwdIter, class _TypeT, class _Distance>
  pair<_FwdIter, _FwdIter>
  __equal_range (_FwdIter __first, _FwdIter __last, const _TypeT& __value,
                 _Distance*, forward_iterator_tag);

  template <class _FwdIter, class _TypeT, class _Distance>
  inline pair<_FwdIter, _FwdIter>
  __equal_range (_FwdIter __first, _FwdIter __last, const _TypeT& __value,
                 _Distance*, bidirectional_iterator_tag)
  {
    return __equal_range(__first, __last, __value,
                         static_cast< _Distance* >(0), 
                         forward_iterator_tag());
  }

  template <class _RandomAccessIter, class _TypeT, class _Distance>
  pair<_RandomAccessIter, _RandomAccessIter>
  __equal_range (_RandomAccessIter __first, _RandomAccessIter __last,
                 const _TypeT& __value, _Distance*,
                 random_access_iterator_tag);

  template <class _FwdIter, class _TypeT>
  inline pair<_FwdIter, _FwdIter>
  equal_range (_FwdIter __first, _FwdIter __last, const _TypeT& __value)
  {


    return __equal_range(__first, __last, __value,
        static_cast< typename iterator_traits<_FwdIter> ::difference_type* >(0),
        typename iterator_traits<_FwdIter>::iterator_category());
#line 1388 "/opt/aCC/include_std/algorithm"
  }

  template <class _FwdIter, class _TypeT, class _Compare, class _Distance>
  pair<_FwdIter, _FwdIter>
  __equal_range (_FwdIter __first, _FwdIter __last, const _TypeT& __value,
                 _Compare __comp, _Distance*, forward_iterator_tag);

  template <class _FwdIter, class _TypeT, class _Compare, class _Distance>
  inline pair<_FwdIter, _FwdIter>
  __equal_range (_FwdIter __first, _FwdIter __last, const _TypeT& __value,
                 _Compare __comp, _Distance*, bidirectional_iterator_tag)
  {
    return __equal_range(__first, __last, __value, __comp,
      static_cast< _Distance* >(0), 
                         forward_iterator_tag());
  }

  template <class _RandomAccessIter, class _TypeT, class _Compare,
      class _Distance>
  pair<_RandomAccessIter, _RandomAccessIter>
  __equal_range (_RandomAccessIter __first, _RandomAccessIter __last,
                 const _TypeT& __value, _Compare __comp, _Distance*,
                 random_access_iterator_tag);

  template <class _FwdIter, class _TypeT, class _Compare>
  inline pair<_FwdIter, _FwdIter>
  equal_range (_FwdIter __first, _FwdIter __last, const _TypeT& __value,
               _Compare __comp)
  {


    return __equal_range(__first, __last, __value, __comp,
        static_cast< typename iterator_traits<_FwdIter> ::difference_type* >(0),
        typename iterator_traits<_FwdIter>::iterator_category());
#line 1432 "/opt/aCC/include_std/algorithm"
  }    

  template <class _FwdIter, class _TypeT>
  inline bool binary_search (_FwdIter __first, _FwdIter __last,
                             const _TypeT& __value)
  {
    _FwdIter __i = std::lower_bound(__first, __last, __value);
    return __i != __last && !(__value < *__i);
  }

  template <class _FwdIter, class _TypeT, class _Compare>
  inline bool binary_search (_FwdIter __first, _FwdIter __last,
                             const _TypeT& __value, _Compare __comp)
  {
    _FwdIter __i = std::lower_bound(__first, __last, __value, __comp);
    return __i != __last && !__comp(__value, *__i);
  }





  template <class _InputIter1, class _InputIter2, class _OutputIter>
  _OutputIter merge (_InputIter1 __first1, _InputIter1 __last1,
                        _InputIter2 __first2, _InputIter2 __last2,
                        _OutputIter __result);

  template <class _InputIter1, class _InputIter2, class _OutputIter,
  class _Compare>
  _OutputIter merge (_InputIter1 __first1, _InputIter1 __last1,
                        _InputIter2 __first2, _InputIter2 __last2,
                        _OutputIter __result, _Compare __comp);

  template <class _BidirIter1, class _BidirIter2,
  class _Distance>
  _BidirIter1 __rotate_adaptive (_BidirIter1 __first,
                                            _BidirIter1 __middle,
                                            _BidirIter1 __last,
                                            _Distance __len1,
                                            _Distance __len2,
                                            _BidirIter2 __buffer,
                                            _Distance __buffer_size);

  template <class _BidirIter1, class _BidirIter2,
  class _BidirIter3>
  _BidirIter3 __merge_backward (_BidirIter1 __first1,
                                           _BidirIter1 __last1,
                                           _BidirIter2 __first2,
                                           _BidirIter2 __last2,
                                           _BidirIter3 __result);

  template <class _BidirIter1, class _BidirIter2,
  class _BidirIter3, class _Compare>
  _BidirIter3 __merge_backward (_BidirIter1 __first1,
                                           _BidirIter1 __last1,
                                           _BidirIter2 __first2,
                                           _BidirIter2 __last2,
                                           _BidirIter3 __result,
                                           _Compare __comp);

  template <class _BidirIter, class _Distance, class _Pointer, class _TypeT>
  void __merge_adaptive (_BidirIter __first,
                         _BidirIter __middle,
                         _BidirIter __last, _Distance __len1,_Distance __len2,
                         _Pointer __buffer, _Distance __buffer_size, _TypeT*);

  template <class _BidirIter, class _Distance, class _Pointer, class _TypeT,
  class _Compare>
  void __merge_adaptive (_BidirIter __first,
                         _BidirIter __middle,
                         _BidirIter __last, _Distance __len1,_Distance __len2,
                         _Pointer __buffer, _Distance __buffer_size, _TypeT*,
                         _Compare __comp);

  template <class _BidirIter, class _Distance, class _Pointer, class _TypeT>
  void __inplace_merge (_BidirIter __first,
                        _BidirIter __middle, 
                        _BidirIter __last, _Distance __len1,
                        _Distance __len2, pair<_Pointer, _Distance> __p,
                        _TypeT*);

  template <class _BidirIter, class _Distance, class _Pointer, class _TypeT,
  class _Compare>
  void __inplace_merge (_BidirIter __first,
                        _BidirIter __middle,
                        _BidirIter __last, _Distance __len1,
                        _Distance __len2, pair<_Pointer, _Distance> __p,
                        _TypeT*,
                        _Compare __comp);


template <class _BidirIter, class _TypeT, class _Distance>
inline void __inplace_merge_aux (_BidirIter __first,
                                 _BidirIter __middle,
                                 _BidirIter __last, _TypeT*, _Distance*)
{
    _Distance __len1 = std::distance (__first, __middle);
    _Distance __len2 = std::distance (__middle, __last);

    
    
    pair<_TypeT*, _Distance> __buf =
        std::get_temporary_buffer (__len1 + __len2, (_TypeT*)0);

    __inplace_merge (__first, __middle, __last, __len1, __len2, __buf,
                     (_TypeT*)0);
}

 
template <class _BidirIter, class _TypeT, class _Distance, class _Compare>
inline void __inplace_merge_aux (_BidirIter __first,
                                 _BidirIter __middle,
                                 _BidirIter __last, _TypeT*, _Distance*,
                                 _Compare __comp)
{
    _Distance __len1 = std::distance (__first, __middle);
    _Distance __len2 = std::distance (__middle, __last);
 
    pair<_TypeT*, _Distance> __buf =
        std::get_temporary_buffer (__len1 + __len2, (_TypeT*)0);

    __inplace_merge (__first, __middle, __last, __len1, __len2, __buf,
                     (_TypeT*)0, __comp);
}


template <class _BidirIter>
inline void inplace_merge (_BidirIter __first,
                             _BidirIter __middle,
                             _BidirIter __last)
  {
    if (!(__first == __middle || __middle == __last))
      __inplace_merge_aux(__first, __middle, __last,
                          __value_type (__first),
                          __distance_type(__first));
  }

  template <class _BidirIter, class _Compare>
  inline void inplace_merge (_BidirIter __first,
                             _BidirIter __middle,
                             _BidirIter __last, _Compare __comp)
  {
    if (!(__first == __middle || __middle == __last))
      __inplace_merge_aux(__first, __middle, __last,
                          __value_type (__first),
                          __distance_type(__first), __comp);
  }





  template <class _InputIter1, class _InputIter2>
  bool includes (_InputIter1 __first1, _InputIter1 __last1,
                 _InputIter2 __first2, _InputIter2 __last2);

  template <class _InputIter1, class _InputIter2, class _Compare>
  bool includes (_InputIter1 __first1, _InputIter1 __last1,
                 _InputIter2 __first2, _InputIter2 __last2, 
                 _Compare __comp);

  template <class _InputIter1, class _InputIter2, class _OutputIter>
  _OutputIter set_union (_InputIter1 __first1, _InputIter1 __last1,
                            _InputIter2 __first2, _InputIter2 __last2,
                            _OutputIter __result);

  template <class _InputIter1, class _InputIter2, class _OutputIter,
  class _Compare>
  _OutputIter set_union (_InputIter1 __first1, _InputIter1 __last1,
                            _InputIter2 __first2, _InputIter2 __last2,
                            _OutputIter __result, _Compare __comp);

  template <class _InputIter1, class _InputIter2, class _OutputIter>
  _OutputIter set_intersection (_InputIter1 __first1, _InputIter1 __last1,
                                   _InputIter2 __first2, _InputIter2 __last2,
                                   _OutputIter __result);

  template <class _InputIter1, class _InputIter2, class _OutputIter,
  class _Compare>
  _OutputIter set_intersection (_InputIter1 __first1, _InputIter1 __last1,
                                   _InputIter2 __first2, _InputIter2 __last2,
                                   _OutputIter __result, _Compare __comp);

  template <class _InputIter1, class _InputIter2, class _OutputIter>
  _OutputIter set_difference (_InputIter1 __first1, _InputIter1 __last1,
                                 _InputIter2 __first2, _InputIter2 __last2,
                                 _OutputIter __result);

  template <class _InputIter1, class _InputIter2, class _OutputIter, 
  class _Compare>
  _OutputIter set_difference (_InputIter1 __first1, _InputIter1 __last1,
                                 _InputIter2 __first2, _InputIter2 __last2, 
                                 _OutputIter __result, _Compare __comp);

  template <class _InputIter1, class _InputIter2, class _OutputIter>
  _OutputIter set_symmetric_difference (_InputIter1 __first1,
                                           _InputIter1 __last1,
                                           _InputIter2 __first2,
                                           _InputIter2 __last2,
                                           _OutputIter __result);

  template <class _InputIter1, class _InputIter2, class _OutputIter,
  class _Compare>
  _OutputIter set_symmetric_difference (_InputIter1 __first1,
                                           _InputIter1 __last1,
                                           _InputIter2 __first2,
                                           _InputIter2 __last2,
                                           _OutputIter __result, 
                                           _Compare __comp);





  template <class _RandomAccessIter, class _Distance, class _TypeT>
  void __push_heap (_RandomAccessIter __first, _Distance __holeIndex,
                    _Distance __topIndex, _TypeT __value);

  template <class _RandomAccessIter, class _Distance, class _TypeT>
  inline void __push_heap_aux (_RandomAccessIter __first,
                               _RandomAccessIter __last, _Distance*, _TypeT*)
  {
    __push_heap(__first, _Distance((__last-__first)-1), _Distance(0),
      _TypeT(*(__last-1)));
  }

  template <class _RandomAccessIter>
  inline void push_heap (_RandomAccessIter __first, _RandomAccessIter __last)
  {
    if (!(__first == __last))
      __push_heap_aux(__first, __last, __distance_type(__first),
                      __value_type (__first));
  }

  template <class _RandomAccessIter, class _Distance, class _TypeT,
      class _Compare>
  void __push_heap (_RandomAccessIter __first, _Distance __holeIndex,
                    _Distance __topIndex, _TypeT __value, _Compare __comp);

  template <class _RandomAccessIter, class _Compare,  class _Distance,
      class _TypeT>
  inline void __push_heap_aux (_RandomAccessIter __first,
                               _RandomAccessIter __last, _Compare __comp,
                               _Distance*, _TypeT*)
  {
    __push_heap(__first, _Distance((__last-__first)-1), _Distance(0),
                _TypeT(*(__last - 1)), __comp);
  }

  template <class _RandomAccessIter, class _Compare>
  inline void push_heap (_RandomAccessIter __first, _RandomAccessIter __last,
                         _Compare __comp)
  {
    if (!(__first == __last))
      __push_heap_aux(__first, __last, __comp, __distance_type(__first),
                      __value_type (__first));
  }

  template <class _RandomAccessIter, class _Distance, class _TypeT>
  void __adjust_heap (_RandomAccessIter __first, _Distance __holeIndex,
                      _Distance __len, _TypeT __value);

  template <class _RandomAccessIter, class _TypeT, class _Distance>
  inline void __pop_heap (_RandomAccessIter __first, _RandomAccessIter __last,
                          _RandomAccessIter __result, _TypeT __value,
                          _Distance*)
  {
    *__result = *__first;
    __adjust_heap(__first, _Distance(0), _Distance(__last - __first),
                  __value);
  }

  template <class _RandomAccessIter, class _TypeT>
  inline void __pop_heap_aux (_RandomAccessIter __first,
                              _RandomAccessIter __last, _TypeT*)
  {
    __pop_heap(__first, __last-1, __last-1, _TypeT(*(__last-1)),
      __distance_type(__first));
  }

  template <class _RandomAccessIter>
  inline void pop_heap (_RandomAccessIter __first, _RandomAccessIter __last)
  {
    if (!(__first == __last))
      __pop_heap_aux(__first, __last, __value_type (__first));
  }

  template <class _RandomAccessIter, class _Distance, class _TypeT,
      class _Compare>
  void __adjust_heap (_RandomAccessIter __first, _Distance __holeIndex,
                      _Distance __len, _TypeT __value, _Compare __comp);

  template <class _RandomAccessIter, class _TypeT, class _Compare,
      class _Distance>
  inline void __pop_heap (_RandomAccessIter __first, _RandomAccessIter __last,
                          _RandomAccessIter __result, _TypeT __value,
                          _Compare __comp, _Distance*)
  {
    *__result = *__first;
    __adjust_heap(__first, _Distance(0), _Distance(__last - __first), __value,
      __comp);
  }

  template <class _RandomAccessIter, class _TypeT, class _Compare>
  inline void __pop_heap_aux (_RandomAccessIter __first,
                              _RandomAccessIter __last, _TypeT*,
                              _Compare __comp)
  {
    __pop_heap(__first, __last - 1, __last - 1, _TypeT(*(__last - 1)), __comp,
               __distance_type(__first));
  }

  template <class _RandomAccessIter, class _Compare>
  inline void pop_heap (_RandomAccessIter __first, _RandomAccessIter __last,
                        _Compare __comp)
  {
    if (!(__first == __last))
      __pop_heap_aux(__first, __last, __value_type (__first), __comp);
  }

  template <class _RandomAccessIter, class _TypeT, class _Distance>
  void __make_heap (_RandomAccessIter __first, _RandomAccessIter __last,
      _TypeT*, _Distance*);

  template <class _RandomAccessIter>
  inline void make_heap (_RandomAccessIter __first, _RandomAccessIter __last)
  {
    if (!(__last - __first < 2))
      __make_heap(__first, __last, __value_type (__first),
                  __distance_type(__first));
  }

  template <class _RandomAccessIter, class _Compare, class _TypeT,
      class _Distance>
  void __make_heap (_RandomAccessIter __first, _RandomAccessIter __last,
                    _Compare __comp, _TypeT*, _Distance*);

  template <class _RandomAccessIter, class _Compare>
  inline void make_heap (_RandomAccessIter __first, _RandomAccessIter __last,
                         _Compare __comp)
  {
    if (!(__last - __first < 2))
      __make_heap(__first, __last, __comp, __value_type (__first),
                  __distance_type(__first));
  }

  template <class _RandomAccessIter>
  void sort_heap (_RandomAccessIter __first, _RandomAccessIter __last);

  template <class _RandomAccessIter, class _Compare>
  void sort_heap (_RandomAccessIter __first, _RandomAccessIter __last,
                  _Compare __comp);






  template <class _TypeT>
  inline const _TypeT& min (const _TypeT& __a, const _TypeT& __b)
  {
    return __b < __a ? __b : __a;
  }


  template <class _TypeT, class _Compare>
  inline const _TypeT& min (const _TypeT& __a, const _TypeT& __b,
      _Compare __comp)
  {
    return __comp(__b, __a) ? __b : __a;
  }


  template <class _TypeT>
  inline const _TypeT& max (const _TypeT& __a, const _TypeT& __b)
  {
    return  __a < __b ? __b : __a;
  }


  template <class _TypeT, class _Compare>
  inline const _TypeT& max (const _TypeT& __a, const _TypeT& __b,
      _Compare __comp)
  {
    return __comp(__a, __b) ? __b : __a;
  }

  template <class _FwdIter>
  _FwdIter min_element (_FwdIter __first, _FwdIter __last);

  template <class _FwdIter, class _Compare>
  _FwdIter min_element (_FwdIter __first, _FwdIter __last,
                               _Compare __comp);

  template <class _FwdIter>
  _FwdIter max_element (_FwdIter __first, _FwdIter __last);

  template <class _FwdIter, class _Compare>
  _FwdIter max_element (_FwdIter __first, _FwdIter __last,
                               _Compare __comp);

  template <class _InputIter1, class _InputIter2>
  bool lexicographical_compare (_InputIter1 __first1, _InputIter1 __last1,
                                _InputIter2 __first2, _InputIter2 __last2);

  template <class _InputIter1, class _InputIter2, class _Compare>
  bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                               _InputIter2 __first2, _InputIter2 __last2,
                               _Compare __comp);





  template <class _BidirIter>
  bool next_permutation (_BidirIter __first,
                         _BidirIter __last);

  template <class _BidirIter, class _Compare>
  bool next_permutation (_BidirIter __first, _BidirIter __last,
                         _Compare __comp);

  template <class _BidirIter>
  bool prev_permutation (_BidirIter __first,
                         _BidirIter __last);

  template <class _BidirIter, class _Compare>
  bool prev_permutation (_BidirIter __first, _BidirIter __last,
                         _Compare __comp);







  template <class _OutputIter, class _TypeT>
  class raw_storage_iterator;





  template <class _InputIter, class _Function>
  inline _Function for_each (_InputIter __first, _InputIter __last,
      _Function __f)
  {
    for (;__first != __last; ++__first)
        __f(*__first);
    return __f;
  }

  template <class _InputIter, class _TypeT>
  inline _InputIter find (_InputIter __first, _InputIter __last,
      const _TypeT& __value)
  {
    for (; !(__first == __last); ++__first)
      if (*__first == __value) return __first;
    return __last;
  }

  template <class _InputIter, class _Predicate>
  inline _InputIter find_if (_InputIter __first, _InputIter __last,
      _Predicate __pred)
  {
    while (__first != __last && !__pred(*__first)) ++__first;
    return __first;
  }



  template <class _FwdIter1, class _FwdIter2, class _Distance>
  _FwdIter1 __find_end (_FwdIter1 __first1,
                               _FwdIter1 __last1,
                               _FwdIter2 __first2,
                               _FwdIter2 __last2,
                               _Distance*);

  template <class _FwdIter1, class _FwdIter2, 
  class _BinaryPredicate, class _Distance>
  _FwdIter1 __find_end (_FwdIter1 __first1,
                               _FwdIter1 __last1,
                               _FwdIter2 __first2,
                               _FwdIter2 __last2,
                               _BinaryPredicate __pred,
                               _Distance*);



  template <class _FwdIter1, class _FwdIter2>
  inline _FwdIter1 find_end (_FwdIter1 __first1,
                             _FwdIter1 __last1,
                             _FwdIter2 __first2,
                             _FwdIter2 __last2)
  {
    return __find_end(__first1,__last1,__first2,__last2,
                      __distance_type(__first1));
  }

  template <class _FwdIter1, class _FwdIter2, 
  class _BinaryPredicate>
  _FwdIter1 find_end (_FwdIter1 __first1,
                             _FwdIter1 __last1,
                             _FwdIter2 __first2,
                             _FwdIter2 __last2,
                             _BinaryPredicate __pred)
  {
    return __find_end(__first1,__last1,__first2,__last2,
                      __pred,__distance_type(__first1));
  }


  template <class _InputIter, class _TypeT>
  inline typename iterator_traits<_InputIter>::difference_type
  count (_InputIter __first, _InputIter __last, const _TypeT& __value)
  {
    typename iterator_traits<_InputIter>::difference_type __n = 0;
    for (; __first != __last; ++__first)
        if (*__first == __value)
            ++__n;
    return __n;
  }

  template <class _InputIter, class _Predicate>
  inline typename iterator_traits<_InputIter>::difference_type
  count_if (_InputIter __first, _InputIter __last, _Predicate __pred)
  {
    typename iterator_traits<_InputIter>::difference_type __n = 0;
    for (;__first != __last; ++__first)
      if (__pred(*__first))
          ++__n;
    return __n;
  }




  template <class _InputIter, class _TypeT, class _Size>
  inline void count (_InputIter __first, _InputIter __last,
                     const _TypeT& __value, _Size& __n)
  {
    for (;__first != __last;++__first) 
      if (*__first == __value)
          ++__n;
  }

  template <class _InputIter, class _Predicate, class _Size>
  inline void count_if (_InputIter __first, _InputIter __last,
                        _Predicate __pred, _Size& __n)
  {
    for (;__first != __last;++__first)
      if (__pred(*__first))
          ++__n;
  }


  template <class _InputIter1, class _InputIter2>
  pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,
                                                _InputIter1 __last1,
                                                _InputIter2 __first2)
  {
    while (__first1 != __last1 && *__first1 == *__first2) {
      ++__first1;
      ++__first2;
    }
    return pair<_InputIter1, _InputIter2> (__first1, __first2);
  }


  template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
  pair<_InputIter1, _InputIter2> mismatch (_InputIter1 __first1,
                                           _InputIter1 __last1,
                                           _InputIter2 __first2,
                                           _BinaryPredicate __binary_pred)
  {
    while (__first1 != __last1 && __binary_pred(*__first1, *__first2)) {
      ++__first1;
      ++__first2;
    }
    return pair<_InputIter1, _InputIter2> (__first1, __first2);
  }




  
  template <class _InputIter, class _OutputIter>
  inline _OutputIter copy (_InputIter __first, _InputIter __last,
                              _OutputIter __result)
  {
    for (; __first != __last; ++__first,++__result)
        *__result = *__first;
    return __result;
  }

  template <class _BidirIter1, class _BidirIter2>
  inline _BidirIter2 copy_backward (_BidirIter1 __first, 
                                        _BidirIter1 __last, 
                                        _BidirIter2 __result)
  {
      while (__first != __last)
          *--__result = *--__last;
      return __result;
  }

  template <class _FwdIter1, class _FwdIter2>
  inline _FwdIter2 swap_ranges (_FwdIter1 __first1,
                                       _FwdIter1 __last1,
                                       _FwdIter2 __first2)
  {
      for (;__first1 != __last1; ++__first1, ++__first2)
          std::iter_swap(__first1, __first2);
      return __first2;
  }


  template <class _InputIter, class _OutputIter, class _UnaryOperation>
  inline _OutputIter transform (_InputIter __first, _InputIter __last,     
                                   _OutputIter __result,
                                   _UnaryOperation __unary_op)
  {
    for (;__first != __last;++__result,++__first)
        *__result = __unary_op(*__first);
    return __result;
  }

  template <class _InputIter1, class _InputIter2,
            class _OutputIter, class _BinaryOperation>
  inline _OutputIter transform (_InputIter1 __first1, _InputIter1 __last1,
                                   _InputIter2 __first2, _OutputIter __result,
                                   _BinaryOperation __binary_op)
  {
      for (;__first1 != __last1;++__result,++__first1,++__first2)
          *__result = __binary_op(*__first1, *__first2);
      return __result;
  }

  template <class _FwdIter, class _TypeT>
  inline void replace (_FwdIter __first, _FwdIter __last,
                       const _TypeT& __old_value, const _TypeT& __new_value)
  {
      for (;__first != __last;++__first) 
          if (*__first == __old_value)
              *__first = __new_value;
  }

  template <class _FwdIter, class _Predicate, class _TypeT>
  inline void replace_if (_FwdIter __first, _FwdIter __last,
                          _Predicate __pred, const _TypeT& __new_value)
  {
      for (;__first != __last;++__first)
          if (__pred(*__first))
              *__first = __new_value;
  }


  template <class _InputIter, class _OutputIter, class _TypeT>
  inline _OutputIter replace_copy (_InputIter __first, _InputIter __last,
                               _OutputIter __result,
                               const _TypeT& __old_value,
                               const _TypeT& __new_value)
  {
      for (;__first != __last;++__first,++__result)
          *__result = *__first == __old_value ? __new_value : *__first;
      return __result;
  }

  template <class _FwdIter, class _TypeT>




  inline void fill (_FwdIter __first, _FwdIter __last, const _TypeT& __value)

  {
      for (;__first != __last; ++__first)
          *__first = __value;
  }

  template <class _OutputIter, class _Size, class _TypeT>
  inline void fill_n (_OutputIter __first, _Size __n, const _TypeT& __value)
  {
      for (;__n > 0;--__n, ++__first)
          *__first = __value;
  }

  template <class _FwdIter, class _Generator>
  inline void generate (_FwdIter __first, _FwdIter __last, _Generator __gen)
  {
      for (;__first != __last;++__first)
          *__first = __gen();
  }

  template <class _OutputIter, class _Size, class _Generator>
  inline void generate_n (_OutputIter __first, _Size __n, _Generator __gen)
  {
      for (;__n > 0;--__n, ++__first)
          *__first = __gen();
  }

  template <class _BidirIter>
  inline void __reverse (_BidirIter __first, _BidirIter __last, 
                  bidirectional_iterator_tag)
  {
      for(; __first != __last && __first != --__last; ++__first)
          std::iter_swap(__first, __last);
  }

  template <class _RandomAccessIter>
  inline void __reverse (_RandomAccessIter __first, _RandomAccessIter __last,
                  random_access_iterator_tag)
  {
      for (; __first < __last; ++__first)
          std::iter_swap(__first, --__last);
  }

  template <class _BidirIter, class _OutputIter>
  inline _OutputIter reverse_copy (_BidirIter __first,
                               _BidirIter __last,
                               _OutputIter __result)
  {
      for (;__first != __last; ++__result)
          *__result = *--__last;
      return __result;
  }


  template <class _RandomAccessIter>
  inline void sort_heap (_RandomAccessIter __first, _RandomAccessIter __last)
  {
    while (__last - __first > 1)
        std::pop_heap(__first, __last--);
  }

  template <class _RandomAccessIter, class _Compare>
  inline void sort_heap (_RandomAccessIter __first, _RandomAccessIter __last,
                  _Compare _RWSTD_COMP)
  {
    while (__last - __first > 1)
        std::pop_heap(__first, __last--, _RWSTD_COMP);
  }

}   


#line 1 "/opt/aCC/include_std/algorithm.cc"










































 

#line 1 "/opt/aCC/include_std/rw/random.h"












































 









namespace __rw {


using std::size_t;


template <unsigned _SIZE>
class  __rw_random_generator
{
    enum { _C_SIZE = _SIZE };

    unsigned long _C_table [_C_SIZE];
    size_t        _C_index1;
    size_t        _C_index2;

public:

    __rw_random_generator (unsigned long __seed = 161803398) {
        seed (__seed);
    }

    void seed (unsigned long __seed);

    unsigned long operator() (unsigned long __limit);

    static unsigned long generate (unsigned long __limit);
};


template <unsigned _SIZE>
inline unsigned long
__rw_random_generator<_SIZE>::operator() (unsigned long __limit)
{
    ((void)0);

    _C_table [++_C_index1 %= _C_SIZE] -= _C_table [++_C_index2 %= _C_SIZE];

    return _C_table [_C_index1] % __limit;
}


template <unsigned _SIZE>
inline unsigned long
__rw_random_generator<_SIZE>::generate (unsigned long __limit)
{
    static __rw::__rw_mutex __guard; __rw::__rw_guard __rw_mt_temp_guard (__guard);

    static __rw_random_generator __gen;

    return __gen (__limit);
}


template <class _Distance>
inline _Distance __rw_random (_Distance __limit)
{
    return __rw_random_generator<55>::generate (__limit);
}


}   


#line 1 "/opt/aCC/include_std/rw/random.cc"











































 





namespace __rw {


template <unsigned _SIZE>
void __rw_random_generator<_SIZE>::seed (unsigned long __seed)
{
    unsigned long __k = 1;

    _C_table [_C_SIZE - 1] = __seed;

    size_t __i;

    for (__i = 0; __i != _C_SIZE - 1; ++__i) {
        size_t __ii = 21 * __i % _C_SIZE;
        _C_table [__ii] = __k;
        __k = __seed - __k;
        __seed = _C_table [__ii];
    }

    for (__i = 0; __i != 4; ++__i) {
        for (size_t __ii = 0; __ii != _C_SIZE; ++__ii)
            _C_table [__i] =
                _C_table [__i] - _C_table [(__i + 31) % _C_SIZE];
    }

    _C_index1 = 0;
    _C_index2 = _C_SIZE * 2 / 3 - 1;
}


}   
#line 120 "/opt/aCC/include_std/rw/random.h"



#line 47 "/opt/aCC/include_std/algorithm.cc"


namespace std {


template <class _FwdIter1, class _FwdIter2, class _Distance>
_FwdIter1 __find_end (_FwdIter1 __first1, _FwdIter1 __last1,
                      _FwdIter2 __first2, _FwdIter2 __last2,
                      _Distance*)
{
    ((void)0);
    ((void)0);

    _Distance __dist1 = std::distance (__first2, __last2);

    if (!__dist1)
        return __last1;

    _Distance __dist2 = std::distance (__first1, __last1);

    _FwdIter1 __result = __last1;

    while (__dist2 >= __dist1) {
        if (equal (__first2, __last2, __first1))
            __result  = __first1;

        __dist2 = std::distance (++__first1, __last1);
    }
    return __result;
}



template <class _FwdIter1, class _FwdIter2,
    class _BinaryPredicate, class _Distance>
_FwdIter1 __find_end (_FwdIter1 __first1, _FwdIter1 __last1,
                      _FwdIter2 __first2, _FwdIter2 __last2,
                      _BinaryPredicate __pred, _Distance*)
{
    ((void)0);
    ((void)0);

    _Distance __dist1 = std::distance (__first2, __last2);

    if (!__dist1)
        return __last1;

    _Distance __dist2 = std::distance (__first1, __last1);

    _FwdIter1 __save = __last1;

    while (__dist2 >= __dist1)
    {
        if (std::equal (__first2, __last2, __first1, __pred))
            __save = __first1;
        __dist2 = std::distance (++__first1, __last1);
    }
    return __save;
}


template <class _FwdIter1, class _FwdIter2>
_FwdIter1 find_first_of (_FwdIter1 __first1, _FwdIter1 __last1,
                         _FwdIter2 __first2, _FwdIter2 __last2)
{
    ((void)0);
    ((void)0);

    if (__first2 == __last2)
        return __last1;
    _FwdIter1 __next = __first1;
    while (__next != __last1)
    {
        if (std::find (__first2, __last2, *__next) != __last2)
            return __next;
        ++__next;
    }
    return __last1;
}


template <class _FwdIter1, class _FwdIter2,
    class _BinaryPredicate>
_FwdIter1 find_first_of (_FwdIter1 __first1, _FwdIter1 __last1,
                         _FwdIter2 __first2, _FwdIter2 __last2,
                         _BinaryPredicate __pred)
{
    ((void)0);
    ((void)0);

    if (__first2 == __last2)
        return __last1;

    for (_FwdIter1 __next = __first1; __next != __last1; ++__next)
        for (_FwdIter2 __iter = __first2; __iter != __last2; ++__iter)
            if (__pred (*__next, *__iter))
                return __next;
    return __last1;
}


template <class _FwdIter>
_FwdIter adjacent_find (_FwdIter __first, _FwdIter __last)
{
    ((void)0);

    if (__first == __last) return __last;
    _FwdIter __next = __first;
    while (++__next != __last)
    {
        if (*__first == *__next) return __first;
        __first = __next;
    }
    return __last;
}


template <class _FwdIter, class _BinaryPredicate>
_FwdIter adjacent_find (_FwdIter __first, _FwdIter __last,
                        _BinaryPredicate __pred)
{
    ((void)0);

    if (__first == __last) return __last;
    _FwdIter __next = __first;
    while (++__next != __last) {
        if (__pred (*__first, *__next))
            return __first;
        __first = __next;
    }
    return __last;
}



template <class _FwdIter1, class _FwdIter2,
    class _Distance1, class _Distance2>
_FwdIter1 __search (_FwdIter1 __first1, _FwdIter1 __last1,
                    _FwdIter2 __first2, _FwdIter2 __last2,
                    _Distance1*, _Distance2*)
{
    ((void)0);
    ((void)0);

    _Distance1 __dist1 = std::distance (__first1, __last1);
    _Distance2 __dist2 = std::distance (__first2, __last2);

    if (__dist1 < __dist2) return __last1;

    _FwdIter1 __cur1 = __first1;
    _FwdIter2 __cur2 = __first2;

    while (__cur2 != __last2) {
        if (!(*__cur1 == *__cur2)) {
            ++__cur1;
            ++__cur2;
            if (__dist1-- == __dist2)
                return __last1;
            else {
                __cur1 = ++__first1;
                __cur2 = __first2;
            }
        }
        else {
            ++__cur1;
            ++__cur2;
        }
    }

    return (__cur2 == __last2) ? __first1 : __last1;
}

template <class _FwdIter1, class _FwdIter2,
    class _BinaryPredicate, class _Distance1, class _Distance2>
_FwdIter1 __search (_FwdIter1 __first1, _FwdIter1 __last1,
                    _FwdIter2 __first2, _FwdIter2 __last2,
                    _BinaryPredicate __pred, _Distance1*, _Distance2*)
{
    ((void)0);
    ((void)0);

    _Distance1 __dist1 = std::distance (__first1, __last1);
    _Distance2 __dist2 = std::distance (__first2, __last2);

    if (__dist1 < __dist2) return __last1;

    _FwdIter1 __cur1 = __first1;
    _FwdIter2 __cur2 = __first2;

    while (__cur2 != __last2) {
        if (!__pred (*__cur1, *__cur2)) {
            ++__cur1;
            ++__cur2;
            if (__dist1-- == __dist2)
                return __last1;
            else {
                __cur1 = ++__first1;
                __cur2 = __first2;
            }
        }
        else {
            ++__cur1;
            ++__cur2;
        }
    }

    return (__cur2 == __last2) ? __first1 : __last1;
}

template <class _FwdIter, class _Distance, class _Size, class _TypeT>
_FwdIter __search_n (_FwdIter __first, _FwdIter __last,
                     _Distance*, _Size __count, const _TypeT& __val)
{
    ((void)0);

    _Distance __dist = std::distance (__first, __last);

    if (__dist < __count || __count <= 0) return __last;

    _Distance        __span    = __dist - __count;
    _Size            __matches = 0;
    _FwdIter         __current = __first;

    while (__current != __last) {
        if (!(*__current == __val)) {
            if (__span < __matches + 1)
                return __last;
            __span   -= __matches + 1;
            __matches = 0;
            __first   = ++__current;
        }
        else {
            if (++__matches == __count)
                return __first;
            ++__current;
        }
    }

    return __last;
}

template <class _FwdIter, class _Distance, class _Size, class _TypeT,
    class _BinaryPredicate>
_FwdIter __search_n (_FwdIter __first, _FwdIter __last,
                     _Distance*, _Size __count, const _TypeT& __val,
                     _BinaryPredicate __pred)
{
    ((void)0);

    _Distance __dist = std::distance (__first, __last);

    if (__dist < __count || __count <= 0) return __last;

    _Distance        __span    = __dist - __count;
    _Size            __matches = 0;
    _FwdIter __current = __first;

    while (__current != __last) {
        if (!__pred (*__current, __val)) {
            if (__span < __matches + 1)
                return __last;
            __span   -= __matches + 1;
            __matches = 0;
            __first   = ++__current;
        }
        else {
            if (++__matches == __count)
                return __first;
            ++__current;
        }
    }

    return __last;
}





template <class _Iter, class _OutputIter, class _Predicate, class _TypeT>
_OutputIter replace_copy_if (_Iter __first, _Iter __last,
                             _OutputIter __result, _Predicate __pred,
                             const _TypeT& __new_value)
{
    ((void)0);

    for (; __first != __last; ++__result, ++__first)
        if (__pred (*__first))
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}

template <class _InputIter, class _OutputIter, class _TypeT>
_OutputIter remove_copy (_InputIter __first, _InputIter __last,
                         _OutputIter __result, const _TypeT& __val)
{
    ((void)0);

    for (; __first != __last; ++__first)
        if (!(*__first == __val)) {
            *__result = *__first;
            ++__result;
        }
    return __result;
}

template <class _InputIter, class _OutputIter, class _Predicate>
_OutputIter remove_copy_if (_InputIter __first, _InputIter __last,
                            _OutputIter __result, _Predicate __pred)
{
    ((void)0);

    for (; __first != __last; ++__first)
        if (!__pred (*__first)) {
            *__result = *__first;
            ++__result;
        }
    return __result;
}

template <class _InputIter, class _FwdIter>
_FwdIter __unique_copy (_InputIter __first, _InputIter __last,
                        _FwdIter __result, forward_iterator_tag)
{
    ((void)0);

    *__result = *__first;
    while (++__first != __last)
        if (!(*__result == *__first))
            *++__result = *__first;
    return ++__result;
}

template <class _InputIter, class _OutputIter, class _TypeT>
_OutputIter __unique_copy (_InputIter __first, _InputIter __last,
                           _OutputIter __result, _TypeT*)
{
    ((void)0);

    _TypeT __val = *__first;
    *__result = __val;
    while (++__first != __last)    {
        if (!(__val == *__first)) {
            __val = *__first;
            *++__result = __val;
        }
    }
    return ++__result;
}

template <class _InputIter, class _FwdIter, class _BinaryPredicate>
_FwdIter __unique_copy (_InputIter __first, _InputIter __last,
                        _FwdIter __result,
                        _BinaryPredicate __pred,
                        forward_iterator_tag)
{
    ((void)0);

    *__result = *__first;
    while (++__first != __last)
        if (!__pred (*__result, *__first)) *++__result = *__first;
    return ++__result;
}


template <class _InputIter, class _OutputIter, class _BinaryPredicate,
    class _TypeT>
_OutputIter __unique_copy (_InputIter __first, _InputIter __last,
                           _OutputIter __result,
                           _BinaryPredicate __pred, _TypeT*)
{
    ((void)0);

    _TypeT __val = *__first;
    *__result = __val;
    while (++__first != __last)  {
        if (!__pred (__val, *__first))   {
            __val = *__first;
            *++__result = __val;
        }
    }
    return ++__result;
}


template <class _FwdIter, class _Distance>
void __rotate (_FwdIter __first, _FwdIter __middle,
               _FwdIter __last, _Distance*, forward_iterator_tag)
{
    ((void)0); 

    _FwdIter __i = __middle;
    for (; ; )
    {
        std::iter_swap (__first, __i);
        ++__first; ++__i;
        if (__first == __middle)
        {
            if (__i == __last) return;
            __middle = __i;
        }
        else if (__i == __last)
            __i = __middle;
    }
}

template <class _EuclideanRingElement>
_EuclideanRingElement __gcd (_EuclideanRingElement __m,
                            _EuclideanRingElement __n)
{
    while (__n != 0)
    {
        _EuclideanRingElement __r = __m % __n;
        __m = __n;
        __n = __r;
    }
    return __m;
}

template <class _RandomAccessIter, class _Distance, class _TypeT>
void __rotate_cycle (_RandomAccessIter __first, _RandomAccessIter __last,
                     _RandomAccessIter __initial, _Distance __shift, _TypeT*)
{
    ((void)0);

    _TypeT __val = *__initial;
    _RandomAccessIter __ptr1 = __initial;
    _RandomAccessIter __ptr2 = __ptr1 + __shift;
    while (__ptr2 != __initial)
    {
        *__ptr1 = *__ptr2;
        __ptr1 = __ptr2;
        if (__last - __ptr2 > __shift)
            __ptr2 += __shift;
        else
            __ptr2 = __first + (__shift - (__last - __ptr2));
    }
    *__ptr1 = __val;
}

template <class _RandomAccessIter, class _Distance>
void __rotate (_RandomAccessIter __first, _RandomAccessIter __middle,
               _RandomAccessIter __last, _Distance*,
               random_access_iterator_tag)
{
    ((void)0);
  
    _Distance __n = __gcd (__last - __first, __middle - __first);
    while (__n--)
        __rotate_cycle (__first, __last, __first + __n, __middle - __first,
                       __value_type (__first));
}

template <class _RandomAccessIter, class _Distance>
void __random_shuffle (_RandomAccessIter __first, _RandomAccessIter __last,
		       _Distance*)
{
    ((void)0);

    if (__first != __last)
	for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
	    std::iter_swap (__i,
		       __first + __rw::__rw_random (__i - __first + 1));
}

template <class _RandomAccessIter, class _RandomNumberGenerator>
void random_shuffle (_RandomAccessIter __first, _RandomAccessIter __last,
                     _RandomNumberGenerator& __rand)
{
    ((void)0);

    if (! (__first == __last))
        for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
            std::iter_swap (__i, __first + __rand ((__i - __first) + 1));
}

template <class _BidirIter, class _Predicate>
_BidirIter partition (_BidirIter __first, _BidirIter __last,
                      _Predicate __pred)
{
    ((void)0);

    while (true)
    {
        while (true)
        {
            if (__first == __last)
                return __first;
            else if (__pred (*__first))
                ++__first;
            else
                break;
        }
        --__last;
        while (true)
        {
            if (__first == __last)
                return __first;
            else if (!__pred (*__last))
                --__last;
            else
                break;
        }
        std::iter_swap (__first, __last);
        ++__first;
    }
}

template <class _BidirIter, class _Predicate, class _Distance>
_BidirIter __inplace_stable_partition (_BidirIter __first, _BidirIter __last,
                                       _Predicate __pred, _Distance __dist)
{
    ((void)0);

    if (__dist == 1) return __pred (*__first) ? __last : __first;
    _BidirIter __middle = __first;
    std::advance (__middle, __dist / 2);
    _BidirIter
        __first_cut = __inplace_stable_partition (__first, __middle, __pred,
                                                  __dist / 2);
    _BidirIter
        __second_cut = __inplace_stable_partition (__middle, __last, __pred,
                                                 __dist - __dist / 2);
    std::rotate (__first_cut, __middle, __second_cut);
    __dist = std::distance (__middle, __second_cut);
    std::advance (__first_cut, __dist);
    return __first_cut;
}

template <class _BidirIter, class _Pointer, class _Predicate,
    class _Distance, class _TypeT>
_BidirIter __stable_partition_adaptive (_BidirIter __first, _BidirIter __last,
                                        _Predicate __pred, _Distance __dist,
                                        _Pointer __buf,
                                        _Distance __buf_size,
                                        _Distance& __fill_pointer, _TypeT*)
{
    ((void)0);

    if (__dist <= __buf_size)
    {
        __dist = 0;
        _BidirIter __result1 = __first;
        _Pointer __result2 = __buf;
        for (; __first != __last && __dist < __fill_pointer; ++__first)
        {
            if (__pred (*__first)) {
                *__result1 = *__first;
                ++__result1;
            }
            else {
                *__result2 = *__first;
                ++__result2;
                ++__dist;
            }
        }
        if (__first != __last)
        {
            raw_storage_iterator<_Pointer, _TypeT> __result3 (__result2);
            for (; __first != __last; ++__first)
            {
                if (__pred (*__first)) {
                    *__result1 = *__first;
                    ++__result1;
                }
                else {
                    *__result3 = *__first;
                    ++__result3;
                    ++__dist;
                }
            }
            __fill_pointer = __dist;
        }
        std::copy (__buf, __buf + __dist, __result1);
        return __result1;
    }
    _BidirIter __middle = __first;
    std::advance (__middle, __dist / 2);

    
    
    _BidirIter __first_cut =
        __stable_partition_adaptive (__first, __middle, __pred,
                                     _Distance (__dist / 2),
                                     __buf, __buf_size,
                                     __fill_pointer, (_TypeT*)0);
    _BidirIter __second_cut =
        __stable_partition_adaptive (__middle, __last, __pred,
                                     _Distance (__dist - __dist / 2),
                                     __buf, __buf_size,
                                     __fill_pointer, (_TypeT*)0);

    std::rotate (__first_cut, __middle, __second_cut);
    __dist = std::distance (__middle, __second_cut);
    std::advance (__first_cut, __dist);
    return __first_cut;
}

template <class _BidirIter, class _Predicate, class _Pointer,
    class _Distance>
_BidirIter __stable_partition (_BidirIter __first, _BidirIter __last,
                               _Predicate __pred, _Distance __dist,
                               pair<_Pointer, _Distance> __pair)
{
    ((void)0);

    if (__pair.first == 0)
        return __inplace_stable_partition (__first, __last, __pred, __dist);
    _Distance __fill_pointer = 0;
    _BidirIter __result =
        __stable_partition_adaptive (__first, __last, __pred, __dist,
                                     __pair.first, __pair.second,
                                     __fill_pointer,
                                     __value_type (__first));
    __rw::__rw_destroy (__pair.first, __pair.first + __fill_pointer);
    std::return_temporary_buffer (__pair.first);
    return __result;
}





template <class _RandomAccessIter, class _TypeT>
_RandomAccessIter __unguarded_partition (_RandomAccessIter __first,
                                         _RandomAccessIter __last,
                                         _TypeT __pivot)
{
    ((void)0);

    while (true)
    {
        while (*__first < __pivot) ++__first;
        --__last;
        while (__pivot < *__last) --__last;
        if (! (__first < __last)) return __first;
        std::iter_swap (__first, __last);
        ++__first;
    }
}

template <class _RandomAccessIter, class _TypeT, class _Compare>
_RandomAccessIter __unguarded_partition (_RandomAccessIter __first,
                                         _RandomAccessIter __last,
                                         _TypeT __pivot, _Compare _RWSTD_COMP)
{
    ((void)0);

    while (true)
    {
        while (_RWSTD_COMP (*__first, __pivot)) ++__first;
        --__last;
        while (_RWSTD_COMP (__pivot, *__last)) --__last;
        if (! (__first < __last)) return __first;
        std::iter_swap (__first, __last);
        ++__first;
    }
}

const int __stl_threshold = 16;

template <class _RandomAccessIter, class _TypeT>
void __quick_sort_loop_aux (_RandomAccessIter __first,
                            _RandomAccessIter __last, _TypeT*)
{
    ((void)0);

    while (__last - __first > __stl_threshold)
    {
        _RandomAccessIter __cut =
            __unguarded_partition (__first, __last,
                                   _TypeT (__median (*__first,
                                                     * (__first +
                                                        (__last - __first)/2),
                                                     * (__last - 1))));
        if (__cut - __first >= __last - __cut)
        {
            __quick_sort_loop (__cut, __last);
            __last = __cut;
        }
        else
        {
            __quick_sort_loop (__first, __cut);
            __first = __cut;
        }
    }
}

template <class _RandomAccessIter, class _TypeT, class _Compare>
void __quick_sort_loop_aux (_RandomAccessIter __first,
                            _RandomAccessIter __last, _TypeT*,
                            _Compare _RWSTD_COMP)
{
    ((void)0);

    while (__last - __first > __stl_threshold)
    {
        _RandomAccessIter __cut =
            __unguarded_partition (__first, __last,
                                   _TypeT (__median (*__first,
                                                     * (__first +
                                                        (__last - __first)/2),
                                                     * (__last - 1),
                                                     _RWSTD_COMP)),
             _RWSTD_COMP);
        if (__cut - __first >= __last - __cut)
        {
            __quick_sort_loop (__cut, __last, _RWSTD_COMP);
            __last = __cut;
        }
        else
        {
            __quick_sort_loop (__first, __cut, _RWSTD_COMP);
            __first = __cut;
        }
    }
}



template <class _RandomAccessIter, class _TypeT>
void __unguarded_linear_insert (_RandomAccessIter __last, _TypeT __val)
{
    _RandomAccessIter __next = __last;
    --__next;
    while (__val < *__next)
    {
        *__last = *__next;
        __last = __next--;
    }
    *__last = __val;
}

template <class _RandomAccessIter, class _TypeT, class _Compare>
void __unguarded_linear_insert (_RandomAccessIter __last, _TypeT __val,
                                _Compare _RWSTD_COMP)
{
    _RandomAccessIter __next = __last;
    --__next;
    while (_RWSTD_COMP (__val , *__next))
    {
        *__last = *__next;
        __last = __next--;
    }
    *__last = __val;
}

template <class _RandomAccessIter>
void __insertion_sort (_RandomAccessIter __first, _RandomAccessIter __last)
{
    ((void)0);

    if (! (__first == __last))
        for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
            __linear_insert (__first, __i, __value_type (__first));
}

template <class _RandomAccessIter, class _Compare>
void __insertion_sort (_RandomAccessIter __first,
                       _RandomAccessIter __last, _Compare _RWSTD_COMP)
{
    ((void)0);

    if (! (__first == __last))
        for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
            __linear_insert (__first, __i, __value_type (__first),
                             _RWSTD_COMP);
}

template <class _RandomAccessIter, class _TypeT>
void __unguarded_insertion_sort_aux (_RandomAccessIter __first,
                                     _RandomAccessIter __last, _TypeT*)
{
    ((void)0);

    for (_RandomAccessIter __i = __first; __i != __last; ++__i)
        __unguarded_linear_insert (__i, _TypeT (*__i));
}

template <class _RandomAccessIter, class _TypeT, class _Compare>
void __unguarded_insertion_sort_aux (_RandomAccessIter __first,
                                     _RandomAccessIter __last,
                                     _TypeT*, _Compare _RWSTD_COMP)
{
    ((void)0);

    for (_RandomAccessIter __i = __first; __i != __last; ++__i)
        __unguarded_linear_insert (__i, _TypeT (*__i), _RWSTD_COMP);
}


template <class _RandomAccessIter>
void __final_insertion_sort (_RandomAccessIter __first,
                             _RandomAccessIter __last)
{
    ((void)0);

    if (__last - __first > __stl_threshold)
    {
        __insertion_sort (__first, __first + __stl_threshold);
        __unguarded_insertion_sort (__first + __stl_threshold, __last);
    }
    else
        __insertion_sort (__first, __last);
}

template <class _RandomAccessIter, class _Compare>
void __final_insertion_sort (_RandomAccessIter __first,
                             _RandomAccessIter __last, _Compare _RWSTD_COMP)
{
    ((void)0);

    if (__last - __first > __stl_threshold)
    {
        __insertion_sort (__first, __first + __stl_threshold, _RWSTD_COMP);
        __unguarded_insertion_sort (__first + __stl_threshold, __last,
                                    _RWSTD_COMP);
    }
    else
        __insertion_sort (__first, __last, _RWSTD_COMP);
}

template <class _RandomAccessIter1, class _RandomAccessIter2,
    class _Distance>
void __merge_sort_loop (_RandomAccessIter1 __first,
                        _RandomAccessIter1 __last,
                        _RandomAccessIter2 __result, _Distance __step)
{
    ((void)0);

    _Distance __two_step = 2 * __step;

    while (__last - __first >= __two_step)
    {
        __result = std::merge (__first, __first + __step,
                       __first + __step, __first + __two_step, __result);
        __first += __two_step;
    }
    __step = std::min (_Distance (__last - __first), __step);

    std::merge (__first, __first + __step, __first + __step, __last,
           __result);
}

template <class _RandomAccessIter1, class _RandomAccessIter2,
    class _Distance, class _Compare>
void __merge_sort_loop (_RandomAccessIter1 __first,
                        _RandomAccessIter1 __last,
                        _RandomAccessIter2 __result, _Distance __step,
                        _Compare _RWSTD_COMP)
{
    ((void)0);

    _Distance __two_step = 2 * __step;

    while (__last - __first >= __two_step)
    {
        __result = std::merge (__first, __first + __step,
                       __first + __step, __first + __two_step, __result,
                        _RWSTD_COMP);
        __first += __two_step;
    }
    __step = std::min (_Distance (__last - __first), __step);

    std::merge (__first, __first + __step, __first + __step, __last,
           __result, _RWSTD_COMP);
}

const int __stl_chunk_size = 7;

template <class _RandomAccessIter, class _Distance>
void __chunk_insertion_sort (_RandomAccessIter __first,
                             _RandomAccessIter __last, _Distance __chunk_size)
{
    ((void)0);

    while (__last - __first >= __chunk_size)
    {
        __insertion_sort (__first, __first + __chunk_size);
        __first += __chunk_size;
    }
    __insertion_sort (__first, __last);
}

template <class _RandomAccessIter, class _Distance, class _Compare>
void __chunk_insertion_sort (_RandomAccessIter __first,
                             _RandomAccessIter __last,
                             _Distance __chunk_size, _Compare _RWSTD_COMP)
{
    ((void)0);

    while (__last - __first >= __chunk_size)
    {
        __insertion_sort (__first, __first + __chunk_size, _RWSTD_COMP);
        __first += __chunk_size;
    }
    __insertion_sort (__first, __last, _RWSTD_COMP);
}

template <class _RandomAccessIter, class _Pointer, class _Distance,
    class _TypeT>
void __merge_sort_with_buffer (_RandomAccessIter __first,
                               _RandomAccessIter __last,
                               _Pointer __buf, _Distance*, _TypeT*)
{
    ((void)0);

    _Distance __dist = __last - __first;
    _Pointer __buf_last = __buf + __dist;

    _Distance __step = __stl_chunk_size;
    __chunk_insertion_sort (__first, __last, __step);

    while (__step < __dist)
    {
        __merge_sort_loop (__first, __last, __buf, __step);
        __step *= 2;
        __merge_sort_loop (__buf, __buf_last, __first, __step);
        __step *= 2;
    }
}

template <class _RandomAccessIter, class _Pointer, class _Distance,
    class _TypeT, class _Compare>
void __merge_sort_with_buffer (_RandomAccessIter __first,
                               _RandomAccessIter __last, _Pointer __buf,
                               _Distance*, _TypeT*, _Compare _RWSTD_COMP)
{
    ((void)0);

    _Distance __dist = __last - __first;
    _Pointer __buf_last = __buf + __dist;

    _Distance __step = __stl_chunk_size;
    __chunk_insertion_sort (__first, __last, __step, _RWSTD_COMP);

    while (__step < __dist)
    {
        __merge_sort_loop (__first, __last, __buf, __step, _RWSTD_COMP);
        __step *= 2;
        __merge_sort_loop (__buf, __buf_last, __first, __step,
                           _RWSTD_COMP);
        __step *= 2;
    }
}

template <class _RandomAccessIter, class _Pointer, class _Distance,
    class _TypeT>
void __stable_sort_adaptive (_RandomAccessIter __first,
                             _RandomAccessIter __last, _Pointer __buf,
                             _Distance __buf_size, _TypeT*)
{
    ((void)0);

    _Distance __dist = (__last - __first + 1) / 2;
    _RandomAccessIter __middle = __first + __dist;
    if (__dist > __buf_size)
    {
        __stable_sort_adaptive (__first, __middle, __buf, __buf_size,
                               (_TypeT*)0);
        __stable_sort_adaptive (__middle, __last, __buf, __buf_size,
                                (_TypeT*)0);
    }
    else
    {
        __merge_sort_with_buffer (__first, __middle, __buf,
                                 (_Distance*)0, (_TypeT*)0);
        __merge_sort_with_buffer (__middle, __last, __buf,
                                 (_Distance*)0,(_TypeT*)0);
    }
    __merge_adaptive (__first, __middle, __last,
                      _Distance (__middle - __first),
                      _Distance (__last - __middle), __buf, __buf_size,
                      (_TypeT*)0);
}

template <class _RandomAccessIter, class _Pointer, class _Distance,
    class _TypeT, class _Compare>
void __stable_sort_adaptive (_RandomAccessIter __first,
                             _RandomAccessIter __last, _Pointer __buf,
                             _Distance __buf_size, _TypeT*,
                             _Compare _RWSTD_COMP)
{
    ((void)0);

    _Distance __dist = (__last - __first + 1) / 2;
    _RandomAccessIter __middle = __first + __dist;
    if (__dist > __buf_size)
    {
        __stable_sort_adaptive (__first, __middle, __buf, __buf_size,
                                (_TypeT*)0, _RWSTD_COMP);
        __stable_sort_adaptive (__middle, __last, __buf, __buf_size,
                                (_TypeT*)0, _RWSTD_COMP);
    }
    else
    {
        __merge_sort_with_buffer (__first, __middle, __buf,
                                 (_Distance*)0, (_TypeT*)0, _RWSTD_COMP);
        __merge_sort_with_buffer (__middle, __last, __buf,
                                 (_Distance*)0, (_TypeT*)0, _RWSTD_COMP);
    }
    __merge_adaptive (__first, __middle, __last,
                      _Distance (__middle - __first),
                     _Distance (__last - __middle), __buf, __buf_size,
                      (_TypeT*)0, _RWSTD_COMP);
}

template <class _RandomAccessIter, class _TypeT>
void __partial_sort (_RandomAccessIter __first, _RandomAccessIter __middle,
                     _RandomAccessIter __last, _TypeT*)
{
    ((void)0);
    
    std::make_heap (__first, __middle);
    for (_RandomAccessIter __i = __middle; __i < __last; ++__i)
        if (*__i < *__first)
            __pop_heap (__first, __middle, __i, _TypeT (*__i),
                        __distance_type (__first));
    std::sort_heap (__first, __middle);
}

template <class _RandomAccessIter, class _TypeT, class _Compare>
void __partial_sort (_RandomAccessIter __first, _RandomAccessIter __middle,
                     _RandomAccessIter __last, _TypeT*, _Compare _RWSTD_COMP)
{
    ((void)0);

    std::make_heap (__first, __middle, _RWSTD_COMP);
    for (_RandomAccessIter __i = __middle; __i < __last; ++__i)
        if (_RWSTD_COMP (*__i, *__first))
            __pop_heap (__first, __middle, __i, _TypeT (*__i), _RWSTD_COMP,
                        __distance_type (__first));
    std::sort_heap (__first, __middle, _RWSTD_COMP);
}

template <class _InputIter, class _RandomAccessIter, class _Distance,
    class _TypeT>
_RandomAccessIter __partial_sort_copy (_InputIter __first,
                                       _InputIter __last,
                                       _RandomAccessIter __first2,
                                       _RandomAccessIter __last2,
                                       _Distance*, _TypeT*)
{
    ((void)0);
    ((void)0);

    if (__first2 == __last2) return __last2;
    _RandomAccessIter __result = __first2;
    for (; __first != __last && __result != __last2;
         ++__first, ++__result )
        *__result = *__first;
    std::make_heap (__first2, __result);
    for (; __first != __last; ++__first) {
        if (*__first < *__first2)
            __adjust_heap (__first2, _Distance (),
                          _Distance (__result - __first2),
                          _TypeT (*__first));
    }
    std::sort_heap (__first2, __result);
    return __result;
}

template <class _InputIter, class _RandomAccessIter, class _Compare,
    class _Distance, class _TypeT>
_RandomAccessIter __partial_sort_copy (_InputIter __first,
                                       _InputIter __last,
                                       _RandomAccessIter __first2,
                                       _RandomAccessIter __last2,
                                       _Compare _RWSTD_COMP,
                                       _Distance*, _TypeT*)
{
    ((void)0);
    ((void)0);

    if (__first2 == __last2) return __last2;
    _RandomAccessIter __result = __first2;
    for (; __first != __last && __result != __last2;
         ++__first, ++__result)
        *__result = *__first;
    std::make_heap (__first2, __result, _RWSTD_COMP);
    for (; __first != __last; ++__first)
    {
        if (_RWSTD_COMP (*__first, *__first2))
            __adjust_heap (__first2, _Distance (),
                          _Distance (__result - __first2),
                           _TypeT (*__first),
                          _RWSTD_COMP);
    }
    std::sort_heap (__first2, __result, _RWSTD_COMP);
    return __result;
}

template <class _RandomAccessIter, class _TypeT>
void __nth_element (_RandomAccessIter __first, _RandomAccessIter __nth,
                    _RandomAccessIter __last, _TypeT*)
{
    ((void)0);

    while (__last - __first > 3) {
        _RandomAccessIter __cut =
            __unguarded_partition (__first, __last,
                                   _TypeT (__median (*__first,
                                                     * (__first +
                                                        (__last - __first)/2),
                                                     * (__last - 1))));
        if (__cut <= __nth)
            __first = __cut;
        else
            __last = __cut;
    }
    __insertion_sort (__first, __last);
}

template <class _RandomAccessIter, class _TypeT, class _Compare>
void __nth_element (_RandomAccessIter __first, _RandomAccessIter __nth,
                    _RandomAccessIter __last, _TypeT*, _Compare _RWSTD_COMP)
{
    ((void)0);

    while (__last - __first > 3)
    {
        _RandomAccessIter __cut =
            __unguarded_partition (__first, __last,
                                   _TypeT (__median (*__first,
                                                     * (__first +
                                                        (__last - __first)/2),
                                                     * (__last - 1),
                                                     _RWSTD_COMP)),
             _RWSTD_COMP);
        if (__cut <= __nth)
            __first = __cut;
        else
            __last = __cut;
    }
    __insertion_sort (__first, __last, _RWSTD_COMP);
}





template <class _FwdIter, class _TypeT, class _Distance>
_FwdIter __lower_bound (_FwdIter __first, _FwdIter __last,
                        const _TypeT& __val, _Distance*,
                        forward_iterator_tag)
{
    ((void)0);

    _Distance __dist = std::distance (__first, __last);
    _Distance __half;
    _FwdIter __middle;

    while (__dist > 0)
    {
        __half = __dist / 2;
        __middle = __first;
        std::advance (__middle, __half);
        if (*__middle < __val)
        {
            __first = __middle;
            ++__first;
            __dist = __dist - __half - 1;
        }
        else
            __dist = __half;
    }
    return __first;
}

template <class _RandomAccessIter, class _TypeT, class _Distance>
_RandomAccessIter __lower_bound (_RandomAccessIter __first,
                                 _RandomAccessIter __last,
                                 const _TypeT& __val,
                                 _Distance*, random_access_iterator_tag)
{
    ((void)0);

    _Distance __dist = __last - __first;
    _Distance __half;
    _RandomAccessIter __middle;

    while (__dist > 0)
    {
        __half = __dist / 2;
        __middle = __first + __half;
        if (*__middle < __val)
        {
            __first = __middle + 1;
            __dist = __dist - __half - 1;
        }
        else
            __dist = __half;
    }
    return __first;
}

template <class _FwdIter, class _TypeT, class _Compare, class _Distance>
_FwdIter __lower_bound (_FwdIter __first, _FwdIter __last,
                        const _TypeT& __val, _Compare _RWSTD_COMP,
                        _Distance*, forward_iterator_tag)
{
    ((void)0);
    
    _Distance __dist = std::distance (__first, __last);
    _Distance __half;
    _FwdIter __middle;

    while (__dist > 0)
    {
        __half = __dist / 2;
        __middle = __first;
        std::advance (__middle, __half);
        if (_RWSTD_COMP (*__middle, __val))
        {
            __first = __middle;
            ++__first;
            __dist = __dist - __half - 1;
        }
        else
            __dist = __half;
    }
    return __first;
}

template <class _RandomAccessIter, class _TypeT, class _Compare,
    class _Distance>
_RandomAccessIter __lower_bound (_RandomAccessIter __first,
                                 _RandomAccessIter __last,
                                 const _TypeT& __val,
                                 _Compare _RWSTD_COMP,
                                 _Distance*,
                                 random_access_iterator_tag)
{
    ((void)0);

    _Distance __dist = __last - __first;
    _Distance __half;
    _RandomAccessIter __middle;

    while (__dist > 0)
    {
        __half = __dist / 2;
        __middle = __first + __half;
        if (_RWSTD_COMP (*__middle, __val))
        {
            __first = __middle + 1;
            __dist = __dist - __half - 1;
        }
        else
            __dist = __half;
    }
    return __first;
}

template <class _FwdIter, class _TypeT, class _Distance>
_FwdIter __upper_bound (_FwdIter __first, _FwdIter __last,
                        const _TypeT& __val, _Distance*,
                        forward_iterator_tag)
{
    ((void)0);

    _Distance __dist = std::distance (__first, __last);
    _Distance __half;
    _FwdIter __middle;

    while (__dist > 0)
    {
        __half = __dist / 2;
        __middle = __first;
        std::advance (__middle, __half);

        if (__val < *__middle)
            __dist = __half;
        else
        {
            __first = __middle;
            ++__first;
            __dist = __dist - __half - 1;
        }
    }
    return __first;
}

template <class _RandomAccessIter, class _TypeT, class _Distance>
_RandomAccessIter __upper_bound (_RandomAccessIter __first,
                                 _RandomAccessIter __last,
                                 const _TypeT& __val,
                                 _Distance*, random_access_iterator_tag)
{
    ((void)0);

    _Distance __dist = __last - __first;
    _Distance __half;
    _RandomAccessIter __middle;

    while (__dist > 0)
    {
        __half = __dist / 2;
        __middle = __first + __half;
        if (__val < *__middle)
            __dist = __half;
        else
        {
            __first = __middle + 1;
            __dist = __dist - __half - 1;
        }
    }
    return __first;
}

template <class _FwdIter, class _TypeT, class _Compare, class _Distance>
_FwdIter __upper_bound (_FwdIter __first, _FwdIter __last,
                        const _TypeT& __val, _Compare _RWSTD_COMP,
                        _Distance*, forward_iterator_tag)
{
    ((void)0);

    _Distance __dist = std::distance (__first, __last);
    _Distance __half;
    _FwdIter __middle;

    while (__dist > 0)
    {
        __half = __dist / 2;
        __middle = __first;
        std::advance (__middle, __half);
        if (_RWSTD_COMP (__val, *__middle))
            __dist = __half;
        else {
            __first = __middle;
            ++__first;
            __dist = __dist - __half - 1;
        }
    }
    return __first;
}

template <class _RandomAccessIter, class _TypeT, class _Compare,
    class _Distance>
_RandomAccessIter __upper_bound (_RandomAccessIter __first,
                                 _RandomAccessIter __last,
                                 const _TypeT& __val,
                                 _Compare _RWSTD_COMP, _Distance*,
                                 random_access_iterator_tag)
{
    ((void)0);

    _Distance __dist = __last - __first;
    _Distance __half;
    _RandomAccessIter __middle;

    while (__dist > 0)
    {
        __half = __dist / 2;
        __middle = __first + __half;
        if (_RWSTD_COMP (__val, *__middle))
            __dist = __half;
        else {
            __first = __middle + 1;
            __dist = __dist - __half - 1;
        }
    }
    return __first;
}

template <class _FwdIter, class _TypeT, class _Distance>
pair<_FwdIter, _FwdIter>
__equal_range (_FwdIter __first, _FwdIter __last, const _TypeT& __val,
               _Distance*, forward_iterator_tag)
{
    ((void)0);

    _Distance __dist = std::distance (__first, __last);
    _Distance __half;
    _FwdIter __middle, __left, __right;

    while (__dist > 0)
    {
        __half = __dist / 2;
        __middle = __first;
        std::advance (__middle, __half);
        if (*__middle < __val)
        {
            __first = __middle;
            ++__first;
            __dist = __dist - __half - 1;
        }
        else if (__val < *__middle)
            __dist = __half;
        else
        {
            __left = std::lower_bound (__first, __middle, __val);
            std::advance (__first, __dist);
            __right = std::upper_bound (++__middle, __first, __val);
            pair<_FwdIter, _FwdIter> __tmp (__left, __right);
            return __tmp;
        }
    }
    pair<_FwdIter, _FwdIter> __tmp (__first, __first);
    return __tmp;
}

template <class _RandomAccessIter, class _TypeT, class _Distance>
pair<_RandomAccessIter, _RandomAccessIter>
__equal_range (_RandomAccessIter __first, _RandomAccessIter __last,
               const _TypeT& __val, _Distance*, random_access_iterator_tag)
{
    ((void)0);

    _Distance __dist = __last - __first;
    _Distance __half;
    _RandomAccessIter __middle, __left, __right;

    while (__dist > 0)
    {
        __half = __dist / 2;
        __middle = __first + __half;
        if (*__middle < __val)
        {
            __first = __middle + 1;
            __dist = __dist - __half - 1;
        }
        else if (__val < *__middle)
            __dist = __half;
        else
        {
            __left = std::lower_bound (__first, __middle, __val);
            __right = std::upper_bound (++__middle, __first + __dist, __val);
            pair<_RandomAccessIter, _RandomAccessIter> __tmp(__left, __right);
            return __tmp;
        }
    }
    pair<_RandomAccessIter, _RandomAccessIter> __tmp (__first, __first);
    return __tmp;
}

template <class _FwdIter, class _TypeT, class _Compare, class _Distance>
pair<_FwdIter, _FwdIter>
__equal_range (_FwdIter __first, _FwdIter __last, const _TypeT& __val,
               _Compare _RWSTD_COMP, _Distance*, forward_iterator_tag)
{
    ((void)0);

    _Distance __dist = std::distance (__first, __last);
    _Distance __half;
    _FwdIter __middle, __left, __right;

    while (__dist > 0)
    {
        __half = __dist / 2;
        __middle = __first;
        std::advance (__middle, __half);
        if (_RWSTD_COMP (*__middle, __val))
        {
            __first = __middle;
            ++__first;
            __dist = __dist - __half - 1;
        }
        else if (_RWSTD_COMP (__val, *__middle))
            __dist = __half;
        else
        {
            __left = std::lower_bound (__first, __middle, __val, _RWSTD_COMP);
            std::advance (__first, __dist);
            __right = std::upper_bound (++__middle, __first, __val, _RWSTD_COMP);
            pair<_FwdIter, _FwdIter> __tmp (__left, __right);
            return __tmp;
        }
    }
    pair<_FwdIter, _FwdIter> __tmp (__first, __first);
    return __tmp;
}

template <class _RandomAccessIter, class _TypeT, class _Compare,
    class _Distance>
pair<_RandomAccessIter, _RandomAccessIter>
__equal_range (_RandomAccessIter __first, _RandomAccessIter __last,
               const _TypeT& __val, _Compare _RWSTD_COMP, _Distance*,
               random_access_iterator_tag)
{
    ((void)0);

    _Distance __dist = __last - __first;
    _Distance __half;
    _RandomAccessIter __middle, __left, __right;

    while (__dist > 0)
    {
        __half = __dist / 2;
        __middle = __first + __half;
        if (_RWSTD_COMP (*__middle, __val))
        {
            __first = __middle + 1;
            __dist = __dist - __half - 1;
        }
        else if (_RWSTD_COMP (__val, *__middle))
            __dist = __half;
        else
        {
            __left = std::lower_bound (__first, __middle,
                                           __val, _RWSTD_COMP);
            __right = std::upper_bound (++__middle, __first + __dist,
                                            __val, _RWSTD_COMP);
            pair<_RandomAccessIter, _RandomAccessIter> __tmp(__left, __right);
            return __tmp;
        }
    }
    pair<_RandomAccessIter, _RandomAccessIter> __tmp (__first, __first);
    return __tmp;
}





template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter merge (_InputIter1 __first1, _InputIter1 __last1,
                   _InputIter2 __first2, _InputIter2 __last2,
                   _OutputIter __result)
{
    ((void)0);
    ((void)0);

    for (; __first1 != __last1 && __first2 != __last2; ++__result)
    {
        if (*__first2 < *__first1) {
            *__result = *__first2;
            ++__first2;
        }
        else {
            *__result = *__first1;
            ++__first1;
        }
    }
    return std::copy (__first2, __last2,
                          std::copy (__first1, __last1, __result));
}

template <class _InputIter1, class _InputIter2, class _OutputIter,
    class _Compare>
_OutputIter merge (_InputIter1 __first1, _InputIter1 __last1,
                   _InputIter2 __first2, _InputIter2 __last2,
                   _OutputIter __result, _Compare _RWSTD_COMP)
{
    ((void)0);
    ((void)0);

    for (; __first1 != __last1 && __first2 != __last2; ++__result)
    {
        if (_RWSTD_COMP (*__first2, *__first1)) {
            *__result = *__first2;
            ++__first2;
        }
        else {
            *__result = *__first1;
            ++__first1;
        }
    }
    return std::copy (__first2, __last2,
                          std::copy (__first1, __last1, __result));
}

template <class _BidirIter, class _Distance>
void __merge_without_buffer (_BidirIter __first,
                             _BidirIter __middle,
                             _BidirIter __last,
                             _Distance __dist1, _Distance __dist2)
{
    ((void)0);

    if (__dist1 == 0 || __dist2 == 0) return;
    if (__dist1 + __dist2 == 2)
    {
        if (*__middle < *__first) std::iter_swap (__first, __middle);
        return;
    }
    _BidirIter __first_cut = __first;
    _BidirIter __second_cut = __middle;
    _Distance __dist11;
    _Distance __dist22;
    if (__dist1 > __dist2)
    {
        __dist11 = __dist1 / 2;
        std::advance (__first_cut, __dist11);
        __second_cut = std::lower_bound (__middle, __last, *__first_cut);
        std::distance (__middle, __second_cut, __dist22);
    }
    else
    {
        __dist22 = __dist2 / 2;
        std::advance (__second_cut, __dist22);
        __first_cut = std::upper_bound (__first, __middle, *__second_cut);
        std::distance (__first, __first_cut, __dist11);
    }
    std::rotate (__first_cut, __middle, __second_cut);
    _BidirIter __middle2 = __first_cut;
    std::advance (__middle2, __dist22);
    __merge_without_buffer (__first, __first_cut, __middle2,
                            __dist11, __dist22);
    __merge_without_buffer (__middle2, __second_cut, __last,
                            __dist1 - __dist11,
                           __dist2 - __dist22);
}

template <class _BidirIter, class _Distance, class _Compare>
void __merge_without_buffer (_BidirIter __first,
                             _BidirIter __middle,
                             _BidirIter __last,
                             _Distance __dist1, _Distance __dist2,
                             _Compare _RWSTD_COMP)
{
    ((void)0);

    if (__dist1 == 0 || __dist2 == 0) return;
    if (__dist1 + __dist2 == 2)
    {
        if (_RWSTD_COMP (*__middle, *__first))
            std::iter_swap (__first, __middle);
        return;
    }
    _BidirIter __first_cut = __first;
    _BidirIter __second_cut = __middle;
    _Distance __dist11;
    _Distance __dist22;
    if (__dist1 > __dist2)
    {
        __dist11 = __dist1 / 2;
        std::advance (__first_cut, __dist11);
        __second_cut = std::lower_bound (__middle, __last,
                                             *__first_cut, _RWSTD_COMP);
        std::distance (__middle, __second_cut, __dist22);
    }
    else
    {
        __dist22 = __dist2 / 2;
        std::advance (__second_cut, __dist22);
        __first_cut = std::upper_bound (__first, __middle,
                                            *__second_cut, _RWSTD_COMP);
        std::distance (__first, __first_cut, __dist11);
    }
    std::rotate (__first_cut, __middle, __second_cut);

    _BidirIter __middle2 = __first_cut;

    std::advance (__middle2, __dist22);

    __merge_without_buffer (__first, __first_cut, __middle2,
                            __dist11, __dist22, _RWSTD_COMP);
    __merge_without_buffer (__middle2, __second_cut, __last,
                            __dist1 - __dist11, __dist2 - __dist22, _RWSTD_COMP);
}

template <class _BidirIter1, class _BidirIter2,
    class _Distance>
_BidirIter1 __rotate_adaptive (_BidirIter1 __first,
                               _BidirIter1 __middle,
                               _BidirIter1 __last,
                               _Distance __dist1, _Distance __dist2,
                               _BidirIter2 __buf,
                               _Distance __buf_size)
{
    ((void)0);

    _BidirIter2 __buf_end;
    if (__dist1 > __dist2 && __dist2 <= __buf_size)
    {
        __buf_end = std::copy (__middle, __last, __buf);
        std::copy_backward (__first, __middle, __last);
        return std::copy (__buf, __buf_end, __first);
    }
    else if (__dist1 <= __buf_size)
    {
        __buf_end = std::copy (__first, __middle, __buf);
        std::copy (__middle, __last, __first);
        return std::copy_backward (__buf, __buf_end, __last);
    }
    else
    {
        std::rotate (__first, __middle, __last);
        std::advance (__first, __dist2);
        return __first;
    }
}

template <class _BidirIter1, class _BidirIter2,
    class _BidirIter3>
_BidirIter3 __merge_backward (_BidirIter1 __first1,
                              _BidirIter1 __last1,
                              _BidirIter2 __first2,
                              _BidirIter2 __last2,
                              _BidirIter3 __result)
{
    ((void)0);
    ((void)0);

    if (__first1 == __last1)
        return std::copy_backward (__first2, __last2, __result);

    if (__first2 == __last2)
        return std::copy_backward (__first1, __last1, __result);

    --__last1;
    --__last2;
    while (true)
    {
        if (*__last2 < *__last1)
        {
            *--__result = *__last1;
            if (__first1 == __last1)
                return std::copy_backward (__first2, ++__last2, __result);
            --__last1;
        }
        else
        {
            *--__result = *__last2;
            if (__first2 == __last2)
                return std::copy_backward (__first1, ++__last1, __result);
            --__last2;
        }
    }
}

template <class _BidirIter1, class _BidirIter2,
    class _BidirIter3, class _Compare>
_BidirIter3 __merge_backward (_BidirIter1 __first1,
                              _BidirIter1 __last1,
                              _BidirIter2 __first2,
                              _BidirIter2 __last2,
                              _BidirIter3 __result,
                              _Compare _RWSTD_COMP)
{
    ((void)0);
    ((void)0);

    if (__first1 == __last1)
        return std::copy_backward (__first2, __last2, __result);
    if (__first2 == __last2)
        return std::copy_backward (__first1, __last1, __result);
    --__last1;
    --__last2;
    while (true)
    {
        if (_RWSTD_COMP (*__last2, *__last1))
        {
            *--__result = *__last1;
            if (__first1 == __last1)
                return std::copy_backward (__first2, ++__last2, __result);
            --__last1;
        }
        else
        {
            *--__result = *__last2;
            if (__first2 == __last2)
                return std::copy_backward (__first1, ++__last1, __result);
            --__last2;
        }
    }
}

template <class _BidirIter, class _Distance, class _Pointer, class _TypeT>
void __merge_adaptive (_BidirIter __first,
                       _BidirIter __middle,
                       _BidirIter __last,
                       _Distance __dist1, _Distance __dist2,
                       _Pointer __buf, _Distance __buf_size, _TypeT*)
{
    ((void)0);
    
    if (__dist1 <= __dist2 && __dist1 <= __buf_size)
    {
        _Pointer __buf_end = std::copy (__first, __middle, __buf);
        std::merge (__buf, __buf_end, __middle, __last, __first);
    }
    else if (__dist2 <= __buf_size)
    {
        _Pointer __buf_end = std::copy (__middle, __last, __buf);
        __merge_backward (__first, __middle, __buf, __buf_end, __last);
    }
    else
    {
        _BidirIter __first_cut = __first;
        _BidirIter __second_cut = __middle;
        _Distance __dist11;
        _Distance __dist22;
        if (__dist1 > __dist2)
        {
            __dist11 = __dist1 / 2;
            std::advance (__first_cut, __dist11);
            __second_cut = std::lower_bound (__middle, __last, *__first_cut);
            std::distance (__middle, __second_cut, __dist22);
        }
        else
        {
            __dist22 = __dist2 / 2;
            std::advance (__second_cut, __dist22);
            __first_cut = std::upper_bound (__first, __middle, *__second_cut);
            std::distance (__first, __first_cut, __dist11);
        }
        _BidirIter __middle2 =
            __rotate_adaptive (__first_cut, __middle, __second_cut,
                               __dist1 - __dist11, __dist22, __buf, __buf_size);

        __merge_adaptive (__first, __first_cut, __middle2, __dist11, __dist22,
                          __buf, __buf_size, (_TypeT*)0);
        __merge_adaptive (__middle2, __second_cut, __last, __dist1 - __dist11,
                         __dist2 - __dist22, __buf, __buf_size, (_TypeT*)0);
    }
}

template <class _BidirIter, class _Distance, class _Pointer, class _TypeT,
    class _Compare>
void __merge_adaptive (_BidirIter __first, _BidirIter __middle,
                       _BidirIter __last,
                       _Distance __dist1, _Distance __dist2,
                       _Pointer __buf, _Distance __buf_size, _TypeT*,
                       _Compare _RWSTD_COMP)
{
    ((void)0);
    
    if (__dist1 <= __dist2 && __dist1 <= __buf_size)
    {
        _Pointer __buf_end = std::copy (__first, __middle, __buf);
        std::merge (__buf, __buf_end, __middle, __last, __first, _RWSTD_COMP);
    }
    else if (__dist2 <= __buf_size)
    {
        _Pointer __buf_end = std::copy (__middle, __last, __buf);
        __merge_backward (__first, __middle, __buf, __buf_end, __last,
                          _RWSTD_COMP);
    }
    else
    {
        _BidirIter __first_cut = __first;
        _BidirIter __second_cut = __middle;
        _Distance __dist11;
        _Distance __dist22;
        if (__dist1 > __dist2)
        {
            __dist11 = __dist1 / 2;
            std::advance (__first_cut, __dist11);
            __second_cut = std::lower_bound (__middle, __last, *__first_cut,
                                                 _RWSTD_COMP);
            std::distance (__middle, __second_cut, __dist22);
        }
        else
        {
            __dist22 = __dist2 / 2;
            std::advance (__second_cut, __dist22);
            __first_cut = std::upper_bound (__first, __middle, *__second_cut,
                                                _RWSTD_COMP);
            std::distance (__first, __first_cut, __dist11);
        }
        _BidirIter __middle2 =
            __rotate_adaptive (__first_cut, __middle, __second_cut,
                               __dist1 - __dist11, __dist22,
                               __buf, __buf_size);
        __merge_adaptive (__first, __first_cut, __middle2,
                          __dist11, __dist22,
                          __buf,
                          __buf_size, (_TypeT*)0,
                          _RWSTD_COMP);
        __merge_adaptive (__middle2, __second_cut, __last,
                          __dist1 - __dist11, __dist2 - __dist22,
                          __buf, __buf_size, (_TypeT*)0, _RWSTD_COMP);
    }
}

template <class _BidirIter, class _Distance, class _Pointer, class _TypeT>
void __inplace_merge (_BidirIter __first,
                      _BidirIter __middle,
                      _BidirIter __last, _Distance __dist1,
                      _Distance __dist2, pair<_Pointer, _Distance> __pair,
                      _TypeT*)
{
    ((void)0);
    
    if (__pair.first == 0)
        __merge_without_buffer (__first, __middle, __last, __dist1, __dist2);
    else
    {
        _Distance __dist = std::min (__pair.second, __dist1 + __dist2);

        std::fill_n (raw_storage_iterator<_Pointer, _TypeT> (__pair.first),
                         __dist, *__first);

        __merge_adaptive (__first, __middle, __last, __dist1, __dist2,
                          __pair.first, __pair.second, (_TypeT*)0);

        __rw::__rw_destroy (__pair.first, __pair.first + __dist);

        std::return_temporary_buffer (__pair.first);
    }
}

template <class _BidirIter, class _Distance, class _Pointer, class _TypeT,
    class _Compare>
void __inplace_merge (_BidirIter __first,
                      _BidirIter __middle,
                      _BidirIter __last, _Distance __dist1,
                      _Distance __dist2, pair<_Pointer, _Distance> __pair,
                      _TypeT*, _Compare _RWSTD_COMP)
{
    ((void)0);
    
    if (__pair.first == 0)
        __merge_without_buffer (__first, __middle, __last, __dist1, __dist2,
                                _RWSTD_COMP);
    else
    {
        _Distance __dist = std::min (__pair.second, __dist1 + __dist2);
        
        std::fill_n (raw_storage_iterator<_Pointer, _TypeT> (__pair.first),
                         __dist, *__first);
        __merge_adaptive (__first, __middle, __last, __dist1, __dist2,
                          __pair.first, __pair.second,
                          (_TypeT*)0, _RWSTD_COMP);
        __rw::__rw_destroy (__pair.first, __pair.first + __dist);
        std::return_temporary_buffer (__pair.first);
    }
}








template <class _InputIter1, class _InputIter2>
bool includes (_InputIter1 __first1, _InputIter1 __last1,
               _InputIter2 __first2, _InputIter2 __last2)
{
    ((void)0);
    ((void)0);

    while (__first1 != __last1 && __first2 != __last2) {
        if (*__first2 < *__first1)
            return false;

        if (!(*__first1 < *__first2))
            ++__first2;

        ++__first1;
    }
    return __first2 == __last2;
}


template <class _InputIter1, class _InputIter2, class _Compare>
bool includes (_InputIter1 __first1, _InputIter1 __last1,
               _InputIter2 __first2, _InputIter2 __last2,
               _Compare _RWSTD_COMP)
{
    ((void)0);
    ((void)0);

    while (__first1 != __last1 && __first2 != __last2) {
        if (_RWSTD_COMP (*__first2, *__first1))
            return false;

        if (!_RWSTD_COMP (*__first1, *__first2))
            ++__first2;

        ++__first1;
    }
    return __first2 == __last2;
}


template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_union (_InputIter1 __first1, _InputIter1 __last1,
                       _InputIter2 __first2, _InputIter2 __last2,
                       _OutputIter __result)
{
    ((void)0);
    ((void)0);

    for (; __first1 != __last1 && __first2 != __last2; ++__result)
    {
        if (*__first1 < *__first2) {
            *__result = *__first1;
            ++__first1;
        }
        else if (*__first2 < *__first1) {
            *__result = *__first2;
            ++__first2;
        }
        else {
            *__result = *__first1;
            ++__first1;
            ++__first2;
        }
    }
    return std::copy (__first2, __last2,
                          std::copy (__first1, __last1, __result));
}

template <class _InputIter1, class _InputIter2, class _OutputIter,
    class _Compare>
_OutputIter set_union (_InputIter1 __first1, _InputIter1 __last1,
                       _InputIter2 __first2, _InputIter2 __last2,
                       _OutputIter __result, _Compare _RWSTD_COMP)
{
    ((void)0);
    ((void)0);

    for (; __first1 != __last1 && __first2 != __last2; ++__result) {
        if (_RWSTD_COMP (*__first1, *__first2)) {
            *__result = *__first1;
            ++__first1;
        }
        else if (_RWSTD_COMP (*__first2, *__first1)) {
            *__result = *__first2;
            ++__first2;
        }
        else {
            *__result = *__first1;
            ++__first1;
            ++__first2;
        }
    }
    return std::copy (__first2, __last2,
                          std::copy (__first1, __last1, __result));
}

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_intersection (_InputIter1 __first1, _InputIter1 __last1,
                              _InputIter2 __first2, _InputIter2 __last2,
                              _OutputIter __result)
{
    ((void)0);
    ((void)0);

    while (__first1 != __last1 && __first2 != __last2)
    {
        if (*__first1 < *__first2)
            ++__first1;
        else if (*__first2 < *__first1)
            ++__first2;
        else
        {
            *__result = *__first1;
            ++__result;
            ++__first1;
            ++__first2;
        }
    }
    return __result;
}

template <class _InputIter1, class _InputIter2, class _OutputIter,
    class _Compare>
_OutputIter set_intersection (_InputIter1 __first1, _InputIter1 __last1,
                              _InputIter2 __first2, _InputIter2 __last2,
                              _OutputIter __result, _Compare _RWSTD_COMP)
{
    ((void)0);
    ((void)0);

    while (__first1 != __last1 && __first2 != __last2)
    {
        if (_RWSTD_COMP (*__first1, *__first2))
            ++__first1;
        else if (_RWSTD_COMP (*__first2, *__first1))
            ++__first2;
        else {
            *__result = *__first1;
            ++__result;
            ++__first1;
            ++__first2;
        }
    }
    return __result;
}

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_difference (_InputIter1 __first1, _InputIter1 __last1,
                            _InputIter2 __first2, _InputIter2 __last2,
                            _OutputIter __result)
{
    ((void)0);
    ((void)0);

    while (__first1 != __last1 && __first2 != __last2)
    {
        if (*__first1 < *__first2) {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else if (*__first2 < *__first1)
            ++__first2;
        else
        {
            ++__first1;
            ++__first2;
        }
    }
    return std::copy (__first1, __last1, __result);
}

template <class _InputIter1, class _InputIter2, class _OutputIter,
    class _Compare>
_OutputIter set_difference (_InputIter1 __first1, _InputIter1 __last1,
                            _InputIter2 __first2, _InputIter2 __last2,
                            _OutputIter __result, _Compare _RWSTD_COMP)
{
    ((void)0);
    ((void)0);

    while (__first1 != __last1 && __first2 != __last2)
    {
        if (_RWSTD_COMP (*__first1, *__first2)) {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else if (_RWSTD_COMP (*__first2, *__first1))
            ++__first2;
        else
        {
            ++__first1;
            ++__first2;
        }
    }
    return std::copy (__first1, __last1, __result);
}

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_symmetric_difference (_InputIter1 __first1,
                                      _InputIter1 __last1,
                                      _InputIter2 __first2,
                                      _InputIter2 __last2,
                                      _OutputIter __result)
{
    ((void)0);
    ((void)0);

    while (__first1 != __last1 && __first2 != __last2)
    {
        if (*__first1 < *__first2) {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else if (*__first2 < *__first1) {
            *__result = *__first2;
            ++__result;
            ++__first2;
        }
        else
        {
            ++__first1;
            ++__first2;
        }
    }
    return std::copy (__first2, __last2,
                          std::copy (__first1, __last1, __result));
}

template <class _InputIter1, class _InputIter2, class _OutputIter,
    class _Compare>
_OutputIter set_symmetric_difference (_InputIter1 __first1,
                                      _InputIter1 __last1,
                                      _InputIter2 __first2,
                                      _InputIter2 __last2,
                                      _OutputIter __result,
                                      _Compare _RWSTD_COMP)
{
    ((void)0);
    ((void)0);

    while (__first1 != __last1 && __first2 != __last2)
    {
        if (_RWSTD_COMP (*__first1, *__first2)) {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else if (_RWSTD_COMP (*__first2, *__first1)) {
            *__result = *__first2;
            ++__result;
            ++__first2;
        }
        else      {
            ++__first1;
            ++__first2;
        }
    }
    return std::copy (__first2, __last2,
                          std::copy (__first1, __last1, __result));
}





template <class _RandomAccessIter, class _Distance, class _TypeT>
void __push_heap (_RandomAccessIter __first, _Distance __holeIndex,
                  _Distance __topIndex, _TypeT __val)
{
    _Distance __parent = (__holeIndex - 1) / 2;
    while (__holeIndex > __topIndex && * (__first + __parent) < __val)
    {
        * (__first + __holeIndex) = * (__first + __parent);
        __holeIndex = __parent;
        __parent = (__holeIndex - 1) / 2;
    }
    * (__first + __holeIndex) = __val;
}

template <class _RandomAccessIter, class _Distance, class _TypeT,
    class _Compare>
void __push_heap (_RandomAccessIter __first, _Distance __holeIndex,
                  _Distance __topIndex, _TypeT __val, _Compare _RWSTD_COMP)
{
    _Distance __parent = (__holeIndex - 1) / 2;
    while (__holeIndex > __topIndex &&
           _RWSTD_COMP (* (__first + __parent), __val))
    {
        * (__first + __holeIndex) = * (__first + __parent);
        __holeIndex = __parent;
        __parent = (__holeIndex - 1) / 2;
    }
    * (__first + __holeIndex) = __val;
}

template <class _RandomAccessIter, class _Distance, class _TypeT>
void __adjust_heap (_RandomAccessIter __first, _Distance __holeIndex,
                    _Distance __dist, _TypeT __val)
{
    _Distance __topIndex = __holeIndex;
    _Distance __secondChild = 2 * __holeIndex + 2;
    while (__secondChild < __dist)
    {
        if (* (__first + __secondChild) < * (__first + (__secondChild - 1)))
            __secondChild--;
        * (__first + __holeIndex) = * (__first + __secondChild);
        __holeIndex = __secondChild;
        __secondChild = 2 * (__secondChild + 1);
    }
    if (__secondChild == __dist)
    {
        * (__first + __holeIndex) = * (__first + (__secondChild - 1));
        __holeIndex = __secondChild - 1;
    }
    __push_heap (__first, __holeIndex, __topIndex, __val);
}

template <class _RandomAccessIter, class _Distance, class _TypeT,
    class _Compare>
void __adjust_heap (_RandomAccessIter __first, _Distance __holeIndex,
                    _Distance __dist, _TypeT __val, _Compare _RWSTD_COMP)
{
    _Distance __topIndex = __holeIndex;
    _Distance __secondChild = 2 * __holeIndex + 2;
    while (__secondChild < __dist)
    {
        if (_RWSTD_COMP (* (__first + __secondChild),
                         * (__first + (__secondChild - 1))))
            __secondChild--;
        * (__first + __holeIndex) = * (__first + __secondChild);
        __holeIndex = __secondChild;
        __secondChild = 2 * (__secondChild + 1);
    }
    if (__secondChild == __dist)
    {
        * (__first + __holeIndex) = * (__first + (__secondChild - 1));
        __holeIndex = __secondChild - 1;
    }
    __push_heap (__first, __holeIndex, __topIndex, __val, _RWSTD_COMP);
}

template <class _RandomAccessIter, class _TypeT, class _Distance>
void __make_heap (_RandomAccessIter __first, _RandomAccessIter __last,
                  _TypeT*, _Distance*)
{
    ((void)0);

    _Distance __dist = __last - __first;
    _Distance __parent = (__dist - 2)/2;
    while (true)
    {
        __adjust_heap (__first, __parent, __dist,
                       _TypeT (*(__first + __parent)));
        if (__parent == 0) return;
        __parent--;
    }
}

template <class _RandomAccessIter, class _Compare, class _TypeT,
    class _Distance>
void __make_heap (_RandomAccessIter __first, _RandomAccessIter __last,
                  _Compare _RWSTD_COMP, _TypeT*, _Distance*)
{
    ((void)0);

    _Distance __dist = __last - __first;
    _Distance __parent = (__dist - 2)/2;
    while (true)
    {
        __adjust_heap (__first, __parent, __dist,
                       _TypeT (* (__first + __parent)),
                       _RWSTD_COMP);
        if (__parent == 0)
            return;
        __parent--;
    }
}






template <class _FwdIter>
_FwdIter min_element (_FwdIter __first, _FwdIter __last)
{
    ((void)0);

    if (__first == __last)
        return __first;

    _FwdIter __result = __first;
    while (++__first != __last)
        if (*__first < *__result)
            __result = __first;

    return __result;
}

template <class _FwdIter, class _Compare>
_FwdIter min_element (_FwdIter __first, _FwdIter __last,
                      _Compare _RWSTD_COMP)
{
    ((void)0);

    if (__first == __last)
        return __first;

    _FwdIter __result = __first;
    while (++__first != __last)
        if (_RWSTD_COMP (*__first, *__result))
            __result = __first;

    return __result;
}

template <class _FwdIter>
_FwdIter max_element (_FwdIter __first, _FwdIter __last)
{
    ((void)0);

    if (__first == __last)
        return __first;

    _FwdIter __result = __first;
    while (++__first != __last)
        if (*__result < *__first)
            __result = __first;

    return __result;
}

template <class _FwdIter, class _Compare>
_FwdIter max_element (_FwdIter __first, _FwdIter __last,
                      _Compare _RWSTD_COMP)
{
    ((void)0);

    if (__first == __last)
        return __first;

    _FwdIter __result = __first;
    while (++__first != __last)
        if (_RWSTD_COMP (*__result, *__first))
            __result = __first;

    return __result;
}

template <class _InputIter1, class _InputIter2>
bool lexicographical_compare (_InputIter1 __first1, _InputIter1 __last1,
                              _InputIter2 __first2, _InputIter2 __last2)
{
    ((void)0);
    ((void)0);

    for (; __first1 != __last1 && __first2 != __last2;
         ++__first2, ++__first1)
    {
        if (*__first1 < *__first2)
            return true;
        if (*__first2 < *__first1)
            return false;
    }
    return __first1 == __last1 && __first2 != __last2;
}

template <class _InputIter1, class _InputIter2, class _Compare>
bool lexicographical_compare (_InputIter1 __first1, _InputIter1 __last1,
                              _InputIter2 __first2, _InputIter2 __last2,
                              _Compare _RWSTD_COMP)
{
    ((void)0);
    ((void)0);

    for (; __first1 != __last1 && __first2 != __last2;
         ++__first2, ++__first1) {
        if (_RWSTD_COMP (*__first1, *__first2))
            return true;
        if (_RWSTD_COMP (*__first2, *__first1))
            return false;
    }
    return __first1 == __last1 && __first2 != __last2;
}





template <class _BidirIter>
bool next_permutation (_BidirIter __first,
                       _BidirIter __last)
{
    ((void)0);

    if (__first == __last) return false;
    _BidirIter __i = __first;
    ++__i;
    if (__i == __last) return false;
    __i = __last;
    --__i;

    for (; ; )
    {
        _BidirIter __ii = __i--;
        if (*__i < *__ii)
        {
            _BidirIter __j = __last;
            while (! (*__i < *--__j))
                ;
            std::iter_swap (__i, __j);
            std::reverse (__ii, __last);
            return true;
        }
        if (__i == __first)
        {
            std::reverse (__first, __last);
            return false;
        }
    }
}

template <class _BidirIter, class _Compare>
bool next_permutation (_BidirIter __first, _BidirIter __last,
                       _Compare _RWSTD_COMP)
{
    ((void)0);

    if (__first == __last) return false;
    _BidirIter __i = __first;
    ++__i;
    if (__i == __last) return false;
    __i = __last;
    --__i;

    for (; ; )
    {
        _BidirIter __ii = __i--;
        if (_RWSTD_COMP (*__i, *__ii))
        {
            _BidirIter __j = __last;
            while (!_RWSTD_COMP (*__i, *--__j))
                ;
            std::iter_swap (__i, __j);
            std::reverse (__ii, __last);
            return true;
        }
        if (__i == __first)
        {
            std::reverse (__first, __last);
            return false;
        }
    }
}

template <class _BidirIter>
bool prev_permutation (_BidirIter __first,
                       _BidirIter __last)
{
    ((void)0);

    if (__first == __last) return false;
    _BidirIter __i = __first;
    ++__i;
    if (__i == __last) return false;
    __i = __last;
    --__i;

    for (; ; )
    {
        _BidirIter __ii = __i--;
        if (*__ii < *__i)
        {
            _BidirIter __j = __last;
            while (! (*--__j < *__i))
                ;
            std::iter_swap (__i, __j);
            std::reverse (__ii, __last);
            return true;
        }
        if (__i == __first)
        {
            std::reverse (__first, __last);
            return false;
        }
    }
}

template <class _BidirIter, class _Compare>
bool prev_permutation (_BidirIter __first, _BidirIter __last,
                       _Compare _RWSTD_COMP)
{
    ((void)0);

    if (__first == __last) return false;
    _BidirIter __i = __first;
    ++__i;
    if (__i == __last) return false;
    __i = __last;
    --__i;

    for (; ; )
    {
        _BidirIter __ii = __i--;
        if (_RWSTD_COMP (*__ii, *__i))
        {
            _BidirIter __j = __last;
            while (!_RWSTD_COMP (*--__j, *__i))
                ;
            std::iter_swap (__i, __j);
            std::reverse (__ii, __last);
            return true;
        }
        if (__i == __first)
        {
            std::reverse (__first, __last);
            return false;
        }
    }
}


}   

#line 2179 "/opt/aCC/include_std/algorithm"




#line 43 "/opt/aCC/include_std/string"



#line 1 "/opt/aCC/include_std/cctype"



#pragma push binding
#pragma binding default
#line 1 "/usr/include/ctype.h"
 















extern "C" {




    
#pragma  extern isalnum, isalpha, iscntrl, isdigit, isgraph, islower
#pragma  extern isprint, ispunct, isspace, isupper, isxdigit


  
extern int isalnum (int);
extern int isalpha (int);
extern int iscntrl (int);
extern int isdigit (int);
extern int isgraph (int);
extern int islower (int);
extern int isprint (int);
extern int ispunct (int);
extern int isspace (int);
extern int isupper (int);
extern int isxdigit (int);
  
















 

    
#  pragma extern tolower, toupper


#line 69 "/usr/include/ctype.h"

  
extern int tolower (int);
extern int toupper (int);
  




    
#pragma extern isascii, toascii


#line 90 "/usr/include/ctype.h"

extern int isascii (int);
extern int toascii (int);

#line 101 "/usr/include/ctype.h"


    
#  pragma extern __tolower, __toupper
#line 113 "/usr/include/ctype.h"

extern int __tolower (int);
extern int __toupper (int);










    
#    pragma extern isblank











extern int isblank (int);





#line 157 "/usr/include/ctype.h"
   

 



    
#    pragma extern isctype
#line 179 "/usr/include/ctype.h"

extern int isctype (int, unsigned int);


    
#    pragma builtin _isalnum, _isalpha, _isblank, _iscntrl, _isdigit, _isgraph, _islower
#    pragma builtin _isprint, _ispunct, _isspace, _isupper, _isxdigit
#    pragma extern _isalnum, _isalpha, _isblank, _iscntrl, _isdigit, _isgraph, _islower
#    pragma extern _isprint, _ispunct, _isspace, _isupper, _isxdigit




          
#      pragma extern __SB_masks

extern unsigned int *__SB_masks;
extern int _isalnum (int);
extern int _isalpha (int);
extern int _isblank (int);
extern int _iscntrl (int);
extern int _isdigit (int);
extern int _isgraph (int);
extern int _islower (int);
extern int _isprint (int);
extern int _ispunct (int);
extern int _isspace (int);
extern int _isupper (int);
extern int _isxdigit (int);

#line 221 "/usr/include/ctype.h"


#line 248 "/usr/include/ctype.h"





}


#pragma pop
#line 5 "/opt/aCC/include_std/cctype"







#line 24 "/opt/aCC/include_std/cctype"


namespace std {
using ::isalnum;
using ::isalpha;
using ::iscntrl;
using ::isdigit;
using ::isgraph;
using ::islower;
using ::isprint;
using ::ispunct;
using ::isspace;
using ::isupper;
using ::isxdigit;
using ::tolower;
using ::toupper;
}


#line 48 "/opt/aCC/include_std/string"
#line 1 "/opt/aCC/include_std/cwchar"





#pragma push binding
#pragma binding default
#line 1 "/usr/include/time.h"
 










#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/_time.h"
 














 




extern "C" {

 
 

















 


  
#line 54 "/usr/include/sys/_time.h"
#    pragma extern time

extern time_t time (time_t *);
  



 




 





 





 





 













 
struct itimerspec {
	struct timespec	it_interval;	 
	struct timespec	it_value;	 
};


   



#      pragma extern clock_getres

extern int clock_getres (clockid_t, struct timespec *);


#      pragma extern clock_gettime

extern int clock_gettime (clockid_t, struct timespec *);


#      pragma extern clock_settime

extern int clock_settime (clockid_t, const struct timespec *);


#      pragma extern nanosleep

extern int nanosleep (const struct timespec *, struct timespec *);


#      pragma extern timer_create

extern int timer_create (clockid_t, struct sigevent * , timer_t * );



#      pragma extern timer_delete

extern int timer_delete (timer_t);


#      pragma extern timer_getoverrun

extern int timer_getoverrun (timer_t);


#      pragma extern timer_gettime

extern int timer_gettime (timer_t, struct itimerspec *);


#      pragma extern timer_settime

extern int timer_settime (timer_t, int, const struct itimerspec * , struct itimerspec * );






 



 
#line 177 "/usr/include/sys/_time.h"

}

#pragma pop
#line 13 "/usr/include/time.h"







extern "C" {







 
 

#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/_null.h"
 


 
 
 

 
#line 16 "/usr/include/sys/_null.h"

#line 24 "/usr/include/sys/_null.h"

 
#pragma pop
#line 33 "/usr/include/time.h"


      


  
struct tm {
	int	tm_sec;		 
	int	tm_min;		 
	int	tm_hour;	 
	int	tm_mday;	 
	int	tm_mon;		 
	int	tm_year;	 
	int	tm_wday;	 
	int	tm_yday;	 
	int	tm_isdst;	 
};
  


 

  

#    pragma extern asctime

extern char *asctime (const struct tm *);

#line 69 "/usr/include/time.h"
#    pragma extern clock

extern clock_t clock (void);


#    pragma extern ctime

extern char *ctime (const time_t *);


#    pragma extern difftime

extern double difftime (time_t, time_t);


#    pragma extern gmtime

extern struct tm *gmtime (const time_t *);


#    pragma extern localtime

extern struct tm *localtime (const time_t *);

#line 101 "/usr/include/time.h"
#    pragma extern mktime

extern time_t mktime (struct tm *);

#line 113 "/usr/include/time.h"
#    pragma extern strftime

extern size_t strftime (char *, size_t, const char *, const struct tm *);
  

 



 

#      pragma extern tzname


extern char *tzname[2];

 

#      pragma extern tzset

extern void tzset (void);





 



#      pragma extern asctime_r

extern char *asctime_r (const struct tm *, char *);


#      pragma extern ctime_r

extern char *ctime_r (const time_t *, char *);


#      pragma extern gmtime_r

extern struct tm *gmtime_r (const time_t *, struct tm *);


#      pragma extern localtime_r

extern struct tm *localtime_r (const time_t *, struct tm *);




 


#      pragma extern daylight

extern int daylight;


#      pragma extern timezone

extern long timezone;

 
#line 186 "/usr/include/time.h"
#      pragma extern strptime

extern char *strptime (const char *, const char *, struct tm *);





 
#line 204 "/usr/include/time.h"
#      pragma extern getdate

extern struct tm *getdate (const char *);

#line 217 "/usr/include/time.h"
#        pragma extern __getdate_error

int * __getdate_error (void) ;
#line 227 "/usr/include/time.h"






 



typedef int64_t         hrtime_t;  



 
#line 252 "/usr/include/time.h"
#      pragma extern get_expiration_time

extern int get_expiration_time (struct timespec *,struct timespec *);



#        pragma extern gethrtime

extern  hrtime_t        gethrtime (void);





}

#pragma pop
#line 12 "/opt/aCC/include_std/cwchar"




#line 26 "/opt/aCC/include_std/cwchar"


#pragma push binding
#pragma binding default
#line 1 "/usr/include/wchar.h"
 








 
#line 29 "/usr/include/wchar.h"


extern "C" {







  


      typedef unsigned int wint_t;




      typedef unsigned int wctype_t;








     
#  pragma extern wcscat, wcsncat, wcscpy, wcsncpy, wcslen
#  pragma extern wcsspn, wcscspn, wcscmp, wcsncmp, wcswcs, wcstok 





#  pragma extern wcscoll, wcsxfrm, wcswidth, iswalnum, iswalpha, iswcntrl
#  pragma extern iswdigit, iswgraph, iswlower, iswprint, iswpunct, iswspace
#  pragma extern iswupper, iswxdigit, towlower, towupper, wctype, iswctype
#  pragma extern fgetwc, fgetws, fputwc, fputws, getwc, getwchar, putwc, putwchar
#  pragma extern ungetwc, wcstod, wcstol, wcstoul, wcsftime 

#    pragma extern wcstoll, wcstoull


#    pragma extern wcwidth

#      pragma extern getws, putws





 
#line 96 "/usr/include/wchar.h"








               
#        pragma extern btowc, fwide, fwprintf, fwscanf, mbsinit 
#        pragma extern mbrlen, mbrtowc, mbsrtowcs, swprintf, swscanf 
#        pragma extern vfwprintf, vwprintf, vswprintf, wctob, __wmemchr_keep_out
#        pragma extern wmemcmp, wmemcpy, wmemmove, wmemset, wprintf
#        pragma extern wscanf, wcrtomb, wcsrtombs, __wcsstr_keep_out 




extern wint_t 	btowc (int);
extern int fwide (FILE *, int);
extern int fwprintf (FILE *, const wchar_t *, ...);
extern int fwscanf (FILE *, const wchar_t *, ...);
extern int mbsinit (const mbstate_t *);
extern size_t mbrlen (const char *, size_t, mbstate_t *);
extern size_t mbrtowc (wchar_t *, const char *, size_t, mbstate_t *);
extern size_t mbsrtowcs (wchar_t *, const char * *, size_t, mbstate_t *);
extern int swprintf (wchar_t *, size_t, const wchar_t *, ...);
extern int swscanf (const wchar_t *, const wchar_t *, ...);
extern int vfwprintf (FILE *, const wchar_t *, __va_list);
extern int vwprintf (const wchar_t *, __va_list);
extern int vswprintf (wchar_t *, size_t, const wchar_t *, __va_list);
extern int wctob ( wint_t);
extern wchar_t *__wmemchr_keep_out (const wchar_t *, wchar_t, size_t);
extern int  wmemcmp (const wchar_t *, const wchar_t *, size_t);
extern wchar_t *wmemcpy (wchar_t *, const wchar_t *, size_t);
extern wchar_t *wmemmove (wchar_t *, const wchar_t *, size_t);
extern wchar_t *wmemset (wchar_t *, wchar_t, size_t);
extern int wprintf (const wchar_t * , ...);
extern int wscanf (const wchar_t * , ...);
extern size_t wcrtomb (char *, wchar_t, mbstate_t *);
extern size_t wcsrtombs (char * , const wchar_t * * , size_t, mbstate_t * );
extern wchar_t *__wcsstr_keep_out (const wchar_t * , const wchar_t * );



 
extern wchar_t *wcscat (wchar_t *, const wchar_t *);
extern wchar_t *wcsncat (wchar_t *, const wchar_t *, size_t);
extern wchar_t *wcscpy (wchar_t *, const wchar_t *);
extern wchar_t *wcsncpy (wchar_t *, const wchar_t *, size_t);
extern size_t wcslen (const wchar_t *);
extern size_t wcsspn (const wchar_t *, const wchar_t *);
extern size_t wcscspn (const wchar_t *, const wchar_t *);
extern int wcscmp (const wchar_t *, const wchar_t *);
extern int wcsncmp (const wchar_t *, const wchar_t *, size_t);


extern size_t  wcsftime (wchar_t *, size_t, const wchar_t *, const struct tm *);

extern wchar_t *wcstok (wchar_t * , const wchar_t * , wchar_t * * );






#line 181 "/usr/include/wchar.h"
 




extern wchar_t *wcswcs (const wchar_t *, const wchar_t *);








extern int wcscoll (const wchar_t *, const wchar_t *);
extern size_t wcsxfrm (wchar_t * , const wchar_t * , size_t);



extern int           wcwidth (wchar_t);






extern int  wcswidth (const wchar_t *, size_t);


 
extern int iswalnum (wint_t);
extern int iswalpha (wint_t);
extern int iswcntrl (wint_t);
extern int iswdigit (wint_t);
extern int iswgraph (wint_t);
extern int iswlower (wint_t);
extern int iswprint (wint_t);
extern int iswpunct (wint_t);
extern int iswspace (wint_t);
extern int iswupper (wint_t);
extern int iswxdigit (wint_t);
extern wint_t towlower (wint_t);
extern wint_t towupper (wint_t);
extern wctype_t wctype (const char *);
extern int iswctype (wint_t, wctype_t);
 
extern wint_t fgetwc (FILE *);
extern wchar_t *fgetws (wchar_t *, int, FILE *);


extern wint_t fputwc (wchar_t, FILE *);
extern wint_t putwc (wchar_t, FILE *);
extern wint_t putwchar (wchar_t);






extern int fputws (const wchar_t *, FILE *);
extern wint_t getwc (FILE *);
extern wint_t getwchar (void);
extern wint_t ungetwc (wint_t, FILE *);
 
extern double wcstod (const wchar_t * , wchar_t * * );
extern long int wcstol (const wchar_t * , wchar_t * * , int);
extern unsigned long wcstoul (const wchar_t * , wchar_t * * , int);


extern long long wcstoll (const wchar_t * , wchar_t * * , int);
extern unsigned long long wcstoull (const wchar_t * , wchar_t * * , int);




     
#        pragma extern vfwscanf, vswscanf, vwscanf, wcstof, wcstold


extern int vwscanf (const wchar_t * , __va_list);
extern int vfwscanf (FILE * , const wchar_t * , __va_list);
extern int vswscanf (const wchar_t * , const wchar_t * , __va_list);
extern float wcstof (const wchar_t* , wchar_t * * );
extern long double wcstold (const wchar_t * , wchar_t * * );






extern wchar_t	*getws (wchar_t *);
extern int putws (const wchar_t *);









     
#line 289 "/usr/include/wchar.h"

#line 300 "/usr/include/wchar.h"









}


#pragma pop
#line 29 "/opt/aCC/include_std/cwchar"

#line 40 "/opt/aCC/include_std/cwchar"
#pragma extern wcschr, wcsrchr, wcspbrk, wcsstr, wmemchr





#line 52 "/opt/aCC/include_std/cwchar"












  extern "C" {
  extern const wchar_t       *wcschr(const wchar_t *, wchar_t);
  extern const wchar_t       *wcsrchr(const wchar_t *, wchar_t);
  extern const wchar_t       *wcspbrk(const wchar_t *, const wchar_t *);


  extern const wchar_t*       wcsstr(const wchar_t*, const wchar_t*);
  extern const wchar_t*       wmemchr(const wchar_t*, wchar_t, size_t);

  }

  
  inline wchar_t *wcschr(wchar_t *p, wchar_t c)
  { return const_cast<wchar_t *> (wcschr(const_cast<const wchar_t *>(p), c)); }
  inline wchar_t *wcsrchr(wchar_t *p, wchar_t c)
  { return const_cast<wchar_t *> (wcsrchr(const_cast<const wchar_t *>(p),c)); }
  inline wchar_t *wcspbrk(wchar_t *p, const wchar_t *q)
  { return const_cast<wchar_t *> (wcspbrk(const_cast<const wchar_t *>(p),q)); }


  inline wchar_t* wcsstr(wchar_t *p, const wchar_t *q)
  { return const_cast<wchar_t*>(wcsstr(const_cast<const wchar_t*>(p),q)); }
  inline wchar_t* wmemchr(wchar_t *p, wchar_t c, size_t n)
  { return const_cast<wchar_t*>(wmemchr(const_cast<const wchar_t*>(p),c,n)); }




#line 101 "/opt/aCC/include_std/cwchar"







namespace std {



using ::wint_t;
using ::mbstate_t;   
using ::size_t;
using ::tm;          




using ::fgetwc;
using ::fgetws;
using ::fputwc;
using ::fputws;
using ::getwc;
using ::getwchar;
using ::putwc;
using ::putwchar;
using ::ungetwc;
using ::wcscat;
using ::wcschr;
using ::wcscmp;
using ::wcscoll;
using ::wcscpy;
using ::wcscspn;
using ::wcsftime;
using ::wcslen;
using ::wcsncat;
using ::wcsncmp;
using ::wcsncpy;
using ::wcspbrk;
using ::wcsrchr;
using ::wcsspn;
using ::wcstod;
using ::wcstok;
using ::wcstol;
using ::wcstoul;
using ::wcsxfrm;



using ::btowc;
using ::fwide;
using ::fwprintf;
using ::fwscanf;
using ::mbrlen;
using ::mbrtowc;
using ::mbsinit;
using ::mbsrtowcs;
using ::swprintf;
using ::swscanf;
using ::vfwprintf;
using ::vswprintf;
using ::vwprintf;
using ::wcrtomb;
using ::wcsrtombs;
using ::wcsstr;
using ::wctob;
using ::wmemchr;
using ::wmemcmp;
using ::wmemcpy;
using ::wmemmove;
using ::wmemset;
using ::wprintf;
using ::wscanf;

}


#line 49 "/opt/aCC/include_std/string"
#line 1 "/opt/aCC/include_std/cwctype"










#pragma push binding
#pragma binding default
#line 1 "/usr/include/wctype.h"
 




#line 1 "/opt/aCC/include_std/wchar.h"





#line 74 "/opt/aCC/include_std/wchar.h"

#line 8 "/usr/include/wctype.h"


     extern "C" {






       typedef int wctrans_t;




     	extern wint_t        towctrans (wint_t, wctrans_t);
     	extern wctrans_t     wctrans (const char *);






        
#     pragma extern iswblank

   extern int iswblank (wint_t);



     }


#pragma pop
#line 13 "/opt/aCC/include_std/cwctype"



namespace std {



using ::wint_t;
using ::wctype_t;     

using ::wctrans_t;   

 



using ::iswalnum;
using ::iswalpha;
using ::iswcntrl;
using ::iswctype;
using ::iswdigit;
using ::iswgraph;
using ::iswlower;
using ::iswprint;
using ::iswpunct;
using ::iswspace;
using ::iswupper;
using ::iswxdigit;
using ::towlower;
using ::towupper;
using ::wctype;

using ::towctrans;
using ::wctrans;

}


#line 50 "/opt/aCC/include_std/string"

#line 1 "/opt/aCC/include_std/rw/string_ref"





























 






#line 1 "/opt/aCC/include_std/rw/traits"































 






#line 1 "/opt/aCC/include_std/rw/iotraits"































 











namespace std {


typedef ssize_t streamsize;
typedef ssize_t streamoff;
typedef ssize_t wstreamoff;


#line 92 "/opt/aCC/include_std/rw/iotraits"
  
  
  








 

template <class _StateT>
class fpos
{
public:

    typedef _StateT  state_type;
      
    fpos (streamoff __off = 0, state_type __state = state_type())
        : _C_pos (__off),
          _C_state (__state)
        { }

    operator streamoff () const {
        return _C_pos;
    }

    fpos (const fpos&);

    fpos& operator= (const fpos&);

    state_type state () const {
        return _C_state;
    }

    void state (state_type __state) {
        _C_state = __state;
    }

    
    fpos operator- (const fpos &__off) const {
        return fpos (*this) -= __off;
    }

    fpos operator+ (const fpos &__off) const {
        return fpos (*this) += __off;
    }

    fpos& operator-= (const fpos &__off) {
        return _C_pos -= __off._C_pos, *this;
    }

    fpos& operator+= (const fpos &__off) {
        return _C_pos += __off._C_pos, *this;
    }

    fpos operator- (streamoff __off) const {
        return fpos (*this) -= __off;
    }

    fpos operator+ (streamoff __off) const {
        return fpos (*this) += __off;
    }

    fpos& operator-= (streamoff __off) {
        return _C_pos -= __off, *this;
    }

    fpos& operator+= (streamoff __off) {
        return _C_pos += __off, *this;
    }


    
    bool operator== (const fpos& __rhs) const; 

    bool operator< (const fpos& __rhs) const {
        return _C_pos < __rhs._C_pos;
    }

    bool operator<= (const fpos& __rhs) const {
        return !(__rhs < *this);
    }

    bool operator>= (const fpos& __rhs) const {
        return !(*this < __rhs);
    }

    bool operator!= (const fpos& __rhs) const {
        return !(*this == __rhs);
    }

    bool operator> (const fpos& __rhs) const {
        return __rhs < *this;
    }

    bool operator== (streamoff __rhs) const {
        return _C_pos == __rhs;
    }

    bool operator< (streamoff __rhs) const {
        return _C_pos < __rhs;
    }

    bool operator<= (streamoff __rhs) const {
        return _C_pos <= __rhs;
    }

    bool operator>= (streamoff __rhs) const {
        return _C_pos >= __rhs;
    }

    bool operator> (streamoff __rhs) const {
        return _C_pos > __rhs;
    }

    bool operator!= (streamoff __rhs) const {
        return !(_C_pos == __rhs);
    }

private:

    streamoff   _C_pos;     
    state_type  _C_state;   
};


template <class _StateT> 
inline
fpos<_StateT>::fpos(const fpos<_StateT>& __rhs)
{
    _C_pos    = __rhs._C_pos;
    _C_state  = __rhs._C_state;
}


template <class _StateT>
inline fpos<_StateT>& 
fpos<_StateT>::operator= (const fpos<_StateT>& __rhs)
{
    if (&__rhs != this) {
        _C_pos    = __rhs._C_pos;
        _C_state  = __rhs._C_state;
    }
    return *this;
}


template <class _StateT>
inline bool 
fpos<_StateT>::operator== (const fpos<_StateT>& __rhs) const
{ 
    return    _C_pos == __rhs._C_pos



    ;
}

} 


#line 41 "/opt/aCC/include_std/rw/traits"




namespace std {


template <class  _CharT> 
struct char_traits 
{
    typedef _CharT                   char_type;
    typedef int                      int_type;


    typedef wstreamoff               off_type;
    typedef mbstate_t                state_type;
    typedef fpos<state_type>         pos_type;


    static void assign (char_type& __c1, const char_type& __c2) {
        __c1 = __c2;
    }

    static bool eq (const char_type& __c1, const char_type& __c2) {
        return __c1 == __c2;
    }

    static bool lt (const char_type& __c1, const char_type& __c2) {
        return __c1 < __c2;
    }

    static int compare (const char_type* __s1, const char_type* __s2,
                        size_t __n) {
        size_t __i = 0;
        while (__i < __n) { 
            if (!eq (__s1[__i], __s2[__i])) {
                return lt (__s1[__i], __s2[__i]) ? -1 : 1;
            }
            ++__i;
        }
        return 0;
    }
        
    static size_t length (const char_type *__s) {
        size_t __len = 0;
        while (!eq (*__s++, char_type ()))
            ++__len;
        return __len;
    }
 
    static const char_type* 
    find (const char_type* __s, size_t __n, const char_type& __a) {
        while (__n-- > 0 && !eq (*__s, __a) )
            ++__s;
        return  eq (*__s, __a) ? __s : 0;
    }

    static char_type* move (char_type* __s1, const char_type* __s2,
                            size_t __n) {
        if (__s1 < __s2)
            copy (__s1, __s2, __n);
        else if (__s1 > __s2) {
            __s1 += __n;
            __s2 += __n;
            for (size_t __i = 0; __i < __n; ++__i) 
                assign (*--__s1, *--__s2);
        }
        return __s1;
    }

    static char_type* copy (char_type *__dst, const char_type *__src,
                             size_t __n) {
        memcpy ((char*)__dst, (char*)__src, __n * sizeof (char_type));
        return __dst;
    }

    static char_type*  assign (char_type* __s, size_t __n, char_type __a) {
        char_type* __tmp = __s;
        while (__n-- > 0) 
            assign (*__tmp++, __a);
        return __s;
    }

    static int_type not_eof (const int_type& __c) {
        return eq_int_type (eof (), __c) ? 0 : __c;
    }

    static char_type to_char_type (const int_type& __c) {
        return __c;
    }
      
    static int_type to_int_type (const char_type& __c) {
        return __c;
    }

    static bool eq_int_type (const int_type& __c1, const int_type& __c2) {
        return __c1 == __c2;
    }


    static state_type get_state (pos_type __pos) {
        return __pos.state ();
    }


    static int_type eof () {
        return (-1);
    }
};



template< >  
struct char_traits<char> 
{
    typedef char                      char_type;
    typedef int              int_type;
       

    typedef streamoff                 off_type; 
    typedef mbstate_t                 state_type;
    typedef fpos<state_type>          pos_type;


    static void assign (char_type& __c1, const char_type& __c2){
        __c1 = __c2;
    }

    static bool eq (const char_type& __c1, const char_type& __c2) {
        return __c1 == __c2;
    }

    static bool lt (const char_type& __c1, const char_type& __c2) {
        return __c1 < __c2;
    }

    static int compare (const char_type* __s1, const char_type* __s2,
                        size_t __n) {
        return memcmp (__s1, __s2, __n);
    }

    static const char_type* find (const char_type* __s, 
                                  size_t __n, const char_type& __a) {
        return (char_type*) memchr (__s, __a, __n);
    }

    static size_t length (const char_type *__s) {
        return strlen (__s);
    }

    static char_type * move (char_type* __s1, const char_type* __s2,
                             size_t __n) {

        memmove (__s1, __s2, __n);
#line 207 "/opt/aCC/include_std/rw/traits"
        return __s1;
    }

    static char_type *copy (char_type *__dst, const char_type *__src,
                             size_t __n){
        memcpy (__dst, __src, __n); 
        return __dst;
    }

    static char_type* assign (char_type* __s, size_t __n, char_type __a) {
        memset (__s, __a, __n);
        return __s;
    }

    static int_type not_eof (const int_type& __c) {
        return eq_int_type (eof (), __c) ? 0 : __c;
    }
                        
    static char_type to_char_type (const int_type& __c) {
        return static_cast< char_type >(__c);
    }
      
    static int_type to_int_type (const char_type& __c) {
        
        return static_cast< unsigned char >(__c);
    }

    static bool eq_int_type (const int_type& __c1, const int_type& __c2) {
        return __c1 == __c2;
    }


    static state_type get_state (pos_type __pos) {
        return __pos.state ();
    }


    static int_type eof () {
        return (-1);
    }
};





template< >  
struct char_traits<wchar_t> 
{
    typedef wchar_t                   char_type;
    typedef wint_t             int_type;






    typedef wstreamoff                off_type;
    typedef mbstate_t                 state_type;
    typedef fpos<state_type>          pos_type;


    static void assign (char_type& __c1, const char_type& __c2) {
        __c1 = __c2;
    }

    static bool eq (const char_type& __c1, const char_type& __c2) {
        return __c1 == __c2;
    }

    static bool lt (const char_type& __c1, const char_type& __c2) {
        return __c1 < __c2;
    }

    static int compare (const char_type* __s1, const char_type* __s2,
                        size_t __n) {

        return memcmp (__s1, __s2, __n*sizeof (char_type));
#line 295 "/opt/aCC/include_std/rw/traits"
    }

    static size_t length (const char_type *__s) {

        return wcslen (__s);
#line 306 "/opt/aCC/include_std/rw/traits"
     }

      
    static const char_type* find (const char_type* __s, size_t __n, 
                                  const char_type& __a)           {



        while (__n-- > 0 && !eq (*__s, __a))
            ++__s;
        return  eq (*__s, __a) ? __s : 0;

    }

      
    static char_type * move (char_type* __s1, const char_type* __s2,
                             size_t __n) {

        memmove (__s1, __s2, __n*sizeof (char_type));
#line 336 "/opt/aCC/include_std/rw/traits"
        return __s1;
    }

    static char_type * copy (char_type *__dst, const char_type *__src,
                             size_t __n) {
        memcpy ((char*)__dst, (char*)__src, __n * sizeof (char_type));
        return __dst;
    }

    static char_type* assign (char_type* __s, size_t __n, char_type __a){



        char_type* __tmp = __s;
        while (__n-- > 0) 
            assign (*__tmp++, __a);

        return __s;
    }

    static int_type not_eof (const int_type& __c) {
        return eq_int_type (eof (), __c) ? 0 : __c;
    }

    static char_type to_char_type (const int_type& __c) {
        return __c;
    }
      
    static int_type to_int_type (const char_type& __c) {
        return __c;
    }

    static bool eq_int_type (const int_type& __c1, const int_type& __c2) {
        return __c1 == __c2;
    }


    static state_type get_state (pos_type __pos) {
        return __pos.state ();
    }


    static int_type eof () {
        return (wint_t)(-1);
    }
};




}   


namespace __rw {


using namespace std;






template <class _CharT, class _Traits> 
struct rw_traits
{
    static const _CharT* find (const _CharT* __s, const _CharT* __v) { 
        size_t __slen = _Traits::length (__s);
        size_t __vlen = _Traits::length (__v);
        for (size_t __j = 0; (__j + __vlen) <= __slen ; ++__j) {
            bool __found = true;
            for (size_t __i = 0; __i < __vlen ; ++__i) {
                if (!_Traits::eq (__s[__j + __i], __v[__i])) {
                    __found = false;
                    break;
                }
            }
            if (__found)
                return &__s[__j];
        }
        return 0;
    }

    static const _CharT* rfind (const _CharT* __s, _CharT __v, size_t __pos) {
        const _CharT* __p = __s + __pos;
        while (__p >= __s) {
            if (_Traits::eq (*__p, __v))
                return __p;
            __p--;
        }
        return 0;       
    }

    static size_t find_first_of (const _CharT* __s, const _CharT* __v) {
        const _CharT* __p = __s;
        for (; !_Traits::eq (*__p, _CharT ()); ++__p) {
            for (const _CharT* q = __v; !_Traits::eq (*q, _CharT ()); ++q)
                if (_Traits::eq (*__p, *q))
                    return __p - __s;
        }
        return  __p - __s;
    }

    static size_t find_first_not_of (const _CharT* __s, const _CharT* __v) {
        bool __found;
        const _CharT* __p = __s;
        for (; !_Traits::eq (*__p, _CharT ()); ++__p) {
            __found = false;
            for (const _CharT* q = __v; !_Traits::eq (*q, _CharT ()); ++q){
                if (_Traits::eq (*__p, *q)){
                    __found=true; 
                    break;
                }  
            }
            if (!__found)      
                return __p - __s;
        }
        return  __p-__s;
    }
};


template< > 
struct rw_traits<char, std::char_traits<char> >
{
    static const char* find (const char* __s, const char* __v) {
        return strstr (__s, __v);
    }

    static const char* rfind (const char* __s, char __v, size_t __pos) { 
        const char* __p = __s + __pos;
        while (__p >= __s)
        {
            if (std::char_traits<char>::eq (*__p, __v))
                return __p;
            __p--; 
        }
        return 0;       
    }

    static size_t find_first_of (const char* __s, const char* __v) {
        return strcspn (__s, __v);
    }

    static size_t find_first_not_of (const char* __s, const char* __v) {
        return strspn (__s, __v);
    }

};



template< > 
struct rw_traits<wchar_t, std::char_traits<wchar_t> >
{
    static const wchar_t* find (const wchar_t* __s, const wchar_t* __v) {



        return wcswcs (__s, __v);

    }

    static const wchar_t* rfind (const wchar_t* __s, wchar_t __v, 
                                size_t __pos) { 
        const wchar_t* __p = __s + __pos;
        while (__p >= __s) {
            if (std::char_traits<wchar_t>::eq (*__p, __v))
                return __p;
            __p--;
        }
        return 0;       
    }

    static size_t find_first_of (const wchar_t* __s, const wchar_t* __v) {
        return wcscspn (__s, __v);
    }

    static size_t find_first_not_of (const wchar_t* __s, const wchar_t* __v) {
        return wcsspn (__s, __v);
    }

};




}   


#line 39 "/opt/aCC/include_std/rw/string_ref"


namespace std {




#line 53 "/opt/aCC/include_std/rw/string_ref"





  template< class _CharT, class _Traits = char_traits<_CharT>, 
  class _Allocator = allocator<_CharT> >
  class basic_string;


}   


namespace __rw {

using std::basic_string;

  
  
  
  
  
  
  
  
  
  
  

  template <class _Allocator>
  class  __string_noref_rep
  {
  public:
     explicit __string_noref_rep(long refs = 0)
      : __refs_((bool)refs), __capacity_(0), __nchars_(0)  {;}
    __string_noref_rep(const __string_noref_rep& r)
      : __refs_((bool)r.__refs_), __capacity_(0), __nchars_(0)  {;}
  
    typedef _Allocator                           allocator_type;
    typedef typename allocator_type::size_type size_type;

  protected:

    size_type       __capacity_;  
    size_type       __nchars_;    
    bool            __refs_;      
  };

  template <class _CharT, class _Traits , class _Allocator>
  class __string_noref
   : public __string_noref_rep<_Allocator>
  {
  public:
    typedef __string_noref_rep<_Allocator> __string_ref_rep_type;
    typedef typename __string_noref_rep<_Allocator>::size_type size_type;
  
    explicit __string_noref (long=0) 
    { ; }

  private:
    long __references () const
    { 
      return (long)__string_noref_rep<_Allocator>::__refs_; 
    }
    void __setRefCount (long r)
    { ; }
    void __addReference ()
    { ; }
    long  __removeReference ()
    { 
      return (long)__string_noref_rep<_Allocator>::__refs_;
    }
    size_type length () const
    { 
      return __string_noref_rep<_Allocator>::__nchars_; 
    }
    size_type __getCapac () const
    { 
      return __string_noref_rep<_Allocator>::__capacity_;
    }
    _CharT*    data () const
    {
      return (_CharT*)(this+1);
    }
    _CharT&   operator[]     (size_type i)      
    { 
      return (reinterpret_cast< _CharT* >((this+1)))[i]; 
    }
    const _CharT&  operator[]     (size_type i) const
    {
      return ((_CharT*)(this+1))[i];
    }

    friend class basic_string<_CharT, _Traits, _Allocator>;
  };


  
  
  
  
  
  








  template <class _Allocator>
  class __string_ref_rep
  {
  public:
    
    
    
  
    __string_ref_rep()
      : __refs_(0), __capacity_(0), __nchars_(0)


       , __mutex_(1)

       {}
    __string_ref_rep(long x)
      : __refs_(x), __capacity_(0), __nchars_(0)


       , __mutex_(1)

       {}
    __string_ref_rep(const __string_ref_rep& r)
      : __refs_(r.__refs_), __capacity_(0), __nchars_(0)


       , __mutex_(1)

       {}
  
    typedef _Allocator                           allocator_type;
    typedef typename allocator_type::size_type size_type;

  protected:






    __rw_mutex __mutex_;







    long   __refs_;               
                                  
    size_type       __capacity_;  
    size_type       __nchars_;    
  };


  template <class _CharT, class _Traits , class _Allocator >
  class  __string_ref : public __string_ref_rep<_Allocator>
  {
  public:
    typedef __string_ref_rep<_Allocator> __string_ref_rep_type;
    typedef typename __string_ref_rep<_Allocator>::size_type size_type;
  
    explicit __string_ref (long initRef = 0) 
      :  __string_ref_rep<_Allocator>(initRef - 1)
    { ; }

    __string_ref (const __string_ref<_CharT,_Traits,_Allocator>& ref)
      : __string_ref_rep<_Allocator>(ref.__refs_)
    { ; }

  private:
    long __references () const 
    { 
      return __string_ref_rep<_Allocator>::__refs_+1; 
    }

    void __setRefCount (long r)       
    { 
      if (this != std::basic_string<_CharT,_Traits,_Allocator>::_C_get_null())
      {
         this->__refs_ = r - 1;
      }
    }

    void __addReference ()
    { 
      if (this != std::basic_string<_CharT,_Traits,_Allocator>::_C_get_null())
      {
         __rw::__rw_atomic_preincrement (this->__refs_, this->__mutex_);

      }
    }

    long  __removeReference () {
      if (this != std::basic_string<_CharT,_Traits,_Allocator>::_C_get_null())
      {
        return 1 + __rw::__rw_atomic_predecrement (this->__refs_, this->__mutex_);

      }
      else
        return 1;
    }

    size_type length () const
    { return __string_ref_rep<_Allocator>::__nchars_; }
    size_type __getCapac () const
    { return __string_ref_rep<_Allocator>::__capacity_;}

    _CharT*    data () const
    {
      return (_CharT*)(this+1);
    }
    _CharT&   operator[]     (size_type i)      
    { 
      return (reinterpret_cast< _CharT* >((this+1)))[i]; 
    }
    const _CharT&  operator[]     (size_type i) const
    {
      return ((_CharT*)(this+1))[i];
    }

    friend class basic_string<_CharT, _Traits, _Allocator>;
  };


  
  
  
  
  
  

  template <class _CharT, class _Traits , class _Allocator, 
            class stringRef = __string_ref_rep<_Allocator> >
  struct __null_string_ref_rep
  {
    
    
    
    stringRef      __ref_hdr_;
    _CharT          __eos_char_; 

    __null_string_ref_rep (_CharT __eos = _CharT ())
      : __ref_hdr_(1), __eos_char_(__eos) { }
    __null_string_ref_rep (const __null_string_ref_rep<_CharT,_Traits, 
                                                       _Allocator,stringRef>& r)
      : __ref_hdr_(r.__ref_hdr_), __eos_char_() {;}

  };


}   


#line 53 "/opt/aCC/include_std/string"






namespace std {

#line 68 "/opt/aCC/include_std/string"

} 








namespace __rw {








}   

namespace std {


template <class _CharT, class _Traits, class _Allocator>
class  basic_string
    : private _Allocator
{
public:

    typedef _Traits                               traits_type;
    typedef typename _Traits::char_type          value_type;
    typedef _Allocator                            allocator_type;

    
    
    
    
    
    
    

    typedef __rw::__string_ref<value_type, traits_type, allocator_type>
     _C_string_ref_type;




    
    
    
    
    typedef typename _C_string_ref_type::__string_ref_rep_type _C_rep_type;
    
    
    
    
    
    
    typedef __rw::__null_string_ref_rep<value_type, traits_type,
                                      allocator_type, _C_rep_type>
        _C_null_ref_type;

private:

    typedef  allocator_type          
        _C_value_alloc_type;
    typedef  typename allocator_type::template rebind < _C_string_ref_type > ::other  
        _C_ref_alloc_type;
      
public:

    typedef typename allocator_type::size_type       size_type;
    typedef typename allocator_type::difference_type difference_type;
    typedef typename allocator_type::reference       reference;
    typedef typename allocator_type::const_reference const_reference;
    typedef typename allocator_type::pointer         pointer;
    typedef typename allocator_type::const_pointer   const_pointer;

    

#line 167 "/opt/aCC/include_std/string"

    typedef pointer                        iterator;
    typedef const_pointer                  const_iterator;

    iterator _C_make_iter (pointer __ptr) {
        return __ptr;
    }

    const_iterator _C_make_iter (const_pointer __ptr) const {
        return __ptr;
    }






    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
#line 196 "/opt/aCC/include_std/string"




    static const size_type npos = size_type(-1);


    explicit
    basic_string (const allocator_type& = allocator_type());





    basic_string (const basic_string&);

    basic_string (const basic_string&, 
                  size_type, size_type = npos, 
                  const allocator_type&
                        = allocator_type ());

    basic_string (const_pointer, size_type, 
                  const allocator_type&
                        = allocator_type ());

    basic_string (const_pointer,
                  const allocator_type&
                        = allocator_type ());


#line 236 "/opt/aCC/include_std/string"




    
    
    
    






    template <class _InputIterator>
    basic_string (_InputIterator, _InputIterator, 
                  const allocator_type&
                        = allocator_type ());

    basic_string (int __n, value_type __c, 
                  const allocator_type& __alloc
                         = allocator_type ())
        : allocator_type (__alloc) {
        _C_initn (__n, __c);
    }

    basic_string (unsigned int __n, value_type __c, 
                  const allocator_type& __alloc
                        = allocator_type ())
      : allocator_type (__alloc) {
        _C_initn (__n, __c);
    }

    basic_string (long __n, value_type __c, 
                  const allocator_type& __alloc
                        = allocator_type ())
        : allocator_type (__alloc) {
        _C_initn (__n, __c);
    }

    basic_string (unsigned long __n, value_type __c, 
                  const allocator_type& __alloc
                         = allocator_type ())
        : allocator_type (__alloc) {
        _C_initn (__n, __c);
    }

    basic_string (short __n, value_type __c, 
                  const allocator_type& __alloc
                        = allocator_type ())
        : allocator_type (__alloc) {
        _C_initn (__n, __c);
    }

    basic_string (unsigned short __n, value_type __c, 
                  const allocator_type& __alloc
                        = allocator_type ())
        : allocator_type (__alloc) {
        _C_initn (__n, __c);
    }

    basic_string (char __n, value_type __c, 
                  const allocator_type& __alloc
                        = allocator_type ())
        : allocator_type (__alloc) {
        _C_initn (__n, __c);
    }

    basic_string (unsigned char __n, value_type __c, 
                  const allocator_type& __alloc
                        = allocator_type ())
        : allocator_type (__alloc) {  
        _C_initn (__n, __c);  
    }




    basic_string (wchar_t __n, value_type __c, 
                  const allocator_type& __alloc
                         = allocator_type ())
        : allocator_type (__alloc) {
        _C_initn (__n, __c);
    }






    basic_string (bool __n, value_type __c, 
                  const allocator_type& __alloc
                        = allocator_type ())
        : allocator_type (__alloc) {
        _C_initn (__n, __c);
    }




#line 346 "/opt/aCC/include_std/string"


    basic_string (const_pointer, const_pointer, 
                  const allocator_type&
                        = allocator_type ());









    ~basic_string () {
        _C_unlink();
    }

    basic_string& operator= (const basic_string&);
    basic_string& operator= (const_pointer __s);

    basic_string& operator= (value_type __c) {
        return replace (0, size(), 1, __c);
    }

    iterator begin () {
        _C_cow(); _C_pref()->__setRefCount(0);
        return _C_make_iter (_C_data);
    }

    const_iterator begin () const {
        return _C_make_iter (_C_data);
    }

    iterator end () {
        _C_cow(); _C_pref()->__setRefCount(0);
        return _C_make_iter (_C_data + size ());
    }

    const_iterator end () const {
        return _C_make_iter (_C_data+size());
    }

    reverse_iterator rbegin () {
        return reverse_iterator (end ());
    }

    const_reverse_iterator rbegin () const {
        return const_reverse_iterator (end());
    }

    reverse_iterator rend () {
        return reverse_iterator (begin());
    }

    const_reverse_iterator rend () const {
        return const_reverse_iterator (begin());
    }

    size_type size () const {
        return _C_pref()->__nchars_;
    }

    size_type length () const {
        return size ();
    }

    size_type max_size () const {
        return npos - sizeof (_C_rep_type) - 2;
    }

    void resize (size_type, value_type);

    void resize (size_type __n) {
        resize (__n, value_type ()); 
    }

    size_type capacity () const {
        return _C_pref()->__getCapac ();
    }

    void reserve (size_type = 0);

    void clear () {
        erase ();
    }

    bool empty () const  {
        return size () == 0;
    }

    const_reference operator[] (size_type) const;
    reference       operator[] (size_type);

    const_reference at (size_type) const;
    reference       at (size_type);

    basic_string& operator+= (const basic_string &__s) {
        return append (__s);
    }

    basic_string& operator+= (const_pointer __s) {
        return append (__s);
    }

    basic_string& operator+= (value_type __c) {
        return append (size_type (1), __c);
    }

    basic_string& append (const basic_string&, size_type, size_type);

    basic_string& append (const basic_string &__str) {
        return append (__str, 0, __str.size ());
    }

    basic_string& append (const_pointer __s, size_type __n) {
        return replace (size (), 0, __s, __n, 0, __n), *this;
    }

    basic_string& append (const_pointer __s) {
        return replace (size (), 0, __s);
    }




    template<class _InputIterator>
    basic_string& append (_InputIterator __first, _InputIterator __last) {
        
        
        
        return append (__first, __last, ((_C_dispatch <void, numeric_limits< _InputIterator > ::is_integer> *)0));
    }

    template<class _InputIterator>
    basic_string& append (_InputIterator __first, _InputIterator __last,
                          const _C_dispatch <void, false > *) {
        
        
        return replace (end (), end (), __first, __last), *this;
    }

    basic_string& append (size_type __n, value_type __c,
                          const _C_dispatch <void, true > *) {
        
        return replace (size (), 0, __n, __c);
    }

#line 502 "/opt/aCC/include_std/string"

    basic_string& append (size_type __n, value_type __c) {
        return replace (size (), 0, __n, __c);
    }

    void push_back (value_type __c) {
        append (size_type (1), __c);
    }

    basic_string& assign (const basic_string &__str) {
        return replace (0, size (), __str);
    }

    basic_string& assign (const basic_string&, size_type, size_type);

    basic_string& assign (const_pointer __s, size_type __n) {
        return replace (0, size (), __s, __n, 0, __n), *this;
    }

    basic_string& assign (const_pointer __s) {
        return assign (__s, traits_type::length (__s));
    }





    template<class _InputIterator>
    basic_string& assign (_InputIterator __first, _InputIterator __last) {
        
        
        
        return assign (__first, __last, ((_C_dispatch <void, numeric_limits< _InputIterator > ::is_integer> *)0));
    }

    template<class _InputIterator>
    basic_string& assign (_InputIterator __first, _InputIterator __last,
                          const _C_dispatch <void, false > *) {
        
        
        return replace (begin (), end (), __first, __last);
    }

    basic_string& assign (size_type __n, value_type __c,
                          const _C_dispatch <void, true > *) {
        
        return replace (0, size (), __n, __c);
    }

#line 560 "/opt/aCC/include_std/string"

    basic_string& assign (size_type __n, value_type __c) {
        return replace (0, size (), __n, __c);
    }

    basic_string& insert (size_type, const basic_string&);
    basic_string& insert (size_type, const basic_string&,
                          size_type, size_type);

    basic_string& insert (size_type __pos, const_pointer __s, size_type __n) {
        return replace (__pos, 0, __s, __n, 0, __n), *this;
    }

    basic_string& insert (size_type __pos, const_pointer __s) {
        return insert (__pos, __s, traits_type::length (__s));
    }

    iterator insert (iterator __pos, value_type __c) { 
      iterator __tmp = __replace_aux(__pos-begin(), 0, basic_string(1, __c)); 
      _C_pref()->__setRefCount(0);
      return __tmp;
    }





    template<class _InputIterator>
    void insert (iterator __p,
                 _InputIterator __first, _InputIterator __last) {
        
        
        
        
        insert (__p, __first, __last, ((_C_dispatch <void, numeric_limits< _InputIterator > ::is_integer> *)0));
    }

    template<class _InputIterator>
    void insert (iterator __p, _InputIterator __first, _InputIterator __last,
                 const _C_dispatch <void, false >*) {
        
        
        
        replace (__p, __p, __first, __last);
    }

    void insert (iterator __p, size_type __n, value_type __c,
                 const _C_dispatch <void, true > *) {
        
        replace (__p - begin(), 0, __n, __c);
    }

#line 619 "/opt/aCC/include_std/string"
    

    void insert (iterator __p, size_type __n, value_type __c) {
        replace (__p - begin(), 0, __n, __c);
    }

    basic_string& insert (size_type __pos, size_type __n, value_type __c) {
        return replace (__pos, 0, __n, __c);
    }

    basic_string& erase (size_type = 0, size_type = npos);

    iterator erase (iterator it) { 
        iterator __tmp = replace (it - begin(), 1, const_pointer (0), 0, 0, 0);
        _C_pref()->__setRefCount(0);
        return __tmp;
    }

    iterator erase (iterator __first, iterator __last) {  
        iterator __tmp =  replace (__first - begin (), __last - __first,
                                   const_pointer (0), 0, 0, 0);
        _C_pref()->__setRefCount(0);
        return __tmp;
    }

private:  
    
    
    
    iterator replace (size_type, size_type, const_pointer,
                      size_type, size_type, size_type);

    iterator __replace_aux (size_type pos1, size_type __n1,
                            const basic_string &__str,
                            size_type pos2 = 0,
                            size_type __n2   = npos) {
        return replace (pos1, __n1, __str.c_str(), __str.size(), pos2, __n2);
    }




    template<class _InputIterator>
    basic_string& __replace_aux (iterator       first1,
                                 iterator       last1, 
                                 _InputIterator first2,
                                 _InputIterator last2);



  public:

    basic_string& replace (size_type pos1, size_type __n1,
                           const basic_string &__s,
                           size_type pos2, size_type __n2) {
        return replace (pos1, __n1, __s.c_str (), __s.size (), pos2, __n2), *this;
    }

    basic_string& replace (size_type __pos, size_type __n,
                           const basic_string &__s) {
        return replace (__pos, __n, __s, 0, __s.size ());
    }


    basic_string& replace (size_type __pos, size_type __n1, const_pointer __s,
                           size_type __n2) {
        return replace (__pos, __n1, __s, __n2, 0, __n2), *this;
    }

    basic_string& replace (size_type __pos, size_type __n, const_pointer __s) {
        return replace (__pos, __n, __s, traits_type::length (__s));
    }

    basic_string& replace (size_type, size_type, size_type, value_type);

    basic_string& replace (iterator __first, iterator __last,
                           const basic_string &__str) {
        return replace (__first - begin (), __last - __first, __str);
    }

    basic_string& replace (iterator __first, iterator __last,
                           const_pointer __s, size_type __n) {
        return replace (__first - begin (), __last - __first, __s, __n, 0, __n), *this;
    }

    basic_string& replace (iterator __first, iterator __last, const_pointer __s) {
        return replace (__first, __last, __s, traits_type::length(__s));
    }





    template<class _InputIterator>
    basic_string& replace (iterator __i1, iterator __i2,
                           _InputIterator __j1, _InputIterator __j2) {
        
        
        
        
        return replace (__i1, __i2, __j1, __j2,
                        ((_C_dispatch <void, numeric_limits< _InputIterator > ::is_integer> *)0));
    }

    template<class _InputIterator>
    basic_string& replace (iterator, iterator,
                           _InputIterator, _InputIterator,
                           const _C_dispatch <void, false > *);


    basic_string& replace (iterator __first, iterator __last,
                           size_type __n, value_type __c,
                           const _C_dispatch <void, true > *) {
        
        return replace (__first - begin (), __last - __first, __n, __c);
    }

#line 745 "/opt/aCC/include_std/string"

    basic_string& replace (iterator __first, iterator __last,
        size_type __n, value_type __c) {

        
        return replace (__first - begin (), __last - __first, __n, __c);
    }

    size_type copy (pointer, size_type, size_type = 0) const;
    basic_string copy () const; 

    void swap (basic_string &__s) {
        pointer __temp = _C_data;
        _C_data = __s._C_data;
        __s._C_data = __temp;
    }

    
    
    
    const_pointer c_str () const {
        return _C_data;
    }

    const_pointer data () const {
        return _C_data;
    }

    allocator_type get_allocator() const {
        return *this;
    }

    
    size_type find (const basic_string &__str, size_type __pos = 0) const {
        return find (__str.c_str (), __pos, __str.size ());
    }

    
    size_type find (const_pointer, size_type, size_type) const;

    
    size_type find (const_pointer, size_type = 0) const;

    
    size_type find (value_type, size_type = 0) const;

    
    size_type rfind (const basic_string &__str, size_type __pos = npos) const {
        return rfind (__str.c_str (), __pos, __str.size ());
    }

    
    size_type rfind (const_pointer, size_type, size_type) const;

    
    size_type rfind (const_pointer __s, size_type __pos = npos) const {
        return rfind (__s, __pos, traits_type::length (__s));
    }

    
    size_type rfind (value_type, size_type = npos) const;

    
    size_type find_first_of (const basic_string &__str,
                             size_type __pos = 0) const {
        return find_first_of (__str.c_str (), __pos, __str.size ());
    }

    
    size_type find_first_of (const_pointer, size_type, size_type) const;

    
    size_type find_first_of (const_pointer, size_type = 0) const;

    
    size_type find_first_of (value_type __c, size_type __pos = 0) const {
        return find (__c, __pos);
    }

    
    size_type find_last_of (const basic_string &__str,
                            size_type __pos = npos) const {
        return find_last_of (__str.c_str (), __pos, __str.size ());
    }

    
    size_type find_last_of (const_pointer, size_type, size_type) const;

    
    size_type find_last_of (const_pointer __s, size_type __pos = npos) const {
        return find_last_of (__s, __pos, traits_type::length (__s));
    }

    
    size_type find_last_of (value_type __c, size_type __pos = npos) const {
        return rfind (__c, __pos);
    }

    
    size_type find_first_not_of (const basic_string &__str, 
                                 size_type __pos = 0) const {
        return find_first_not_of (__str.c_str (), __pos, __str.size ());
    }

    
    size_type find_first_not_of (const_pointer, size_type,
                                 size_type) const;

    
    size_type find_first_not_of (const_pointer, size_type = 0) const;

    
    size_type find_first_not_of (value_type, size_type = 0) const;

    
    size_type find_last_not_of (const basic_string &__str, 
                                size_type __pos = npos) const {
        return find_last_not_of (__str.c_str (), __pos, __str.size ());
    }

    
    size_type find_last_not_of (const_pointer, size_type, size_type) const;

    
    size_type find_last_not_of (const_pointer __s,
                                size_type __pos = npos) const {
        return find_last_not_of (__s, __pos, traits_type::length (__s));
    }

    
    size_type find_last_not_of (value_type, size_type = npos) const;
  
    
    basic_string substr (size_type = 0, size_type = npos) const;
  
    int compare (const basic_string &__str) const {
        return compare (0, size (), __str.c_str (), __str.size ());
    }

    int compare (size_type __pos, size_type __n, const basic_string &__str) const {
        return compare (__pos, __n, __str.c_str(), __str.size());
    }

    int compare (size_type, size_type, const basic_string&, 
                size_type, size_type) const;

    int compare (const_pointer __s) const {
        return compare (0, size (), __s, traits_type::length(__s));
    }

    int compare (size_type, size_type, const_pointer, size_type) const;

    int compare (size_type __pos, size_type __n, const_pointer __s) const {
        return compare(__pos, __n, __s, traits_type::length (__s));
    }

  protected:

    void _C_cow () {             
        if (_C_pref ()->__references() > 1) 
            _C_clone(); 
    }

    void _C_cow (size_type __nc) {   
        if (_C_pref ()->__references () > 1 || capacity () < __nc)
            _C_clone (__nc);
    }

  private:

    void _C_initn(size_type, value_type);

    
    
    
    void _C_clone (size_type __nc = npos);

    _C_string_ref_type *  _C_pref () const { 



      return reinterpret_cast< _C_string_ref_type* >(_C_data) - 1; 

    }

    
    
    
    void _C_unlink ();   


    friend
    class __rw::__string_ref<value_type, traits_type, allocator_type>;




    
    
    

    static const _C_null_ref_type __nullref;


    static _C_string_ref_type* _C_get_null ()
    {

      return reinterpret_cast< _C_string_ref_type* >(const_cast< _C_null_ref_type* >(&__nullref));
#line 963 "/opt/aCC/include_std/string"
    }
    _C_string_ref_type * _C_getRep (size_type capac, size_type nchar);

    pointer   _C_data;
};



  template <>
  const basic_string<char, char_traits<char>, allocator<char> >::_C_null_ref_type basic_string<char, char_traits<char>, allocator<char> >::__nullref;

  template <>
  const basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >::_C_null_ref_type basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >::__nullref;






  typedef basic_string<char, char_traits<char>, allocator<char> >
  string;


  typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >
  wstring;


  template <class _CharT, class _Traits , class _Allocator>
  inline void basic_string<_CharT, _Traits, _Allocator>::_C_unlink()
  {
    if (!_C_data)
      return;
    if (_C_pref()->__references() == 0 || _C_pref()->__removeReference() == 0) 
    {
      
      
      size_type dealloc_size =
          capacity() + sizeof(_C_rep_type)/sizeof(value_type) + 2;

      _C_ref_alloc_type(*this).destroy(_C_pref());
      allocator_type::deallocate (reinterpret_cast< pointer >(_C_pref()), dealloc_size);



      _C_data = 0;
    }
  }

  template <class _CharT, class _Traits , class _Allocator>
  inline basic_string<_CharT, _Traits, _Allocator>
  ::basic_string (const allocator_type& __alloc)
      : allocator_type (__alloc)
  {
    _C_data = _C_get_null()->data();
    _C_get_null()->__addReference();
  }

#line 1029 "/opt/aCC/include_std/string"


template <class _CharT, class _Traits , class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>::
basic_string (const basic_string<_CharT, _Traits, _Allocator> &__s)
    : allocator_type (__s.get_allocator ())
{                     
    if (__s._C_pref()->__references () > 0) {
        _C_data = __s._C_data;
        _C_pref()->__addReference ();
    }
    else {
        size_type __n = __s.size();
        _C_data  = _C_getRep (__n, __n)->data ();
        traits_type::copy (_C_data, __s.c_str (), __n);
    }
}


template <class _CharT, class _Traits , class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::erase (size_type __pos,
                                                  size_type __n)
{
    (__pos <= size ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string" ":" "1053" ": "). _C_format ((0 + 9), "basic_string<>::erase (size_type, size_type)", __pos, size ());




    const value_type __tmp = value_type();
    size_type __len = size () - __pos;
    return replace (__pos, __n < __len ? __n : __len, &__tmp, 0);
}


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::const_reference 
basic_string<_CharT, _Traits, _Allocator>::operator[] (size_type __pos) const
{
#line 1074 "/opt/aCC/include_std/string"
    return _C_data [__pos];
}


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::operator[] (size_type __pos)
{
#line 1089 "/opt/aCC/include_std/string"
    _C_cow();
    _C_pref()->__setRefCount(0);
    return _C_data[__pos];
}


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::at (size_type __pos) const
{
    (__pos < size()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string" ":" "1099" ": "). _C_format ((0 + 9), "basic_string<>::at (size_type) const", __pos, size());




    return _C_data[__pos];
}


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::at (size_type __pos)
{
    (__pos < size()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string" ":" "1112" ": "). _C_format ((0 + 9), "basic_string<>::at (size_type)", __pos, size());




    _C_cow();
    _C_pref()->__setRefCount(0);
    return _C_data[__pos];
}


  template <class _CharT, class _Traits , class _Allocator>
  inline void
  basic_string<_CharT, _Traits, _Allocator>::
  resize (size_type __n, value_type __c)
  {
      (__n <= max_size ()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string" ":" "1128" ": "). _C_format ((0 + 8), "basic_string::resize (size_type, value_type)", __n, max_size());



      
    if (__n < size())
      erase(__n, size()-__n);
    else
      replace (size(), 0, __n-size(), __c);
    _C_pref()->__setRefCount(1);
  }

  template <class _CharT, class _Traits , class _Allocator>
  inline void basic_string<_CharT, _Traits, _Allocator>::
  reserve(size_type res_arg)
  {
     (res_arg <= max_size ()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string" ":" "1144" ": "). _C_format ((0 + 8), "basic_string::reserve (size_type)", res_arg, max_size());



    if (res_arg > capacity())
        _C_clone(res_arg);
  }

  template <class _CharT, class _Traits , class _Allocator>
  inline basic_string<_CharT, _Traits, _Allocator>
  basic_string<_CharT, _Traits, _Allocator>::copy () const
  {
    basic_string __temp(*this); 
    __temp._C_clone();   
    return __temp;
  }


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
find (const_pointer __s, size_type __pos) const
{
    ((void)0);

    
    if (__pos > size ())
        return npos;

    const_pointer __where =
        __rw::rw_traits<value_type, traits_type>::find (_C_data + __pos, __s);
 
   return __where ? __where - _C_data : npos;
}


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
find (value_type __c, size_type __pos) const
{
    if (__pos > size())
        return npos;

    const_pointer __where =  traits_type::find (_C_data + __pos,
                                                size() - __pos, __c);
    return __where ? __where  - _C_data : npos;
}


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
rfind (value_type __c, size_type __pos) const
{
    if (!size ())
        return npos;

    if (__pos >= size ())
        __pos = size () - 1;   

    const_pointer __where =
        __rw::rw_traits<value_type, traits_type>::rfind (_C_data,
                                                            __c, __pos);
    return __where ? __where - _C_data : npos;
}


  template <class _CharT, class _Traits , class _Allocator>
  inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
  basic_string<_CharT, _Traits, _Allocator>::
  find_first_of (const_pointer __s, size_type __pos) const
  {
    ((void)0);

    if (__pos > size())
      return npos;
    size_type __i = __rw::rw_traits<_CharT, _Traits>::find_first_of(_C_data+__pos, __s) + __pos;
    return __i >= size() ? npos : __i;
  }

  template <class _CharT, class _Traits , class _Allocator>
  inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
  basic_string<_CharT, _Traits, _Allocator>::
  find_first_not_of (const_pointer __s, size_type __pos) const
  {
    ((void)0);

    if (__pos > size())
      return npos;
    size_type __i = __rw::rw_traits<_CharT, _Traits>::find_first_not_of(_C_data+__pos, __s) + __pos;
    return __i >= size() ? npos : __i;
  }


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
find_first_not_of (value_type __c, size_type __pos) const
{
    return find_first_not_of (&__c, __pos, 1);
}


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
find_last_not_of (value_type __c, size_type __pos) const
{




    value_type __tmp [2];
    traits_type::assign (__tmp [0], __c);
    traits_type::assign (__tmp [1], value_type ());


    return find_last_not_of (__tmp, __pos);
}


template <class _CharT, class _Traits, class _Allocator>
inline void
basic_string<_CharT, _Traits, _Allocator>::_C_clone (size_type __nc  )
{
    size_type __len = size();
    _C_string_ref_type * __temp = _C_getRep (npos == __nc ? size () : __nc,
                                             __len > __nc ? __nc : __len);
    traits_type::copy (__temp->data(), _C_data, size());
    _C_unlink ();
    _C_data = __temp->data();
}



template <class _CharT, class _Traits , class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>
operator+ (const basic_string<_CharT, _Traits, _Allocator> &__lhs, 
           const basic_string<_CharT, _Traits, _Allocator> &__rhs)
{
    return basic_string<_CharT, _Traits, _Allocator>(__lhs) += __rhs;
}



template <class _CharT, class _Traits , class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>
operator+ (const _CharT*                                    __lhs, 
           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return basic_string<_CharT, _Traits, _Allocator>(__lhs) += __rhs;
}



template <class _CharT, class _Traits , class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>
operator+ (_CharT __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return basic_string<_CharT, _Traits, _Allocator>(1, __lhs) += __rhs;
}



template <class _CharT, class _Traits , class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>
operator+ (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
           const _CharT*                                    __rhs)
{
    return basic_string<_CharT, _Traits, _Allocator>(__lhs) += __rhs;
}



template <class _CharT, class _Traits , class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>
operator+ (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
           _CharT                                           __rhs)
{
    return basic_string<_CharT, _Traits, _Allocator>(__lhs) += __rhs;
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator== (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return 0 == __lhs.compare (__rhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator== (const _CharT*                                    __lhs, 
            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return 0 == __rhs.compare (__lhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator== (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
            const _CharT*                                    __rhs)
{
    return 0 == __lhs.compare (__rhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return 0 > __lhs.compare (__rhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator< (const _CharT*                                    __lhs, 
           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return 0 < __rhs.compare (__lhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT*                                    __rhs)
{
    return 0 > __lhs.compare (__rhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator!= (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return !(__lhs == __rhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return __rhs < __lhs;
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator<= (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return !(__rhs < __lhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator>= (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return !(__lhs < __rhs);
}



template <class _CharT, class _Traits, class _Allocator>
inline void swap (basic_string<_CharT, _Traits, _Allocator>& __a, 
                  basic_string<_CharT, _Traits, _Allocator>& __b)
{
    __a.swap (__b);
}




template <class _CharT, class _Traits , class _Allocator>
inline bool
operator!= (const _CharT*                                    __lhs, 
            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return !(__lhs == __rhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator!= (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
            const _CharT*                                    __rhs)
{
    return !(__lhs == __rhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator> (const _CharT*                                    __lhs, 
           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return __rhs < __lhs;
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
           const _CharT*                                    __rhs)
{
    return __rhs < __lhs;
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator<= (const _CharT*                                    __lhs, 
            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return !(__rhs < __lhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator<= (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
            const _CharT*                                    __rhs)
{
    return !(__rhs < __lhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator>= (const _CharT*                                    __lhs, 
            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return !(__lhs < __rhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator>= (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
            const _CharT*                                    __rhs)
{
    return !(__lhs < __rhs);
}


}   


namespace __rw {






template <class _CharT, class _Traits, class _Allocator>
inline size_t
__rw_new_capacity (size_t __size,
                   const std::basic_string<_CharT, _Traits, _Allocator>*)
{
    size_t __cap = 
        static_cast< size_t >(__size * float(1.618));
    return (__size += size_t(128)) > __cap ? __size : __cap;
}                     

#line 1560 "/opt/aCC/include_std/string"

}   


#line 1 "/opt/aCC/include_std/string.cc"








 








namespace std {







    template <class _CharT, class _Traits, class _Allocator>
    const typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::npos;





  template <class _CharT, class _Traits, class _Allocator>
  const typename basic_string<_CharT, _Traits, _Allocator>::_C_null_ref_type
  basic_string<_CharT, _Traits, _Allocator>::__nullref = _CharT ();



template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::_C_string_ref_type *
basic_string<_CharT, _Traits, _Allocator>::
_C_getRep (size_type __cap, size_type __len)
{
    (__cap <= max_size ()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "45" ": "). _C_format ((0 + 8), "basic_string::_C_getRep (size_type, size_type)", __cap, max_size ());




    (__len <= __cap) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "50" ": "). _C_format ((0 + 8), "basic_string::_C_getRep (size_type, size_type)", __len, __cap);



    if ((__cap | __len) == 0) {
        _C_get_null()->__addReference();
        return _C_get_null();
    }

    
    _C_string_ref_type * __ret =
    reinterpret_cast< _C_string_ref_type* >(allocator_type::allocate (__cap + sizeof (_C_string_ref_type) / sizeof (value_type) + 2));




    
    
    new (__ret) _C_string_ref_type ();

    __ret->__capacity_ = __cap;
    __ret->__nchars_ = __len;


    
    __ret->__setRefCount(1);
 





    allocator_type::construct (__ret->data () + __len, value_type ());


    return __ret;
}


template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::
basic_string (const basic_string &__s, 
              size_type __pos, size_type __n, const allocator_type& __alloc)
    : allocator_type (__alloc)
{
    (__pos <= __s . size ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string.cc" ":" "95" ": "). _C_format ((0 + 9), "basic_string<>::basic_string (const basic_string&, size_type, size_type)", __pos, __s . size ());




    size_type __slen = __s.size() - __pos;
    size_type __rlen = __n < __slen ? __n : __slen; 
    size_type __nlen =  __n == npos ? 0 : __n;
    size_type __maxlen = __nlen > __rlen ? __nlen : __rlen; 
    if (__maxlen) 
      _C_data = _C_getRep(std::max(__rw::__rw_new_capacity(0, this),
                                size_t (__maxlen)),
                           __rlen)->data();
    else
      _C_data = _C_getRep(__maxlen,__rlen)->data();

    traits_type::copy(_C_data, &__s._C_data[__pos], __rlen);
}


template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::
_C_initn (size_type __n, value_type __c)
{
    (__n <= max_size ()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "119" ": "). _C_format ((0 + 8), "basic_string::_C_initn (size_type, value_type)", __n, max_size ());



   
      _C_data = _C_getRep(__n, __n)->data();

    while (__n--) traits_type::assign(_C_data[__n], __c);
}


template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::
basic_string (const_pointer __s, size_type __n, const allocator_type& __alloc)
    : allocator_type (__alloc)
{     
    ((void)0);
    
    (__n <= max_size ()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "137" ": "). _C_format ((0 + 8), "basic_string<>::basic_string (const_pointer , size_type, const allocator_type&)", __n, max_size ());



    
    if (__n)
      _C_data = _C_getRep(std::max(__rw::__rw_new_capacity(0, this), size_t(__n)),
                           __n)->data();
    else
      _C_data = _C_getRep(__n, __n)->data();
    traits_type::copy(_C_data, __s, __n);
}


template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::
basic_string (const_pointer __s, const allocator_type& __alloc)
    : allocator_type(__alloc)
{     
    ((void)0);

    size_type __len = traits_type::length(__s);
    if (__len)
        _C_data = _C_getRep(std::max(__rw::__rw_new_capacity(0, this),
                                  size_t (__len)),
                             __len)->data();
    else
      _C_data = _C_getRep(__len, __len)->data();

    traits_type::copy(_C_data, __s, __len);
}


#line 211 "/opt/aCC/include_std/string.cc"




template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator>
basic_string<_CharT, _Traits, _Allocator>::
basic_string (_InputIterator __first, _InputIterator __last, 
              const allocator_type &__alloc)
    : allocator_type(__alloc)
{
    _C_data = _C_getRep(__rw::__rw_new_capacity(0, this), 0)->data();
    replace(_C_make_iter (_C_data), _C_make_iter (_C_data), __first, __last);
}




template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::
basic_string (const_pointer __first, const_pointer __last, 
              const allocator_type& __alloc)
    : allocator_type(__alloc)
{
    if(__last-__first)
      _C_data = _C_getRep(std::max(__rw::__rw_new_capacity(0, this), 
                                size_t (__last - __first)), 0)->data();
    else
      _C_data = _C_getRep(__last-__first, 0)->data();
    replace(0, 0, __first, __last-__first, 0, __last-__first);
}


#line 259 "/opt/aCC/include_std/string.cc"


template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::
operator= (const basic_string<_CharT, _Traits, _Allocator>& __str)
{
    if (this != &__str)
    {
      if (__str._C_pref()->__references() > 0)
      {
        __str._C_pref()->__addReference();
        _C_unlink();
        _C_data = __str._C_data;
      }
      else
        this->replace(0, size(), __str.data(), __str.size());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator= (const_pointer __s)
{
    ((void)0);

    if (traits_type::eq(*__s, value_type()))
    {
      if (_C_pref()->__references() == 1)
      {
        _C_pref()->__nchars_ = 0;
        traits_type::assign(_C_data[0], value_type());
      }
      else
      {
        _C_unlink();
        _C_get_null()->__addReference();
        _C_data = _C_get_null()->data();
      }
      return *this;
    }

    return replace(0, size(), __s, traits_type::length(__s));
}


template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::
append (const basic_string<_CharT, _Traits, _Allocator>& __str, 
        size_type                                       __pos, 
        size_type                                       __n)
{
    (__pos <= __str . size ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string.cc" ":" "313" ": "). _C_format ((0 + 9), "basic_string<>::append (const basic_string&, size_type, size_type)", __pos, __str . size ());




    size_type __slen = __str.size() - __pos;
    size_type __rlen = __n < __slen ? __n : __slen; 


    (size () <= max_size () - __rlen) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "322" ": "). _C_format ((0 + 8), "basic_string<>::append (const basic_string&, size_type, size_type)", size (), max_size () - __rlen);




    replace(size(), 0, __str.c_str(), __str.size(), __pos, __n);

    return *this;
}


template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::
assign (const basic_string<_CharT, _Traits, _Allocator>& __str, 
        size_type                                       __pos, 
        size_type                                       __n)
{
    (__pos <= __str . size ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string.cc" ":" "340" ": "). _C_format ((0 + 9), "basic_string<>::assign (basic_string&, size_type, size_type)", __pos, __str . size ());



    
    size_type __slen = __str.size() - __pos;
    size_type __rlen = __n < __slen ? __n : __slen; 
    return replace(0, size(), __str, __pos, __rlen);
}


template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::
insert (size_type                                       pos1, 
        const basic_string<_CharT, _Traits, _Allocator>& __str, 
        size_type                                       pos2, 
        size_type                                       __n)
{
    (pos1 <= size() && pos2 <= __str . size ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string.cc" ":" "359" ": "). _C_format ((0 + 9), "basic_string<>::insert (size_type, const basic_string&, size_type, size_type)", pos1 > size() ? pos1:pos2, __str . size());



    
    size_type __slen = __str.size() - pos2;
    size_type __rlen = __n < __slen ? __n : __slen; 

    (size () <= max_size () - __rlen) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "367" ": "). _C_format ((0 + 8), "basic_string<>::insert (size_type, const basic_string&, size_type, size_type)", size (), max_size () - __rlen);




    return replace(pos1, 0, __str, pos2, __n);
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::
insert (size_type pos1, const basic_string &__str)
{
    (pos1 <= size ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string.cc" ":" "380" ": "). _C_format ((0 + 9), "basic_string<>::insert (size_type, const basic_string&)", pos1, size ());



    
    (size() <= max_size() - __str . size()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "385" ": "). _C_format ((0 + 8), "basic_string::insert(size_t, const basic_string&)", size (), max_size () - __str . size ());




    return replace(pos1, 0, __str);
}


template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::iterator 
basic_string<_CharT, _Traits, _Allocator>::
replace (size_type pos1, size_type __n1, const_pointer cs, 
         size_type cslen, size_type pos2, size_type __n2)
{
    (pos1 <= size () && pos2 <= cslen) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string.cc" ":" "400" ": "). _C_format ((0 + 9), "basic_string<>::replace (size_type, size_type, const_pointer, size_type, size_type, size_type)", pos1 > size() ? pos1 : pos2, size () > cslen ? size () : cslen);





    size_type __slen = size() - pos1;
    size_type __xlen = __n1 < __slen ? __n1 : __slen; 
    size_type __clen = cslen - pos2;
    size_type __rlen = __n2 < __clen ? __n2 : __clen; 

    (size() - __xlen <= max_size () - __rlen && max_size () >= __rlen) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "411" ": "). _C_format ((0 + 8), "basic_string<>::replace (size_type, size_type, const_pointer, size_type, size_type, size_type)", size () - __xlen, max_size() - __rlen);





    size_type tot = size() - __xlen + __rlen;  

    if (!tot)
    {
      
      _C_unlink();
      _C_get_null()->__addReference();
      _C_data = _C_get_null()->data();
    }
    else
    {
      size_type rem = size() - __xlen - pos1;  
      
      
      if ( (_C_pref()->__references() > 1)
           || (capacity() < tot)
           || (cs && (cs >= data() && cs < data()+size())))
      {
        
        size_t __new_capacity = std::max(__rw::__rw_new_capacity(size(), this),
                                     size_t (tot));
        _C_string_ref_type * __temp = _C_getRep(__new_capacity, tot);
        if (pos1) traits_type::copy(__temp->data(), _C_data, pos1);
        if (__rlen) traits_type::copy(__temp->data()+pos1, cs+pos2, __rlen);
        if (rem ) traits_type::copy(__temp->data()+pos1+__rlen, _C_data+pos1+__n1, rem);
        _C_unlink();
        _C_data = __temp->data();
      }
      else
      {
        
        if (rem)
            traits_type::move(_C_data+pos1+__rlen, _C_data+pos1+__n1, rem);

        if (__rlen)
            traits_type::move(_C_data+pos1, cs+pos2, __rlen);

        traits_type::assign (_C_data[_C_pref()->__nchars_ = tot], value_type ());
      }
    }
    return _C_make_iter (_C_data + pos1);
}


template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::
replace (size_type __pos, size_type __n, size_type __n2, value_type __c)
{
    (__pos <= size ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string.cc" ":" "466" ": "). _C_format ((0 + 9), "basic_string<>:::replace (size_type, size_type, size_type, value_type)", __pos, size ());



    
    size_type __slen = size() - __pos;
    size_type __xlen = __n < __slen ? __n : __slen; 

    (size() - __xlen < max_size () - __n2 && max_size () >= __n2) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "474" ": "). _C_format ((0 + 8), "basic_string<>::replace (size_type, size_type, size_type, value_type)", size () - __xlen, max_size () - __n2);




    
    size_type tot = size() - __xlen + __n2;  

    if (!tot)
    {
      
      _C_unlink();
      _C_get_null()->__addReference();
      _C_data = _C_get_null()->data();
    }
    else
    {
      size_type rem = size() - __xlen - __pos; 
      
      if ( (_C_pref()->__references() > 1) || (capacity() < tot))
      {
        
          size_t __new_capacity = std::max(__rw::__rw_new_capacity(size(), this),
                                       size_t (tot));
        _C_string_ref_type * __temp = _C_getRep(__new_capacity, tot);
        if (__pos) traits_type::copy(__temp->data(), _C_data, __pos);
        if (__n2) traits_type::assign(__temp->data()+__pos, __n2, __c);
        if (rem ) traits_type::copy(__temp->data()+__pos+__n2, _C_data+__pos+__n, rem);
        _C_unlink();
        _C_data = __temp->data();
      }
      else
      {
        
        if (rem) 
            traits_type::move(_C_data+__pos+__n2, _C_data+__pos+__n, rem);
        if (__n2)
            traits_type::assign(_C_data+__pos, __n2, __c);
        traits_type::assign (_C_data[_C_pref()->__nchars_ = tot], value_type ());
      }
    }
    return *this;
}





  
  
  
  
  
  
  
  
template<class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
inline basic_string<_CharT, _Traits, _Allocator>& 
basic_string<_CharT, _Traits, _Allocator>::
replace (iterator first1, iterator last1, 
         _InputIterator first2, _InputIterator last2,
         const _C_dispatch <void, false > *)
{
      

     iterator __first = first1;
     iterator __last = last1;

     
     if (__is_bidirectional_iterator(__iterator_category(first2)))
       return __replace_aux(first1, last1, first2, last2);

     (__first <= end () && __last <= end ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string.cc" ":" "547" ": "). _C_format ((0 + 9), "basic_string<>::replace<> (iterator, iterator, InputIterator, InputIterator)", __first > end () ? __first : __last, end ());






     while (first2 != last2) {
         (size_type (__first - _C_data) <= max_size()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "555" ": "). _C_format ((0 + 8), "basic_string<>::replace<>(iterator, iterator, InputIterator, InputIterator)", __first - _C_data, max_size ());




         

       if (__first == __last)  {
         
         size_t __new_capacity = __rw::__rw_new_capacity(size(), this);
         size_t __delta = __new_capacity - size();
         
         _C_string_ref_type * __temp = 
               _C_getRep(__new_capacity, __new_capacity);

         
         size_type __current = __last-begin();
         traits_type::copy (__temp->data (), _C_data, __current);
         traits_type::copy (__temp->data () + __current + __delta, __last,
                            end () - __last);
         _C_unlink();
         _C_data = __temp->data();
         __first = _C_make_iter (_C_data + __current);
         __last = __first + __delta;
       }
       
       traits_type::assign (*__first++, *first2++);
     }    
     if (__first != __last)
         replace (__first - _C_data, __last - __first, 0, value_type ());

     return *this;
}




template<class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
inline basic_string<_CharT, _Traits, _Allocator>& 
basic_string<_CharT, _Traits, _Allocator>::
__replace_aux (iterator first1, iterator last1, 
               _InputIterator first2, _InputIterator last2)
{
    difference_type __n2 = 0;
    distance(first2, last2, __n2);
    size_type __n = last1-first1;
    size_type __pos = first1 - _C_data;

    (__pos <= size ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string.cc" ":" "604" ": "). _C_format ((0 + 9), "basic_string<>::__replace_aux<>(iterator, iterator, InputIterator, InputIterator)", __pos, size ());




    size_type __slen = size() - __pos;
    size_type __xlen = __n < __slen ? __n : __slen; 

   (size () - __xlen < max_size() - __n2) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "612" ": "). _C_format ((0 + 8), "basic_string<>::__replace_aux<>(iterator, iterator, InputIterator, InputIterator)", size () - __xlen, max_size () - __n2);




    size_type tot = size() - __xlen + __n2;  

    if (!tot)
    {
      
      _C_unlink();
      _C_get_null()->__addReference();
      _C_data = _C_get_null()->data();
    }

    else
    {
      size_type __d = 0;
      size_type rem = size() - __xlen - __pos; 
      
      if ( (_C_pref()->__references() > 1) || (capacity() < tot))
      {
        
        size_t __new_capacity = std::max(__rw::__rw_new_capacity(size(), this),
                                     size_t (tot));
        _C_string_ref_type * __temp = _C_getRep(__new_capacity, tot);
        if (__pos) traits_type::copy(__temp->data(), _C_data, __pos);
        for (__d = 0; __d < (size_type)__n2; __d++)
            traits_type::assign (*(__temp->data()+__pos+__d), *first2++);
        if (rem ) 
          traits_type::copy(__temp->data()+__pos+__n2, _C_data+__pos+__n, rem);
        _C_unlink();
        _C_data = __temp->data();
      }
      else
      {
        
        if (rem)  
          traits_type::move(_C_data+__pos+__n2, _C_data+__pos+__n, rem);
        for (__d = 0; __d < (size_type)__n2; __d++)
            traits_type::assign (*(_C_data+__pos+__d), *first2++);
        traits_type::assign (_C_data[_C_pref()->__nchars_ = tot], value_type());
      }
    }
    return *this;
}




template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
copy (pointer __s, size_type __n, size_type __pos) const
{
    (__pos <= size()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string.cc" ":" "667" ": "). _C_format ((0 + 9), "basic_string<>::copy (pointer, size_type, size_type)", __pos, size ());




    size_type __slen = size() - __pos;
    size_type __rlen = __n < __slen ? __n : __slen;
    traits_type::copy(__s, _C_data+__pos, __rlen);
    return __rlen;
}


template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
find (const_pointer __s, size_type __pos, size_type __n) const
{
    ((void)0);

    (__n <= max_size ()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "686" ": "). _C_format ((0 + 8), "basic_string<>::find (const_pointer, size_type, size_type) const", __n, max_size());




    for (size_type xpos = __pos; (xpos + __n) <= size() ; xpos++)
    {
      if (!traits_type::compare(_C_data+xpos, __s, __n))
        return xpos;
    }

    return npos;
}


template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
rfind (const_pointer __s,  size_type __pos, size_type __n) const
{
    ((void)0);

    (__n <= max_size ()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "708" ": "). _C_format ((0 + 8), "basic_string<>::rfind (const_pointer, size_type, size_type) const", __n, max_size ());




    if (size() < __n)
      return npos;
    
    size_type __slen = size() -__n;
    size_type xpos_start = __slen < __pos ? __slen : __pos; 

    for (size_type xpos = xpos_start+1; xpos != 0 ; xpos--)
    {
      if (!traits_type::compare(_C_data+xpos-1, __s, __n))
        return xpos-1;
    }

    return npos;
}


template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
find_first_of (const_pointer __s, size_type __pos, size_type __n) const
{
    ((void)0);

    (__n <= max_size ()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "736" ": "). _C_format ((0 + 8), "basic_string<>::find_first_of (const_pointer, size_type, size_type) const", __n, max_size ());




    for (size_type xpos = __pos; xpos < size() ; xpos++)
    {
      for (size_type __i = 0; __i < __n ; __i++)
        if (traits_type::eq(_C_data[xpos], __s[__i]))
          return xpos;
    }

    return npos;
}


template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
find_last_of (const_pointer __s, size_type __pos, size_type __n) const
{
    ((void)0);

    (__n <= max_size ()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "759" ": "). _C_format ((0 + 8), "basic_string<>::find_last_of (const_pointer, size_type, size_type) const", __n, max_size ());




    if (size())
    {
      size_type __slen = size() -1;
      size_type xpos_start = __pos < __slen ? __pos : __slen; 
      for (size_type xpos = xpos_start+1; xpos != 0 ; xpos--)
      {
        for(size_type __i = 0; __i < __n ; __i++)
          if (traits_type::eq(_C_data[xpos-1], __s[__i]))
            return xpos-1;
      } 
    }
    return npos;
}


template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
find_first_not_of (const_pointer __s, size_type __pos, size_type __n) const
{
    ((void)0);

    (__n <= max_size ()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "786" ": "). _C_format ((0 + 8), "basic_string<>::find_first_not_of (const_pointer, size_type, size_type) const", __n, max_size ());




    for (size_type xpos = __pos; xpos < size() ; xpos++)
    {
      bool found = false;
      for (size_type __i = 0; __i < __n ; __i++)
      {
        if (traits_type::eq(_C_data[xpos], __s[__i]))
        {
          found = true;
          break;
        }
      }
      if (!found)
        return xpos;
    }

    return npos;
}


template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
find_last_not_of(const_pointer __s, size_type __pos, size_type __n) const
{
    ((void)0);

    (__n <= max_size ()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "817" ": "). _C_format ((0 + 8), "basic_string<>::find_last_not_of(const_pointer, size_type, size_type) const", __n, max_size ());



    
    if (size())
    {
      size_type __slen = size() -1;
      size_type xpos_start = __pos < __slen ? __pos : __slen; 
      for (size_type xpos = xpos_start+1; xpos != 0 ; xpos--)
      {
        bool found = false;
        for (size_type __i = 0; __i < __n ; __i++)
        {
          if (traits_type::eq(_C_data[xpos-1], __s[__i]))
          {
            found = true;
            break;
          }
        }
        if (!found)
          return xpos-1;
      }
    }

    return npos;
}


template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
basic_string<_CharT, _Traits, _Allocator>::
substr (size_type __pos, size_type __n) const
{
    (__pos <= size ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string.cc" ":" "851" ": "). _C_format ((0 + 9), "basic_string<>::substr (size_type, size_type) const", __pos, size ());




    size_type __slen = size() -__pos;
    size_type __rlen = __n < __slen ? __n : __slen;
    return basic_string (_C_data + __pos, __rlen);
}


template <class _CharT, class _Traits, class _Allocator>
int basic_string<_CharT, _Traits, _Allocator>::
compare (size_type pos1, size_type __n1, 
         const basic_string& __str, 
         size_type pos2, size_type __n2) const
{
    (pos2 <= __str . size ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string.cc" ":" "868" ": "). _C_format ((0 + 9), "basic_string<>::compare (size_type, size_type, const basic_string&, size_type, size_type) const", pos2, __str . size ());








    if(__str.size() - pos2 < __n2)
      __n2 = __str.size() - pos2;





    return compare(pos1, __n1, __str.c_str()+pos2, __n2);
}


template <class _CharT, class _Traits, class _Allocator>
int basic_string<_CharT, _Traits, _Allocator>::
compare (size_type __pos, size_type __n1,
         const_pointer __s, size_type __n2) const
{
    (__pos <= size ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string.cc" ":" "893" ": "). _C_format ((0 + 9), "basic_string<>::compare (size_type, size_type, const const_pointer, size_type) const", __pos, size ());



    if(size() - __pos < __n1)
      __n1 = size() - __pos;
    size_type __rlen = __n1 < __n2 ? __n1 : __n2; 
    int result = traits_type::compare(_C_data+__pos,__s, __rlen);

    if (result == 0)
      result = (__n1 < __n2) ? -1 : (__n1 != __n2);

    return result;
}


}   
#line 1566 "/opt/aCC/include_std/string"



#line 45 "/opt/aCC/include_std/rw/rwlocale"
#line 1 "/opt/aCC/include_std/iosfwd"
































 















namespace std {












  template<class _CharT> struct  char_traits;



  template <class _TypeT> class  allocator;

  template <class stateT> class  fpos;


template<class _CharT,
         class _Traits = char_traits<_CharT> >
class  basic_ios;

template<class _CharT,
         class _Traits = char_traits<_CharT> >
class  basic_streambuf;

template<class _CharT,
         class _Traits = char_traits<_CharT> >
class  basic_istream;

template<class _CharT,
         class _Traits = char_traits<_CharT> >
class  basic_ostream;

template<class _CharT,
         class _Traits = char_traits<_CharT>,
         class _Allocator = allocator<_CharT> > 
class  basic_stringbuf;

template<class _CharT,
        class _Traits = char_traits<_CharT>,
        class _Allocator = allocator<_CharT>  > 
class  basic_istringstream;

template<class _CharT,
         class _Traits = char_traits<_CharT>,
         class _Allocator = allocator<_CharT> > 
class  basic_ostringstream;

template<class _CharT,
        class _Traits = char_traits<_CharT> >
class  basic_filebuf;

template<class _CharT,
         class _Traits = char_traits<_CharT> >
class  basic_ifstream;

template<class _CharT,
         class _Traits = char_traits<_CharT> >
class  basic_ofstream;

template<class _TypeT,
         class _CharT = char,
         class _Traits = char_traits<_CharT> > 
class  ostream_iterator;

template<class _TypeT,
         class _CharT = char,
         class _Traits = char_traits<_CharT>,
         class Distance = ptrdiff_t >
class  istream_iterator;

template<class _CharT,
         class _Traits = char_traits<_CharT> > 
class  ostreambuf_iterator;

template<class _CharT,
         class _Traits = char_traits<_CharT> > 
class  istreambuf_iterator;

template<class _CharT,
         class _Traits = char_traits<_CharT> >
class  basic_iostream;

template<class _CharT,
         class _Traits = char_traits<_CharT> >
class  basic_fstream;

template<class _CharT,
         class _Traits = char_traits<_CharT>,
         class _Allocator = allocator<_CharT>  > 
class  basic_stringstream;




class ios_base;

  typedef basic_ios<char>                                    ios;
  typedef basic_streambuf<char>                              streambuf;
  typedef basic_istream<char>                                istream;
  typedef basic_ostream<char>                                ostream;
  typedef basic_stringbuf<char>                              stringbuf;
  typedef basic_istringstream<char>                          istringstream;
  typedef basic_ostringstream<char>                          ostringstream;
  typedef basic_filebuf<char>                                filebuf;
  typedef basic_ifstream<char>                               ifstream;
  typedef basic_ofstream<char>                               ofstream;
  typedef basic_fstream<char>                                fstream;
  typedef basic_iostream<char>                               iostream;
  typedef basic_stringstream<char>                           stringstream;

  typedef basic_ios<wchar_t>                                 wios;
  typedef basic_streambuf<wchar_t>                           wstreambuf;
  typedef basic_istream<wchar_t>                             wistream;
  typedef basic_ostream<wchar_t>                             wostream;
  typedef basic_stringbuf<wchar_t>                           wstringbuf;
  typedef basic_istringstream<wchar_t>                       wistringstream;
  typedef basic_ostringstream<wchar_t>                       wostringstream;
  typedef basic_filebuf<wchar_t>                             wfilebuf;
  typedef basic_ifstream<wchar_t>                            wifstream;
  typedef basic_ofstream<wchar_t>                            wofstream;
  typedef basic_fstream<wchar_t>                             wfstream;
  typedef basic_iostream<wchar_t>                            wiostream;
  typedef basic_stringstream<wchar_t>                        wstringstream;
#line 209 "/opt/aCC/include_std/iosfwd"


  typedef fpos<char_traits<char>::state_type> streampos;
  typedef fpos<char_traits<wchar_t>::state_type> wstreampos;





}   


#line 46 "/opt/aCC/include_std/rw/rwlocale"




#line 1 "/opt/aCC/include_std/typeinfo"










 




extern const char* __bad_cast_exception;
extern const char* __bad_typeid_exception;

struct _BaseClassTableEntry;




namespace __cxxabiv1
{
  class __class_type_info;
} 




namespace std {



#pragma vtable OFF_IF_NO_KEY_BEGIN


class bad_cast : public exception { 
public:
	bad_cast() throw() { }
	virtual ~bad_cast() throw() {}
	virtual const char* what() const throw() {
	   return __bad_cast_exception;
	}
};

class bad_typeid : public exception { 
public:
	bad_typeid() { }
	virtual ~bad_typeid() throw() {}
	virtual const char* what() const throw() {
	   return __bad_typeid_exception;
	}
};


#pragma vtable OFF_IF_NO_KEY_END


#line 88 "/opt/aCC/include_std/typeinfo"

































class type_info {
public:
  
  
  
  
  virtual ~type_info ();

private:
  
  type_info& operator= (const type_info&);
  type_info (const type_info&);

protected:
  const char *__name;

protected:
  explicit type_info (const char *__n): __name (__n) { }

public:
  
  
  
  bool before (const type_info& __arg) const
    { return __name < __arg.__name; }
  const char* name () const
    { return __name; }
  bool operator== (const type_info& __arg) const
    { return __name == __arg.__name



       ; }
  bool operator!= (const type_info& __arg) const
    { return !operator== (__arg); }

  
public:
  
  virtual bool __is_pointer_p () const;
  
  virtual bool __is_function_p () const;

  
  
  
  
  
  virtual bool __do_catch (const type_info *__thr_type, void **__thr_obj,
                         unsigned __outer) const;

  
  virtual bool __do_upcast (const __cxxabiv1::__class_type_info *__target,
			    void **__obj_ptr) const;



};




} 










#line 51 "/opt/aCC/include_std/rw/rwlocale"
#line 1 "/opt/aCC/include_std/ctime"





 







namespace std {



using ::clock_t;
using ::size_t;
using ::time_t;
using ::tm;



using ::asctime;
using ::clock;
using ::ctime;
using ::difftime;
using ::gmtime;
using ::localtime;
using ::mktime;
using ::strftime;
using ::time;

}





#line 52 "/opt/aCC/include_std/rw/rwlocale"
#line 1 "/opt/aCC/include_std/clocale"








#pragma push binding
#pragma binding default
#line 1 "/usr/include/locale.h"
 








  extern "C" {


#line 21 "/usr/include/locale.h"

#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/_null.h"
 


 
 
 

 
#line 16 "/usr/include/sys/_null.h"

#line 24 "/usr/include/sys/_null.h"

 
#pragma pop
#line 24 "/usr/include/locale.h"


#line 34 "/usr/include/locale.h"

  
  struct lconv {
	char *decimal_point;
	char *thousands_sep;
	char *grouping;
	char *int_curr_symbol;
	char *currency_symbol;
	char *mon_decimal_point;
	char *mon_thousands_sep;
	char *mon_grouping;
	char *positive_sign;
	char *negative_sign;
	char int_frac_digits;
	char frac_digits;
	char p_cs_precedes;
	char p_sep_by_space;
	char n_cs_precedes;
	char n_sep_by_space;
	char p_sign_posn;
	char n_sign_posn;
	 
	char int_n_cs_precedes;
	char int_n_sep_by_space;
	char int_n_sign_posn;
	char int_p_cs_precedes;
	char int_p_sep_by_space;
	char int_p_sign_posn;
	};
  


    
#  pragma extern setlocale, localeconv 



  
     extern char *setlocale(int, const char *);
  
  
     extern struct lconv *localeconv(void);
  













#line 107 "/usr/include/locale.h"



 


    
#  pragma extern __locale_names


   extern char __locale_names[6+1][255+1];

 



 


  struct locale_data {
    char LC_ALL_D[59];	 
    char LC_COLLATE_D[59];
    char LC_CTYPE_D[59];
    char LC_MONETARY_D[59];
    char LC_NUMERIC_D[59];
    char LC_TIME_D[59];
    char LC_MESSAGES_D[59]; 
    };

     
#  pragma extern getlocale 

#      pragma extern getlocale_r, setlocale_r



     extern struct locale_data *getlocale (int);

     extern int getlocale_r (int, struct locale_data *);
     extern int setlocale_r (int, const char *, char *, int);


 

#line 163 "/usr/include/locale.h"






     
#  pragma extern __err_string

extern char *__err_string;




 







	



}


#pragma pop
#line 10 "/opt/aCC/include_std/clocale"



namespace std
{

using ::lconv; 


using ::localeconv;
using ::setlocale;

}



#line 53 "/opt/aCC/include_std/rw/rwlocale"



#line 69 "/opt/aCC/include_std/rw/rwlocale"


namespace std {

class  locale;



template <class _Facet>
inline const _Facet& use_facet (const locale&);

template <class _Facet>
inline bool has_facet (const locale&) throw();

#line 92 "/opt/aCC/include_std/rw/rwlocale"

template <class _CharT> inline bool isspace  (_CharT, const locale&);
template <class _CharT> inline bool isprint  (_CharT, const locale&);
template <class _CharT> inline bool iscntrl  (_CharT, const locale&);
template <class _CharT> inline bool isupper  (_CharT, const locale&);
template <class _CharT> inline bool islower  (_CharT, const locale&);
template <class _CharT> inline bool isalpha  (_CharT, const locale&);
template <class _CharT> inline bool isdigit  (_CharT, const locale&);
template <class _CharT> inline bool ispunct  (_CharT, const locale&);
template <class _CharT> inline bool isxdigit (_CharT, const locale&);
template <class _CharT> inline bool isalnum  (_CharT, const locale&);
template <class _CharT> inline bool isgraph  (_CharT, const locale&);

template <class _CharT> inline _CharT toupper (_CharT, const locale&);
template <class _CharT> inline _CharT tolower (_CharT, const locale&);

class ctype_base;

template <class _CharT>
class ctype;

template< >
class  ctype<char>;

template <class _CharT>
class ctype_byname;

template< >
class  ctype_byname<char>;

class codecvt_base;

template <class internT, class externT, class stateT>
class codecvt;

template< >
class  codecvt<char, char, mbstate_t>;     



template< >
class  ctype<wchar_t>;               

template< >
class  ctype_byname<wchar_t>;

template< >
class  codecvt<wchar_t, char, mbstate_t>;  



template <class internT, class externT, class stateT>
class codecvt_byname;

template <class _CharT, 
    class InputIterator = istreambuf_iterator<_CharT> >
class num_get;

template <class _CharT, 
    class OutputIterator = ostreambuf_iterator<_CharT> >
class num_put;

template <class _CharT>
class numpunct;

template <class _CharT>
class numpunct_byname;

template <class _CharT>
class collate;

template <class _CharT>
class collate_byname;

class time_base;

template <class _CharT, 
    class InputIterator = istreambuf_iterator<_CharT> >
class time_get;

template <class _CharT, 
    class InputIterator = istreambuf_iterator<_CharT> >
class time_get_byname;

template <class _CharT, 
    class OutputIterator = ostreambuf_iterator<_CharT> >
class time_put;

template <class _CharT, 
    class OutputIterator = ostreambuf_iterator<_CharT> >
class time_put_byname;

class  money_base;

template <class _CharT, 
    class InputIterator = istreambuf_iterator<_CharT> >
class money_get;

template <class _CharT, 
    class OutputIterator = ostreambuf_iterator<_CharT> >
class money_put;

template <class _CharT, bool Intl = false>
class moneypunct;

template <class _CharT, bool Intl = false>
class moneypunct_byname;

class __rw_messages_base;

template <class _CharT>
class messages;

template <class _CharT>
class messages_byname;


}   


#line 1 "/opt/aCC/include_std/rw/locimpl"






























 







namespace std {

class  locale;

}   


namespace __rw {

using namespace std;











template <class _CharT> class __rw_timepunct;




class  __rw_locale_imp;

class  __rw_facet_base;

struct  __rw_digit_map_base;
template <class _CharT> class  __rw_digit_map;
template <class _CharT> class  __rw_keyword_def;
template <class _CharT> class  __rw_keyword_map;
template <class _CharT> class  __rw_keyword_cracker;

class  __rw_digit_reader_base;
template <class _CharT> class __rw_digit_reader_base_1;
template <class _CharT,class InputIterator>
  class  __rw_digit_reader;

class  __rw_digit_writer_base;
template <class _CharT>
  class  __rw_digit_writer_base_1;
template <class _CharT,class OutputIterator>
  class  __rw_digit_writer;








#pragma vtable OFF_IF_NO_KEY_BEGIN


class  __rw_facet_base: public __rw_synchronized
{
    friend class __rw_locale_imp;
    friend class std::locale;

public:

    enum {
        _C_facet_cat    = 0,   
        _C_ok_implicit  = 0,   
        _C_initialized = 1    
    };

    void _C_set_ref (size_t __ref) {
        _C_ref_count = __ref;
    }

private:

    int    _C_category;     
    int    _C_flags;        
    size_t _C_ref_count;    

protected:

    __rw_facet_base (size_t __ref, int __cat = 0)
        : _C_category (__cat),  _C_flags (0), _C_ref_count (__ref) { }

    __rw_facet_base (const __rw_facet_base &__rhs)
        : __rw_synchronized (),
          _C_category (__rhs._C_category),
          _C_flags (__rhs._C_flags),
          _C_ref_count (__rhs._C_ref_count) { }

    __rw_facet_base& operator= (const __rw_facet_base &__rhs) {
        if (this != &__rhs) {
            _C_category  = __rhs._C_category;
            _C_flags     = __rhs._C_flags;
            _C_ref_count = __rhs._C_ref_count;
        }
        return *this;
    }

    virtual ~__rw_facet_base () { }

    
    
    
    

    virtual void _C_initfacet (const locale&) { }
};

#pragma vtable OFF_IF_NO_KEY_END



}   


#line 1 "/opt/aCC/include_std/rw/locvector"





























 

namespace __rw {

using std::size_t;
using std::ptrdiff_t;







template <class _TypeT>
class __rw_locale_vector
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _TypeT value_type;
    typedef _TypeT& reference;
    typedef _TypeT* pointer;
    typedef _TypeT* iterator;
    
private:
    iterator _C_first;
    size_type _C_size;
    
public:
    __rw_locale_vector() : _C_first(0), _C_size(0)
        { }
    
    __rw_locale_vector(size_type __n) : _C_first(0), _C_size(__n) {
        if (__n)
            _C_first = new _TypeT[__n];
    }
    
    __rw_locale_vector(size_type __n, const _TypeT& __v) : _C_first(0), _C_size(__n) {
        if (__n)
            _C_first = new _TypeT[__n];
        while (__n)
            _C_first[--__n] = __v;
    }
    
    __rw_locale_vector(const __rw_locale_vector<_TypeT>& lv) : _C_first(0), _C_size(0) {
        size_type __n = _C_size = lv.size();
        if (__n)
            _C_first = new _TypeT[__n];
        while (__n--)
            _C_first[__n] = lv[__n];
    }    
    
    ~__rw_locale_vector() { if (_C_first) delete [] _C_first;}
    const __rw_locale_vector& operator= (const __rw_locale_vector& lv) {
        size_type __n = _C_size = lv.size();
        if (_C_first)
        delete [] _C_first;
        if (__n)
        _C_first = new _TypeT[__n];
        while (__n--)
        _C_first[__n] = lv[__n];
        return *this;
    }
    
    iterator begin() const {
        return iterator(_C_first);
    }
    
    iterator end() const {
        return iterator(_C_first+_C_size);
    }    
    
    size_type size() const {
        return _C_size;
    }
    
    _TypeT& operator[] (size_t __i) {
        return _C_first[__i];
    }
    
    const _TypeT& operator[] (size_t __i) const {
        return _C_first[__i];
    }
    
    
    iterator resize(size_t __s) { 
        return resize(__s,_TypeT()); 
    }
    
    iterator resize(size_t __s, _TypeT __v) {
        _TypeT *__new_buf = new _TypeT[__s];
        iterator __j,__k;
        size_type __d = _C_size < __s ? _C_size : __s;
        
        for (__j = _C_first, __k = __new_buf; __j != _C_first+__d; ++__j,++__k)
            *__k =  *__j;
        
        while (__d < __s) 
            __new_buf[__d++] = __v;
        
        if (_C_first)
            delete [] _C_first;    
        _C_first = __new_buf;
        _C_size = __s;
        return _C_first;
    }
};


}   


#line 157 "/opt/aCC/include_std/rw/locimpl"


namespace __rw {






class  __rw_locale_imp: public __rw::__rw_synchronized
{
public:


    friend class std::locale;
    
    
    typedef int locale_cat;

    static const locale_cat _C_none = 0x0000;
    static const locale_cat _C_collate = 0x0010;
    static const locale_cat _C_ctype = 0x0020;
    static const locale_cat _C_monetary = 0x0040;
    static const locale_cat _C_numeric = 0x0080;
    static const locale_cat _C_time = 0x0100;
    static const locale_cat _C_messages = 0x0200;
    static const locale_cat _C_all = _C_ctype | _C_collate | _C_monetary | _C_time | _C_numeric | _C_messages;

 
    
    static const locale_cat _C_libc_constants = 0x000f;
    static const locale_cat _C_first_category = _C_collate;
    static const locale_cat _C_n_categories = 6;


    __rw_locale_vector<std::string>     _C_facet_names;   
    __rw_locale_vector<__rw_facet_base*> _C_facets;        

    locale_cat _C_native;
    locale_cat _C_named;

    
    const char *_C_name;

    unsigned long _C_ref_count;   

    __rw_locale_imp (const char* = 0, size_t = 36, size_t = 0);

    __rw_locale_imp (const __rw_locale_imp&, const char*, size_t);

    ~__rw_locale_imp () {
        
        delete [] const_cast< char* >(_C_name);
    }

    __rw_facet_base* _C_get_facet (size_t __inx) const {
        return __inx < _C_facets.size () ? _C_facets [__inx] : 0;
    }

private:
    inline const char *_C_category_name (locale_cat) const;

    
    static locale_cat _C_map_category (locale_cat);

    
    static bool _C_parse_name (__rw_locale_vector<std::string>&,const char*);

    
    static std::string _C_clean_name(std::string s) {



        return s;

    }
};






inline __rw_locale_imp::__rw_locale_imp (const char *__name,
                                         size_t __size, size_t __ref)
    : _C_facets (__size, 0), 
      _C_native (0), 
      _C_named (0),
      _C_name (0),
      _C_ref_count (__ref) {


    if (__name) {
        __size = strlen (__name) + 1;

        _C_name = (char*)memcpy (new char [__size], __name, __size);
    }

    _C_facet_names.resize (_C_n_categories, string ());
}


inline __rw_locale_imp::__rw_locale_imp (const __rw_locale_imp &__rhs,
                                         const char *__name, size_t __ref)
    : _C_facet_names (__rhs._C_facet_names), 
      _C_facets (__rhs._C_facets), 
      _C_native (__rhs._C_native), 
      _C_named (__rhs._C_named), 
      _C_name (0),
      _C_ref_count (__ref) {

    
    if (__name) {
        size_t __size = strlen (__name) + 1;
        _C_name = (char*)memcpy (new char [__size], __name, __size);
    }

    for (size_t __i = _C_facets.size (); __i--; ) {
        if (_C_facets [__i])
            __rw::__rw_atomic_preincrement (_C_facets [__i]->_C_ref_count, _C_facets [__i]->_C_mutex);

    }
}


inline const char*
__rw_locale_imp::_C_category_name (locale_cat cat) const {

    locale_cat __mask = _C_first_category;

    for (size_t __i = 0;
         __i < size_t (_C_n_categories); ++__i, __mask <<= 1)

        if (cat & __mask)
            return _C_facet_names[__i].c_str();

    return "";
}













struct  __rw_digit_map_base {
  enum { _C_zero, _C_minus, _C_plus, _C_X, _C_x, _C_E, _C_e };
  static const char _C_punct_chars[7];   
  static const char _C_digit_chars[22];  
  static const char _C_char_values[22];  
};
















template< >
class  __rw_digit_map<char>:
    public __rw_digit_map_base
{
 public:
  typedef char char_type;

  bool        _C_is_inited (void) const {
      return true;
  }
  const char *_C_get_punct (void) const {
      return _C_punct_chars;
  }
  inline int  _C_eval (char c) const;

  static inline const __rw_digit_map<char>&
              _C_get_digit_map (const std::ctype<char>&);
};






inline int __rw_digit_map<char>::_C_eval (char c) const {
  int num=c;
  if ((num-='0')>9) {
    if (((num-=('A'-'0'))>5 && (num-=('a'-'A'))>5) || (num+=10)<10)
      num=-1;
  }
  return num;
}

template <class _CharT>
class  __rw_digit_map:
    public __rw_digit_map_base
{
  bool _C_inited;
  _CharT _C_punct_array[7];
  _CharT _C_digit_array[22];
  char _C_value_array[22];
 public:
  typedef _CharT char_type;

  __rw_digit_map (void): _C_inited(false)
        { }
  bool          _C_is_inited (void) const {
      return _C_inited;
  }
  void          _C_init (const std::ctype<_CharT>& ct);

  const _CharT *_C_get_punct (void) const {
      return _C_punct_array;
  }
  int           _C_eval (_CharT) const;

    
    
    
  static inline
  const __rw_digit_map<_CharT>&
                _C_get_digit_map (const std::ctype<_CharT>& ct) {

      if (!ct._C_digit_map._C_inited)
          (const_cast< __rw_digit_map<char_type> & >(ct . _C_digit_map))
              ._C_init(ct);
      return ct._C_digit_map;
  }
};


template <class _CharT>
inline void 
__rw_digit_map<_CharT>::_C_init (const std::ctype<_CharT> &__ctype) {

    __ctype.widen (_C_punct_chars, _C_punct_chars + sizeof _C_punct_chars,
                   _C_punct_array);

    __ctype.widen (_C_digit_chars, _C_digit_chars + sizeof _C_digit_chars,
                   _C_digit_array);

    std::memcpy (_C_value_array, _C_char_values, sizeof _C_value_array);
    _C_inited = true;
}


template <class _CharT>
inline int __rw_digit_map<_CharT>::_C_eval (_CharT __c) const {

    const _CharT *__end = _C_digit_array + sizeof _C_value_array;

    for (const _CharT *__p = _C_digit_array; __p != __end; ++__p)
        if (*__p == __c)
            return _C_value_array [__p - _C_digit_array];

    return -1;
}









template <class _CharT>
class  __rw_keyword_def {
 public:
  const _CharT *_C_name;
  int _C_indx;
};









template <class _CharT>
class  __rw_keyword_map {
 public:
  int _C_numdefs;
  const __rw_keyword_def<_CharT> *_C_defs;
};







template <class _CharT>
class  __rw_punct_data
{
    friend class __rw_digit_reader_base_1<_CharT>;
    friend class __rw_digit_writer_base_1<_CharT>;

public:

    typedef std::basic_string<_CharT,
                               std::char_traits<_CharT>,
                               std::allocator<_CharT> >   string_type;
protected:

    _CharT _C_dp, _C_ts;
    std::string _C_gr;
};





















template <class _Facet>
inline _Facet* 
__rw_create_named_facet (_Facet*, const char*, size_t);

template <class _Facet>
inline _Facet* 
__rw_create_native_facet (_Facet*);

template <class _Facet>
inline _Facet* 
__rw_create_classic_facet (_Facet*)
{
    return new _Facet ();
}













template <class _Facet>
class  __rw_facet_maker
{
public:

    static __rw_facet_base*
    _C_maker_func (int __t, const char* __name, size_t __ref) {
        switch (__t) {
        case 0:  return __rw_create_classic_facet ((_Facet*)0);
        case 1:  return __rw_create_native_facet ((_Facet*)0);
        default: return __rw_create_named_facet ((_Facet*)0,
                                                    __name, __ref);
        }
    }
};

template<class _CharT>
class __rw_timepunct;
extern template class __rw_facet_maker<ctype<char> >;
extern template class __rw_facet_maker<numpunct<char> >;
extern template class __rw_facet_maker<collate<char> >;
extern template class __rw_facet_maker<codecvt<char,char,mbstate_t> >;
extern template class __rw_facet_maker<messages<char> >;
extern template class __rw_facet_maker<__rw_timepunct<char> >;
extern template class __rw_facet_maker<moneypunct<char,true> >;
extern template class __rw_facet_maker<moneypunct<char,false> >;

extern template class __rw_facet_maker<ctype<wchar_t> >;
extern template class __rw_facet_maker<numpunct<wchar_t> >;
extern template class __rw_facet_maker<collate<wchar_t> >;
extern template class __rw_facet_maker<codecvt<wchar_t,wchar_t,mbstate_t> >;
extern template class __rw_facet_maker<messages<wchar_t> >;
extern template class __rw_facet_maker<__rw_timepunct<wchar_t> >;
extern template class __rw_facet_maker<moneypunct<wchar_t,true> >;
extern template class __rw_facet_maker<moneypunct<wchar_t,false> >;

#line 580 "/opt/aCC/include_std/rw/locimpl"





typedef __rw_facet_base* __rw_facet_maker_func (int, const char*, size_t);


}   


#line 214 "/opt/aCC/include_std/rw/rwlocale"


namespace std {


class  locale
{
public:
    class facet;
    class id;

    friend class facet;
    friend class id;

    typedef int category;

    static const category none = __rw::__rw_locale_imp::_C_none;
    static const category collate = __rw::__rw_locale_imp::_C_collate;
    static const category ctype = __rw::__rw_locale_imp::_C_ctype;
    static const category monetary = __rw::__rw_locale_imp::_C_monetary;
    static const category numeric = __rw::__rw_locale_imp::_C_numeric;
    static const category time = __rw::__rw_locale_imp::_C_time;
    static const category messages = __rw::__rw_locale_imp::_C_messages;
    static const category all = __rw::__rw_locale_imp::_C_all;
 
    
    
    

    inline locale () throw();

    
    
    
    

    inline locale (const locale& __rhs) throw()
        : _C_imp (__rhs._C_imp) {
        __rw::__rw_atomic_preincrement (_C_imp->_C_ref_count, _C_imp->_C_mutex);
    }

    
    
    
    
    
    
    
    

    explicit locale (const char*);

    
    
    
    

    locale (const locale&, const char*, category);

    
    



    template <class _Facet>
    locale (const locale&, _Facet*);

#line 301 "/opt/aCC/include_std/rw/rwlocale"

    
    
    

    locale (const locale&, const locale&, category);

    ~locale () {
        
        
        if (_C_imp && 0 == __rw::__rw_atomic_predecrement (_C_imp->_C_ref_count, _C_imp->_C_mutex))

            delete _C_imp;
    }

    const locale& operator = (const locale&) throw();

    
    




    template <class _Facet>
    locale combine (const locale &__rhs) const {
        bool __ok_implicit = has_facet<_Facet>(__rhs);
        (__ok_implicit) ? (void)0 : throw (runtime_error&)runtime_error ("/opt/aCC/include_std/rw/rwlocale" ":" "327" ": "). _C_format ((0 + 18), "locale::combine(const locale&) const", size_t(0), name(). c_str());




        
        
        return locale (*this, (_Facet*)&use_facet < _Facet >(__rhs));
    }





    

    string name () const;

    
    
    

    bool operator== (const locale &__rhs) const {
        return    this == &__rhs || _C_imp == __rhs._C_imp
               || name() != "*" && name () == __rhs.name();
    }

    bool operator != (const locale& __rhs) const {
        return !(*this == __rhs);
    }

    
    
    
    
    
    



    template <class _CharT, class _Traits, class _Allocator>
    bool
    operator() (const basic_string<_CharT, _Traits, _Allocator>& __x, 
                const basic_string<_CharT, _Traits, _Allocator>& __y) const;

#line 382 "/opt/aCC/include_std/rw/rwlocale"


    
    static locale global (const locale&);

    
    static const locale &classic ();

    

    
    
    


#pragma vtable OFF_IF_NO_KEY_BEGIN

    class facet: public __rw::__rw_facet_base {
        friend class __rw::__rw_locale_imp;
        friend class locale;

    protected:

        explicit facet (size_t __ref = 0, int __cat = 0)
            : __rw::__rw_facet_base (__ref, __cat) { }
        




        virtual ~facet() {}

    private:

        facet (const facet&);            
        void operator= (const facet&);   
    };

#pragma vtable OFF_IF_NO_KEY_END


    

    
    
    
    
    
    
    

    
    
    class  id {

        friend class locale;

        mutable size_t _C_id;    
  
        void _C_init () const {
            static size_t _C_id_gen = 0;

            if (!_C_id)
                _C_id = __rw::__rw_atomic_preincrement (_C_id_gen, false);
        }

        operator size_t () const {
            return _C_id;
        }

    public:
        id (): _C_id (0) { }
        
    private:
        id (const id&);               
        void operator= (const id&);   
    };

    
    
    typedef __rw::__rw_facet_maker_func __facet_maker_func;

    
    const facet& _C_use_facet (const id &__id, bool __implicit, category __cat,
                               __facet_maker_func __maker) const;

    
    const facet& _C_unsafe_use_facet (const id &__id, bool __implicit,
                                      category __cat,
                                      __facet_maker_func __maker) const;

    
    
    

    facet* _C_make_facet (const id &__id, bool __implicit, 
                             category __cat, __facet_maker_func) const;

    facet* _C_get_facet (const id &__id) const {
        return static_cast< facet* >(_C_imp->_C_get_facet (__id));
    }


    void _C_install_facet (__rw::__rw_facet_base*, const id&) const;

private:

    friend class __rw::__rw_locale_imp;

    
    explicit locale (__rw::__rw_locale_imp*);

    
    static void _C_init ();

    
    inline void _C_remove_facets (category);

    static __rw::__rw_locale_imp *_C_classic;   
    static __rw::__rw_locale_imp *_C_native;    
    static __rw::__rw_locale_imp *_C_global;    

    __rw::__rw_locale_imp *_C_imp;   
};









inline locale::locale (__rw::__rw_locale_imp *__rhs)
    : _C_imp (__rhs)
{
    ((void)0);

    if (!_C_global)
        _C_init ();

    

    _Asm_fetchadd(_FASZ_D, _SEM_ACQ, &_C_imp->_C_ref_count, +1,
                  _LDHINT_NONE);



}


inline void locale::_C_remove_facets (category __cat)
{
    if (__cat & __rw::__rw_locale_imp::_C_libc_constants)
        
        
        __cat = __rw::__rw_locale_imp::_C_map_category (__cat);

    
    for (size_t __i = 0, end = _C_imp->_C_facets.size (); __i != end; ++__i) {
        __rw::__rw_facet_base *__facet = _C_imp->_C_facets [__i];
        if (__facet && (__cat & __facet->_C_category)) {

            if (0 == __rw::__rw_atomic_predecrement (__facet->_C_ref_count, __facet->_C_mutex))

                delete __facet;

            _C_imp->_C_facets [__i] = 0;
        }
    }
}




inline locale::locale () throw()
{
    if (!_C_global)
        _C_init ();

    _C_imp = _C_global;

    ((void)0);

    __rw::__rw_atomic_preincrement (_C_imp->_C_ref_count, _C_imp->_C_mutex);
}





template <class _Facet>
inline locale::locale (const locale& __rhs, _Facet* __facet)
{
    ((void)0);

    __rw::__rw_guard __rw_mt_temp_guard (__rhs . _C_imp->_C_mutex);

    
    

    _C_imp = new __rw::__rw_locale_imp (*__rhs._C_imp, 0, 1);

    if (__facet) {
        _C_install_facet (__facet, _Facet::id);
    }
}








template <class _CharT, class _Traits, class _Allocator>
inline bool
locale::operator() (const basic_string<_CharT,_Traits,_Allocator>& __x,
                    const basic_string<_CharT,_Traits,_Allocator>& __y) const
{
    return use_facet < std::collate<_CharT> >(*this)
        .compare (__x.data (), __x.data () + __x.length (),
                  __y.data (), __y.data () + __y.length ()) < 0;
}

#line 620 "/opt/aCC/include_std/rw/rwlocale"


inline const locale&
locale::operator= (const locale& __rhs) throw()
{
    ((void)0);

    if (this != &__rhs)
    if (_C_imp != __rhs._C_imp) {

        __rw::__rw_atomic_preincrement (__rhs . _C_imp->_C_ref_count, __rhs . _C_imp->_C_mutex);


        if (0 == __rw::__rw_atomic_predecrement (_C_imp->_C_ref_count, _C_imp->_C_mutex))

            delete _C_imp;

        _C_imp = __rhs._C_imp;
    }
    return *this;
}


inline const locale& locale::classic()       
{
    if (!_C_global)
        _C_init ();

    static locale __loc (_C_classic);

    return __loc;
}


inline const locale::facet&
locale::_C_use_facet (const id &__id, bool __implicit, category __cat,
                             __facet_maker_func __maker) const
{
    ((void)0);

    
    const facet *__facet = _C_get_facet (__id);

    
    
    
    

    if (!__facet) {
        __rw::__rw_guard __rw_mt_temp_guard (_C_imp->_C_mutex);

        __facet = _C_make_facet (__id, __implicit, __cat, __maker);
    }

    ((void)0);

    return *__facet;
}



inline const locale::facet&
locale::_C_unsafe_use_facet (const id &__id, bool __implicit, category __cat,
                             __facet_maker_func __maker) const
{
    ((void)0);

    const facet *__facet = _C_get_facet (__id);

    if (!__facet)
        __facet = _C_make_facet (__id, __implicit, __cat, __maker);

    ((void)0);

    return *__facet;
}

}   


namespace __rw {









template <class _Facet>
inline _Facet*
__rw_create_named_facet (_Facet*, const char *__name, size_t __ref)
{
    ((void)&__name);

    
    

    
    
    _Facet *__facet = new _Facet ();

    __facet->_C_set_ref (__ref);

    return __facet;
}





class  __rw_use_c_lib_locale
{
    int _C_saved_cat;
    char *_C_previous_locale_name;
public:
    __rw_use_c_lib_locale (const char* = 0, int = 0);

    ~__rw_use_c_lib_locale ();

    operator bool () const {
        return _C_previous_locale_name != 0L;
    }
};








inline __rw_use_c_lib_locale::~__rw_use_c_lib_locale ()
{
    if (_C_previous_locale_name) {

        

        std::setlocale(_C_saved_cat, _C_previous_locale_name);




        delete[] _C_previous_locale_name;
    }
}

}   




#line 1 "/opt/aCC/include_std/rw/vendor"






























 




#line 1 "/opt/aCC/include_std/rw/ctype"




























 








namespace std {

class  ctype_base {
 public:
  enum mask {
    space=1<<0, print=1<<1, cntrl=1<<2, upper=1<<3, lower=1<<4,
    alpha=1<<5, digit=1<<6, punct=1<<7, xdigit=1<<8,
    alnum=(1<<5)|(1<<6), graph=1<<9
  };
};

}   

namespace __rw {








template <class _CharT>
class  __rw_ctype_helper {

  friend class __rw_digit_map<_CharT>;



  __rw_digit_map<_CharT> _C_digit_map;
};

}   

namespace std {






#pragma vtable OFF_IF_NO_KEY_BEGIN


template< >
class  ctype_byname<char>;






template< >
class  ctype<char>: public locale::facet, public ctype_base,
    public __rw::__rw_ctype_helper<char>
{
  friend class  locale;
  friend class  ctype_byname<char>;


  friend class  ctype<wchar_t>;


 public:
  typedef char char_type;


  static const size_t table_size = 256;




  explicit ctype (const mask* __tab=0,bool __del=false,size_t __refs=0);


  bool is (mask __m,char __c) const {
      return (_C_table[(unsigned char)__c] & __m) != 0;
  }






  inline const char* is (const char* __lo,const char* __hi,mask* vec) const;
  inline const char* scan_is (mask __m,const char* __low,const char* __high) const;
  inline const char* scan_not (mask __m,const char* __low,const char* __high) const;

  char toupper (char __c) const {
      return do_toupper(__c);
  }
  char tolower (char __c) const {
      return do_tolower(__c);
  }
  char widen (char __c) const {
      return do_widen(__c);
  }
  char narrow (char __c, char __dfault) const {
      return do_narrow(__c,__dfault);
  }

  const char* toupper (char* __low,const char* __high) const {
      return do_toupper(__low,__high);
  }
  const char* tolower (char* __low,const char* __high) const {
      return do_tolower(__low,__high);
  }
  const char* widen (const char* __lo, const char* __hi, char* __to) const {
      return do_widen(__lo,__hi,__to);
  }
  const char* narrow (const char* __lo, const char* __hi, char __dfault,
                         char* __to) const {
      return do_narrow(__lo,__hi,__dfault,__to);
  }

  static locale::id  id;


  typedef string string_type;

  
  string_type widen (const string &_s) const {
      return _s;
  }
  string narrow (const string_type &_s, char) const {
      return _s;
  }


  
  enum { _C_facet_cat = locale::ctype, _C_ok_implicit = 1 };

 protected:

  const mask* table() const throw() {
      return _C_table;
  }
  static const mask* classic_table() throw() {
      return _C_classic_table;
  }

  virtual ~ctype () {
      if (_C_delete_it)
          delete[] const_cast< mask* >(_C_table);
      delete[] _C_to_upper_tab;
      delete[] _C_to_lower_tab;
  }

  virtual inline const char* do_toupper (char* __low, const char* __high) const;
  virtual inline const char* do_tolower (char* __low, const char* __high) const;

  virtual char        do_toupper (char __c) const {
      return is(lower,__c)? _C_to_upper_tab[(unsigned char)__c-_C_lower_min] : __c;
  }
  virtual char        do_tolower (char __c) const {
      return is(upper,__c)? _C_to_lower_tab[(unsigned char)__c-_C_upper_min] : __c;
  }
  virtual char        do_widen (char __c) const {
      return __c;
  }
  virtual const char* do_widen (const char* __low,
                                   const char* __high, char* __to) const {
      memcpy(__to,__low,__high-__low);
      return __high;
  }
  virtual char        do_narrow (char __c, char  ) const {
      return __c;
  }
  virtual const char* do_narrow (const char* __low, const char* __high,
                                    char  , char* __to) const {
      memcpy(__to,__low,__high-__low); return __high;
  }

  virtual void _C_initfacet (const locale&);
 private:
  static const mask _C_classic_table[table_size];
  const mask* _C_table;
  bool        _C_delete_it;
  int         _C_lower_min,
              _C_lower_max;
  int         _C_upper_min,
              _C_upper_max;
  char       *_C_to_upper_tab;
  char       *_C_to_lower_tab;

#line 229 "/opt/aCC/include_std/rw/ctype"




};

#pragma vtable OFF_IF_NO_KEY_END



inline const char*
ctype<char>::is (const char* __lo, const char* __hi, mask* __vec) const {
    while (__lo != __hi)
        *__vec++ = _C_table[(unsigned char)*__lo++];
    return __hi;
}

inline const char*
ctype<char>::scan_is (ctype_base::mask __m,
                      const char* __lo, const char* __hi) const {
    while (__lo != __hi && !(_C_table[(unsigned char) *__lo] & __m))
        ++__lo;
    return __lo;
}

inline const char*
ctype<char>::scan_not (ctype_base::mask __m,
                       const char* __lo, const char* __hi) const {
    while (__lo != __hi && (_C_table[(unsigned char) *__lo] & __m))
        ++__lo;
    return __lo;
}


inline const char*
ctype<char>::do_toupper (char* __low, const char* __high) const {
    for ( ; __low<__high; ++__low)
        if (is(lower,*__low))
            *__low=_C_to_upper_tab[(unsigned char) *__low-_C_lower_min];
    return __low;
}


inline const char*
ctype<char>::do_tolower(char* __low, const char* __high) const {
    for (; __low < __high; ++__low)
        if (is(upper,*__low))
            *__low=_C_to_lower_tab[(unsigned char) *__low-_C_upper_min];
    return __low;
}








#pragma vtable OFF_IF_NO_KEY_BEGIN


template< >
class  ctype<wchar_t>: public locale::facet, public ctype_base,
    public __rw::__rw_ctype_helper<wchar_t>
{

 private:
  static bool _C_fits (wchar_t __c) {
      return ((~(wchar_t)0377) & __c) == 0;
  }
    
 public:
  typedef wchar_t char_type;

  explicit ctype (size_t refs=0) : locale::facet(refs,locale::ctype)
        { }

  bool is (mask __m, wchar_t __c) const {
      return do_is( __m, __c);
  }
  const wchar_t* is (const wchar_t* __lo, const wchar_t* __hi, mask* __vec) const {
      return do_is(__lo,__hi,__vec);
  }
  const wchar_t* scan_is (mask __m, const wchar_t* __lo, const wchar_t* __hi) const {
      return do_scan_is(__m,__lo,__hi);
  }
  const wchar_t* scan_not (mask __m, const wchar_t* __lo, const wchar_t* __hi) const {
      return do_scan_not(__m,__lo,__hi);
  }
  wchar_t toupper(wchar_t __c) const {
      return do_toupper(__c);
  }
  const wchar_t* toupper (wchar_t* __lo, const wchar_t* __hi) const {
      return do_toupper(__lo,__hi);
  }
  wchar_t tolower (wchar_t __c) const {
      return do_tolower(__c);
  }
  const wchar_t* tolower (wchar_t* __lo, const wchar_t* __hi) const {
      return do_tolower(__lo,__hi);
  }
  wchar_t widen (char __c) const {
      return do_widen(__c);
  }
  const char* widen (const char* __lo, const char* __hi, wchar_t* __to) const {
      return do_widen(__lo,__hi,__to);
  }
  char narrow (wchar_t __c, char __dfault) const {
      return do_narrow(__c,__dfault);
  }
  const wchar_t* narrow (const wchar_t* __lo, const wchar_t* __hi, char __dfault,
                         char* __to) const {
      return do_narrow(__lo,__hi,__dfault,__to);
  }

  static locale::id  id;


  
  typedef wstring string_type;
  string_type widen (const string&) const;
  string narrow (const string_type&, char) const;


  
  enum { _C_facet_cat = locale::ctype, _C_ok_implicit = 1 };

  protected:

  virtual bool do_is (mask __m, wchar_t __c) const {
        return (mask_of(__c) & __m) != 0;
  }

  virtual inline
  const wchar_t*  do_is (const wchar_t*, const wchar_t*, mask*) const;
  virtual inline
  const wchar_t*  do_scan_is (mask,const wchar_t*,const wchar_t*) const;
  virtual inline
  const wchar_t*  do_scan_not (mask,const wchar_t*,const wchar_t*) const;

    
  virtual inline
  const wchar_t*  do_toupper (wchar_t*, const wchar_t*) const;
  virtual wchar_t do_toupper (wchar_t __c) const {
      return (mask_of(__c) & lower) ? (__c &~ 0x20) : __c;
  }
    
  virtual inline
  const wchar_t*  do_tolower (wchar_t*, const wchar_t*) const;
  virtual wchar_t do_tolower (wchar_t __c) const {
      return (mask_of(__c) & upper) ? (__c | 0x20) : __c;
  }

    
  virtual inline
  const char*     do_widen (const char*, const char*, wchar_t*) const;
  virtual wchar_t do_widen (char __c) const {
      return (wchar_t)(unsigned char)__c;
  }

    
  virtual inline
  const wchar_t*  do_narrow (const wchar_t*, const wchar_t*,
                             char __dfault, char* __dest) const;
  virtual char    do_narrow (wchar_t __c, char ____dfault) const { 
      return (_C_fits(__c) ? (char)(unsigned char)__c : ____dfault);
  }

  virtual ~ctype() {}

  private:

  static mask mask_of (wchar_t __c) {
        return _C_fits(__c) ? ctype<char>::classic_table()[(unsigned char)__c]
                          : (ctype_base::mask) 0;
      
  }




};



#pragma vtable OFF_IF_NO_KEY_END



inline const wchar_t*
ctype<wchar_t>::do_is(const wchar_t* __lo, const wchar_t* __hi, mask* __vec) const {
    while (__lo != __hi)
        *__vec++ = mask_of(*__lo++);
    return __hi;
}


inline const wchar_t*
ctype<wchar_t>::do_scan_is(ctype_base::mask __m,
                           const wchar_t* __low, const wchar_t* __high) const {
    while (__low != __high && !(mask_of(*__low) & __m))
        ++__low;
    return __low;
}


inline const wchar_t*
ctype<wchar_t>::do_scan_not( mask __m, const wchar_t* __low, const wchar_t* __high) const {
    while (__low != __high && (mask_of(*__low) & __m))
        ++__low;
    return __low;
}


inline const wchar_t*
ctype<wchar_t>::do_toupper(wchar_t* __low, const wchar_t* __high) const {
    for (; __low < __high; ++__low)
        if (mask_of(*__low) & lower)
            *__low &=~ 0x20;
    return __low;
}


inline const wchar_t*
ctype<wchar_t>::do_tolower(wchar_t* __low, const wchar_t* __high) const {
    for (; __low < __high; ++__low)
        if ((mask_of(*__low) & upper) != 0) *__low |= 0x20;
    return __low;
}



inline const char*
ctype<wchar_t>::do_widen(const char* __lo, const char* __hi, wchar_t* __dest) const {
    while (__lo != __hi) {
        *__dest = (wchar_t)(unsigned char)*__lo;
        ++__lo; ++__dest;
    }
    return __hi;
}


inline const wchar_t*
ctype<wchar_t>::do_narrow(const wchar_t* __lo, const wchar_t* __hi,
                          char __dfault, char* __dest) const {
    for ( ; __lo != __hi; __lo++)
        *__dest++ = _C_fits(*__lo) ? (char)(unsigned char)*__lo : __dfault;
    return __hi;
}



inline ctype<wchar_t>::string_type
ctype<wchar_t>::widen (const string &_s) const {
    string_type result(_s.size(),0);
    do_widen(_s.begin(),_s.end(),result.begin());
    return result;
}


inline string
ctype<wchar_t>::narrow (const string_type &_s,char __dfault) const {
    string result(_s.size(),0);
    do_narrow(_s.begin(),_s.end(),__dfault,result.begin());
    return result;
}







#pragma vtable OFF_IF_NO_KEY_BEGIN


template <class _CharT>
class ctype : public locale::facet, public ctype_base,
    public __rw::__rw_ctype_helper<_CharT>
{
 public:
  typedef _CharT char_type;

    explicit ctype (size_t __ref = 0)
      : locale::facet(__ref, locale::ctype) { }
    

  bool         is(mask __m, _CharT __c) const
                 { return do_is( __m, __c); }
  const _CharT* is(const _CharT* __low, const _CharT* __high, mask* __vec) const
                 { return do_is(__low, __high, __vec); }
  const _CharT* scan_is(mask __m, const _CharT* __low, const _CharT* __high) const
                 { return do_scan_is( __m, __low, __high); }
  const _CharT* scan_not(mask __m, const _CharT* __low, const _CharT* __high) const
                 { return do_scan_not( __m, __low, __high); }

  _CharT        toupper(_CharT __c)               const
                 { return do_toupper(__c); }
  const _CharT* toupper(_CharT* __low, const _CharT* __high) const
                 { return do_toupper(__low, __high); }
  _CharT        tolower(_CharT __c)               const
                 { return do_tolower(__c); }
  const _CharT* tolower(_CharT* __low, const _CharT* __high) const
                 { return do_tolower(__low, __high); }

  _CharT  widen(char __c) const { return do_widen(__c); }
  const char* widen(const char* __lo, const char* __hi, _CharT* __to) const
           { return do_widen(__lo, __hi, __to); }
  char   narrow(_CharT __c, char __dfault) const { return do_narrow(__c, __dfault); }
  const _CharT* narrow(const _CharT* __lo, const _CharT* __hi,
                      char __dfault, char* __to) const
           { return do_narrow(__lo, __hi, __dfault, __to); }

  static locale::id id;


  
  typedef basic_string<_CharT,char_traits<_CharT>,allocator<_CharT> > string_type;
  string_type widen (const string&) const;
  string narrow (const string_type&, char) const;


  
  enum { _C_facet_cat = locale::ctype, _C_ok_implicit = 1 };

 protected:

  virtual bool do_is(mask, _CharT) const {
      return false;
  }
  virtual const _CharT* do_is (const _CharT*, const _CharT* __high,
                               mask*) const {
      return __high;
  }
  virtual const _CharT* do_scan_is(mask,
                                   const _CharT*, const _CharT* __high) const {
      return __high;
  }
  virtual const _CharT* do_scan_not(mask,
                                    const _CharT*, const _CharT* __high) const {
      return __high;
  }
  virtual _CharT        do_toupper(_CharT __c) const {
      return __c;
  }
  virtual const _CharT* do_toupper(_CharT*, const _CharT* __high) const {
      return __high;
  }
  virtual _CharT        do_tolower(_CharT __c) const {
      return __c;
  }
  virtual const _CharT* do_tolower(_CharT*, const _CharT* __high) const {
      return __high;
  }
  virtual _CharT        do_widen(char __c) const {
      return _CharT(__c);
  }
  virtual const char*  do_widen(const char* __lo,
                                const char* __hi, _CharT* __dest) const {
      while (__lo < __hi)  
          *__dest++ = _CharT(*__lo++); 
      return __hi; 
  }
  virtual char do_narrow (_CharT, char __dfault) const {
      return __dfault;
  }
  virtual const _CharT* do_narrow(const _CharT*, const _CharT* __hi,
                                 char, char*) const {
      return __hi;
  }

  virtual ~ctype() {}

 private:




};










template< >
class  ctype_byname<char> : public ctype<char>
{
public:
  explicit ctype_byname (const char*, size_t refs=0);

protected:
  virtual ~ctype_byname() {}

private:
  
  static const mask *_C_get_mask_table (const char*);
};







template< >
class  ctype_byname<wchar_t> : public ctype<wchar_t>
{
public:
    explicit ctype_byname (const char*, size_t __ref = 0)
	: ctype<wchar_t> (__ref) { }
protected:
    virtual ~ctype_byname() {}
};







template <class _CharT>
class ctype_byname: public ctype<_CharT>
{
public:
    explicit ctype_byname (const char*, size_t __ref = 0)
	: ctype<_CharT>(__ref) { }
protected:
    virtual ~ctype_byname() {}
};


#pragma vtable OFF_IF_NO_KEY_END


}   

namespace __rw {

inline const __rw_digit_map<char>&
__rw_digit_map<char>::_C_get_digit_map (const std::ctype<char>& ct)
{
  return ct._C_digit_map;
}


template< >
inline std::ctype<char>*
__rw_create_named_facet (std::ctype<char>*,
                            const char *__name, size_t __ref)
{
    return new std::ctype_byname<char>(__name, __ref);
}


template< >
inline std::ctype<char>*
__rw_create_classic_facet (std::ctype<char>*)
{
    return new std::ctype<char>(0L,false,0);
}



}   

#line 1 "/opt/aCC/include_std/rw/ctype.cc"



























 

namespace std {






template <class charT> locale::id ctype<charT>::id;


}   
#line 701 "/opt/aCC/include_std/rw/ctype"


#line 37 "/opt/aCC/include_std/rw/vendor"
#line 1 "/opt/aCC/include_std/rw/numeral"





























 




#line 1 "/opt/aCC/include_std/limits"





























 





























 





#line 79 "/opt/aCC/include_std/limits"


#line 87 "/opt/aCC/include_std/limits"







#line 100 "/opt/aCC/include_std/limits"

#line 109 "/opt/aCC/include_std/limits"









extern const float _FLT_NANS;         
extern const float _FLT_DMIN;         





extern const double _DBL_NANS;        
extern const double _DBL_DMIN;        

#line 134 "/opt/aCC/include_std/limits"





extern const long double _LDBL_NANS;  
extern const long double _LDBL_DMIN;  

#line 166 "/opt/aCC/include_std/limits"















#line 226 "/opt/aCC/include_std/limits"











#line 314 "/opt/aCC/include_std/limits"


#line 36 "/opt/aCC/include_std/rw/numeral"

#line 1 "/opt/aCC/include_std/rw/rwlocale"





























 

#line 38 "/opt/aCC/include_std/rw/numeral"
#line 1 "/opt/aCC/include_std/rw/iosbase"































 







#line 46 "/opt/aCC/include_std/rw/iosbase"




namespace std {



#pragma vtable OFF_IF_NO_KEY_BEGIN


class  ios_base: public __rw::__rw_synchronized
{
public:



    
    class  failure : public __rw_exception {
    public:
        explicit failure (const string& __what):
            __rw_exception (__what) { }

        
        explicit failure (const char *__what = 0):
            __rw_exception (__what) { }
    };




    
    class badbit_set : public failure { };

    class eofbit_set : public failure { };

    class failbit_set : public failure { };




    
    typedef int fmtflags;

    
    static const fmtflags boolalpha = 0x0001;

    
    static const fmtflags dec = 0x0002;

    
    static const fmtflags fixed = 0x0004;

    
    static const fmtflags hex = 0x0008;

    
    
    static const fmtflags internal = 0x0010;

    
    static const fmtflags left = 0x0020;

    
    static const fmtflags oct = 0x0040;

    
    static const fmtflags right = 0x0080;

    
    static const fmtflags scientific = 0x0100;

    
    
    static const fmtflags showbase = 0x0200;

    
    
    static const fmtflags showpoint = 0x0400;

    
    static const fmtflags showpos = 0x0800;

    
    static const fmtflags skipws = 0x1000;

    
    static const fmtflags unitbuf = 0x2000;

    
    
    static const fmtflags uppercase = 0x4000;



    
    
    static const fmtflags bin = 0x8000;

    static const fmtflags basefield = dec | oct | hex | bin;







    static const fmtflags adjustfield = left | right | internal;
    static const fmtflags floatfield = scientific | fixed;

    
    static const fmtflags _C_padbits = adjustfield | right | internal;


    
    int _C_base () const {
        fmtflags __flags = flags () & basefield;
        return   oct == __flags ?  8
               : dec == __flags ? 10
               : hex == __flags ? 16



               : bin == __flags ?  2    



               : __flags ? 10           
               : 0;                     
    }

    
    typedef int iostate;

    static const iostate goodbit = 0x00;

    
    
    static const iostate badbit = 0x01;

    
    static const iostate eofbit = 0x02;

    
    
    
    static const iostate failbit = 0x04;

    
    typedef int openmode;

    
    static const openmode app = 0x01;

    
    static const openmode binary = 0x02;

    
    static const openmode in = 0x04;

    
    static const openmode out = 0x08;

    
    static const openmode trunc = 0x10;

    
    static const openmode ate = 0x20;



    
    static const openmode nocreate = 0x40;

    
    static const openmode noreplace = 0x80;









    
    
    enum seekdir {
        _C_beg = 0,
        _C_cur = 1,
        _C_end = 2
    };


    
    static const seekdir beg = _C_beg;
    static const seekdir cur = _C_cur;
    static const seekdir end = _C_end;

#line 252 "/opt/aCC/include_std/rw/iosbase"

    


    
    typedef seekdir  seek_dir;
    typedef openmode open_mode;
    typedef iostate  io_state;
    typedef std::streamoff streamoff;
    typedef std::streampos streampos;


    
    
    
    class  Init {
	static int _C_initcnt;   
    public:
        Init ();

        ~Init ();
    };

    fmtflags flags () const {
        return _C_fmtfl;
    }

    fmtflags flags (fmtflags __f) {
        return __rw::__rw_atomic_exchange (_C_fmtfl, __f, _C_mutex);
    }

    fmtflags setf (fmtflags __f) {
        return flags (flags () | __f);
    }

    fmtflags setf (fmtflags __f, fmtflags __mask) {
        return flags (flags () & ~__mask | __f & __mask);
    }

    void unsetf (fmtflags __f) {
        flags (flags () & ~__f);
    }

    streamsize precision () const {
          return _C_prec;
    }

    streamsize precision (streamsize __p) {
        return __rw::__rw_atomic_exchange (_C_prec, __p, _C_mutex);
    }

    streamsize width () const {
        return _C_wide;
    }

    streamsize width (streamsize __w) {
        return __rw::__rw_atomic_exchange (_C_wide, __w, _C_mutex);
    }

    locale imbue (const locale&);

    
    
    
    locale& getloc () {
        return _C_loc;
    }

    locale getloc () const {
        return _C_loc;
    }

    static int xalloc () {
        return __rw::__rw_atomic_preincrement (_C_index, false) - 1;
    }

    long&  iword (int);
    void*& pword (int);

    enum event { erase_event, imbue_event, copyfmt_event };

    typedef void (*event_callback)(event, ios_base&, int);
    void register_callback (event_callback, int);
    
    static bool _C_is_sync () {
        return _C_sync_with_stdio;
    }

    static bool sync_with_stdio (bool __sync = true) {
        return __rw::__rw_atomic_exchange (_C_sync_with_stdio, __sync, false);
    }

    virtual ~ios_base();    

protected:

    
    void _C_fire_event (event, bool __reentrant);

    
    void _C_copyfmt (const ios_base&);

    
    
    iostate _C_unsafe_clear (iostate = goodbit, iostate = ~0);

    
    locale _C_unsafe_imbue (const locale&);

    ios_base ();

    fmtflags    _C_fmtfl;   
    streamsize  _C_prec;    
    streamsize  _C_wide;    
    iostate     _C_state;   
    iostate     _C_except;  
    
private:


    ios_base (const ios_base&);            
    ios_base& operator= (const ios_base&); 

    struct _C_event_cb {
        int             _C_index;
        event_callback  _C_fn;
    };

    locale       _C_loc;      

    long        *_C_iarray;   
    void*       *_C_parray;   

    size_t       _C_isize;    
    size_t       _C_psize;    

    _C_event_cb *_C_cbarray;  
    size_t       _C_cbsize;   

    static int   _C_index;    
    static bool  _C_sync_with_stdio;
};


#pragma vtable OFF_IF_NO_KEY_END


inline ios_base::ios_base ()
    : _C_iarray (0),
      _C_parray (0),
      _C_isize (0),
      _C_psize (0),
      _C_cbarray (0),
      _C_cbsize (0)
{
}


inline ios_base::~ios_base()
{
    _C_fire_event (erase_event, false);

    delete [] _C_iarray;
    delete [] _C_parray;
    delete [] _C_cbarray;
}


inline locale ios_base::_C_unsafe_imbue (const locale& __loc)
{
    locale __tmp = _C_loc;
    _C_loc = __loc;

    _C_fire_event (imbue_event, true);

    return __tmp;  
}


inline locale ios_base::imbue (const locale& __loc)
{
    __rw::__rw_guard __rw_mt_temp_guard (_C_mutex);

    return _C_unsafe_imbue (__loc);
}





inline ios_base& unitbuf (ios_base& __strm)
{
    __strm.setf (ios_base::unitbuf);
    return __strm;
}



inline ios_base& nounitbuf (ios_base& __strm)
{
    __strm.unsetf (ios_base::unitbuf);
    return __strm;
}



inline ios_base& boolalpha (ios_base& __strm)
{
    __strm.setf (ios_base::boolalpha);
    return __strm;
}



inline ios_base& noboolalpha (ios_base& __strm)
{
    __strm.unsetf (ios_base::boolalpha);
    return __strm;
}



inline ios_base& showbase (ios_base& __strm)
{
    __strm.setf (ios_base::showbase);
    return __strm;
}



inline ios_base& noshowbase (ios_base& __strm)
{
    __strm.unsetf (ios_base::showbase);
    return __strm;
}



inline ios_base& showpoint (ios_base& __strm)
{ 
    __strm.setf (ios_base::showpoint);
    return __strm;
}



inline ios_base& noshowpoint (ios_base& __strm)
{
    __strm.unsetf (ios_base::showpoint);
    return __strm;
}



inline ios_base& showpos (ios_base& __strm)
{
    __strm.setf (ios_base::showpos);
    return __strm;
}



inline ios_base& noshowpos (ios_base& __strm)
{
    __strm.unsetf (ios_base::showpos);
    return __strm;
}



inline ios_base& skipws (ios_base& __strm)
{
    __strm.setf (ios_base::skipws);
    return __strm;
}



inline ios_base& noskipws (ios_base& __strm)
{
    __strm.unsetf (ios_base::skipws);
    return __strm;
}



inline ios_base& uppercase (ios_base& __strm)
{
    __strm.setf (ios_base::uppercase);
    return __strm;
}



inline ios_base& nouppercase (ios_base& __strm)
{
    __strm.unsetf (ios_base::uppercase);
    return __strm;
}





inline ios_base& internal (ios_base& __strm)
{
    __strm.setf (ios_base::internal, ios_base::adjustfield);
    return __strm;
}



inline ios_base& left (ios_base& __strm)
{
    __strm.setf (ios_base::left, ios_base::adjustfield);
    return __strm;
}



inline ios_base& right (ios_base& __strm)
{
    __strm.setf (ios_base::right, ios_base::adjustfield);
    return __strm;
}





inline ios_base& dec (ios_base& __strm)
{
    __strm.setf (ios_base::dec, ios_base::basefield);
    return __strm;
}



inline ios_base& hex (ios_base& __strm)
{
    __strm.setf (ios_base::hex, ios_base::basefield);
    return __strm;
}



inline ios_base& oct (ios_base& __strm)
{
    __strm.setf (ios_base::oct, ios_base::basefield);
    return __strm;
}





inline ios_base& bin (ios_base& __strm)
{
    __strm.setf (ios_base::bin, ios_base::basefield);
    return __strm;
}







inline ios_base& fixed (ios_base& __strm)
{
    __strm.setf (ios_base::fixed, ios_base::floatfield);
    return __strm;
}



inline ios_base& scientific (ios_base& __strm)
{
    __strm.setf (ios_base::scientific, ios_base::floatfield);
    return __strm;
}


}   


#line 39 "/opt/aCC/include_std/rw/numeral"


namespace __rw {

using namespace std;







template <class _CharT>
class  __rw_numpunct_init_data {
 public:
  bool _C_del;                    
  _CharT _C_dp, _C_ts;               
  const char *_C_gr;              
  const _CharT *_C_tn, *_C_fn;       
};

extern template class __rw_numpunct_init_data<char>;
extern template class __rw_numpunct_init_data<wchar_t>;









class  __rw_numpunct_impl_base {
 public:
  static __rw_numpunct_init_data<char> *_C_get_named_init_ (const char*);
};








template <class _CharT>
class  __rw_numpunct_impl_data :
    public __rw_numpunct_impl_base, 
    public __rw_punct_data<_CharT>
{

  friend class numpunct<_CharT>;
  friend class __rw_keyword_cracker<_CharT>;

  typedef basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> >
  string_type;

  string_type _C_tn, _C_fn;

  __rw_keyword_def<_CharT> tf_defs_[2];
  __rw_keyword_map<_CharT> tf_map_;

 protected:
  inline __rw_numpunct_impl_data (const __rw_numpunct_init_data<_CharT>*);
  static __rw_numpunct_init_data<_CharT> *_C_get_init_by_name_ (const char*);
  void _C_initfacetbase (const locale&);
};

template <class _CharT>
inline
__rw_numpunct_impl_data<_CharT>::
__rw_numpunct_impl_data (const __rw_numpunct_init_data<_CharT> *__init)
{
    if (!__init) {
        this->_C_dp = _CharT ('.');
        this->_C_ts = _CharT (',');
    } else {
        this->_C_dp = __init->_C_dp;
        this->_C_ts = __init->_C_ts;
        this->_C_gr = __init->_C_gr;
        _C_tn       = __init->_C_tn;
        _C_fn       = __init->_C_fn;

        if (__init->_C_del)
            delete[] (char*) __init;
    }
}

template <class _CharT>
__rw_numpunct_init_data<_CharT>* 
__rw_fixup_numpunct_init (__rw_numpunct_init_data<char>*, _CharT*);

template< >
inline __rw_numpunct_init_data<char>*
__rw_fixup_numpunct_init (__rw_numpunct_init_data<char> *init, char*)
{
    return init;
}

template<>
__rw_numpunct_init_data<wchar_t>*
__rw_fixup_numpunct_init (__rw_numpunct_init_data<char> *init, wchar_t*);











template <class _CharT>
class  __rw_numpunct_impl :
    public __rw_numpunct_impl_data<_CharT>
{
 protected:
  __rw_numpunct_impl (const __rw_numpunct_init_data<_CharT>* init)
   : __rw_numpunct_impl_data<_CharT>(init) { }
 public:
  static const __rw_numpunct_init_data<_CharT> *_C_get_ivals ()
    { return 0L; }
};

template< >
class  __rw_numpunct_impl<char>:                  
    public __rw_numpunct_impl_data<char>
{
  static const  __rw_numpunct_init_data<char> _C_ivals;  

 protected:
  __rw_numpunct_impl
      (const __rw_numpunct_init_data<char> *init):
       __rw_numpunct_impl_data<char>(init) { }
 public:
  static const __rw_numpunct_init_data<char> *_C_get_ivals ()
    { return &_C_ivals; }
};


template< >
class  __rw_numpunct_impl<wchar_t>:               
    public __rw_numpunct_impl_data<wchar_t>
{
  static const  __rw_numpunct_init_data<wchar_t> _C_ivals; 

 protected:
  __rw_numpunct_impl
      (const __rw_numpunct_init_data<wchar_t> *init):
       __rw_numpunct_impl_data<wchar_t>(init) { }
 public:
  static const __rw_numpunct_init_data<wchar_t> *_C_get_ivals ()
    { return &_C_ivals; }
};




template <class _CharT, class _InputIterator, class _TypeT>
inline _InputIterator
__rw_num_do_get (_CharT, 
		 _InputIterator     __begin, 
		 _InputIterator     __end, 
		 ios_base          &__flags, 
		 ios_base::iostate &__err, 
		 _TypeT            &__val)
{
    __rw_digit_reader<_CharT, _InputIterator>
        __reader (__begin, __end, __flags);


    _TypeT __tmp = __reader._C_parse (__reader._C_get_digits (_TypeT ()),
                                      _TypeT ());

    if (__reader._C_error)
        __err = ios_base::failbit;
    else {
        __err = ios_base::goodbit;
        __val = __tmp;
    }

    if (__reader.eof ())
        __err |= ios_base::eofbit;

    return __begin;
}


}   


namespace std {





template <class _CharT, class _InputIterator>
class num_get: public locale::facet
{
public:
    typedef _CharT         char_type;
    typedef _InputIterator iter_type;

    static locale::id id;

    explicit num_get (size_t __refs = 0)
        : locale::facet (__refs, locale::numeric) { }



    iter_type get (iter_type __begin, iter_type __end, ios_base &__flags, 
                   ios_base::iostate &__err, bool& __val) const {
        ((void)0);
        return do_get (__begin, __end, __flags, __err, __val);
    }



    iter_type get (iter_type __begin, iter_type __end, ios_base &__flags, 
                   ios_base::iostate &__err,  unsigned short& __val) const {
        ((void)0);
        return do_get (__begin, __end, __flags, __err, __val);
    }

    
    iter_type get (iter_type __begin, iter_type __end, ios_base &__flags, 
                   ios_base::iostate &__err,  short& __val) const {
        ((void)0);
        return __rw::__rw_num_do_get (_CharT (), __begin, __end, __flags,
                                            __err, __val);
    }

    
    iter_type get (iter_type __begin, iter_type __end, ios_base &__flags, 
                   ios_base::iostate &__err, int& __val) const {
        ((void)0);
        return __rw::__rw_num_do_get (_CharT (), __begin, __end, __flags,
                                            __err, __val);
    }

    iter_type get (iter_type __begin, iter_type __end, ios_base &__flags, 
                   ios_base::iostate &__err, unsigned int& __val) const {
        ((void)0);
        return do_get (__begin, __end, __flags, __err, __val);
    }

    iter_type get (iter_type __begin, iter_type __end, ios_base &__flags, 
                   ios_base::iostate &__err, long& __val) const {
        ((void)0);
        return do_get (__begin, __end, __flags, __err, __val);
    }

    iter_type get (iter_type __begin, iter_type __end, ios_base &__flags, 
                   ios_base::iostate &__err, unsigned long& __val) const {
        ((void)0);
        return do_get (__begin, __end, __flags, __err, __val);
    }

    iter_type get (iter_type __begin, iter_type __end, ios_base &__flags, 
                   ios_base::iostate &__err, float& __val) const {
        ((void)0);
        return do_get (__begin, __end, __flags, __err, __val);
    }

    iter_type get (iter_type __begin, iter_type __end, ios_base &__flags, 
                   ios_base::iostate &__err, double& __val) const {
        ((void)0);
        return do_get (__begin, __end, __flags, __err, __val);
    }

    iter_type get (iter_type __begin, iter_type __end, ios_base &__flags, 
                   ios_base::iostate &__err, long double& __val) const {
        ((void)0);
        return do_get (__begin, __end, __flags, __err, __val);
    }

    iter_type get (iter_type __begin, iter_type __end, ios_base &__flags, 
                   ios_base::iostate &__err, void*& __val) const {
        ((void)0);
        return do_get (__begin, __end, __flags, __err, __val);
    }




    
    iter_type get (iter_type __begin, iter_type __end, ios_base &__flags,
                   ios_base::iostate &__err, long long& __val) const {
        ((void)0);
        return do_get (__begin, __end, __flags, __err, __val);
    }

    
    iter_type get (iter_type __begin, iter_type __end, ios_base &__flags,
                   ios_base::iostate &__err,
                   unsigned long long& __val) const {
        ((void)0);
        return do_get (__begin, __end, __flags, __err, __val);
    }



    
    enum { _C_facet_cat = locale::numeric, _C_ok_implicit = 1 };

protected:



    virtual iter_type do_get (iter_type, iter_type, ios_base&, 
                              ios_base::iostate&, bool&) const;


    virtual iter_type do_get (iter_type __begin, iter_type __end,
                              ios_base &__flags, ios_base::iostate &__err,
                              unsigned short &__val) const {
        return __rw::__rw_num_do_get (char_type (), __begin, __end,
                                     __flags, __err, __val);
    }

    virtual iter_type do_get (iter_type __begin, iter_type __end,
                              ios_base &__flags, ios_base::iostate &__err,
                              unsigned int &__val) const {
        return __rw::__rw_num_do_get (char_type (), __begin, __end,
                                     __flags, __err, __val);
    }

    virtual iter_type do_get (iter_type __begin, iter_type __end,
                              ios_base &__flags, ios_base::iostate &__err,
                              long &__val) const {
        return __rw::__rw_num_do_get (char_type (), __begin, __end,
                                     __flags, __err, __val);
    }

    virtual iter_type do_get (iter_type __begin, iter_type __end,
                              ios_base &__flags, ios_base::iostate &__err,
                              unsigned long &__val) const {
        return __rw::__rw_num_do_get (char_type (), __begin, __end,
                                     __flags, __err, __val);
    }

    virtual iter_type do_get (iter_type __begin, iter_type __end,
                              ios_base &__flags, ios_base::iostate &__err,
                              float &__val) const {
        return __rw::__rw_num_do_get (char_type (), __begin, __end,
                                     __flags, __err, __val);
    }

    virtual iter_type do_get (iter_type __begin, iter_type __end,
                              ios_base &__flags, ios_base::iostate &__err,
                              double &__val) const {
        return __rw::__rw_num_do_get (char_type (),
                                     __begin, __end,
                                     __flags, __err, __val);
    }

    virtual iter_type do_get (iter_type __begin, iter_type __end,
                              ios_base &__flags, ios_base::iostate &__err,
                              long double &__val) const {
        return __rw::__rw_num_do_get (char_type (),
                                     __begin, __end,
                                     __flags, __err, __val);
    }

    virtual iter_type do_get (iter_type __begin, iter_type __end,
                              ios_base &__flags, ios_base::iostate &__err,
                              void* &__val) const {
        return __rw::__rw_num_do_get (char_type (),
                                     __begin, __end,
                                     __flags, __err, __val);
    }



    
    virtual iter_type do_get (iter_type __begin, iter_type __end,
                              ios_base &__flags, ios_base::iostate &__err,
                              long long &__val) const {
        return __rw::__rw_num_do_get (char_type (), __begin, __end,
                                            __flags, __err, __val);
    }

    
    virtual iter_type do_get (iter_type __begin, iter_type __end,
                              ios_base &__flags, ios_base::iostate &__err, 
                              unsigned long long &__val) const {
        return __rw::__rw_num_do_get (char_type (), __begin, __end,
                                            __flags, __err, __val);
    }



    virtual ~num_get() {}

private:

#line 443 "/opt/aCC/include_std/rw/numeral"

};

extern template class num_get<char, istreambuf_iterator<char, char_traits<char> > >;
extern template class num_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t> > >;







template <class _CharT, class _OutputIterator>
class num_put: public locale::facet
{
public:
    typedef _CharT          char_type;
    typedef _OutputIterator iter_type;

    explicit num_put (size_t __refs = 0)
        : locale::facet (__refs, locale::numeric) { }


    iter_type put (iter_type __it, ios_base& __flags, char_type __fill,
                   bool __val) const {
        return do_put(__it, __flags, __fill, __val);
    }


    iter_type put (iter_type __it, ios_base& __flags, char_type __fill,
                   long __val) const {
        return do_put (__it, __flags, __fill, __val);
    }

    iter_type put (iter_type __it, ios_base& __flags, char_type __fill,
                   unsigned long __val) const {
        return do_put (__it, __flags, __fill, __val);
    }

    iter_type put (iter_type __it, ios_base& __flags, char_type __fill,
                   double __val) const {
        return do_put (__it, __flags, __fill, __val);
    }

    iter_type put (iter_type __it, ios_base& __flags, char_type __fill,
                   long double __val) const {
        return do_put(__it, __flags, __fill, __val);
    }

    iter_type put (iter_type __it, ios_base& __flags, char_type __fill,
                   const void* __val) const {
        return do_put(__it, __flags, __fill, __val);
    }

    

#line 505 "/opt/aCC/include_std/rw/numeral"

    iter_type put (iter_type __it, ios_base& __flags, char_type __fill,
                   short __val) const {
        return do_put(__it, __flags, __fill, __val);
    }

    iter_type put (iter_type __it, ios_base& __flags, char_type __fill,
                   unsigned short __val) const {
        return do_put(__it, __flags, __fill, __val);
    }

    iter_type put (iter_type __it, ios_base& __flags, char_type __fill,
                   int __val) const {
        return do_put(__it, __flags, __fill, __val);
    }

    iter_type put (iter_type __it, ios_base& __flags, char_type __fill,
                   unsigned int __val) const {
        return do_put(__it, __flags, __fill, __val);
    }



    iter_type put (iter_type __it, ios_base& __flags, char_type __fill,
                   long long __val) const {
        return do_put(__it, __flags, __fill, __val);
    }

    iter_type put (iter_type __it, ios_base& __flags, char_type __fill,
                   unsigned long long __val) const {
        return do_put(__it, __flags, __fill, __val);
    }



    static locale::id id;

  
    enum { _C_facet_cat = locale::numeric, _C_ok_implicit = 1 };

protected:


    virtual iter_type do_put (iter_type, ios_base&, char_type, bool) const;

    virtual iter_type do_put (iter_type, ios_base&, char_type, long) const;
    virtual iter_type do_put (iter_type, ios_base&, char_type,
                              unsigned long) const;
    virtual iter_type do_put (iter_type, ios_base&, char_type, double) const;
    virtual iter_type do_put (iter_type, ios_base&, char_type,
                              long double) const;
    virtual iter_type do_put (iter_type, ios_base&, char_type,
                              const void* p) const;

    
    virtual iter_type do_put (iter_type, ios_base&, char_type, short) const;
    virtual iter_type do_put (iter_type, ios_base&, char_type,
                              unsigned short) const;
    virtual iter_type do_put (iter_type, ios_base&, char_type, int) const;
    virtual iter_type do_put (iter_type, ios_base&, char_type,
                              unsigned int) const;



    virtual iter_type do_put (iter_type, ios_base&, char_type, 
                              long long) const;

    virtual iter_type do_put (iter_type, ios_base&, char_type, 
                              unsigned long long) const;



    virtual ~num_put() {}

private:





};

extern template class num_put<char, ostreambuf_iterator<char, char_traits<char> > >;
extern template class num_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >;






template <class _CharT>
class numpunct: public locale::facet, 
                public __rw::__rw_numpunct_impl<_CharT>
{
public:
    typedef _CharT char_type;
    typedef basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> >
    string_type;

    
    


    explicit inline numpunct (size_t __refs = 0, 
                        const __rw::__rw_numpunct_init_data<_CharT> *i =
                        __rw::__rw_numpunct_impl<_CharT>::_C_get_ivals());






    char_type decimal_point () const {
        return do_decimal_point();
    }

    char_type thousands_sep () const {
        return do_thousands_sep();
    }

    string  grouping () const {
        return do_grouping();
    }

    string_type truename () const {
        return do_truename ();
    }

    string_type falsename ()  const {
        return do_falsename();
    }

    static locale::id id;

    
    enum { _C_facet_cat = locale::numeric, _C_ok_implicit = 1 };

protected:

    virtual char_type do_decimal_point () const {
        return this->_C_dp;
    }

    virtual char_type do_thousands_sep () const {
        return this->_C_ts;
    }

    virtual string do_grouping () const {
        return this->_C_gr;
    }

    virtual string_type do_truename () const {
        return this->_C_tn;
    }

    virtual string_type do_falsename () const {
        return this->_C_fn;
    }

    virtual ~numpunct() {}

  

private:
    virtual void _C_initfacet (const locale&);





};

extern template class numpunct<char>;
extern template class numpunct<wchar_t>;


template <class _CharT>
inline numpunct<_CharT>::numpunct
    (size_t refs, const __rw::__rw_numpunct_init_data<_CharT> *init):
     locale::facet(refs, locale::numeric), 
     __rw::__rw_numpunct_impl<_CharT>(init)
{ }





template <class _CharT>
class numpunct_byname: public numpunct<_CharT>
{
public:

    explicit numpunct_byname (const char *__name, size_t __refs = 0) :



        numpunct<_CharT>(__refs,
                         __rw::__rw_numpunct_impl_data<_CharT>::_C_get_init_by_name_(__name))

        { }
protected:
    virtual ~numpunct_byname() {}
};


extern template class numpunct_byname<char>;
extern template class numpunct_byname<wchar_t>;


}   


namespace __rw {


using namespace std;




template <class _CharT>
inline numpunct<_CharT>*
__rw_create_named_facet (numpunct<_CharT>*, const char *__name, size_t __ref)
{
    return new numpunct_byname<_CharT>(__name, __ref);
}

#line 753 "/opt/aCC/include_std/rw/numeral"


}   


#line 1 "/opt/aCC/include_std/rw/numeral.cc"




























 

#line 1 "/opt/aCC/include_std/rw/numbrw"





























 








namespace __rw {

using namespace std;






template <class _CharT>
class  __rw_timepunct_init_data
{
public:
  const _CharT *_C_day_nms[7][2];   
  const _CharT *_C_month_nms[12][2];
  const _CharT *_C_ampm_nms[2];     
  const _CharT *_C_bad_nm;          
  const _CharT *_C_ord_nms[100];    
  const _CharT *_C_dt_tm_pats[6];   
};

template <class _CharT>
class  __rw_timepunct_init;

template< >
class  __rw_timepunct_init<char> 
{

 public:
  typedef basic_string<char, char_traits<char>,
                              allocator<char> > string_type;

  const __rw_timepunct_init_data<char>& _C_tinit;

  __rw_timepunct_init (const __rw_timepunct_init_data<char> &i)
    : _C_tinit(i) 
  {}

  const string_type _C_get_day(int i, bool abbr) const;
  const string_type _C_get_month(int i, bool abbr) const;
  const string_type _C_get_ampm(bool afternoon) const;
  const string_type _C_get_bad() const  { return _C_tinit._C_bad_nm ; }
  const string_type _C_get_ord(int i) const { return _C_tinit._C_ord_nms[i]; }
  const string_type _C_get_pattern(int i) const { return _C_tinit._C_dt_tm_pats[i]; }
};


template< >
class  __rw_timepunct_init<wchar_t> 
{

 public:
  typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > string_type;

  const __rw_timepunct_init_data<wchar_t>& _C_tinit;

  __rw_timepunct_init (const __rw_timepunct_init_data<wchar_t> &i)
    : _C_tinit(i) 
  {}

  const string_type _C_get_day(int i, bool abbr) const;
  const string_type _C_get_month(int i, bool abbr) const;
  const string_type _C_get_ampm(bool afternoon) const;





  const string_type _C_get_bad() const  { return _C_tinit._C_bad_nm; }
  const string_type _C_get_ord(int i) const { return _C_tinit._C_ord_nms[i]; }
  const string_type _C_get_pattern(int i) const { return _C_tinit._C_dt_tm_pats[i]; }
};



template <class _CharT>
class  __rw_timepunct_init
{

 public:
  typedef basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> > string_type;

  const __rw_timepunct_init_data<_CharT>& _C_tinit;

  __rw_timepunct_init (const __rw_timepunct_init_data<_CharT> &i)
    : _C_tinit(i) 
  {}

  const string_type _C_get_day(int i, bool abbr) const  { return _C_tinit._C_day_nms[i][abbr]; }
  const string_type _C_get_month(int i, bool abbr) const { return _C_tinit._C_month_nms[i][abbr]; }
  const string_type _C_get_ampm(bool afternoon) const { return _C_tinit._C_ampm_nms[afternoon]; }
  const string_type _C_get_bad() const  { return _C_tinit._C_bad_nm; }
  const string_type _C_get_ord(int i) const { return _C_tinit._C_ord_nms[i]; }
  const string_type _C_get_pattern(int i) const { return _C_tinit._C_dt_tm_pats[i]; }
};








template <class _CharT>
class  __rw_timepunct_impl_data {
  friend class __rw_timepunct<_CharT>;
  friend class __rw_keyword_cracker<_CharT>;
 public:
  typedef basic_string<_CharT, char_traits<_CharT>,
                             allocator<_CharT> > string_type;
 private:

  string_type _C_day_nms[7][2];
  string_type _C_month_nms[12][2];
  string_type _C_ampm_nms[2];
  string_type _C_bad_nm;
  string_type _C_ord_nms[100];
  string_type _C_dt_tm_pats[6];

  __rw_keyword_def<_CharT> _C_dn_defs[7][2];
  __rw_keyword_map<_CharT> _C_dn_defsmap;
  __rw_keyword_def<_CharT> _C_mn_defs[12][2];
  __rw_keyword_map<_CharT> _C_mn_defsmap;
  __rw_keyword_def<_CharT> _C_ampm_defs[2];
  __rw_keyword_map<_CharT> _C_ampm_defsmap;

 protected:
  __rw_timepunct_impl_data (const __rw_timepunct_init<_CharT> &i);
  void _C_initpat (const locale&);
  void _C_initfacet (const locale&);
};

extern template class __rw_timepunct_impl_data<char>;
extern template class __rw_timepunct_impl_data<wchar_t>;










template <class _CharT>
class  __rw_timepunct_impl :
    public __rw_timepunct_impl_data<_CharT>
{
 protected:
  __rw_timepunct_impl(void);
};

template< >
class  __rw_timepunct_impl<char>:           
    public __rw_timepunct_impl_data<char>
{
  static const 
  __rw_timepunct_init_data<char> _C_ivals;                    

 protected:
  __rw_timepunct_impl (void):
    __rw_timepunct_impl_data<char>(__rw_timepunct_init<char>(_C_ivals)) { }
};


template< >
class  __rw_timepunct_impl<wchar_t>:              
    public __rw_timepunct_impl_data<wchar_t>
{
  static const 
  __rw_timepunct_init_data<wchar_t> _C_ivals;                       

 protected:
  __rw_timepunct_impl(void):
      __rw_timepunct_impl_data<wchar_t>(__rw_timepunct_init<wchar_t>(_C_ivals)) { }
};






template <class _CharT>
class  __rw_timepunct : public locale::facet, 
    public __rw_timepunct_impl<_CharT>
{
 public:
  typedef _CharT char_type;
  typedef basic_string<_CharT, char_traits<_CharT>,
                                allocator<_CharT> >
    string_type;

  explicit __rw_timepunct (size_t __refs=0):
      locale::facet(__refs, locale::time) { }

  string_type dayname (int __day, bool __abbreviated) const
      { return do_dayname(__day, __abbreviated); }
  string_type monthname (int __month, bool __abbreviated) const
      { return do_monthname(__month, __abbreviated); }
  string_type ordinal (int __number) const
      { return do_ordinal(__number); }

  static locale::id id;

  
  enum { _C_facet_cat = locale::time, _C_ok_implicit = 1 };

 protected:

  virtual string_type do_dayname (int day, bool abbreviated) const;
  virtual string_type do_monthname (int month, bool abbreviated) const;
  virtual string_type do_ordinal (int number) const;

 private:
  void _C_initfacet (const locale&);




};

extern template class __rw_timepunct<char>;
extern template class __rw_timepunct<wchar_t>;










template <class _CharT>
class  __rw_keyword_cracker {
public:

    static const __rw_keyword_map<_CharT>&
    _C_get_tf_map (const numpunct<_CharT> &__np) {
        return __np.tf_map_;
    }

    static const __rw_keyword_map<_CharT>&
    _C_get_day_map (const __rw_timepunct<_CharT>& __tp) {
        return __tp._C_dn_defsmap;
    }

    static const __rw_keyword_map<_CharT>&
    _C_get_month_map (const __rw_timepunct<_CharT>& __tp) {
        return __tp._C_mn_defsmap;
    }

    static const __rw_keyword_map<_CharT>&
    _C_get_ampm_map (const __rw_timepunct<_CharT>& __tp) {
        return __tp._C_ampm_defsmap;
    }

    static const typename numpunct<_CharT>::string_type&
    _C_get_tf_string (const numpunct<_CharT>& __np, bool __val) {
        return __val ? __np._C_tn : __np._C_fn;
    }

    static const typename __rw_timepunct<_CharT>::string_type&
    _C_get_day_string (const __rw_timepunct<_CharT>& __tp, unsigned __val, bool __abr) {
        return __val < 7 ? __tp._C_day_nms[__val][__abr] : __tp._C_bad_nm;
    }

    static const typename __rw_timepunct<_CharT>::string_type&
    _C_get_month_string (const __rw_timepunct<_CharT>& __tp, unsigned __val, bool __abr)
{
        return __val < 12 ? __tp._C_month_nms[__val][__abr] : __tp._C_bad_nm;
    }

    static const typename __rw_timepunct<_CharT>::string_type&
    _C_get_ampm_string (const __rw_timepunct<_CharT>& __tp, bool __pm) {
        return __tp._C_ampm_nms[__pm];
    }

    static const typename __rw_timepunct<_CharT>::string_type&
    _C_get_ord_string (const __rw_timepunct<_CharT>& __tp, unsigned __val) {
        return __val < 99 ? __tp._C_ord_nms[__val] :  __tp._C_bad_nm;
    }

    static const typename __rw_timepunct<_CharT>::string_type&
    _C_get_patt_string (const __rw_timepunct<_CharT>& __tp, unsigned __val) {
        return __val < 6 ? __tp._C_dt_tm_pats[__val] : __tp._C_bad_nm;
    }
};









template <class _CharT>
class  __rw_digit_handler_base_1
    : public __rw_keyword_cracker<_CharT>
{
public:
    const ctype<_CharT>     &_C_ctyp;
    const __rw_digit_map<_CharT>  &_C_dmap;
    const __rw_punct_data<_CharT> &_C_punct;

    
    __rw_digit_handler_base_1 (const locale& __loc)
        : _C_ctyp (use_facet < ctype<_CharT> >(__loc)), 
          _C_dmap (__rw_digit_map<_CharT>::_C_get_digit_map (_C_ctyp)), 
         _C_punct(use_facet < numpunct<_CharT> >(__loc))
        { }


    
    
    __rw_digit_handler_base_1 (const locale& __loc,
                          const __rw_punct_data<_CharT>& __pun)
        : _C_ctyp (use_facet < ctype<_CharT> >(__loc)), 
          _C_dmap (__rw_digit_map<_CharT>::_C_get_digit_map (_C_ctyp)), 
         _C_punct(__pun)
        { }
    
};

extern template class __rw_digit_handler_base_1<char>;
extern template class __rw_digit_handler_base_1<wchar_t>;











class  __rw_digit_reader_base : public __rw_digit_map_base
{
public:

    enum {
        _C_good              = 0x0000, 
        _C_no_digits         = 0x0001, 
        _C_too_many_groups   = 0x0004, 
        _C_group_too_long    = 0x0008, 
        _C_group_is_empty    = 0x0010, 
        _C_bad_grouping      = 0x0020, 
        _C_bad_exponent      = 0x0040, 
        _C_overflow          = 0x0080, 
        _C_bad_curr_symbol   = 0x0100, 
        _C_bad_sign          = 0x0200,

        
        _C_signed         = 0x01000,   
        _C_negative       = 0x02000,   
        _C_exp_negative   = 0x04000,   
        _C_advanced       = 0x08000,   
        _C_infinity       = 0x10000,   
        _C_nan            = 0x20000,   

        _C_DEF_BUFSIZE    = 64         
    };

    
    
    int _C_error;                    
    int _C_base;                  

    int _C_state;                 

    char *_C_frac_beg;               
    char *_C_exp_beg;                

    size_t _C_bufsize;            

    
    char  _C_buffer [_C_DEF_BUFSIZE];   
    char *_C_digits;                    

    __rw_digit_reader_base (int __radix = 0)
        : _C_error (_C_good), _C_base (__radix), _C_state (_C_signed),
          _C_bufsize (_C_DEF_BUFSIZE), _C_digits (_C_buffer) { }

    ~__rw_digit_reader_base () {
        if (_C_digits != _C_buffer)
            delete[] _C_digits;
    }

    
    unsigned long _C_parse (const char *__end, unsigned long = 0);

    
    short _C_parse (const char *__end, short) {
        return _C_parse (__end, 0L);
    }

    unsigned short _C_parse (const char *__end, unsigned short) {
        return _C_parse (__end, 0UL);
    }

    int _C_parse (const char *__end, int) {
        return _C_parse (__end, 0L);
    }

    unsigned int _C_parse (const char *__end, unsigned int) {
        return _C_parse (__end, 0UL);
    }

    long _C_parse (const char *__end, long) {
        unsigned long __tmp = _C_parse (__end, 0UL);
        return _C_state & _C_negative ? -__tmp : __tmp;
    }



    unsigned long long _C_parse (const char *__end, 
                                        unsigned long long);

    long long _C_parse (const char *__end, long long) {
        unsigned long long __tmp =
            _C_parse (__end, (unsigned long long)0);
        return _C_state & _C_negative ? -__tmp : __tmp;
  }



    
    void *_C_parse (const char *__end, void* __val);

    float _C_parse (const char *__end, float __val, const char *__fmt = "%g") {
        return _C_parse_float (__end, __fmt, &__val), __val;
    }
        
    double _C_parse (const char *__end, double __val,
                     const char *__fmt = "%lg") {
        return _C_parse_float (__end, __fmt, &__val), __val;
    }

    long double _C_parse (const char *__end, long double __val, 
                       const char *__fmt = "%Lg") {
        return _C_parse_float (__end, __fmt, &__val), __val;
    }

protected:

    
    static char* _C_realloc (char *&__begin, char *__buf, size_t &__bufsize);

    
    char* _C_realloc ();

private:

    
    unsigned long _C_parse_decimal (const char *__beg, const char *__end);

    
    void _C_parse_float (const char *__end, const char *__fmt, void *__val);
};


inline char* __rw_digit_reader_base::_C_realloc ()
{
    
    ptrdiff_t __frac_off = _C_frac_beg - _C_digits;
    ptrdiff_t __exp_off  = _C_exp_beg  - _C_digits;

    char *__cur = _C_realloc (this->_C_digits, this->_C_buffer,
                              this->_C_bufsize);

    
    if (_C_frac_beg)
        _C_frac_beg = _C_digits + __frac_off;

    if (_C_exp_beg)
        _C_exp_beg = _C_digits + __exp_off;

    return __cur;
}








template <class _CharT>
class  __rw_digit_reader_base_1
    : public __rw_digit_reader_base, 
      public __rw_digit_handler_base_1<_CharT>
{
public:
    typedef basic_string<_CharT, char_traits<_CharT>, 
                                  allocator<_CharT> > string_type;

protected:
    
    __rw_digit_reader_base_1 (const locale &__loc, int __radix = 0)
        : __rw_digit_reader_base (__radix),
          __rw_digit_handler_base_1<_CharT>(__loc) { }


    
    
    __rw_digit_reader_base_1 (const locale   &__loc,
                         const __rw_punct_data<_CharT> &__mp)
        : __rw_digit_handler_base_1<_CharT>(__loc, __mp) { }


    
    _CharT _C_get_decimal_point() const {
        return this->_C_punct._C_dp;
    }

    _CharT _C_get_thousands_sep() const {
        return this->_C_punct._C_ts;
    }

    const char* _C_get_grouping() const {
        return this->_C_punct._C_gr.c_str();
    }
};

extern template class __rw_digit_reader_base_1<char>;
extern template class __rw_digit_reader_base_1<wchar_t>;










template <class _CharT, class InputIterator>
class  __rw_digit_reader
    : public __rw_digit_reader_base_1<_CharT>
{
public:
    
    __rw_digit_reader (InputIterator     &__first,
                       InputIterator     &__last,
                       ios_base &__flags)
        : __rw_digit_reader_base_1<_CharT> (__flags.getloc (),
                                            __flags._C_base ()),
          _C_io (__flags), _C_in (__first), _C_end (__last) { }

protected:
    
    __rw_digit_reader (InputIterator &__first, InputIterator &__last, 
                       ios_base &__flags,
                       const __rw_punct_data<_CharT> &__mp)
        : __rw_digit_reader_base_1<_CharT>(__flags.getloc (), __mp), 
          _C_io (__flags), _C_in (__first), _C_end (__last) { }

public:
    char *_C_get_digits (int);        

    
    char *_C_get_digits (short) {
        return _C_get_digits (0);
    }

    char *_C_get_digits (unsigned short) {
        return _C_get_digits (0);
    }

    char *_C_get_digits (unsigned int) {
        return _C_get_digits (0);
    }

    char *_C_get_digits (long) {
        return _C_get_digits (0);
    }

    char *_C_get_digits (unsigned long) {
        return _C_get_digits (0);
    }



    char *_C_get_digits (long long) {
        return _C_get_digits (0);
    }

    char *_C_get_digits (unsigned long long) {
        return _C_get_digits (0);
    }




    char *_C_get_digits (double);     

    
    char *_C_get_digits (float) {
        return _C_get_digits (0.0);
    }

    char *_C_get_digits (long double) {
        return _C_get_digits (0.0);
    }

    char *_C_get_digits (void*) {      
        this->_C_base = 16;
        return _C_get_digits (0);
    }

    
    int _C_get_keyword (const __rw_keyword_map<_CharT>&);

    bool eof () const {
        return _C_in == _C_end;
    }

protected:

    ios_base &_C_io;
    InputIterator& _C_in;
    InputIterator& _C_end;

    const char *_C_grouping;
    _CharT thousands_sep;
    char _C_groups[40];
    char *_C_gpos;

    
    char *_C_get_digit_string (char*, bool = false);

    char *_C_get_digit_groups (char*);       
};

extern template class __rw_digit_reader<char, istreambuf_iterator<char, char_traits<char> > >;
extern template class __rw_digit_reader<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t> > >;











#pragma vtable OFF_IF_NO_KEY_BEGIN


class  __rw_digit_writer_base :
    public __rw_digit_map_base
{
public:
    __rw_digit_writer_base (ios_base&);

    virtual ~__rw_digit_writer_base () {
	if (_C_start != _C_buffer)
            delete[] _C_start;
    }

    void _C_get_pattern (char*, const char*, bool);

    bool _C_get_f_pattern(char*, char);

    void _C_digitize (unsigned long, bool __is_signed, const char *__fmat);

    void _C_digitize (const void *__val);

    void _C_digitize (unsigned short __val) {
        _C_digitize (__val, false, "h");
    }

    void _C_digitize (short __val) {
        _C_digitize (__val, true, "h");
    }

    void _C_digitize (unsigned int __val) {
        _C_digitize (__val, false, "");
    }

    void _C_digitize (int __val) {
        _C_digitize (__val, true, "");
    }

    void _C_digitize (long __val) {
        _C_digitize (__val, true, "l");
    }

    void _C_digitize (unsigned long __val) {
        _C_digitize (__val, false, "l");
    }



    void _C_digitize (unsigned long long, bool = false);

    void _C_digitize (long long __val) {
        _C_digitize (__val, true);
    }

    
    void _C_to_binary (unsigned long long);



    void _C_digitize (double);


    void _C_digitize (long double);


    
    void _C_to_binary (unsigned long);

    ios_base &_C_io;             
    ios_base::fmtflags _C_flags; 
    int _C_precision, _C_width, _C_base, _C_iprecision, _C_num_groups;
    enum { _C_left, _C_internal, _C_right } _C_adjust;
    bool _C_fractional, _C_separable;
    char *_C_start, *_C_end, *_C_group;

    enum { _C_DEF_BUFSIZE = 65 };       
    char _C_buffer [_C_DEF_BUFSIZE ];   
    char _C_groups[150];

    int _C_calc_groups (int, const char*);
};

#pragma vtable OFF_IF_NO_KEY_END



inline
__rw_digit_writer_base::__rw_digit_writer_base (ios_base &__b)
    : _C_io(__b), _C_flags(__b.flags()),  _C_precision(__b.precision()),
      _C_width(__b.width()), _C_iprecision(0), _C_num_groups(0), 
      _C_fractional(false), _C_separable(true), _C_start(_C_buffer),
      _C_end(_C_buffer) {

    
    _C_base = __b._C_base ();

    switch (_C_flags & ios_base::adjustfield) {

    case ios_base::left:
        _C_adjust = _C_left;
        break;

    case ios_base::internal:
        _C_adjust = _C_internal;
        break;

    default:
        _C_adjust = _C_right;
        break;
    }
}









template <class _CharT>
class  __rw_digit_writer_base_1 :
    public __rw_digit_writer_base, 
    public __rw_digit_handler_base_1<_CharT>
{
 public:
  typedef basic_string<_CharT, char_traits<_CharT>,
                             allocator<_CharT> > string_type;

 protected:
  
  __rw_digit_writer_base_1(ios_base &__b, const locale &__loc) 
      : __rw_digit_writer_base (__b), __rw_digit_handler_base_1<_CharT>(__loc)
        { }


  
  __rw_digit_writer_base_1  (ios_base&, const __rw_punct_data<_CharT>&);

  
  _CharT _C_get_decimal_point() const {
      return this->_C_punct._C_dp;
  }
  _CharT _C_get_thousands_sep() const {
      return this->_C_punct._C_ts;
  }
  const char *_C_get_grouping() const {
      return this->_C_punct._C_gr.c_str();
  }
};

extern template class __rw_digit_writer_base_1<char>;
extern template class __rw_digit_writer_base_1<wchar_t>;










template <class _CharT, class _OutputIterator>
class  __rw_digit_writer :
    public __rw_digit_writer_base_1<_CharT>
{
public:
  typedef basic_string<_CharT, char_traits<_CharT>,
                             allocator<_CharT> > string_type;

  
  __rw_digit_writer (_OutputIterator& o, ios_base& b)
      : __rw_digit_writer_base_1<_CharT>(b, b.getloc ()), _C_out (o) 
        { }

 protected:
    
    
    __rw_digit_writer (_OutputIterator &o, ios_base &b, 
                  const __rw_punct_data<_CharT> &mp)
        : __rw_digit_writer_base_1<_CharT>(b, mp), _C_out (o) 
        { }

 public:
  void _C_put_digits (_CharT fill);
  void _C_put_keyword (const string_type&, _CharT fill);

 protected:
  _OutputIterator &_C_out;
};

extern template class __rw_digit_writer<char, ostreambuf_iterator<char, char_traits<char> > >;
extern template class __rw_digit_writer<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >;



}   


#line 1 "/opt/aCC/include_std/rw/numbrw.cc"




























 











namespace __rw {

using namespace std;






template <class _CharT>
__rw_timepunct_impl_data<_CharT>::__rw_timepunct_impl_data
    (const __rw_timepunct_init<_CharT> &__init)
{
  size_t __i;
  for (__i=0; __i<7; __i++) {
      _C_day_nms[__i][0]=__init._C_get_day (__i, false);
      _C_day_nms[__i][1]=__init._C_get_day (__i, true);
  }
  for (__i=0; __i<12; __i++) {
      _C_month_nms[__i][0]=__init._C_get_month (__i, false);
      _C_month_nms[__i][1]=__init._C_get_month (__i, true);
  }
  _C_ampm_nms[0]=__init._C_get_ampm (false);
  _C_ampm_nms[1]=__init._C_get_ampm (true);
  _C_bad_nm=__init._C_get_bad ();
  for (__i=0; __i<100; __i++)
      _C_ord_nms[__i]=__init._C_get_ord (__i);
  for (size_t __j=0; __j<sizeof _C_dt_tm_pats/sizeof _C_dt_tm_pats[0]; __j++)
      _C_dt_tm_pats[__j]=__init._C_get_pattern (__j);
}


struct __rwstd_fmt {
    __rwstd_fmt () {}
    __rwstd_fmt (int __pos, int __len, char __fmtc)
        : _C_pos(__pos), _C_len(__len), _C_fmt_char(__fmtc) {}
    int _C_pos;
  int _C_len;
    char _C_fmt_char;
    bool operator < (const __rwstd_fmt& __fmt) {
        return _C_pos < __fmt._C_pos;
    }
};


template <class _CharT>
void __rw_timepunct_impl_data<_CharT>::_C_initpat (const locale &__loc)
{
  static const char __tm_single_data_patts[] = "YyjSMIHmBbAapdZUWw";

  tm __tmb;
  char __buf[256];
  __rwstd_fmt __fmtstruct_array[20];

  
  __tmb.tm_sec = 56;
  __tmb.tm_min = 54;
  __tmb.tm_hour = 22;
  __tmb.tm_mday = 30;
  __tmb.tm_mon = 10;
  __tmb.tm_year = 90;
  __tmb.tm_wday = 5;
  __tmb.tm_yday = -1;
  __tmb.tm_isdst = -1;
  (void) mktime (&__tmb);

  typedef std::ctype<_CharT> _Ctype;
  typedef __rw_facet_maker<_Ctype>   _FacetMaker;

  
  

  const _Ctype &__ct =
      static_cast< const _Ctype& >(__loc . _C_unsafe_use_facet (_Ctype::id, _Ctype::_C_ok_implicit, _Ctype::_C_facet_cat, _FacetMaker::_C_maker_func));





  
  std::string __oldloc = setlocale (0, 0);




    setlocale (0, __loc.name ().c_str ());


  
  static const char __tm_mult_data_patts[] = "xXcDrT";

  for (unsigned int __j = 0; __j != sizeof __tm_mult_data_patts - 1; ++__j) {
    
      char __tmfmt_pat[] = "% ";
      __tmfmt_pat[1] = __tm_mult_data_patts[__j];
      strftime (__buf, sizeof (__buf), __tmfmt_pat, &__tmb);
      std::string __tmfmt_result (__buf);

    
    
    int __pos;
    int __fmtstruct_index = 0;
    for (unsigned int __i=0; __i < sizeof (__tm_single_data_patts) - 1; ++__i) {
        char __tmp_fmt_arg[] = "% ";
      __tmp_fmt_arg[1] = __tm_single_data_patts[__i];
      strftime (__buf, sizeof (__buf), __tmp_fmt_arg, &__tmb);
      
      
      if (!(__tm_single_data_patts[__i]=='p' && strcmp (__buf, " ")==0)) {
        if ((__pos = __tmfmt_result.find (__buf)) != -1) {
          if (strlen (__buf) > 0) {
            __fmtstruct_array[__fmtstruct_index++] = __rwstd_fmt (__pos, strlen (__buf), __tm_single_data_patts[__i]);
            __tmfmt_result.replace (__pos, strlen (__buf), strlen (__buf), ' ');
          }
        }
      }
    }

    
    for (int __top = __fmtstruct_index; __top > 0; --__top) {
      int __large = 0;
      for (int __i = 0; __i < __top; ++__i) {
	if (__fmtstruct_array[__i] < __fmtstruct_array[__large])
	  __large = __i;
      }
      __rwstd_fmt __temp = __fmtstruct_array[__large];
      __fmtstruct_array[__large] = __fmtstruct_array[__top-1];
      __fmtstruct_array[__top-1] = __temp;
    }

    
    {
      std::string __alt_tmfmt (__tmfmt_result); 
      char __compare_buf[256];                

      
      for (__rwstd_fmt *__tmpfmt = __fmtstruct_array;
           __tmpfmt < (__fmtstruct_array + __fmtstruct_index);
           ++__tmpfmt) {
        __tmfmt_result.replace ((*__tmpfmt)._C_pos, (*__tmpfmt)._C_len, 
                                 (std::string ("%").append (1, (*__tmpfmt)._C_fmt_char)));
	
        if ((*__tmpfmt)._C_fmt_char != 'd') {
          __alt_tmfmt.replace ((*__tmpfmt)._C_pos, (*__tmpfmt)._C_len, 
                        (std::string ("%").append (1, (*__tmpfmt)._C_fmt_char)));
        } else {
          __alt_tmfmt.replace ((*__tmpfmt)._C_pos, (*__tmpfmt)._C_len, 
                        (std::string ("%e")));
        }                                                              
      }

      
      __tmb.tm_mday=3;

      
      strftime (__buf, sizeof (__buf), __tmfmt_result.c_str (), &__tmb);
      strftime (__compare_buf, sizeof (__compare_buf), __tmfmt_pat, &__tmb);

      
      
      

      if (strcmp (__buf, __compare_buf)) {
        __tmfmt_result = __alt_tmfmt; 
      }

      
      __tmb.tm_mday=30;
    }

    
    string_type __convert;
    for (unsigned int k = 0; k < __tmfmt_result.length (); ++k)
      __convert = std::operator + (__convert, __ct.widen (__tmfmt_result[k]));
    _C_dt_tm_pats[__j] = __convert;

  }

  setlocale (0, __oldloc.c_str ());
}

template <class _CharT>
void __rw_timepunct_impl_data<_CharT>::_C_initfacet (const locale &__loc) {

    int __i;
    for (__i=0; __i<7; ++__i) {
        _C_dn_defs[__i][0]._C_name=_C_day_nms[__i][0].c_str ();
        _C_dn_defs[__i][0]._C_indx=__i;
        _C_dn_defs[__i][1]._C_name=_C_day_nms[__i][1].c_str ();
        _C_dn_defs[__i][1]._C_indx=__i;
    }
    
    for (__i=0; __i<12; ++__i) {
        _C_mn_defs[__i][0]._C_name=_C_month_nms[__i][0].c_str ();
        _C_mn_defs[__i][0]._C_indx=__i;
        _C_mn_defs[__i][1]._C_name=_C_month_nms[__i][1].c_str ();
        _C_mn_defs[__i][1]._C_indx=__i;
    }
    
    _C_ampm_defs[0]._C_name=_C_ampm_nms[0].c_str ();
    _C_ampm_defs[0]._C_indx= 0;
    _C_ampm_defs[1]._C_name=_C_ampm_nms[1].c_str ();
    _C_ampm_defs[1]._C_indx= 1;
    
    _C_dn_defsmap._C_numdefs=7*2;
    _C_dn_defsmap._C_defs=&(_C_dn_defs[0][0]);
    _C_mn_defsmap._C_numdefs=12*2;
    _C_mn_defsmap._C_defs=&(_C_mn_defs[0][0]);
    _C_ampm_defsmap._C_numdefs=2;
    _C_ampm_defsmap._C_defs=&(_C_ampm_defs[0]);
    _C_initpat (__loc);
}






template <class _CharT>
std::locale::id __rw_timepunct<_CharT>::id;

template <class _CharT>
void __rw_timepunct<_CharT>::_C_initfacet (const locale &__loc) {
  __rw_timepunct_impl<_CharT>::_C_initfacet (__loc);
}

template <class _CharT>
typename __rw_timepunct<_CharT>::string_type
__rw_timepunct<_CharT>::do_dayname (int __day, bool __abbr) const {
  return this->_C_day_nms[__day][__abbr];
}

template <class _CharT>
typename __rw_timepunct<_CharT>::string_type
__rw_timepunct<_CharT>::do_monthname (int __mon, bool __abbr) const {
  return this->_C_month_nms[__mon][__abbr];
}

template <class _CharT>
typename __rw_timepunct<_CharT>::string_type
__rw_timepunct<_CharT>::do_ordinal (int __num) const {
  return (__num<0 || __num>99) ? this->_C_bad_nm : this->_C_ord_nms[__num];
}






template <class _CharT, class InputIterator>
char* __rw_digit_reader<_CharT, InputIterator>::
_C_get_digit_string (char *__first, bool __discard  ) {

    char *__last = __first;

    
    const _CharT *__punct = this->_C_dmap._C_get_punct ();

    int digitCount = 0;
    bool firstWasZero = false;
    const bool base16 = (this->_C_base == 16);

    if( !eof() && *_C_in == __punct[this->_C_zero] )
        firstWasZero = true;

    
    
    while (!eof ()) {

        int __c     = *_C_in;                
        int __digit = this->_C_dmap._C_eval (__c);  
  
        digitCount ++;

        bool XinBase16 =  base16 && (__c == __punct [this->_C_x] || __c == __punct [this->_C_X] );

        if (  __digit >= this->_C_base ||  __digit < 0  &&
              ( (XinBase16 && (digitCount != 2 || !firstWasZero))  || !XinBase16 )
           )
           break;

        
        if (__last == this->_C_digits + this->_C_bufsize)
            __last = this->_C_realloc ();

        
        
        if (   0 < __digit
            || 0 == __digit && (!__discard || __first != __last))
            *__last++ = char (__digit);

        ++_C_in;
    }

    return __last;
}


template <class _CharT, class InputIterator>
char* __rw_digit_reader<_CharT, InputIterator>::_C_get_digits (int)
{
    char *__last          = this->_C_digits;
    const _CharT* __punct = this->_C_dmap._C_get_punct ();

    _CharT __ch;

    if (!eof () && (this->_C_state & this->_C_signed)) {
        
        do {
            if ((__ch = *_C_in) == __punct [this->_C_minus])
                this->_C_state |= this->_C_negative;
            else if (__ch != __punct [this->_C_plus])
                break;

                ++_C_in;

            this->_C_state |= this->_C_advanced;
        } while (0);
    }

    if (!this->_C_base) {

        this->_C_base = _C_io._C_base ();

        if (0 == this->_C_base || (_C_io.flags () & std::ios_base::showbase)) {
            
            

            if (0 == this->_C_base)
                this->_C_base = 10;

            if (!eof () && *_C_in == __punct[this->_C_zero]) {
                this->_C_base = 8;
                ++_C_in;
                *__last++ = 0;
                this->_C_state |= this->_C_advanced;

                if (  !eof ()
                    && (   (__ch = *_C_in) == __punct[this->_C_x]
                        || __ch == __punct[this->_C_X])) {
                    this->_C_base = 16;
                    ++_C_in;
                    __last--; 
                }
            }
        }
    }

    if (!*(_C_grouping = this->_C_get_grouping ()))
        __last = _C_get_digit_string (__last);
    else {
        _C_gpos = _C_groups;

        thousands_sep = this->_C_get_thousands_sep ();
        __last        = _C_get_digit_groups (__last);

        if (!this->_C_error && --_C_gpos > _C_groups) {
            
            const char *__gdef = _C_grouping;
            do {
                if (*__gdef != *_C_gpos && *__gdef != 127)
                    break;

                if (__gdef[1])
                    ++__gdef;
            } while (--_C_gpos > _C_groups);

            if (_C_gpos > _C_groups || *_C_gpos > *__gdef)
                this->_C_error |= this->_C_bad_grouping;
        }
    }

    if (__last > this->_C_digits)
        this->_C_state |= this->_C_advanced;

    return __last;
}


template <class _CharT, class InputIterator>
char* __rw_digit_reader<_CharT, InputIterator>::_C_get_digits (double)
{
    
    this->_C_base = 10;
    char *__first = _C_get_digits (0);

    
    const _CharT *__punct = this->_C_dmap._C_get_punct ();

    this->_C_frac_beg = __first;

    if (!this->_C_error && !eof ()) {
        if (*_C_in == this->_C_get_decimal_point ()) {
            
            
            ++_C_in;
            __first = _C_get_digit_string (__first);
        }
    }

    
    

    if (__first == this->_C_digits && !eof ()) {

        char __c = tolower (char (*_C_in));

        if ('i' == __c) {
            static const char __inf[] = "infinity";

            for (const char *__p = __inf; ; ++__p, ++_C_in) {
                
                if (!*__p || 3 == __p - __inf && eof ()) {
                    this->_C_state |= this->_C_infinity;
                    return __first;
                }
                if (eof () || *__p != tolower (*_C_in))
                    break;   
            }
        }
        else if ('n' == __c) {
            for (const char *__p = "nan"; ; ++__p, ++_C_in) {
                
                if (!*__p) {
                    if (eof ()) {
                        this->_C_state |= this->_C_nan;
                        return __first;
                    }
                    if ('(' == *_C_in) {
                        
                        while (!eof ())
                            if (')' == *_C_in++) {
                                this->_C_state |= this->_C_nan;
                                return __first;
                            }
                    }
                    break;   
                }
                else if (eof () || tolower (*_C_in) != *__p)
                    break;   
            }
        }
    }

    if (__first == this->_C_digits)
        this->_C_error |= this->_C_no_digits;

    this->_C_exp_beg  = __first;
    this->_C_state   &= ~this->_C_exp_negative;

    _CharT __ch;

    if (   !this->_C_error && !eof ()
        && (  (__ch = *_C_in) == __punct [this->_C_e]
            || __ch == __punct [this->_C_E])) {

        
        
        ++_C_in;
        if (eof ())
            this->_C_error |= this->_C_bad_exponent;
        else {
            
            if ((__ch = *_C_in) == __punct [this->_C_plus])
                ++_C_in;
            else if (__ch == __punct [this->_C_minus]) {
                this->_C_state |= this->_C_exp_negative;
                ++_C_in;
            }

            
            int __radix   = this->_C_base;
            this->_C_base = 10;
            __first       = _C_get_digit_string (__first);
            this->_C_base = __radix;

            if (__first == this->_C_exp_beg)
                this->_C_error |= this->_C_bad_exponent;
        }
    }

    return __first;
}


template <class _CharT, class InputIterator>
char* __rw_digit_reader<_CharT, InputIterator>::
    _C_get_digit_groups (char *__first) {

    char *__eod=_C_get_digit_string (__first);
    
    if (_C_gpos==_C_groups+sizeof _C_groups)
        this->_C_error|=this->_C_too_many_groups;
    else {
        int __i=__eod-__first;
        if (__i >= 127)
            this->_C_error|=this->_C_group_too_long;
        else {
            if (__i!=0) {
                *_C_gpos++=__i;
                if (!eof () && *_C_in==thousands_sep) {
                    ++_C_in;
                    __eod=_C_get_digit_groups (__eod);
                }
            }
        }
    }
    
    return __eod;
}


template <class _CharT, class InputIterator>
int __rw_digit_reader<_CharT, InputIterator>::
    _C_get_keyword (const __rw_keyword_map<_CharT> &__in_map) {

    const __rw_keyword_def<_CharT> *__map_ptr=__in_map._C_defs;
    const __rw_keyword_def<_CharT> *__end_ptr=__in_map._C_defs+__in_map._C_numdefs;
    
    __rw_keyword_def<_CharT> __can_ary[40],       
        *__can_ptr=__can_ary; 
    
    const _CharT *__name;
    int           __result;
    _CharT        __input;
    
    
    
    
    
    
    
    
    while (1) {
        if (eof ()) {
            for ( ; __map_ptr<__end_ptr; ++__map_ptr) 
                if (!*__map_ptr->_C_name)               
                    return __map_ptr->_C_indx;            
            return -1;                                
        }
        
        __input=*_C_in;
        __result=-1;
        
        for ( ; __map_ptr<__end_ptr; ++__map_ptr) {
            __name=__map_ptr->_C_name;
            if (__input==*__name) {
                __can_ptr->_C_name=++__name;
                __can_ptr->_C_indx=__map_ptr->_C_indx;
                ++__can_ptr;                 
            }
            else if (*__name==0 )           
                __result=__can_ptr->_C_indx;
        }                                   
                                            
                                            
        if (__can_ptr==__can_ary)           
            return __result;                
                                            
                                            
        
        ++_C_in;
        
        if (__can_ptr==__can_ary+1) { 
            for (__name=__can_ary[0]._C_name; *__name; ++__name) {
                if (eof () || *_C_in!=*__name) 
                    return -1;
                ++_C_in;
            }
            return __can_ary[0]._C_indx;
        }
        
        __end_ptr =__can_ptr;         
        __can_ptr =__can_ary;         
        __map_ptr =__can_ary;         
        
    }

}






template <class _CharT>
__rw_digit_writer_base_1<_CharT>::
__rw_digit_writer_base_1(std::ios_base &b, const __rw_punct_data<_CharT> &mp)
    : __rw_digit_writer_base (b),
      __rw_digit_handler_base_1<_CharT>(b.getloc (), mp) {

    _C_flags&=~(std::ios_base::floatfield | std::ios_base::showpos);
    _C_flags|=std::ios_base::fixed;
    _C_base=10;
    _C_precision=0;
}





template <class _CharT, class OutputIterator>
void __rw_digit_writer<_CharT, OutputIterator>::_C_put_digits (_CharT __fill) {

    char *__p=this->_C_start;
    bool __has_sign=false, __has_point=false,
        __has_prefix_8=false, __has_prefix_16=false;
    
    if (__p<this->_C_end && (*__p==' ' || *__p=='-' || *__p=='+')) {
        __has_sign=true;
        __p++;
    }

    if (__p+1 < this->_C_end
        && (this->_C_base == 16 && *__p == '0'
            && (*(__p+1) == 'x') || *(__p+1) == 'X'))
        __has_prefix_16 = true;
    
    if (__p+1 < this->_C_end
        && (this->_C_base == 8 && *__p == '0'))
        __has_prefix_8 = true;
            
    
    char *__dec;
    if (!this->_C_fractional)
        __dec=this->_C_end;
    else {
        __dec=this->_C_start;
        if (__has_sign) __dec++;
        for ( ; __dec<this->_C_end; ++__dec)
            if (*__dec<'0' || *__dec>'9') {
                if (*__dec!='e' && *__dec!='E')
                    __has_point=true;
                break;
            }
    }

    
    
    _CharT __separator = _CharT ();
    
    int __ungrouped=__dec-this->_C_start;
    if (__has_sign)
        __ungrouped--;
    if (__has_prefix_16)
        __ungrouped -= 2;
    if (__has_prefix_8)
        __ungrouped--;

    if (this->_C_separable) {
        __ungrouped=this->_C_calc_groups (__ungrouped, this->_C_get_grouping ());
        if (this->_C_num_groups)
            __separator=this->_C_get_thousands_sep ();
    }
    
    
    int __left_fill=0, __internal_fill=0, __right_fill=0;
    if (this->_C_width>0) {
        int __w=this->_C_width - (this->_C_end - this->_C_start)
                               - this->_C_num_groups;
        this->_C_width=0;

        if (__w>0) {
            switch (this->_C_adjust) {
            case __rw_digit_writer_base::_C_left:
                __right_fill=__w;
                break;
            case __rw_digit_writer_base::_C_internal:
                __internal_fill=__w;
                break;
            default:
                __left_fill=__w;
            }
        }
    }
    
    

    
    _CharT  __widebuf [__rw_digit_writer_base::_C_DEF_BUFSIZE];
    _CharT *__wide_digits = __widebuf;

    
    if (this->_C_end - this->_C_start >= __rw_digit_writer_base::_C_DEF_BUFSIZE)
        __wide_digits = new _CharT [this->_C_end - this->_C_start + 1];
    
    this->_C_ctyp.widen (this->_C_start, this->_C_end, __wide_digits);
    
    
    _CharT *__digit_pos = __wide_digits;
    while (__left_fill--)
        *_C_out++ = __fill;

    if (__has_sign)
        *_C_out++ = *__digit_pos++;    

    if (__has_prefix_16) {
        *_C_out++ = *__digit_pos++; 
        *_C_out++ = *__digit_pos++; 
    }
    if (__has_prefix_8) 
        *_C_out++ = *__digit_pos++; 

    while (__internal_fill--)
        *_C_out++ = __fill;

    while (__ungrouped--)
        *_C_out++ = *__digit_pos++;

    while (this->_C_num_groups--) {
        *_C_out++ = __separator;

        while (this->_C_group[0]--)
            *_C_out++=*__digit_pos++;
        ++this->_C_group;
    }
    
    if (__has_point) {
        *_C_out++=this->_C_get_decimal_point ();
        ++__digit_pos;
    }
    
    __ungrouped = this->_C_end - __dec;

    if (__has_point)
        __ungrouped--;

    while ((__ungrouped--) > 0)
        *_C_out++ = *__digit_pos++;
    
    while (__right_fill--)
        *_C_out++ = __fill;

    if (__wide_digits != __widebuf)
        delete[] __wide_digits;
}

template <class _CharT, class OutputIterator>
void __rw_digit_writer<_CharT, OutputIterator>::
    _C_put_keyword (const string_type &__instr, _CharT __fillchar) {

    int __left_fill=0, __right_fill=0;
    int __fillnum=this->_C_width-__instr.length ();
    if (__fillnum>0) {
        switch (this->_C_adjust) {
        case __rw_digit_writer_base::_C_left:
            __right_fill=__fillnum;
            break;
        case __rw_digit_writer_base::_C_internal:
        default:
            __left_fill=__fillnum;
        }
        if (__left_fill)
            do *_C_out++=__fillchar;
            while (--__left_fill);
    }
    
    const _CharT *__tmp=__instr.c_str (), *__endtmp=__tmp+__instr.length ();
    while (__tmp<__endtmp)
        *_C_out++=*__tmp++;
    
    if (__right_fill)
        do *_C_out++=__fillchar;
        while (--__right_fill);
}

}   


#line 890 "/opt/aCC/include_std/rw/numbrw"




#line 33 "/opt/aCC/include_std/rw/numeral.cc"


namespace __rw {

template <class _CharT>
__rw_numpunct_init_data<_CharT>*
 __rw_fixup_numpunct_init (__rw_numpunct_init_data<char> *init,
                                                 _CharT*) {
  if (init->_C_del)
    delete[] (char*) init;
  return 0L;
}





template <class _CharT>
void __rw_numpunct_impl_data<_CharT>::_C_initfacetbase (const locale&) {
  tf_defs_[0]._C_name=_C_tn.c_str();
  tf_defs_[0]._C_indx=1;
  tf_defs_[1]._C_name=_C_fn.c_str();
  tf_defs_[1]._C_indx=0;

  tf_map_._C_numdefs=2 ;
  tf_map_._C_defs=tf_defs_;
}

template <class _CharT>
__rw_numpunct_init_data<_CharT>*
__rw_numpunct_impl_data<_CharT>::_C_get_init_by_name_ (const char *name) {
  return __rw_fixup_numpunct_init(_C_get_named_init_(name), (_CharT*)0);
}

}   


namespace std {






template <class _CharT, class InputIterator>
locale::id num_get<_CharT, InputIterator>::id;




template <class _CharT, class _InputIterator>
_InputIterator num_get<_CharT, _InputIterator>::
do_get (_InputIterator __first, _InputIterator __last,
        ios_base& __flags, ios_base::iostate& __err, bool& __val) const
{
    __rw::__rw_digit_reader<_CharT, _InputIterator>
        __reader(__first, __last, __flags);

    long __tmp = __reader._C_parse (__reader._C_get_digits(long()), long());

    __err = ios_base::failbit;

    if (__flags.flags () & ios_base::boolalpha) {
        
        if (__reader._C_error) {
            const numpunct<_CharT>& __punct =
                static_cast< const numpunct<_CharT> & >(__reader . _C_punct);
            __tmp = __reader._C_get_keyword (__reader._C_get_tf_map (__punct));
            if (__tmp >= 0) {
                __val = __tmp;
                __err = ios_base::goodbit;
            }
        }
    }
    else if (!__reader._C_error) {
        
        if (0 == __tmp) {
            __val = false;
            __err = ios_base::goodbit;
        }
        else if (1 == __tmp && !(__reader._C_state & __reader._C_negative)) {
            __val = true;
            __err = ios_base::goodbit;
        }
    }

    
    if (__reader.eof ())
        __err |= ios_base::eofbit;

    return __first;
}








template <class _CharT, class OutputIterator>
locale::id num_put<_CharT, OutputIterator>::id;



template <class _CharT, class OutputIterator>
OutputIterator num_put<_CharT, OutputIterator>::do_put
    (OutputIterator out, ios_base& __flags, _CharT fill, bool __val) const
{
  __rw::__rw_digit_writer<_CharT, OutputIterator> writer(out, __flags);
  if (__flags.flags() & ios_base::boolalpha) {
    const numpunct<_CharT>& __punct =
        static_cast< const numpunct<_CharT> & >(writer . _C_punct);
    writer._C_put_keyword(writer._C_get_tf_string(__punct, __val), fill);
  } else {
    writer._C_digitize((unsigned long) (__val? 1 : 0));
    writer._C_put_digits(fill);
  }
  return out;
}



template <class _CharT, class OutputIterator>
OutputIterator num_put<_CharT, OutputIterator>::
do_put (OutputIterator out, ios_base& __flags, _CharT fill,
        const void* __val) const
{
  __rw::__rw_digit_writer<_CharT, OutputIterator> writer(out, __flags);
  writer._C_digitize(__val);
  writer._C_put_digits(fill);
  return out;
}

template <class _CharT, class OutputIterator>
OutputIterator num_put<_CharT, OutputIterator>::do_put
    (OutputIterator out, ios_base& __flags, _CharT fill, long __val) const
{
  __rw::__rw_digit_writer<_CharT, OutputIterator> writer(out, __flags);
  writer._C_digitize(__val);
  writer._C_put_digits(fill);
  return out;
}

template <class _CharT, class OutputIterator>
OutputIterator num_put<_CharT, OutputIterator>::
do_put (OutputIterator out, ios_base& __flags, _CharT fill,
        unsigned long __val) const
{
  __rw::__rw_digit_writer<_CharT, OutputIterator> writer(out, __flags);
  writer._C_digitize(__val);
  writer._C_put_digits(fill);
  return out;
}



template <class _CharT, class OutputIterator>
OutputIterator num_put<_CharT, OutputIterator>::do_put
    (OutputIterator out, ios_base& __flags, _CharT fill, 
     long long val) const
{
  __rw::__rw_digit_writer<_CharT, OutputIterator> writer(out, __flags);
  writer._C_digitize(val);
  writer._C_put_digits(fill);
  return out;
}

template <class _CharT, class OutputIterator>
OutputIterator num_put<_CharT, OutputIterator>::do_put
    (OutputIterator out, ios_base& __flags, _CharT fill, 
     unsigned long long val) const
{
  __rw::__rw_digit_writer<_CharT, OutputIterator> writer(out, __flags);
  writer._C_digitize(val);
  writer._C_put_digits(fill);
  return out;
}



template <class _CharT, class OutputIterator>
OutputIterator num_put<_CharT, OutputIterator>::do_put
    (OutputIterator out, ios_base& __flags, _CharT fill, double __val) const
{
  __rw::__rw_digit_writer<_CharT, OutputIterator> digits(out, __flags);
  digits._C_digitize(__val);
  digits._C_put_digits(fill);
  return out;
}


template <class _CharT, class OutputIterator>
OutputIterator num_put<_CharT, OutputIterator>::
do_put (OutputIterator out, ios_base& __flags, _CharT fill,
        long double __val) const
{
  __rw::__rw_digit_writer<_CharT, OutputIterator> digits(out, __flags);
  digits._C_digitize(__val);
  digits._C_put_digits(fill);
  return out;
}



template <class _CharT, class OutputIterator>
OutputIterator num_put<_CharT, OutputIterator>::do_put
    (OutputIterator out, ios_base& __flags, _CharT fill, short __val) const
{
  __rw::__rw_digit_writer<_CharT, OutputIterator> writer(out, __flags);
  writer._C_digitize(__val);
  writer._C_put_digits(fill);
  return out;
}

template <class _CharT, class OutputIterator>
OutputIterator num_put<_CharT, OutputIterator>::
do_put (OutputIterator out, ios_base& __flags, _CharT fill,
        unsigned short __val) const
{
  __rw::__rw_digit_writer<_CharT, OutputIterator> writer(out, __flags);
  writer._C_digitize(__val);
  writer._C_put_digits(fill);
  return out;
}

template <class _CharT, class OutputIterator>
OutputIterator num_put<_CharT, OutputIterator>::do_put
    (OutputIterator out, ios_base& __flags, _CharT fill, int __val) const
{
  __rw::__rw_digit_writer<_CharT, OutputIterator> writer(out, __flags);
  writer._C_digitize(__val);
  writer._C_put_digits(fill);
  return out;
}

template <class _CharT, class OutputIterator>
OutputIterator num_put<_CharT, OutputIterator>::
do_put (OutputIterator out, ios_base& __flags, _CharT fill,
        unsigned int __val) const
{
  __rw::__rw_digit_writer<_CharT, OutputIterator> writer(out, __flags);
  writer._C_digitize(__val);
  writer._C_put_digits(fill);
  return out;
}





template <class _CharT>
locale::id numpunct<_CharT>::id;

template <class _CharT>
void numpunct<_CharT>::_C_initfacet (const locale &loc) {
  this->_C_dp=do_decimal_point();
  this->_C_ts=do_thousands_sep();
  this->_C_gr=do_grouping();
  this->_C_fn=do_falsename();
  this->_C_tn=do_truename();
  this->_C_initfacetbase(loc);
}


}   
#line 760 "/opt/aCC/include_std/rw/numeral"



#line 38 "/opt/aCC/include_std/rw/vendor"


namespace __rw {















template< >
inline std::ctype<char>*
__rw_create_native_facet (std::ctype<char>*)
{
    return new std::ctype<char>(0, false, 1);
}


template< >
inline std::numpunct<char>*
__rw_create_native_facet (std::numpunct<char>*)
{
    return new std::numpunct_byname<char>("", 1);
}





template <class _Facet>
inline _Facet*
__rw_create_native_facet (_Facet*)
{
    return __rw_create_named_facet ((_Facet*)0, "", size_t (1));
}


}   


#line 774 "/opt/aCC/include_std/rw/rwlocale"


#line 37 "/opt/aCC/include_std/ios"
#line 1 "/opt/aCC/include_std/rw/codecvt"































 

#line 1 "/opt/aCC/include_std/limits"





























 





























 





#line 79 "/opt/aCC/include_std/limits"


#line 87 "/opt/aCC/include_std/limits"







#line 100 "/opt/aCC/include_std/limits"

#line 109 "/opt/aCC/include_std/limits"









extern const float _FLT_NANS;         
extern const float _FLT_DMIN;         





extern const double _DBL_NANS;        
extern const double _DBL_DMIN;        

#line 134 "/opt/aCC/include_std/limits"





extern const long double _LDBL_NANS;  
extern const long double _LDBL_DMIN;  

#line 166 "/opt/aCC/include_std/limits"















#line 226 "/opt/aCC/include_std/limits"











#line 314 "/opt/aCC/include_std/limits"


#line 35 "/opt/aCC/include_std/rw/codecvt"




namespace std {



class codecvt_base
{
public:
    enum result { ok, partial, error, noconv };
};







#pragma vtable OFF_IF_NO_KEY_BEGIN


template <class _InternT, class _ExternT, class _StateT>
class codecvt: public locale::facet,
               public codecvt_base
{
public:
    typedef _InternT intern_type;
    typedef _ExternT extern_type;
    typedef _StateT  state_type;

    explicit codecvt (size_t __ref = 0): locale::facet (__ref) { }

    result out (state_type& __state,
                const intern_type* __from, const intern_type* __from_end,
                const intern_type*& __from_next,
                extern_type* __to, extern_type* __to_limit,
                extern_type*& __to_next) const {
        return do_out(__state,__from,__from_end,__from_next,
                      __to,__to_limit,__to_next);
    }

    result unshift (state_type& __state, extern_type* __to,
                    extern_type* __to_limit, extern_type*& __to_next) const {
        return do_unshift (__state,__to,__to_limit,__to_next);
    }

    result in (state_type& __state, const extern_type* __from,
               const extern_type* __from_end, const extern_type*& __from_next,
               intern_type* __to, intern_type* __to_limit,
               intern_type*& __to_next) const {
        return do_in (__state,__from,__from_end,__from_next,
                      __to,__to_limit,__to_next);
    }

    bool always_noconv() const throw() {
        return do_always_noconv();
    }

    int encoding() const throw() {
        return do_encoding();
    }

    int length (state_type& __state, const extern_type* __from,
                const extern_type* end, size_t __max) const {
        return do_length(__state,__from,end,__max);
    }

    int max_length() const throw()  {
        return do_max_length();
    }

    static locale::id id;

    
    typedef basic_string<extern_type,char_traits<extern_type>,
                         allocator<extern_type> >
    external_string_type;

    typedef basic_string<intern_type,char_traits<intern_type>,
                         allocator<intern_type> >
    internal_string_type;

    internal_string_type in (const external_string_type &) const;

    external_string_type out (const internal_string_type &) const;

    
    enum { _C_facet_cat = locale::ctype, _C_ok_implicit = 1 };

protected:

    

    virtual result do_out (state_type&,
                           const intern_type*, const intern_type*,
                           const intern_type*&,
                           extern_type*, extern_type*, extern_type*&) const {
        return noconv;
    }

    virtual result do_in (state_type&, const extern_type*,
                          const extern_type*, const extern_type*&,
                          intern_type*, intern_type*, intern_type*&) const {
        return noconv;
    }

    
    virtual result do_unshift (state_type&, extern_type *__to,
                               extern_type*, extern_type *&__to_next) const {
        __to_next = __to;
        return noconv;
    }

    
    virtual int do_encoding () const throw() {
        return 1;   
    }

    
    virtual bool do_always_noconv () const throw() {
        return true;   
    }

    
    virtual int do_length (state_type&, const extern_type* __from,
                           const extern_type *__end, size_t __max) const {
        
        size_t __n = __end - __from;
        return __n < __max ? __n : __max;
    }

    
    virtual int do_max_length () const throw() {
        
        
        return 1;
    }

    virtual ~codecvt() {}
    
private:

#line 186 "/opt/aCC/include_std/rw/codecvt"

};




template< >
class codecvt<char, char, mbstate_t>: public locale::facet,
                                      public codecvt_base
{
public:
    typedef char      extern_type;   
    typedef char      intern_type;
    typedef mbstate_t state_type;

    explicit codecvt (size_t __refs = 0)
        : locale::facet (__refs, locale::ctype) { }

    result out (state_type &__state,
                const intern_type *__from, const intern_type* __from_end,
                const intern_type *&__from_next,
                extern_type* __to, extern_type* __to_limit,
                extern_type *&__to_next) const {
        return do_out (__state, __from, __from_end, __from_next,
                       __to, __to_limit, __to_next);
    }

    result unshift (state_type &__state,
                    extern_type *__to, extern_type *__to_limit,
                    extern_type*& __to_next) const {
        return do_unshift (__state, __to, __to_limit, __to_next);
    }

    result in (state_type &__state,
               const extern_type *__from, const extern_type *__from_end,
               const extern_type *&__from_next,
               intern_type *__to, intern_type *__to_limit,
               intern_type *&__to_next) const {
        return do_in (__state, __from, __from_end, __from_next,
                      __to, __to_limit, __to_next);
    }

    int encoding () const throw() {
        return do_encoding ();
    }

    bool always_noconv () const throw() {
        return do_always_noconv ();
    }

    int length (const state_type &__state, const extern_type *__from,
                const extern_type *__end,  size_t __max) const {
        return do_length (__state,__from,__end,__max);
    }

    int max_length () const throw() {
        return do_max_length ();
    }

    static locale::id  id;



    
    typedef string internal_string_type;
    typedef string external_string_type;

    internal_string_type in (const external_string_type & __s) const {
        return __s;
    }

    external_string_type out (const internal_string_type &__s) const {
        return __s;
    }



    
    enum { _C_facet_cat = locale::ctype, _C_ok_implicit = 1 };

protected:

    virtual result do_out (state_type&,
                           const intern_type *__from, const intern_type*,
                           const intern_type *&__from_next,
                           extern_type *__to, extern_type*,
                           extern_type *&__to_next) const {
        __from_next = __from;
        __to_next   = __to;
        return noconv; 
    }

    virtual result do_in (state_type&,
                          const extern_type *__from, const extern_type*,
                          const extern_type *&__from_next,
                         intern_type *__to, intern_type*,
                          intern_type*& __to_next) const {
        __from_next = __from;
        __to_next   = __to;
        return noconv; 
    }

    
    virtual result do_unshift (state_type&, extern_type *__to,
                               extern_type*, extern_type *&__to_next) const {
        __to_next = __to;
        return noconv;
    }

    virtual int do_encoding () const throw() {
        return 1;   
    }

    virtual bool do_always_noconv () const throw(){
        return true;   
    }

    virtual int do_length (const state_type&,
                           const extern_type *__from,
                           const extern_type *__from_end,
                           size_t __max) const {
        
        ((void)0);

        
        size_t __len = __from_end - __from;
        return __len < __max ? __len : __max; 
    }

    virtual int do_max_length () const throw() {
        return 1;   
    }

    virtual ~codecvt() {}

#line 330 "/opt/aCC/include_std/rw/codecvt"
};







template< >
class  codecvt<wchar_t, char, mbstate_t> : public locale::facet,
                                                        public codecvt_base
{
public:
    typedef wchar_t   intern_type;
    typedef char      extern_type;
    typedef mbstate_t state_type;

    explicit codecvt (size_t __refs = 0)
        : locale::facet(__refs,locale::ctype) { }

    result out (state_type& __state,
                const intern_type *__from, const intern_type *__from_end,
                const intern_type *&__from_next,
                extern_type *__to, extern_type* __to_limit,
                extern_type *& __to_next) const {
        return do_out (__state, __from, __from_end, __from_next, __to,
                       __to_limit, __to_next);
    }

    result unshift (state_type &__state,
                    extern_type *__to, extern_type *__to_limit,
                    extern_type *&__to_next) const {
        return do_unshift (__state, __to, __to_limit, __to_next);
    }

    result in (state_type& __state,
               const extern_type *__from, const extern_type *__from_end,
               const extern_type *&__from_next,
               intern_type *__to, intern_type *__to_limit,
               intern_type *&__to_next) const {
        return do_in (__state, __from, __from_end, __from_next,
                      __to, __to_limit, __to_next);
  }

    int encoding () const throw() {
        return do_encoding();
    }

    bool always_noconv () const throw() {
        return do_always_noconv ();
    }

    int length (const state_type &__state,
                const extern_type *__from, const extern_type *__end,
                size_t __max) const {
        return do_length (__state, __from, __end, __max);
    }

    int max_length () const throw() {
        return do_max_length ();
    }

    static locale::id  id;

    
    typedef string external_string_type;
    typedef wstring internal_string_type;

    inline
    internal_string_type in (const external_string_type&) const;

    external_string_type out (const internal_string_type&) const;

    
    enum { _C_facet_cat = locale::ctype, _C_ok_implicit = 1 };

protected:

    virtual result do_out (state_type&,
                           const intern_type*, const intern_type*,
                           const intern_type*&,
                           extern_type*, extern_type*, extern_type*&) const;
    
    virtual result do_in (state_type&,
                          const extern_type*, const extern_type*,
                          const extern_type*&,
                          intern_type*, intern_type*, intern_type*&) const;

    
    virtual result do_unshift (state_type&, extern_type *__to,
                               extern_type*, extern_type *&__to_next) const {
        __to_next = __to;
        return noconv;
    }

    virtual bool do_always_noconv () const throw() {
        return false;   
    }

    virtual int do_encoding () const throw() {
        return 1;   
    }

    virtual int do_length (const state_type&, const extern_type* __from,
                           const extern_type* __from_end,
                           size_t __max) const {
        
        ((void)0);

        
        size_t __len = __from_end - __from;
        return __len < __max ? __len : __max; 
    }


    virtual int do_max_length () const throw() {
        return 1;
    }

    virtual ~codecvt() {}

#line 460 "/opt/aCC/include_std/rw/codecvt"
};


#pragma vtable OFF_IF_NO_KEY_END


inline codecvt_base::result
codecvt<wchar_t, char, mbstate_t>::
do_out (state_type&,
        const intern_type *__from, const intern_type *__from_end,
        const intern_type *&__from_next,
        extern_type *__to, extern_type *__to_end, extern_type *&__to_next) const
{
    
    ((void)0);
    ((void)0);

    
    for (__from_next = __from, __to_next = __to;
         __from_next != __from_end && __to_next != __to_end;
         ++__from_next, ++__to_next)
        *__to_next = (extern_type)*__from_next;

    return ok;
}


inline codecvt_base::result
codecvt<wchar_t,char,mbstate_t>::
do_in (state_type&,
       const extern_type *__from, const extern_type *__from_end,
       const extern_type *&__from_next,
       intern_type *__to, intern_type *__to_end, intern_type *&__to_next) const
{
    
    ((void)0);
    ((void)0);

    
    for (__from_next = __from, __to_next = __to;
         __from_next != __from_end && __to_next != __to_end;
         ++__from_next, ++__to_next) {
        
        *__to_next = static_cast< unsigned char >(*__from_next);
    }

    return ok;
}



inline wstring
codecvt<wchar_t,char,mbstate_t>::in (const string &__s) const {

    wchar_t  __result_buf[1000];
    size_t   __max = sizeof (__result_buf) / sizeof (wchar_t);
    size_t   __n = mbstowcs(__result_buf,__s.c_str(),__max);
    
    (__n != size_t(-1)) ? (void)0 : throw (runtime_error&)runtime_error ("/opt/aCC/include_std/rw/codecvt" ":" "518" ": "). _C_format ((0 + 22), "codecvt<>::in (const string&) const");


    
    if (__n==__max) {
    
    
    }
    return wstring(__result_buf,(wstring::size_type)__n);
}



inline string
codecvt<wchar_t,char,mbstate_t>::out (const wstring &__s) const {
    char __result_buf[1000];
    size_t __n=wcstombs(__result_buf,__s.c_str(),sizeof __result_buf);
    
    (__n != size_t (-1)) ? (void)0 : throw (runtime_error&)runtime_error ("/opt/aCC/include_std/rw/codecvt" ":" "536" ": "). _C_format ((0 + 22), "codecvt<>::out(const wstring&) const");


    
    if (__n==sizeof __result_buf) {
        
        
    }

    return string(__result_buf,(string::size_type)__n);
}





template <class _InternT, class _ExternT, class _StateT>
class codecvt_byname: public codecvt<_InternT, _ExternT, _StateT>
{
public:
  
    typedef _InternT intern_type;
    typedef _ExternT extern_type;
    typedef _StateT  state_type; 

    explicit codecvt_byname (const char*, size_t __ref = 0)
        : codecvt <_InternT, _ExternT, _StateT> (__ref) { }

protected:

    virtual codecvt_base::result
    do_out (state_type&,
            const intern_type*, const intern_type*, const intern_type*&,
            extern_type*, extern_type*, extern_type*&) const {
        return codecvt_base::error;
    }

    virtual codecvt_base::result
    do_in (state_type&,
           const extern_type*, const extern_type*, const extern_type*&,
           intern_type*, intern_type*, intern_type*&) const {
        return codecvt_base::error;
    }

    virtual codecvt_base::result
    do_unshift (state_type&,
                extern_type*, extern_type*, extern_type*&) const {
        return codecvt_base::error;
    }

    virtual int do_encoding () const throw() {
        return -1;
    }

    virtual bool do_always_noconv () const throw() {
        return false;
    }

    virtual ~codecvt_byname() {}
};

extern template class codecvt_byname<char,char,mbstate_t>;




template <class _InternT,class _ExternT,class _StateT>
typename codecvt<_InternT,_ExternT,_StateT>::internal_string_type
codecvt<_InternT,_ExternT,_StateT>::in (const external_string_type &__s) const
{
    
    
    
    
    

    
    

    int __n = 1000; 
                    
                    
    
    const extern_type* __unused_from;
    intern_type*       __unused_to;
    
    intern_type *__conversion_buffer = new intern_type[__n];

    state_type __stt (0);

    __n = do_in (__stt,
                 __s.c_str(), __s.c_str() + __s.length(), __unused_from,
                 __conversion_buffer, __conversion_buffer + __n, __unused_to);

    internal_string_type __result (__conversion_buffer,
                                   __conversion_buffer + __n);

    delete[] __conversion_buffer;

    return __result;
}


#pragma vtable OFF_IF_NO_KEY_BEGIN


template< >
class codecvt_byname<wchar_t, char, mbstate_t>
    : public codecvt<wchar_t, char, mbstate_t>
{
public:

    explicit codecvt_byname (const char* = 0, size_t __ref = 0)
        : codecvt<wchar_t, char, mbstate_t> (__ref) { }

protected:

    virtual codecvt_base::result
    do_out (state_type&,
            const intern_type*, const intern_type*, const intern_type*&,
            extern_type*, extern_type*, extern_type*&) const;

    virtual codecvt_base::result
    do_in (state_type&,
           const extern_type*, const extern_type*, const extern_type*&,
           intern_type*, intern_type*, intern_type*&) const;

    virtual codecvt_base::result
    do_unshift (state_type&,
                extern_type*, extern_type*, extern_type*&) const;

    virtual int do_encoding () const throw() {
        
        
        
        return mbtowc (0, 0, 0) ? -1 : 1;
    }

    virtual bool do_always_noconv () const throw() {
        return false;   
    }

    virtual int do_max_length () const throw() {
        
        
        return __nl_char_size;
    }

    virtual ~codecvt_byname() {}
};


#pragma vtable OFF_IF_NO_KEY_END


inline codecvt_base::result
codecvt_byname <wchar_t, char, mbstate_t>::
do_unshift (mbstate_t& __state,
            extern_type* __to, extern_type* __to_end,
            extern_type*& __to_next) const
{
    intern_type __c      = intern_type ();
    const intern_type *__dummy = 0;

    
    
    
    return do_out (__state, &__c, &__c + 1, __dummy,
                   __to, __to_end, __to_next);
}


}   

#line 1 "/opt/aCC/include_std/rw/codecvt.cc"





























 

namespace std {






template <class _InternT,class _ExternT,class _StateT>
locale::id codecvt<_InternT,_ExternT,_StateT>::id;


} 
#line 712 "/opt/aCC/include_std/rw/codecvt"



#line 39 "/opt/aCC/include_std/ios"
#line 1 "/opt/aCC/include_std/rw/usefacet"






























 








namespace std {













template <class _Facet>
const _Facet& use_facet (const locale &__loc )
{
    const _Facet &__facet = static_cast< const _Facet& >(__loc . _C_use_facet (_Facet::id, _Facet::_C_ok_implicit, _Facet::_C_facet_cat, __rw::__rw_facet_maker<_Facet> ::_C_maker_func));





    return __facet;
}






template <class _Facet>
inline bool
has_facet (const locale &__loc )
    throw()
{
    return _Facet::_C_ok_implicit || __loc._C_get_facet (_Facet::id);
}







template <class _CharT>
inline bool isspace (_CharT __c, const locale& __loc)
{
    return use_facet < ctype<_CharT> >(__loc).is (ctype_base::space, __c);
}


template <class _CharT>
inline bool isprint (_CharT __c, const locale& __loc)
{
    return use_facet < ctype<_CharT> >(__loc).is (ctype_base::print, __c);
}

template <class _CharT>
inline bool iscntrl (_CharT __c, const locale& __loc)
{
    return use_facet < ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);
}


template <class _CharT>
inline bool isupper (_CharT __c, const locale& __loc)
{
    return use_facet < ctype<_CharT> >(__loc).is (ctype_base::upper, __c);
}


template <class _CharT>
inline bool islower (_CharT __c, const locale& __loc)
{
    return use_facet < ctype<_CharT> >(__loc).is (ctype_base::lower, __c);
}


template <class _CharT>
inline bool isalpha (_CharT __c, const locale& __loc)
{
    return use_facet < ctype<_CharT> >(__loc).is (ctype_base::alpha, __c);
}


template <class _CharT>
inline bool isdigit (_CharT __c, const locale& __loc)
{
    return use_facet < ctype<_CharT> >(__loc).is (ctype_base::digit, __c);
}


template <class _CharT>
inline bool ispunct (_CharT __c, const locale& __loc)
{
    return use_facet < ctype<_CharT> >(__loc).is(ctype_base::punct, __c);
}


template <class _CharT>
inline bool isxdigit (_CharT __c, const locale& __loc)
{
    return use_facet < ctype<_CharT> >(__loc).is (ctype_base::xdigit, __c);
}


template <class _CharT>
inline bool isalnum (_CharT __c, const locale& __loc)
{
    return use_facet < ctype<_CharT> >(__loc).is (ctype_base::alnum, __c);
}


template <class _CharT>
inline bool isgraph (_CharT __c, const locale& __loc)
{
    return use_facet < ctype<_CharT> >(__loc).is (ctype_base::graph, __c);
}


template <class _CharT>
inline _CharT toupper (_CharT __c, const locale& __loc)
{
    return use_facet < ctype<_CharT> >(__loc).toupper (__c);
}


template <class _CharT>
inline _CharT tolower (_CharT __c, const locale& __loc)
{
    return use_facet < ctype<_CharT> >(__loc).tolower (__c);
}


}   


#line 42 "/opt/aCC/include_std/ios"






namespace std {

template<class _CharT, class _Traits>
class  basic_ios : public ios_base
{ 
public:

    typedef _CharT                                  char_type;
    typedef _Traits                                 traits_type;

    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::int_type off_type;
      
protected:

    typedef basic_streambuf<char_type, traits_type> streambuf_type; 
    typedef basic_ostream<char_type, traits_type>   ostream_type;

public:

    
    

    explicit basic_ios (streambuf_type *__sb) {
        init (__sb);
    }

    operator void*() const {
        return fail () ? (void*)0 : (void*)1;
    }

    bool operator! () const {
        return fail ();
    }

    iostate rdstate () const {
        return _C_state;
    }

    
    inline iostate clear (iostate __st, iostate __mask);

    void clear (iostate __st = goodbit) {
        clear (__st, ~0);
    }

    
    iostate setstate (iostate __st, iostate __mask) {
        return clear (rdstate () | __st, __mask);
    }

    void setstate (iostate __st) {
        clear (rdstate () | __st);
    }

    bool good () const {
        return goodbit == rdstate ();
    }

    bool eof () const {
        return 0 != (rdstate () & eofbit);
    }

    bool fail () const {
        return 0 != (rdstate () & (failbit | badbit));
    }

    bool bad () const {
        return 0 != (rdstate () & badbit);
    }
      
    iostate exceptions () const {
        return _C_except;
    }

    void exceptions (iostate);
      
    ostream_type* tie () const {
        return _C_tiestrm;
    }

    ostream_type* tie (ostream_type *__strm) {
        return __rw::__rw_atomic_exchange (_C_tiestrm, __strm, this->_C_mutex);
    }

    
    

    streambuf_type* rdbuf () const {
        return _C_strmbuf;
    }

    streambuf_type* rdbuf (streambuf_type *__sb);

    basic_ios& copyfmt (const basic_ios& __rhs);
      
    char_type fill () const {
        return _C_fillch;
    }

    char_type fill (char_type __c) {
        return __rw::__rw_atomic_exchange (_C_fillch, __c, this->_C_mutex);
    }

    locale imbue (const locale&);

    char narrow (char_type __c, char __dflt) const {
        return use_facet < ctype<char_type> >(getloc ()).narrow (__c, __dflt);
    }

    char_type widen (char __c) const {
        return use_facet < ctype<char_type> >(getloc ()).widen (__c);
    }

protected:

    
    
    basic_ios () {   }

    void init (streambuf_type*);

private:

    basic_ios (const basic_ios&);              
    basic_ios& operator= (const basic_ios&);   

    streambuf_type *_C_strmbuf;   
    ostream_type   *_C_tiestrm;   
    char_type       _C_fillch;    
};

extern template class basic_ios<char, char_traits<char> >;
extern template class basic_ios<wchar_t, char_traits<wchar_t> >;



template<class _CharT, class _Traits>
inline ios_base::iostate
basic_ios<_CharT, _Traits>::clear (ios_base::iostate __st    ,
                                   ios_base::iostate __mask  )
{
    __rw::__rw_guard __rw_mt_temp_guard (this->_C_mutex);

    return _C_unsafe_clear (rdbuf () ? __st : __st | badbit, __mask);
}


template<class _CharT, class _Traits>
inline void basic_ios<_CharT, _Traits>::exceptions (iostate __ex)
{
    __rw::__rw_guard __rw_mt_temp_guard (this->_C_mutex);

    _C_except = __ex;

    _C_unsafe_clear (rdbuf () ? rdstate () : rdstate () | badbit);
}


template<class _CharT, class _Traits>
inline typename basic_ios<_CharT, _Traits>::streambuf_type* 
basic_ios<_CharT, _Traits>::rdbuf (streambuf_type *__sb)
{
    __rw::__rw_guard __rw_mt_temp_guard (this->_C_mutex);

    streambuf_type *__tmp = _C_strmbuf;

    
    _C_unsafe_clear ((_C_strmbuf = __sb) ? goodbit : badbit);

    return __tmp;
}


template<class _CharT, class _Traits>
inline locale basic_ios<_CharT, _Traits>::imbue (const locale& __loc)
{
    __rw::__rw_guard __rw_mt_temp_guard (this->_C_mutex);

    locale __tmp = _C_unsafe_imbue (__loc);
   
    if (rdbuf ())
        rdbuf()->pubimbue (__loc);

    return __tmp;
}


template<class _CharT, class _Traits>
inline basic_ios<_CharT, _Traits>&
basic_ios<_CharT, _Traits>::copyfmt (const basic_ios<_CharT, _Traits>& __rhs)
{
    __rw::__rw_guard __rw_mt_temp_guard (this->_C_mutex);

    
    _C_copyfmt (__rhs);

    _C_tiestrm = __rhs._C_tiestrm;
    _C_fillch  = __rhs._C_fillch;

    
    _C_fire_event (copyfmt_event, true);

    
    _C_except = __rhs._C_except;

    
    _C_unsafe_clear (rdstate ());

    return *this;
}


template<class _CharT, class _Traits>
inline void basic_ios<_CharT, _Traits>::init (streambuf_type *__sb)
{
    __rw::__rw_guard __rw_mt_temp_guard (this->_C_mutex);

    
    

    _C_state   = (_C_strmbuf = __sb) ? goodbit : badbit;
    _C_tiestrm = 0;
    _C_except  = goodbit;
    _C_fmtfl   = skipws | dec;
    _C_wide    = 0;
    _C_prec    = 6;
    _C_fillch  = widen (' ');
}


}   


#line 1 "/opt/aCC/include_std/ios.cc"




























 


namespace std {
  

}   



#line 285 "/opt/aCC/include_std/ios"



#line 36 "/opt/aCC/include_std/istream"
#line 1 "/opt/aCC/include_std/ostream"































 





#line 1 "/opt/aCC/include_std/streambuf"
































 










namespace std {


template<class _CharT, class _Traits>
class basic_streambuf: public __rw::__rw_synchronized
{
public:
    typedef _CharT                                    char_type;
    typedef _Traits                                   traits_type;

    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    virtual ~basic_streambuf () { }

    locale pubimbue (const locale &__loc);

    locale getloc () const {
        return _C_locale;
    }

    
    
    
    locale& getloc () {
        return _C_locale;
    }

    basic_streambuf* pubsetbuf (char_type *__buf, streamsize __n) {
        return setbuf (__buf, __n);
    }

    pos_type pubseekoff (off_type __off, ios::seekdir __way,
			 ios::openmode __which = ios::in | ios::out) {
        return seekoff (__off, __way, __which);
    }
    
    pos_type pubseekpos (pos_type __sp, 
                         ios::openmode __which = ios::in | ios::out) {
        return seekpos (__sp, __which);
    }
    
    int pubsync () {
        return sync ();
    }
    
    streamsize in_avail () {
        return gptr () < egptr () ? streamsize (egptr () - gptr ())
            : showmanyc ();
    }

    int_type snextc () {
        return _C_is_eof (sbumpc ()) ? traits_type::eof () : sgetc ();
    }
    
    int_type sbumpc ();
    
    int_type sgetc () {
        return gptr () >= egptr () ? underflow ()
            : traits_type::to_int_type (*gptr ());
    }
    
    streamsize sgetn (char_type *__s, streamsize __n) {
        ((void)0);
        return xsgetn (__s, __n);
    }
    
    int_type sputbackc (char_type);
    int_type sungetc ();

    int_type sputc (char_type __c);
    
    streamsize sputn (const char_type *__s, streamsize __n) {
        ((void)0);
        return xsputn (__s, __n);
    }

    ios::openmode _C_mode () const {
        return _C_iomode;
    }

protected:

    
    basic_streambuf (ios::openmode __mode = ios::in | ios::out) 
        : _C_iomode (__mode),
          _C_buffer (0),
          _C_bufsize (0),
          _C_bufstate (0),
          _C_eback (0),
          _C_gptr (0),
          _C_egptr (0),
          _C_pbase (0),
          _C_pptr (0),
          _C_epptr (0)
        { }
    
    char_type* eback () const {
        return _C_eback;
    }

    char_type* gptr () const {
        return _C_gptr;
    }

    char_type* egptr () const {
        return _C_egptr;
    }

    void gbump (int __n) {
        ((void)0);
        _C_gptr += __n;
    }

    void setg (char_type *__eback, char_type *__gptr, char_type *__egptr) {
        _C_eback = __eback;
        _C_gptr  = __gptr;
        _C_egptr = __egptr;
    }

    char_type* pbase () const {
        return _C_pbase;
    }

    char_type* pptr () const {
        return _C_pptr;
    }

    char_type* epptr () const {
        return _C_epptr;
    }

    void pbump (int __n) {
        _C_pptr += __n;
    }

    void setp (char_type *__pbase, char_type *__epptr) {
        _C_pbase = _C_pptr = __pbase;
        _C_epptr = __epptr;
    }


    virtual void imbue (const locale &__loc) {
        _C_locale = __loc;
    }

    virtual basic_streambuf* setbuf (char_type*, streamsize ) {
        return this;
    }

    virtual pos_type seekoff (off_type  , ios::seekdir  ,
                              ios::openmode   = ios::in | ios::out) {
        return pos_type (off_type (-1));
    }

    virtual pos_type seekpos (pos_type  ,
                              ios::openmode   = ios::in | ios::out) {
        return pos_type (off_type (-1));
    }

    virtual streamsize showmanyc () {
        return 0;
    }

    virtual streamsize xsgetn (char_type *, streamsize);

    virtual int_type underflow () {
        return traits_type::eof ();
    }

    virtual int_type uflow ();

    virtual int_type overflow (int_type = traits_type::eof ()) {
        return traits_type::eof ();
    }

    virtual int_type pbackfail (int_type = traits_type::eof ()) {
        return traits_type::eof ();  
    }

    virtual streamsize xsputn (const char_type*, streamsize);

    virtual int sync () {
        return 0;
    }


    
    
    

    
    streamsize _C_read_avail () const {
        return _C_is_in () ? egptr () - gptr () : 0;
    }

    
    streamsize _C_write_avail () const {
        return _C_is_out () ? epptr () - pptr () : 0;
    }

    
    streamsize _C_putback_avail () const {
        return (_C_is_in () && gptr () != 0) ? gptr () - eback () : 0;
    }

    
    bool _C_is_in () const {
        return 0 != (_C_iomode & ios::in);
    }

    
    bool _C_is_out () const {
        return  0 != (_C_iomode & ios::out);
    }

    
    bool _C_is_inout () const {
        return (_C_iomode & (ios::in | ios::out)) == (ios::in | ios::out);
    }

    
    bool _C_is_eof (int_type __c) const {
        return traits_type::eq_int_type (__c, traits_type::eof ());
    }

    
    char_type* _C_buf_end () const {
        return _C_buffer + _C_bufsize;
    }
    
    
    enum {
        _C_allocated   = 0x1,    
        _C_out_mode    = 0x2,    
        _C_unbuf_mode  = 0x4     
    }; 

    bool _C_own_buf () const {
        return 0 != (_C_bufstate & _C_allocated);
    }

    void _C_own_buf (bool __own) {
        if (__own)
            _C_bufstate |= _C_allocated;
        else
            _C_bufstate &= ~_C_allocated;
    }

    bool _C_out_last () const {
        return 0 != (_C_bufstate & _C_out_mode);
    }

    void _C_out_last (bool __last) {
        if (__last)
            _C_bufstate |= _C_out_mode;
        else
            _C_bufstate &= ~_C_out_mode;
    }

    bool _C_is_unbuffered () const {
        return 0 != (_C_bufstate & _C_unbuf_mode);
    }

    void _C_set_unbuffered (bool __unbuf) {
        if (__unbuf)
            _C_bufstate |= _C_unbuf_mode;
        else
            _C_bufstate &= ~_C_unbuf_mode;
    }

    
    ios::openmode  _C_iomode;     
    char_type*     _C_buffer;     
    streamsize     _C_bufsize;    
    int            _C_bufstate;   

private:

    char_type *_C_eback;   
    char_type *_C_gptr;    
    char_type *_C_egptr;   

    char_type *_C_pbase;   
    char_type *_C_pptr;    
    char_type *_C_epptr;   

    locale     _C_locale;  
};

extern template class basic_streambuf<char, char_traits<char> >;
extern template class basic_streambuf<wchar_t, char_traits<wchar_t> >;


template<class _CharT, class _Traits>
inline typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::uflow ()
{
    if (_C_is_eof (underflow ()))
        return traits_type::eof ();

    return traits_type::to_int_type (*_C_gptr++);
}

template<class _CharT, class _Traits>
inline typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::sbumpc ()
{ 
    if (! _C_read_avail ())
        return uflow ();
    
    char_type __c = *gptr ();  
    gbump (1);
    
    return traits_type::to_int_type (__c);
}

template<class _CharT, class _Traits>
inline typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::sputbackc (char_type __c)
{
    if (_C_putback_avail () && traits_type::eq (gptr ()[-1], __c) ) { 
        gbump (-1);
        return traits_type::to_int_type (*gptr ());
    }
    
    return pbackfail (traits_type::to_int_type (__c)); 
}

template<class _CharT, class _Traits>
inline typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::sputc (char_type __c)
{
    if (_C_write_avail ()) {
        traits_type::assign (*_C_pptr++, __c);
        return traits_type::to_int_type (__c);
    }

    return overflow (traits_type::to_int_type (__c));
}

template<class _CharT, class _Traits>
inline typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::sungetc ()
{
    if (gptr () > eback ()) {
        gbump (-1);
        return traits_type::to_int_type (*gptr ());
    }

    return pbackfail ();
}


template<class _CharT, class _Traits>
inline streamsize
basic_streambuf<_CharT, _Traits>::xsgetn (char_type* __buf, streamsize __n)
{
    streamsize __nget = 0;
    
    for (; __nget < __n; ++__nget) {
        int_type __c = sbumpc ();
        if (_C_is_eof (__c)) 
            break;
        traits_type::assign (*__buf++, traits_type::to_char_type (__c));
    }

    return __nget;
}

template<class _CharT, class _Traits>
inline streamsize
basic_streambuf<_CharT, _Traits>::xsputn (const char_type* __buf,
                                          streamsize __n)
{
    streamsize __nput = 0;

    for (; __nput < __n; ++__nput) 
        if (_C_is_eof (sputc (*__buf++)))
            break;
    
    return __nput;
}

template<class _CharT, class _Traits>
inline locale
basic_streambuf<_CharT, _Traits>::pubimbue (const locale &__loc)
{
    locale __retloc = getloc ();
    imbue (__loc);
    return __retloc; 
}


template<class _CharT, class _Traits >
class ostreambuf_iterator 
    : public iterator<output_iterator_tag, void, void, void, void>
{
public:

    typedef _CharT                                  char_type;
    typedef _Traits                                 traits_type;
    typedef basic_streambuf<char_type, traits_type> streambuf_type;
    typedef basic_ostream<char_type, traits_type>   ostream_type;

    ostreambuf_iterator (ostream_type &__strm) throw()
    : _C_sb (__strm.rdbuf ()) { }

    ostreambuf_iterator (streambuf_type *__sb) throw()
    : _C_sb (__sb) { }

    ostreambuf_iterator& operator* () {
        return *this;
    }

    ostreambuf_iterator& operator++ () {
        return *this;
    }

    ostreambuf_iterator& operator++ (int) {
        return *this;
    }

    ostreambuf_iterator& operator= (char_type __c) { 
        if (!failed () && traits_type::eq_int_type (_C_sb->sputc (__c),
                                                    traits_type::eof ()))
            _C_sb = 0;
        return *this;
    }

    bool failed () const throw() {
        return !_C_sb;
    }

private:
    streambuf_type *_C_sb;
};

extern template class ostreambuf_iterator<char, char_traits<char> >;
extern template class ostreambuf_iterator<wchar_t, char_traits<wchar_t> >;



template<class _CharT, class _Traits >
class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, 
                      typename _Traits::off_type, _CharT*, _CharT&>
{
public:

    typedef _CharT                                  char_type;
    typedef _Traits                                 traits_type;

    typedef typename traits_type::int_type int_type;

    typedef basic_streambuf<char_type, traits_type> streambuf_type;
    typedef basic_istream<char_type, traits_type>   istream_type;

    
    class proxy {
        char_type       _C_keep;
        streambuf_type *_C_sb;

        proxy (char_type __c, streambuf_type *__sb)
            : _C_keep (__c), _C_sb (__sb) { }

    public:
        
        char_type operator* () const {
            return _C_keep;
        }

        friend class istreambuf_iterator<char_type, traits_type>;
    };

public:

    istreambuf_iterator ()  throw()
    : _C_sb (0) { }

    istreambuf_iterator (istream_type& __strm)  throw()
    : _C_sb (__strm.rdbuf ()) { } 

    istreambuf_iterator (streambuf_type *__sb) throw()
    : _C_sb (__sb) { }

    istreambuf_iterator (const proxy &__proxy) throw()
    : _C_sb (__proxy._C_sb) { }

    char_type operator*() const {
        return traits_type::to_char_type (_C_sb ? _C_sb->sgetc ()
                                          : traits_type::eof ()) ;
    }

    istreambuf_iterator& operator++ () {
        if (_C_sb)
            _C_sb->sbumpc ();
        return *this;
    }

    proxy operator++ (int);

    
    bool equal (const istreambuf_iterator& __rhs) const {
        register const int_type __eof = traits_type::eof();
        return (_C_sb ? traits_type::eq_int_type(_C_sb->sgetc(), __eof) : true) ==
               (__rhs._C_sb ? traits_type::eq_int_type(__rhs._C_sb->sgetc(), __eof) : true);
    }

private:
    streambuf_type *_C_sb;
};

extern template class istreambuf_iterator<char, char_traits<char> >;
extern template class istreambuf_iterator<wchar_t, char_traits<wchar_t> >;



template<class _CharT, class _Traits>
inline typename istreambuf_iterator<_CharT, _Traits>::proxy 
istreambuf_iterator<_CharT, _Traits>::operator++(int)
{
    int_type __c = _C_sb ? _C_sb->sgetc () : traits_type::eof ();

    if (!traits_type::eq_int_type (__c, traits_type::eof ()))
        _C_sb->sbumpc ();

    return proxy (traits_type::to_char_type (__c), _C_sb);
}

template<class _CharT, class _Traits>
inline bool 
operator== (const istreambuf_iterator<_CharT, _Traits>& __x,
            const istreambuf_iterator<_CharT, _Traits>& __y)
{
    return __x.equal (__y);
}


template<class _CharT, class _Traits>
inline bool 
operator!= (const istreambuf_iterator<_CharT, _Traits>& __x, 
            const istreambuf_iterator<_CharT, _Traits>& __y)
{
    return !(__x == __y);
}


typedef basic_streambuf<char, char_traits<char> >         streambuf;
 



typedef basic_streambuf<wchar_t, char_traits<wchar_t> >   wstreambuf;




}   


#line 40 "/opt/aCC/include_std/ostream"


namespace __rw {


template <class _CharT, class _Traits, class _NativeType>
std::basic_ostream<_CharT, _Traits>&
__rw_insert (std::basic_ostream<_CharT, _Traits> &__strm,
             _NativeType                           __val);



template<class _CharT, class _Traits, class _StringT>
basic_ostream<_CharT, _Traits>&
__rw_insert (basic_ostream<_CharT, _Traits> &__strm,
             _StringT                       *__s,
             streamsize                      __len,
             streamsize                      __width);

}   


namespace std {

template<class _CharT, class _Traits>
class  basic_ostream:
    virtual public basic_ios<_CharT, _Traits>
{

public:
    typedef _CharT                             char_type;
    typedef _Traits                            traits_type;
    typedef typename traits_type::int_type    int_type;
    typedef typename traits_type::pos_type    pos_type;
    typedef typename traits_type::off_type    off_type;
      
    typedef basic_ios<char_type, traits_type>  ios_type;

    
    explicit basic_ostream (basic_streambuf<char_type, traits_type> *__sb) {
        this->init (__sb);
    }

    
    basic_ostream& _C_opfx ();

    
    class sentry: public __rw::__rw_guard {
        sentry (const sentry&);            
        sentry& operator= (const sentry&); 

    public:

        explicit
        sentry (basic_ostream<char_type, traits_type> &__strm)
            : __rw::__rw_guard (__strm.rdbuf () ? &__strm.rdbuf ()->_C_mutex : 0),
              _C_strm (__strm) {
                _C_ok = _C_strm._C_opfx ().good ();
            }

        
        ~sentry () {
            if (   (   _C_strm.flags () & ios_base::unitbuf
                    || _C_strm._C_is_sync ()
                    && _C_strm._C_is_std ())   
              
              
                 && _C_strm.rdbuf()     
                 && -1 == _C_strm.rdbuf ()->pubsync ()) {

                
                _C_strm.setstate (ios_base::badbit, 0);

            }    
        }

        operator bool () const {
            return _C_ok;
        }

    private:

        basic_ostream& _C_strm;   
        bool           _C_ok;     
    };

    

    
    basic_ostream& operator<< (basic_ostream& (*__pf)(basic_ostream&)) {
        return (*__pf)(*this);
    }

    
    basic_ostream& operator<< (ios_base& (*__pf)(ios_base&)) {
        return (*__pf)(*this), *this;
    }

    
    basic_ostream& operator<< (ios_type& (*__pf)(ios_type&)) {
        return (*__pf)(*this), *this;
    }

    



    basic_ostream& operator<<(bool __val) {
        return __rw::__rw_insert (*this, __val);
    }



    basic_ostream& operator<< (short __val) {
        return __rw::__rw_insert (*this, __val);
    }

    basic_ostream& operator<< (unsigned short __val) {
        return *this << static_cast< unsigned long >(__val);
    }

    basic_ostream& operator<< (int __val) {
        return __rw::__rw_insert (*this, __val);
    }

    basic_ostream& operator<< (unsigned int __val) {
        return *this << static_cast< unsigned long >(__val);
    }

    basic_ostream& operator<< (long __val) {
        return __rw::__rw_insert (*this, __val);
    }

    basic_ostream& operator<< (unsigned long __val) {
        return __rw::__rw_insert (*this, __val);
    }

    basic_ostream& operator<< (float __val) {
        return *this << static_cast<double>(__val);
    }

    basic_ostream& operator<< (double __val) {
        return __rw::__rw_insert (*this, __val);
    }

    basic_ostream& operator<< (long double __val) {
        return __rw::__rw_insert (*this, __val);
    }



    
    basic_ostream& operator<< (unsigned long long __val) {
        return __rw::__rw_insert (*this, __val);
    }

    
    basic_ostream& operator<< (long long __val) {
        return __rw::__rw_insert (*this, __val);
    }



    basic_ostream& operator<< (const void *__val) {
        return __rw::__rw_insert (*this, __val);
    }

    
    basic_ostream& operator<< (basic_streambuf<char_type, traits_type>&);

    
    basic_ostream&
    operator<< (basic_streambuf<char_type, traits_type> *__sb) {
        return __sb ? *this << *__sb : (this->setstate (ios::badbit), *this);
    }

    

    
    basic_ostream& put (char_type __c) {
        return __rw::__rw_insert (*this, &__c, 1, 0  );
    }

    
    basic_ostream& write (const char_type *__s, streamsize __len) {
        return __rw::__rw_insert (*this, __s, __len, 0  );
    }

    
    basic_ostream& flush ();

    

    
    pos_type tellp ();

    
    basic_ostream& seekp (pos_type __pos) {

        ((void)0);
        __rw::__rw_guard __rw_mt_temp_guard (this->rdbuf()->_C_mutex);

        if (!this->fail ())
            this->rdbuf ()->pubseekpos (__pos, ios_base::out);

        return *this;
    }

    
    basic_ostream& seekp (off_type, ios_base::seekdir);

    
    bool _C_is_cout () const {
        return false;
    }

    bool _C_is_cerr () const {
        return false;
    }

    
    bool _C_is_std () const {
        return false;
    }
    
    
    streamsize _C_pad (streamsize);
};

extern template class basic_ostream<char, char_traits<char> >;
extern template class basic_ostream<wchar_t, char_traits<wchar_t> >;


template<class _CharT, class _Traits>
inline streamsize
basic_ostream<_CharT, _Traits>::_C_pad (streamsize __len)
{
    
    for (streamsize __i = 0; __i < __len; ++__i) {
        if (traits_type::eq_int_type (this->rdbuf ()->sputc (this->fill ()), 
                                      traits_type::eof ())) {
            return __i;
        }
    }
    return __len;
}



extern  const void* __rw_std_streams[];


template< >
inline bool
basic_ostream<char, char_traits<char> >::_C_is_cout () const
{
    
    return static_cast< const ios_base* >(this) == __rw_std_streams [1];
}


template< >
inline bool
basic_ostream<char, char_traits<char> >::_C_is_cerr () const
{
    
    return static_cast< const ios_base* >(this) == __rw_std_streams [2];
}


template< >
inline bool
basic_ostream<char, char_traits <char> >::_C_is_std () const
{
    
    return    _C_is_cout () || _C_is_cerr ()
        || static_cast< const ios_base* >(this) == __rw_std_streams [3];
}




template< >
inline bool
basic_ostream<wchar_t, char_traits <wchar_t> >::_C_is_cout () const
{
    
    return static_cast< const ios_base* >(this) == __rw_std_streams [5];
}


template< >
inline bool
basic_ostream<wchar_t, char_traits <wchar_t> >::_C_is_cerr () const
{
    
    return static_cast< const ios_base* >(this) == __rw_std_streams [6];
}


template< >
inline bool
basic_ostream<wchar_t, char_traits <wchar_t> >::_C_is_std () const
{
    
    return    _C_is_cout () || _C_is_cerr ()
        || static_cast< const ios_base* >(this) == __rw_std_streams [7];
}




template<class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::flush ()
{
    if (this->rdbuf ()) {
        __rw::__rw_guard __rw_mt_temp_guard (this->rdbuf()->_C_mutex);

        if (-1 == this->rdbuf ()->pubsync ())
            this->setstate (ios_base::badbit);
    }

    return *this;
}
  

template<class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::seekp (off_type __off, ios_base::seekdir __dir)
{
    ((void)0);

    __rw::__rw_guard __rw_mt_temp_guard (this->rdbuf()->_C_mutex);

    if (!this->fail ())
        this->rdbuf()->pubseekoff (__off, __dir, ios_base::out);

    return *this;
}


template<class _CharT, class _Traits>
inline typename basic_ostream<_CharT, _Traits>::pos_type
basic_ostream<_CharT, _Traits>::tellp ()
{
    ((void)0);

    __rw::__rw_guard __rw_mt_temp_guard (this->rdbuf()->_C_mutex);

    return this->fail() ? pos_type (-1)
        : this->rdbuf()->pubseekoff (0, ios_base::cur, ios_base::out);
}


template <class _TypeT, 
          class _CharT , 
          class _Traits >
class ostream_iterator




    : public iterator<output_iterator_tag, void, void, void, void>

{
    typedef iterator<output_iterator_tag, _TypeT, 
                     typename _Traits::off_type, _TypeT*, _TypeT&> _C_base;
public:
    typedef _CharT                                char_type;
    typedef _Traits                               traits_type;
    typedef basic_ostream<char_type, traits_type> ostream_type;

    ostream_iterator (ostream_type& __strm) 
      : _C_strm (&__strm), _C_str (0) { }

    ostream_iterator (ostream_type& __strm, const char_type* __s) 
      : _C_strm (&__strm), _C_str (__s) { }

    ostream_iterator& operator= (const _TypeT &__val) { 
	*_C_strm << __val;
	if (_C_str)
	    *_C_strm << _C_str;
	return *this;
    }

    ostream_iterator& operator*  ()    { return *this; }
    ostream_iterator& operator++ ()    { return *this; } 
    ostream_iterator& operator++ (int) { return *this; }

protected:

    ostream_type*    _C_strm;   
    const char_type* _C_str;    
};




template<class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
operator<< (basic_ostream<_CharT, _Traits> &__strm, _CharT __c)
{
    __rw::__rw_insert (__strm, &__c, 1, __strm.width ()).width (0);
    return __strm;
}




template<class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
operator<< (basic_ostream<_CharT, _Traits> &__strm, char __c)
{
    __rw::__rw_insert (__strm, &__c, 1, __strm.width ()).width (0);
    return __strm;
}




template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<< (basic_ostream<char, _Traits> &__strm, char __c)
{
    __rw::__rw_insert (__strm, &__c, 1, __strm.width ()).width (0);
    return __strm;
}

#line 480 "/opt/aCC/include_std/ostream"


template<class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
operator<< (basic_ostream<_CharT, _Traits> &__strm, const _CharT *__s)
{
    __rw::__rw_insert (__strm, __s, _Traits::length (__s),
                      __strm.width ()).width (0);
    return __strm;
}




template<class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
operator<< (basic_ostream<_CharT, _Traits> &__strm, const char *__s)
{
    __rw::__rw_insert (__strm, __s, char_traits<char>::length (__s),
                      __strm.width ()).width (0);
    return __strm;
}




template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<< (basic_ostream<char, _Traits> &__strm, const char *__s)
{
    __rw::__rw_insert (__strm, __s, char_traits<char>::length (__s),
                      __strm.width ()).width (0);
    return __strm;
}

#line 527 "/opt/aCC/include_std/ostream"




template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<< (basic_ostream<char, _Traits> &__strm, unsigned char __c)
{
    return __strm << static_cast< char >(__c);
}


template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<< (basic_ostream<char, _Traits> &__strm, signed char __c)
{
    return __strm << static_cast< char >(__c);
}


template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<< (basic_ostream<char, _Traits> &__strm, const unsigned char *__s)
{
    return __strm << reinterpret_cast< const char* >(__s);
}


template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<< (basic_ostream<char, _Traits>& __strm, const signed char *__s)
{
    return __strm << reinterpret_cast< const char* >(__s);
}






template<class _CharT, class _Traits, class _Allocator>
inline basic_ostream<_CharT, _Traits>&
operator<< (basic_ostream<_CharT, _Traits>                  & __strm,
            const basic_string<_CharT, _Traits, _Allocator> &__str)
{
    __rw::__rw_insert (__strm, __str.data (), __str.length (),
                      __strm.width ()).width (0);
    return __strm;
}



template<class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
endl (basic_ostream<_CharT, _Traits>& __strm)
{



    return __strm.put (__strm.widen ('\n')).flush ();

}



template<class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
ends (basic_ostream<_CharT, _Traits>& __strm)
{
    return __strm.put (_CharT ());
}



template<class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
flush (basic_ostream<_CharT, _Traits>& __strm)
{
    return __strm.flush ();
}
 

}   


#line 1 "/opt/aCC/include_std/ostream.cc"




























 

namespace __rw {

using namespace std;



extern template basic_ostream<char, char_traits<char> >&
__rw_insert(basic_ostream<char, char_traits<char> >&, bool);

extern template basic_ostream<char, char_traits<char> >&
__rw_insert(basic_ostream<char, char_traits<char> >&, short);

extern template basic_ostream<char, char_traits<char> >&
__rw_insert(basic_ostream<char, char_traits<char> >&, int);
extern template basic_ostream<char, char_traits<char> >&
__rw_insert(basic_ostream<char, char_traits<char> >&, long);
extern template basic_ostream<char, char_traits<char> >&
__rw_insert(basic_ostream<char, char_traits<char> >&, unsigned long);

extern template basic_ostream<char, char_traits<char> >&
__rw_insert(basic_ostream<char, char_traits<char> >&, long long);
extern template basic_ostream<char, char_traits<char> >&
__rw_insert(basic_ostream<char, char_traits<char> >&, unsigned long long);

extern template basic_ostream<char, char_traits<char> >&
__rw_insert(basic_ostream<char, char_traits<char> >&, const void*);
extern template basic_ostream<char, char_traits<char> >&
__rw_insert(basic_ostream<char, char_traits<char> >&, float);
extern template basic_ostream<char, char_traits<char> >&
__rw_insert(basic_ostream<char, char_traits<char> >&, double);
extern template basic_ostream<char, char_traits<char> >&
__rw_insert(basic_ostream<char, char_traits<char> >&, long double);

extern template basic_ostream<char, char_traits<char> >&
__rw_insert(basic_ostream<char, char_traits<char> >&,
            const char*, streamsize, streamsize);
extern template basic_ostream<char, char_traits<char> >&
__rw_insert(basic_ostream<char, char_traits<char> >&,
            char*, streamsize, streamsize);



extern template basic_ostream<wchar_t, char_traits<wchar_t> >&
__rw_insert(basic_ostream<wchar_t, char_traits<wchar_t> >&, bool);

extern template basic_ostream<wchar_t, char_traits<wchar_t> >&
__rw_insert(basic_ostream<wchar_t, char_traits<wchar_t> >&, short);

extern template basic_ostream<wchar_t, char_traits<wchar_t> >&
__rw_insert(basic_ostream<wchar_t, char_traits<wchar_t> >&, int);
extern template basic_ostream<wchar_t, char_traits<wchar_t> >&
__rw_insert(basic_ostream<wchar_t, char_traits<wchar_t> >&, long);
extern template basic_ostream<wchar_t, char_traits<wchar_t> >&
__rw_insert(basic_ostream<wchar_t, char_traits<wchar_t> >&, unsigned long);

extern template basic_ostream<wchar_t, char_traits<wchar_t> >&
__rw_insert(basic_ostream<wchar_t, char_traits<wchar_t> >&, long long);
extern template basic_ostream<wchar_t, char_traits<wchar_t> >&
__rw_insert(basic_ostream<wchar_t, char_traits<wchar_t> >&, unsigned long long);

extern template basic_ostream<wchar_t, char_traits<wchar_t> >&
__rw_insert(basic_ostream<wchar_t, char_traits<wchar_t> >&, const void*);
extern template basic_ostream<wchar_t, char_traits<wchar_t> >&
__rw_insert(basic_ostream<wchar_t, char_traits<wchar_t> >&, float);
extern template basic_ostream<wchar_t, char_traits<wchar_t> >&
__rw_insert(basic_ostream<wchar_t, char_traits<wchar_t> >&, double);
extern template basic_ostream<wchar_t, char_traits<wchar_t> >&
__rw_insert(basic_ostream<wchar_t, char_traits<wchar_t> >&, long double);

#line 110 "/opt/aCC/include_std/ostream.cc"

extern template basic_ostream<wchar_t, char_traits<wchar_t> >&
__rw_insert(basic_ostream<wchar_t, char_traits<wchar_t> >&,
            const wchar_t*, streamsize, streamsize);
extern template basic_ostream<wchar_t, char_traits<wchar_t> >&
__rw_insert(basic_ostream<wchar_t, char_traits<wchar_t> >&,
            wchar_t*, streamsize, streamsize);


template <class _CharT, class _Traits, class _NativeType>
basic_ostream<_CharT, _Traits>&
__rw_insert (basic_ostream<_CharT, _Traits> &__strm,
             _NativeType                     __val)
{
    ios::iostate __err = ios::goodbit;

    typename basic_ostream<_CharT, _Traits>::sentry __opfx (__strm);

    try {

        if (__opfx) {

            typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
                __num_put_t;

            if (use_facet < __num_put_t >(__strm . getloc ())
                .put (ostreambuf_iterator<_CharT, _Traits>(__strm), __strm,
                      __strm.fill (), __val).failed ())
                __err = ios::badbit;

            __strm.width (0);
        } 
    }
    catch (...) {
        if (__strm.setstate (ios::badbit, 0))
            throw;
    }

    if (__err)
        __strm.setstate (__err);

    return __strm;
}



template <class _CharT, class _Traits>
inline streamsize
__rw_sputn (basic_ostream<_CharT, _Traits> &__strm,
            const _CharT*__s, streamsize    __len)
{
    return __strm.rdbuf ()->sputn (__s, __len);

}





template <class _CharT, class _Traits>
inline streamsize
__rw_sputn (basic_ostream<_CharT, _Traits> &__strm,
            const char *__s, streamsize     __len)
{
    ((void)0);

    const ctype<_CharT>& __ct = use_facet < ctype<_CharT> >(__strm . getloc ());

    for (streamsize __i = 0; __i < __len; ++__i) {
        typename basic_ostream<_CharT, _Traits>::int_type __n =
            __strm.rdbuf ()->sputc (__ct.widen (__s [__i]));
        if (_Traits::eq_int_type (__n, _Traits::eof ()))
            return __i;
    }

    return __len;
}



template <class _Traits>
inline streamsize
__rw_sputn (basic_ostream<char, _Traits> &__strm,
            const char*__s, streamsize    __len)
{
    return __strm.rdbuf ()->sputn (__s, __len);
}

#line 233 "/opt/aCC/include_std/ostream.cc"


template<class _CharT, class _Traits, class _StringT>
basic_ostream<_CharT, _Traits>&
__rw_insert (basic_ostream<_CharT, _Traits> &__strm,
             _StringT                       *__s,
             streamsize                      __len,
             streamsize                      __width)
{
    ((void)0);
    ((void)0);
      
    ios::iostate __err = ios::goodbit;

    try {
  
        typename basic_ostream<_CharT, _Traits>::sentry __opfx (__strm);

        if (__opfx) {

            
            
            const int __pad     = __width - __len;
            const int __padbits = ios::adjustfield & __strm.flags ();

            
            if (   ios::left != __padbits
                && __pad != __strm._C_pad (__pad))
                __err = ios::badbit;

            
            if (   ios::goodbit == __err
                && __len && __len != __rw_sputn (__strm, __s, __len))
                __err = ios::badbit;

            
            if (   ios::goodbit == __err
                && ios::left == __padbits
                && __pad != __strm._C_pad (__pad))
                __err = ios::badbit;
        }
    }
    catch (...) {
        if (__strm.setstate (ios::badbit, 0  ))
            throw;
    }

    if (__err)
        __strm.setstate (__err);  

    return __strm;
}


}   


namespace std {


template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::_C_opfx ()
{
    if (this->tie ())
        this->tie ()->flush ();

    if (this->_C_is_sync ()) {
    
        if (_C_is_cout ())       
            fflush ((&__iob[1]));
        else if (_C_is_std ())   
            fflush ((&__iob[2]));
    }

    return *this;
}


template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::
operator<< (basic_streambuf<_CharT, _Traits>& __sb)
{
    ios_base::iostate __err = 0;

    bool __extracted = false;    
    
    if (__sb._C_mode () & ios_base::in) {

        sentry opfx (*this);

        try {

            if (opfx) {
                if (_Traits::eq_int_type (__sb.sgetc (), _Traits::eof ()))
                    __err = ios_base::failbit;
                else {
                    while (true) {
                        int_type __c = __sb.sbumpc ();
                        if (_Traits::eq_int_type (__c, _Traits::eof ()))
                            break;
                        if (_Traits::eq_int_type (this->rdbuf ()->sputc (__c),
                                                  _Traits::eof ())) {
                            __err = ios_base::failbit;
                            break;
                        }
                        __extracted = true;
                    } 
                }
            }
        }
        catch (...) {
            if (this->setstate (ios_base::badbit, 0))
                throw;
        }
    }
    
    if (!__extracted) 
        __err = ios_base::failbit;
    
    if (__err)
        this->setstate (__err);

    return *this;
}


}   
#line 614 "/opt/aCC/include_std/ostream"




#line 38 "/opt/aCC/include_std/istream"








namespace __rw {

template <class _CharT, class _Traits, class _NativeType>
inline std::basic_istream<_CharT, _Traits>&
__rw_extract (std::basic_istream<_CharT, _Traits> &__strm,
              _NativeType                          &__val);

}   


namespace std {

template<class _CharT, class _Traits>
class  basic_istream
    : virtual public basic_ios<_CharT, _Traits>
{
public:

    typedef _CharT                                    char_type;
    typedef _Traits                                   traits_type;
    typedef typename traits_type::int_type           int_type;
    typedef typename traits_type::pos_type           pos_type;
    typedef typename traits_type::off_type           off_type;
      
    typedef basic_ios<char_type, traits_type>         ios_type;
    typedef basic_streambuf<char_type, traits_type>   streambuf_type;

    explicit basic_istream (streambuf_type *__sb)
        : _C_chcount (0) {
        this->init (__sb);   
    }

    
    basic_istream& _C_ipfx (int __flags);

    class sentry: public __rw::__rw_guard
    {
        bool _C_ok;

        sentry (const sentry&);            
        sentry& operator= (const sentry&); 

    public:

        
        explicit sentry (basic_istream &__strm, bool __noskipws = false)
            :  __rw::__rw_guard (__strm.rdbuf ()->_C_mutex) {
            int __flags = (__strm.flags () & ios::skipws && !__noskipws ?
                _C_skipws : 0) | _C_faileof;
                _C_ok = __strm._C_ipfx (__flags).good ();
            }
        
        operator bool () const {
            return _C_ok;
        }
    };

    
    basic_istream& operator>> (basic_istream& (*__pf)(basic_istream&)) {
        return (*__pf)(*this);
    }

    
    basic_istream& operator>> (ios_base& (*__pf)(ios_base&)) {
        return (*__pf)(*this), *this;
    }

    
    basic_istream& operator>>(ios_type& (*__pf)(ios_type&)) {
        return (*__pf)(*this), *this;
    }



    basic_istream& operator>> (bool &__val) {
        return __rw::__rw_extract (*this, __val);
    }



    basic_istream& operator>>(short &__val) {
        return __rw::__rw_extract (*this, __val);
    }

    basic_istream& operator>>(unsigned short &__val) {
        return __rw::__rw_extract (*this, __val);
    }

    basic_istream& operator>>(int &__val) {
        return __rw::__rw_extract (*this, __val);
    }

    basic_istream& operator>>(unsigned int &__val) {
        return __rw::__rw_extract (*this, __val);
    }

    basic_istream& operator>>(long &__val) {
        return __rw::__rw_extract (*this, __val);
    }

    basic_istream& operator>>(unsigned long &__val) {
        return __rw::__rw_extract (*this, __val);
    }

    basic_istream& operator>>(float &__val) {
        return __rw::__rw_extract (*this, __val);
    }

    basic_istream& operator>>(double &__val) {
        return __rw::__rw_extract (*this, __val);
    }

    basic_istream& operator>>(long double &__val) {
        return __rw::__rw_extract (*this, __val);
    }



    basic_istream& operator>>(long long &__val) {
        return __rw::__rw_extract (*this, __val);
    }

    basic_istream& operator>>(unsigned long long &__val) {
        return __rw::__rw_extract (*this, __val);
    }



    basic_istream& operator>>(void* &__val) {
        return __rw::__rw_extract (*this, __val);
    }

    
    basic_istream& operator>> (streambuf_type& __sb) {
        
        return get (__sb, traits_type::eof ());
    }

    
    basic_istream& operator>>(streambuf_type *__sb) {
        return  __sb ? *this >> *__sb : (this->setstate (ios::badbit), *this);
    }

    

    
    int_type get () {
        return sentry (*this, true) ?
              _C_unsafe_get (&_C_chcount, traits_type::eof (), _C_faileof)
            : traits_type::eof ();
    }

    
    basic_istream& get (char_type& __ch) {
        return read (&__ch, 1, traits_type::eof (), _C_failnoi);
    }

    
    
    basic_istream& get (char_type *__s, streamsize __n, char_type __delim) {
        return read (__s, __n, traits_type::to_int_type (__delim),
                     _C_nullterm | _C_failnoi);
    }

    
    
    basic_istream& get (char_type *__s, streamsize __n) {
        return get (__s, __n, this->widen ('\n'));
    }

    
    
    basic_istream& get (streambuf_type*, int_type);

    
    basic_istream& get (streambuf_type& __sb, char_type __delim) {
        
        return get (&__sb, traits_type::to_int_type (__delim));
    }

    
    basic_istream& get (streambuf_type& __sb) {
        return get (__sb, this->widen ('\n'));
    }

    
    
    basic_istream& getline (char_type *__s, streamsize __n, char_type __delim) {
        
        return read (__s, __n, traits_type::to_int_type (__delim),
                     _C_nullterm | _C_eatdelim | _C_failend | _C_failnoi);
    }

    
    basic_istream& getline (char_type *__s, streamsize __n) {
        return getline (__s, __n, this->widen ('\n'));
    }

    
    basic_istream& ignore (streamsize __n = 1,
                           int_type __delim = traits_type::eof ()) {
        
        return read (0, __n, __delim, _C_eatdelim);
    }

    
    basic_istream& read (char_type*, streamsize, int_type, int);

    
    basic_istream& read (char_type *__s, streamsize __n) {
        return read (__s, __n, traits_type::eof (), _C_faileof);
    }

    
    streamsize readsome (char_type *__s, streamsize __n);

    
    int_type peek ();
      
    
    pos_type tellg ();

    
    inline basic_istream& seekg (pos_type);

    
    basic_istream& seekg (off_type, ios::seekdir);

    
    int sync ();

    
    basic_istream& putback (char_type);

    
    basic_istream& unget ();

    
    streamsize gcount () const {
        return _C_chcount;
    }

    
    enum {
        _C_nullterm = 0x01,   
        _C_wsterm   = 0x02,   
        _C_skipws   = 0x04,   
        _C_eatdelim = 0x08,   
        _C_faileof  = 0x10,   
        _C_failend  = 0x20,   
        _C_failnoi  = 0x40    
    };

    
    
    int_type _C_unsafe_get (streamsize* = 0,
                            int_type    = traits_type::eof (),
                            int         = 0);

protected:

    streamsize _C_chcount;   
};

extern template class basic_istream<char, char_traits<char> >;
extern template class basic_istream<wchar_t, char_traits<wchar_t> >;



template<class _CharT, class _Traits>
inline basic_istream<_CharT, _Traits>&
ws (basic_istream<_CharT, _Traits> &__strm)
{
    return __strm._C_ipfx (basic_istream<_CharT, _Traits>::_C_skipws);
}


template<class _CharT, class _Traits>
inline basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg (pos_type __pos)
{
    ((void)0);

    if (!this->fail ()) {
        __rw::__rw_guard __rw_mt_temp_guard (this->rdbuf ()->_C_mutex);

        
        
        
        if (-1 == this->rdbuf ()->pubseekpos (__pos, ios::in))
            this->setstate (ios::failbit);
    }

    return *this;
}


template<class _CharT, class _Traits>
inline basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg (off_type __off, ios::seekdir __dir)
{
    ((void)0);

    if (!this->fail ()) {
        __rw::__rw_guard __rw_mt_temp_guard (this->rdbuf ()->_C_mutex);

        
        
        
        if (-1 == this->rdbuf ()->pubseekoff (__off, __dir, ios::in))
            this->setstate (ios::failbit);
    }

    return *this;
}




template <class _Traits>
inline basic_istream<char, _Traits>&
operator>> (basic_istream<char, _Traits>& __strm, 
            unsigned char&                __c)
{
    return __strm >> reinterpret_cast< char& >(__c);
}

template <class _Traits>
inline basic_istream<char, _Traits>&
operator>> (basic_istream<char, _Traits>& __strm, 
            signed char&                  __c)
{
    return __strm >> reinterpret_cast< char& >(__c);
}


template <class _Traits>
inline basic_istream<char, _Traits>&
operator>> (basic_istream<char, _Traits>& __strm, 
            unsigned char*                __s)
{
    return __strm >> reinterpret_cast< char* >(__s);
}


template <class _Traits>
inline basic_istream<char, _Traits>&
operator>> (basic_istream<char, _Traits>& __strm, 
            signed char* __s)
{
    return __strm >> reinterpret_cast< char* >(__s);
}




template<class _CharT, class _Traits>
inline typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::peek ()
{
    ((void)0);

    _C_chcount = 0;

    return sentry (*this, true) ? this->rdbuf ()->sgetc ()
                                : traits_type::eof ();
}


template<class _CharT, class _Traits>
inline basic_istream<_CharT, _Traits>&
operator>> (basic_istream<_CharT, _Traits> &__strm, _CharT &__c)
{
    
    return __strm.read (&__c, 1, _Traits::eof (),
                        __strm._C_skipws | __strm._C_failnoi);
}



template<class _CharT, class _Traits>
inline basic_istream<_CharT, _Traits>&
operator>> (basic_istream<_CharT, _Traits> &__strm, _CharT *__s)
{
    ((void)0);

    
    const streamsize __maxlen = __strm.width () ? __strm.width () :
                                numeric_limits<streamsize>::max () - 1;

    
    __strm.read (__s, __maxlen, _Traits::to_int_type (__strm.widen ('\n')),
                   __strm._C_nullterm | __strm._C_wsterm
                 | __strm._C_skipws   | __strm._C_failnoi);

    __strm.width (0);

    return __strm;
}


template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>& 
operator>> (basic_istream<_CharT, _Traits>&            __is,
            basic_string<_CharT, _Traits, _Allocator>& __str);


template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>& 
getline (basic_istream<_CharT, _Traits>&            __strm,
         basic_string<_CharT, _Traits, _Allocator>& __str,
         _CharT                                     __delim);

#line 481 "/opt/aCC/include_std/istream"

template<class _CharT, class _Traits, class _Allocator>
inline basic_istream<_CharT, _Traits>& 
getline (basic_istream<_CharT, _Traits>&            __is,
         basic_string<_CharT, _Traits, _Allocator>& __str)
{
    return getline (__is, __str, __is.widen ('\n'));
}

template<class _CharT, class _Traits>
class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits> 
{
public:
    explicit basic_iostream (basic_streambuf<_CharT, _Traits> *__sb)
        : basic_istream<_CharT, _Traits> (__sb), 
          basic_ostream<_CharT, _Traits> (__sb)
        {   }
};

extern template class basic_iostream<char, char_traits<char> >;
extern template class basic_iostream<wchar_t, char_traits<wchar_t> >;


template <class _TypeT,
          class _CharT ,
          class _Traits ,
          class _Distance >
class istream_iterator;

template <class _TypeT, class _CharT, class _Traits, class _Distance>
bool operator== (const istream_iterator<_TypeT, _CharT, _Traits, _Distance>&,
		 const istream_iterator<_TypeT, _CharT, _Traits, _Distance>&);


template <class _TypeT,
          class _CharT ,
          class _Traits ,
          class _Distance >
class istream_iterator
    : public iterator<input_iterator_tag, _TypeT, _Distance,
                      const _TypeT*, const _TypeT&>
{
    friend bool operator== < >
        (const istream_iterator&, const istream_iterator&);

    typedef iterator<input_iterator_tag, _TypeT, _Distance,
                     const _TypeT*, const _TypeT&> _C_base;
public: 
    typedef _CharT                                char_type;
    typedef _Traits                               traits_type;
    typedef basic_istream<char_type, traits_type> istream_type;

    
    typedef typename _C_base::value_type         value_type;
    typedef typename _C_base::difference_type    difference_type;
    typedef typename _C_base::pointer            pointer;
    typedef typename _C_base::reference          reference;
    typedef typename _C_base::iterator_category  iterator_category;
    
    istream_iterator (): _C_strm (0) { }

    istream_iterator (istream_type& __s)
        : _C_strm (&__s) {
        ++*this;
    }

    reference operator* () const {
        return _C_val;
    }

    pointer operator->() const { return & * *this; };

    istream_iterator& operator++ () {
        return _C_strm && !!*_C_strm && (*_C_strm >> _C_val), *this;
    }

    istream_iterator operator++ (int) {
        istream_iterator __tmp = *this;
        return ++*this, __tmp;
    }
      
protected:

    istream_type *_C_strm;   
    value_type    _C_val;    
};


template <class _TypeT, class _CharT, class _Traits, class _Distance>
inline bool
operator== (const istream_iterator<_TypeT, _CharT, _Traits, _Distance>& __x,
            const istream_iterator<_TypeT, _CharT, _Traits, _Distance>& __y)
{
    return (__x._C_strm && !!*__x._C_strm) == (__y._C_strm && !!*__y._C_strm);
}


template <class _TypeT, class _CharT, class _Traits, class _Distance>
inline bool
operator!= (const istream_iterator<_TypeT, _CharT, _Traits, _Distance>& __x,
            const istream_iterator<_TypeT, _CharT, _Traits, _Distance>& __y)
{
    return !(__x == __y);
}


}   


#line 1 "/opt/aCC/include_std/istream.cc"










































 

#line 1 "/opt/aCC/include_std/limits"





























 





























 





#line 79 "/opt/aCC/include_std/limits"


#line 87 "/opt/aCC/include_std/limits"







#line 100 "/opt/aCC/include_std/limits"

#line 109 "/opt/aCC/include_std/limits"









extern const float _FLT_NANS;         
extern const float _FLT_DMIN;         





extern const double _DBL_NANS;        
extern const double _DBL_DMIN;        

#line 134 "/opt/aCC/include_std/limits"





extern const long double _LDBL_NANS;  
extern const long double _LDBL_DMIN;  

#line 166 "/opt/aCC/include_std/limits"















#line 226 "/opt/aCC/include_std/limits"











#line 314 "/opt/aCC/include_std/limits"


#line 46 "/opt/aCC/include_std/istream.cc"






namespace __rw {

using namespace std;

template <class _CharT, class _Traits, class _NativeType>
basic_istream<_CharT, _Traits>&
__rw_extract (std::basic_istream<_CharT, _Traits> &__strm,
              _NativeType                          &__val)
{
    ((void)0);

    typedef istreambuf_iterator<_CharT, _Traits> _Iter;
    typedef num_get<_CharT, _Iter>               _NumGet;

    ios::iostate __err = ios::goodbit;

    typename basic_istream<_CharT, _Traits>::sentry __ipfx (__strm);

    if (__ipfx) {
        try {
            use_facet < _NumGet >(__strm . getloc ())
                .get (_Iter (__strm), _Iter (), __strm, __err, __val);
        }
        catch (...) {
            if (__strm.setstate (ios::badbit, 0  ))
                throw;
        }
    }

    if (ios::goodbit != __err)
        __strm.setstate (__err);

    return __strm;
}


}   


namespace std {


template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::_C_ipfx (int __flags)
{
    ((void)0);

    ios::iostate __err = this->rdstate ();

    
    
    _C_chcount = 0;

    if (ios::goodbit == __err) {

        if (this->tie ())
            this->tie ()->flush ();

        if (_C_skipws & __flags) {

            int_type __c = this->rdbuf ()->sgetc ();

            
            locale &__loc = this->getloc ();

            while (1) {

                if (traits_type::eq_int_type (__c, traits_type::eof ())) {
                    __err =  ios::eofbit;
                    break;
                }

                if (!isspace (traits_type::to_char_type (__c), __loc))
                    break;

                __c = this->rdbuf ()->snextc ();

                
                ++_C_chcount;
            }
        }
    }

    
    if (ios::goodbit != __err)
        this->setstate (__err | (_C_faileof & __flags ? ios::failbit : 0));

    return *this;
}


template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::
_C_unsafe_get (streamsize *__cnt    ,               
               int_type    __delim  ,
               int         __flags  )
{
    ((void)0);

    ios::iostate __err = ios::goodbit;

    int_type __c = traits_type::eof ();

    try {

        
        __c = this->rdbuf ()->sgetc ();

        
        
        if (traits_type::eq_int_type (__c, traits_type::eof ()))
            __err = ios::eofbit | (__flags & _C_faileof ? ios::failbit : 0);
        else if (   (   _C_eatdelim & __flags
                     || !traits_type::eq_int_type (__c, __delim))
                 && (   !(_C_wsterm & __flags)
                     || !isspace (traits_type::to_char_type (__c),
                                  this->getloc()))) {
            if (traits_type::eq_int_type (this->rdbuf ()->sbumpc (),
                                          traits_type::eof ()))
                __err = ios::failbit;
            else if (__cnt)
                ++*__cnt;   
        }
    }
    catch (...) {
        if (this->setstate (ios::badbit, 0  ))
            throw;
    }

    if (__err)
        this->setstate (__err);

    return __c;    
}


template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::
get (streambuf_type* __sb, int_type __delim)
{
    ((void)0);
    ((void)0);

    ios::iostate __err = 0;   

    sentry __ipfx (*this, true);

    if (__ipfx) { 

        try {

            while (1) {
                int_type __c = this->rdbuf ()->sgetc ();

                if (traits_type::eq_int_type (__c, traits_type::eof ())) {
                    __err = ios::eofbit;
                    break;
                }

                if (traits_type::eq (traits_type::to_char_type (__c),
                                     __delim))
                    break;

                try {
                    
                    __c = __sb->sputc (__c);
                }
                catch (...) {
                    __c = traits_type::eof ();
                }

                if (traits_type::eq_int_type (__c, traits_type::eof ())) {
                    __err = ios::failbit;  
                    break;
                }

                ++_C_chcount;
                this->rdbuf ()->sbumpc ();  
            }
        }
        catch (...) {
            if (this->setstate (ios::badbit, 0  ))
                throw;
        }

        if (__err)
            this->setstate (__err);
    }

    
    if (!gcount ())
        this->setstate (ios::failbit);

    return *this;
}


template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::read (char_type  *__s,
                                      streamsize  __n,
                                      int_type    __delim,
                                      int         __flags)
{
    

    ((void)0);
    ((void)0);

    
    sentry __ipfx (*this, !(_C_skipws & __flags));

    
    if (__ipfx) {

        
        if (_C_nullterm & __flags)
            traits_type::assign (*__s, char_type ());

        
        while (__n && (--__n || !(_C_nullterm & __flags))) {

            
            int_type __c = _C_unsafe_get (&_C_chcount, __delim, __flags);

            
            if (   traits_type::eq_int_type (__c, traits_type::eof())
                || traits_type::eq_int_type (__c, __delim))
                break;

            char_type __ch = traits_type::to_char_type (__c);

            
            if (   _C_nullterm & __flags && traits_type::eq (__ch, char_type ())
                || _C_wsterm   & __flags && isspace (__ch, this->getloc ()))
                break;

            
            if (__s)
                traits_type::assign (*__s++, __ch);
        }

        if (_C_nullterm & __flags && __s)
            traits_type::assign (*__s, char_type ());
    }

    
    if (   _C_failnoi & __flags && !gcount ()
        || _C_failend & __flags && !__n)
        this->setstate (ios::failbit);

    return *this;
}



template<class _CharT, class _Traits>
streamsize basic_istream<_CharT, _Traits>::
readsome (char_type *__s, streamsize __n)
{
    ((void)0);
    ((void)0);
    ((void)0);

    if (!this->good ()) {
        this->setstate (ios::failbit);
        return 0;
    }
    
    streamsize __navail = this->rdbuf ()->in_avail ();
   
    if(-1 == __navail) {   
        this->setstate (ios::eofbit);
        return 0;
    }

    if (0 == __navail)
        return 0;

    if (__n > __navail)
        __n = __navail;

    read (__s, __n);
    return __n;
}


template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::pos_type
basic_istream<_CharT, _Traits>::tellg ()
{
    pos_type __p = off_type (-1);

    if (!this->fail ()) {

        try {
            __p = this->rdbuf ()->pubseekoff (0, ios::cur, ios::in);
          }
        catch (...) {
            if (this->setstate (ios::badbit, 0  ))
                throw;
        }
    }

    return __p;
}


template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::putback (char_type __c)
{
    ios::iostate __err = 0;

    if (this->rdbuf ()) {
        
        sentry __ipfx (*this, true);

        if (__ipfx) {
      
            try {
                if (traits_type::eq_int_type (this->rdbuf ()->sputbackc (__c), 
                                              traits_type::eof ()))
                    __err = ios::badbit;
            }
            catch (...) {
                if (this->setstate (ios::badbit, 0  ))
                    throw;
            }
        }
    }
    else
        __err = ios::badbit;

    if (__err)
        this->setstate (__err);

    return *this;
}


template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::unget ()
{
    ios::iostate __err = 0;

    if (this->rdbuf ()) {

        sentry __ipfx (*this, true);

        if (__ipfx) {

            try {

                if (traits_type::eq_int_type (this->rdbuf ()->sungetc (), 
                                              traits_type::eof ()))
                    __err = ios::badbit;  
            }
            catch (...) {
                if (this->setstate (ios::badbit, 0  ))
                    throw;
            }
        }
    }
    else
        __err = ios::badbit;

    if (__err)
        this->setstate (__err);
    
    return *this;
}


template<class _CharT, class _Traits>
int basic_istream<_CharT, _Traits>::sync ()
{
    if (!this->rdbuf ())
        return -1;

    sentry __ipfx (*this, true);

    if (__ipfx) {

        try {
            if (-1 != this->rdbuf ()->pubsync ())
                return 0;
        }
        catch (...) {
            if (this->setstate (ios::badbit, 0  ))
                throw;
        }

        this->setstate (ios::badbit);
    }

    return traits_type::eof ();
}


template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>& 
operator>> (basic_istream<_CharT, _Traits>&            __is, 
            basic_string<_CharT, _Traits, _Allocator>& __str)
{
    ((void)0);

    ios::iostate __err = 0;

    try {

        typename basic_istream<_CharT, _Traits>::sentry __ipfx (__is);

        if (__ipfx) {

            
            

            
            

            size_t __maxlen =
                __is.width () ? __is.width () : __str.max_size ();

            size_t __i = 0;

            __str.erase ();
            __str.resize (32);

            while (__maxlen != __i) {

                typename _Traits::int_type __c = __is.rdbuf ()->sgetc ();

                if (_Traits::eq_int_type (__c, _Traits::eof ())) {
                    __err = ios::eofbit;
                    break;
                }

                
                typename _Traits::char_type
                    __ch = _Traits::to_char_type (__c);

                if (isspace (__ch, __is.getloc ()))
                    break;

                __is.rdbuf ()->sbumpc ();

                if (__str.size () == __i)
                    __str.resize (__i * 2);

                _Traits::assign (__str [__i++], __ch);
            }
            __str.resize (__i);

            __is.width (0);

            if (!__i)
                __err |= ios::failbit;
        }
    }
    catch (...) {
        if (__is.setstate (ios::badbit, 0  ))
            throw;
    }

    if (__err)
        __is.setstate (__err);

    return __is;
}  


template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>& 
getline (basic_istream<_CharT, _Traits>&            __is, 
         basic_string<_CharT, _Traits, _Allocator>& __str, 
         _CharT                                     __delim)
{
    ((void)0);

    typename basic_istream<_CharT, _Traits>::sentry __ipfx (__is, true);

    if (__ipfx) { 

        ios::iostate __err = ios::failbit;

        try {

            
            

            
            

            size_t __i = 0;

            __str.erase ();
            __str.resize (32);

            while (__str.max_size () != __i) {

                typename _Traits::int_type __c = __is.rdbuf ()->sbumpc ();

                if (_Traits::eq_int_type (__c, _Traits::eof ())) {
                    
                    __err = ios::eofbit | (__i ? ios::goodbit : ios::failbit);
                    break;
                }

                if (_Traits::eq (_Traits::to_char_type (__c), __delim)) {
                    __err = ios::goodbit;
                    break;
                }

                if (__str.size () == __i)
                    __str.resize (__i * 2);

                _Traits::assign (__str [__i++], _Traits::to_char_type (__c));
            }
            __str.resize (__i);   
        }
        catch (...) {
            if (__is.setstate (ios::badbit, 0  ))
                throw;
        }

        if (__err)
            __is.setstate (__err);
    }

    return __is;
}  


}   
#line 594 "/opt/aCC/include_std/istream"



#line 36 "/opt/aCC/include_std/iostream"







namespace __rw {




static std::ios_base::Init __rw_stream_initializer;

}   




namespace std {

extern istream  &cin;
extern ostream  &cout;
extern ostream  &cerr;
extern ostream  &clog;



extern wistream  &wcin;
extern wostream  &wcout;
extern wostream  &wcerr;
extern wostream  &wclog;



#line 81 "/opt/aCC/include_std/iostream"

}   

#line 7 "Application.cpp"
#line 1 "/opt/aCC/include_std/signal.h"



#line 1 "/opt/aCC/include_std/csignal"



#pragma push binding
#pragma binding default
#line 1 "/usr/include/signal.h"
 





#pragma pop
#line 5 "/opt/aCC/include_std/csignal"



namespace std
{




using ::sig_atomic_t;



using ::raise;
using ::signal;

}



#line 5 "/opt/aCC/include_std/signal.h"

#line 19 "/opt/aCC/include_std/signal.h"

#line 8 "Application.cpp"
#line 1 "ABMException.h"



#line 1 "/opt/aCC/include_std/vector"











































 




#line 1 "/opt/aCC/include_std/rw/rwdispatch.h"



























 





struct _RW_is_integer {};
struct _RW_is_not_integer {};

template <class T>
struct _RWdispatch {
  typedef _RW_is_not_integer _RWtype;
};

template< >
struct _RWdispatch<int> {
  typedef _RW_is_integer _RWtype;
};

template< >
   struct _RWdispatch<unsigned int> {
	typedef _RW_is_integer _RWtype;
};

template< >
   struct _RWdispatch<long> {
	typedef _RW_is_integer _RWtype;
};

template< >
   struct _RWdispatch<unsigned long> {
	typedef _RW_is_integer _RWtype;
};

template< >
   struct _RWdispatch<short> {
	typedef _RW_is_integer _RWtype;
};

template< >
   struct _RWdispatch<unsigned short> {
	typedef _RW_is_integer _RWtype;
};

template< >
   struct _RWdispatch<char> {
	typedef _RW_is_integer _RWtype;
};

template< >
   struct _RWdispatch<unsigned char> {
	typedef _RW_is_integer _RWtype;
};


template< >
   struct _RWdispatch<bool> {
	typedef _RW_is_integer _RWtype;
};



template< >
   struct _RWdispatch<wchar_t> {
	typedef _RW_is_integer _RWtype;
};


#line 51 "/opt/aCC/include_std/vector"

#line 1 "/opt/aCC/include_std/limits"





























 





























 





#line 79 "/opt/aCC/include_std/limits"


#line 87 "/opt/aCC/include_std/limits"







#line 100 "/opt/aCC/include_std/limits"

#line 109 "/opt/aCC/include_std/limits"









extern const float _FLT_NANS;         
extern const float _FLT_DMIN;         





extern const double _DBL_NANS;        
extern const double _DBL_DMIN;        

#line 134 "/opt/aCC/include_std/limits"





extern const long double _LDBL_NANS;  
extern const long double _LDBL_DMIN;  

#line 166 "/opt/aCC/include_std/limits"















#line 226 "/opt/aCC/include_std/limits"











#line 314 "/opt/aCC/include_std/limits"


#line 54 "/opt/aCC/include_std/vector"





namespace std {

template <class _TypeT,
          class _Allocator = allocator<_TypeT> >
class vector : private _Allocator
{
public:

    typedef _TypeT                                     value_type;
    typedef _Allocator                                 allocator_type;
    typedef typename allocator_type::size_type        size_type;
    typedef typename allocator_type::difference_type  difference_type;
    typedef typename allocator_type::reference        reference;
    typedef typename allocator_type::const_reference  const_reference;
    typedef typename allocator_type::pointer          pointer;
    typedef typename allocator_type::const_pointer    const_pointer;


#line 94 "/opt/aCC/include_std/vector"

    typedef pointer         iterator;
    typedef const_pointer   const_iterator;

    iterator _C_make_iter (pointer __ptr) {
        return __ptr;
    }

    const_iterator _C_make_iter (const_pointer __ptr) const {
        return __ptr;
    }




    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator>  reverse_iterator;
#line 121 "/opt/aCC/include_std/vector"

protected:
    typedef _Allocator           _C_value_alloc_type;
    pointer            _C_start;
    pointer            _C_finish;
    pointer            _C_end_of_storage;

    void _C_insert_aux (iterator __position, const_reference __x);
    
    void _C_insert_aux (iterator __position, size_type __n, const_reference __x);
    


    template<class InputIterator>
    void _C_insert_aux (iterator __position, InputIterator __first,
                        InputIterator __last, _RW_is_not_integer) {
        _C_insert_aux2 (__position, __first, __last);
    }

    template<class InputIterator>
    void _C_insert_aux (iterator __position, InputIterator __first,
                        InputIterator __last, _RW_is_integer) {
        _C_insert_aux (__position, (size_type)__first, __last);
    }
    
    template<class InputIterator>
    void _C_insert_aux2 (iterator __position, InputIterator __first,
                         InputIterator __last);

    template <class InputIterator>
    void _C_insert_interval_dispatch (iterator __position,
                                      InputIterator __first, 
                                      InputIterator __last,
                                      forward_iterator_tag) {
        typedef typename _RWdispatch<InputIterator>::_RWtype _RWtype;
        _C_insert_aux(__position, __first, __last, _RWtype());
    }
    
    template <class InputIterator>
    void _C_insert_interval_dispatch (iterator __position,
                                      InputIterator __first, 
                                      InputIterator __last,
                                      input_iterator_tag) { 
        while(__first != __last) { 
            __position = insert (__position,*__first); 
            ++__position;
            ++__first;
        }
    }






    void _C_destroy(iterator __start, iterator __finish) {
        while ( __start != __finish)
            allocator_type::destroy(__start++);
    }
    
    
    
    
    void _C_initn(size_type __n, const_reference __value) {
        size_t __initial_capacity = 
            max (__n, (size_t)__rw::__rw_new_capacity(0,this));

        _C_start = allocator_type::allocate(__initial_capacity,0);

        try {
            uninitialized_fill_n(begin(), __n, __value,
                                 static_cast< allocator_type& >(*this));
        }
        catch (...) {
            allocator_type::deallocate(_C_start,__n);
            throw;
        }
        _C_finish = _C_start + __n;
        _C_end_of_storage = _C_start + __initial_capacity;
    } 


  public:
    
    
    
    explicit vector (const _Allocator& __alloc
                      = _Allocator()) 
        : allocator_type(__alloc), _C_start(0), _C_finish(0),
          _C_end_of_storage(0){ 
    }

#line 222 "/opt/aCC/include_std/vector"
    
    explicit vector (size_type __n)
        : _C_start(0), _C_finish(0), _C_end_of_storage(0) {
        value_type __value = value_type ();
        _C_initn(__n,__value);
    }
    

    
    template<class InputIterator>
    void _C_init_aux (InputIterator __first, InputIterator __last,
                     _RW_is_not_integer) {
        if (__is_input_iterator (typename iterator_traits< InputIterator > ::iterator_category ())) {
            copy(__first, __last, back_inserter(*this));
        }
        else {
            size_type __n = 0;
            distance(__first, __last, __n);
            size_t __initial_capacity = 
                max (__n, (size_t)__rw::__rw_new_capacity(0,this));
            _C_start = allocator_type::allocate(__initial_capacity,0);

            
            try {
                uninitialized_copy(__first, __last, _C_start,
                                   static_cast< allocator_type& >(*this));
            }
            catch (...) {
                allocator_type::deallocate(_C_start,__n);

                throw;
            }
            _C_finish = _C_start + __n;
            _C_end_of_storage = _C_start + __initial_capacity;
        }
    }

    template<class InputIterator>
    void _C_init_aux (InputIterator __first, InputIterator __last,
                      _RW_is_integer) {
        _C_initn((size_type)__first,__last);
    }

    template<class InputIterator>
    vector (InputIterator __first, InputIterator __last,
            const _Allocator& __alloc = _Allocator())
      : allocator_type(__alloc), _C_start(0), _C_finish(0),
        _C_end_of_storage(0) {
        typedef typename _RWdispatch<InputIterator>::_RWtype _RWtype;
        _C_init_aux(__first, __last, _RWtype());
    }
    
    vector (size_type __n, const_reference __value,
            const _Allocator& __alloc = _Allocator())
        : allocator_type(__alloc), _C_start(0), _C_finish(0),
          _C_end_of_storage(0) {
        _C_initn((size_type)__n,__value);
    }

#line 339 "/opt/aCC/include_std/vector"

    vector (const vector<value_type ,_Allocator>& __x)
        : allocator_type (__x.get_allocator ()), _C_start(0), _C_finish(0),
          _C_end_of_storage(0) {

        size_t __initial_capacity = 
            max (__x.size(), (size_t)__rw::__rw_new_capacity(0,this));
        _C_start = allocator_type::allocate(__initial_capacity,0);

        try {
            uninitialized_copy(__x.begin(), __x.end(), begin(),
                                 static_cast< allocator_type& >(*this));
        }
        catch (...) {
            allocator_type::deallocate(_C_start,__x . size());

            throw;
        }
        _C_finish = _C_start + __x.size();
        _C_end_of_storage = _C_start + __initial_capacity;
    }
    
    
    ~vector () { 
        _C_destroy(begin (), end ()); 
        allocator_type::deallocate(_C_start, _C_end_of_storage - _C_start);

    }
    
    vector<value_type ,_Allocator>& operator= (const vector<value_type ,_Allocator>& __x);
    

    template<class InputIterator>
    void assign (InputIterator __first, InputIterator __last) {
        erase(begin(), end());
        typedef typename _RWdispatch<InputIterator>::_RWtype _RWtype;
        _C_insert_aux(begin(), __first, __last, _RWtype());
    }
    
    void assign (size_type __n, const_reference __t) {
        erase(begin(), end()); insert(begin(), __n, __t);
    }
#line 393 "/opt/aCC/include_std/vector"

    allocator_type get_allocator() const {
        return *this;
    }
    
    
    
    
    iterator       begin ()       {
        return _C_make_iter (_C_start);
    }

    const_iterator begin () const {
        return _C_make_iter (_C_start);
    }

    iterator       end ()         {
        return _C_make_iter (_C_finish);
    }

    const_iterator end ()   const {
        return _C_make_iter (_C_finish);
    }
    
    reverse_iterator rbegin () { 
        reverse_iterator __tmp(end());
        return __tmp;
    }
    
    const_reverse_iterator rbegin () const { 
        const_reverse_iterator __tmp(end());
        return __tmp;
    }
    
    reverse_iterator rend () { 
        reverse_iterator __tmp(begin());
        return __tmp;
    }
    
    const_reverse_iterator rend () const { 
        const_reverse_iterator __tmp(begin());
        return __tmp;
    }

    size_type size ()     const {
        return size_type(end() - begin());
    }

    size_type max_size () const {
        return allocator_type::max_size();
    }
    
    void resize (size_type __new_size, value_type __value = value_type ()) {
        if (__new_size > size())
            insert(end(), __new_size - size(), __value);
        else if (__new_size < size())
            erase(begin() + __new_size, end());
    }

    size_type capacity () const {
        return _C_end_of_storage - _C_start;
    }
    
    bool      empty ()    const {
        return begin() == end();
    }
    
    void reserve (size_type __n) {
        (__n <= max_size ()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/vector" ":" "461" ": "). _C_format ((0 + 8), "vector<>::reserve (size_type)", __n, max_size ());





        if (capacity() < __n) {
            size_t __new_capacity = 
                max (__n, (size_t)__rw::__rw_new_capacity(size(),this));
            pointer __tmp =
                allocator_type::allocate(__new_capacity,_C_start);


            try {
                uninitialized_copy(begin(), end(), _C_make_iter (__tmp),
                                 static_cast< allocator_type& >(*this));
            }
            catch (...) {
                allocator_type::deallocate(__tmp,__n);
                throw;
            }
            _C_destroy(begin (), end ());
            allocator_type::deallocate(_C_start, _C_end_of_storage - _C_start);

            _C_finish = __tmp + size();
            _C_start = __tmp;
            _C_end_of_storage = _C_start + __new_capacity;
        }
    }

    
    
    
    reference       operator[] (size_type __n) {
#line 502 "/opt/aCC/include_std/vector"
        return *(begin() + __n);

    }
  
    const_reference operator[] (size_type __n) const {
#line 514 "/opt/aCC/include_std/vector"
        return *(begin() + __n);
    }
  
    reference at (size_type __n) { 
        (__n < size ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/vector" ":" "518" ": "). _C_format ((0 + 9), "vector<>::at (size_type)", __n, size());



        return *(begin() + __n); 
    }
    
    const_reference at (size_type __n)  const  { 
        (__n < size ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/vector" ":" "526" ": "). _C_format ((0 + 9), "vector<>::at (size_type) const", __n, size ());




        return *(begin() + __n); 
    }
    
    reference front () {
        return *begin();
    }
    
    const_reference front () const {
        return *begin();
    }
    
    reference back () {
        return *(end() - 1);
    }
    
    const_reference back () const {
        return *(end() - 1);
    }

    
    
    
    void push_back (const_reference __x) {
        if (_C_finish != _C_end_of_storage) {
            ++_C_finish;
            try {
                allocator_type::construct(_C_finish - 1, __x);

            }
            catch (...) {
                --_C_finish;
                throw;
            }
        }
        else
            _C_insert_aux(end(), __x);
    }
    
    void pop_back()
    {
        allocator_type::destroy(_C_finish-1);
        --_C_finish; 
    }

    
    
    
    iterator insert (iterator __position, const_reference __x) {
        size_type __n = __position - begin();
        if (_C_finish != _C_end_of_storage && __position == end()) {
            ++_C_finish;
            try {
                allocator_type::construct(_C_finish - 1, __x);

            }
            catch (...) {
                --_C_finish;
                throw;
            }
        }
        else
            _C_insert_aux(__position, __x);
        return begin() + __n;
    }



    template<class _InputIter>
    void insert (iterator __pos, _InputIter __first, _InputIter __last) {
	insert (__pos, __first, __last, ((_C_dispatch <void, numeric_limits< _InputIter > ::is_integer> *)0));
    }

    template<class _InputIter>
    void insert (iterator __pos, _InputIter __first, _InputIter __last, 
                 const _C_dispatch <void, false > *) {
        
        
        _C_insert_interval_dispatch  (__pos, __first, __last,
                                      typename iterator_traits< _InputIter > ::iterator_category ());
    }

    void insert (iterator __pos, size_type __n, const_reference __val,
                 const _C_dispatch <void, true > *) {
        
        _C_insert_aux (__pos, __n, __val);
    }

    void insert (iterator __position, size_type __n, const_reference __value) {
        _C_insert_aux(__position,__n,__value);
    }
    
#line 634 "/opt/aCC/include_std/vector"

    iterator erase (iterator __position) {
        if (!empty ()) { 
            if (__position + 1 != end()) 
                copy(__position + 1, end(), __position);
            allocator_type::destroy(_C_finish - 1);
            --_C_finish;
        }
        return __position;
    }

    iterator erase (iterator __first, iterator __last) {
        if (!empty ()) {
            iterator __i = copy (__last, end(), __first);
            iterator __tmp = end ();
            _C_destroy(__i, __tmp);
            _C_finish -= (__last - __first);
        }
        return __first;
    }

    void swap (vector& __x) {
        if((_C_value_alloc_type)*this==(_C_value_alloc_type)__x) {
            std::swap(_C_start, __x._C_start);
            std::swap(_C_finish, __x._C_finish);
            std::swap(_C_end_of_storage, __x._C_end_of_storage);
        }
        else {
            vector __v = *this;
            *this = __x;
            __x=__v;
        } 
    }
    
    void clear () {
        erase (begin (), end ());
    }

};

template <class _TypeT, class _Allocator>
inline bool operator== (const vector<_TypeT,_Allocator>& __x,
                        const vector<_TypeT,_Allocator>& __y)
{
    return __x.size() == __y.size()
        && equal(__x.begin(), __x.end(), __y.begin());
}

template <class _TypeT, class _Allocator>
inline bool operator< (const vector<_TypeT,_Allocator>& __x,
                       const vector<_TypeT,_Allocator>& __y)
{
    return lexicographical_compare(__x.begin(), __x.end(),
                                   __y.begin(), __y.end());
}

template <class _TypeT, class _Allocator>
inline bool operator!= (const vector<_TypeT,_Allocator>& __x,
                        const vector<_TypeT,_Allocator>& __y)
{
    return !(__x == __y);
}

template <class _TypeT, class _Allocator>
inline bool operator> (const vector<_TypeT,_Allocator>& __x,
                       const vector<_TypeT,_Allocator>& __y)
{
    return __y < __x;
}

template <class _TypeT, class _Allocator>
inline bool operator>= (const vector<_TypeT,_Allocator>& __x,
                        const vector<_TypeT,_Allocator>& __y)
{
    return !(__x < __y);
}

template <class _TypeT, class _Allocator>
inline bool operator<= (const vector<_TypeT,_Allocator>& __x,
                        const vector<_TypeT,_Allocator>& __y)
{
    return !(__y <  __x);
}


template <class _TypeT, class _Allocator>
inline void swap(vector<_TypeT,_Allocator>& __a, vector<_TypeT,_Allocator>& __b)
{
    __a.swap(__b);
}


#line 735 "/opt/aCC/include_std/vector"
















  template <class _Allocator>

#line 759 "/opt/aCC/include_std/vector"

class  vector<bool, _Allocator > : private _Allocator
  {

#line 770 "/opt/aCC/include_std/vector"
  public:  
    
    
    
    typedef _Allocator                                    allocator_type;
    typedef bool                                          value_type;

  private:
    typedef typename _Allocator::template rebind < unsigned int > ::other         _C_value_alloc_type;

  public:





    typedef typename allocator_type::size_type           size_type;
    typedef typename allocator_type::difference_type     difference_type;


    typedef typename _C_value_alloc_type::pointer         pointer;
    typedef typename _C_value_alloc_type::const_pointer   const_pointer;

  public:
    
    
    
    class iterator;
    class const_iterator;

    
    
    

    class reference
    {
      friend class iterator;
      friend class const_iterator;
    protected:
      unsigned int* _C_p;
      unsigned int _C_mask;
      reference (unsigned int* __x, unsigned int __y) :
          _C_p(__x), _C_mask(__y) {}
    public:
      reference () : _C_p(0), _C_mask(0) {}
      operator bool () const { return !!(*_C_p & _C_mask); }
      reference& operator= (bool __x)
      {
        if (__x)      
          *_C_p |= _C_mask;
        else
          *_C_p &= ~_C_mask;
        return *this;
      }
      reference& operator= (const reference& __x) { return *this = bool(__x); }


      bool operator== (const reference& __x) const
      {
        return bool(*this) == bool(__x);
      }
      bool operator< (const reference& __x) const
      {

        return bool(*this) < bool(__x);



      }
      bool operator!= (const reference& __x) const
      {
        return !(*this == __x);
      }
      bool operator> (const reference& __x) const
      {
        return  __x < *this;
      }
      bool operator>= (const reference& __x) const
      {
        return !(*this < __x);
      }
      bool operator<= (const reference& __x) const
      {
        return !(*this > __x);
      }


      void flip () { *_C_p ^= _C_mask; }
    };
    
    typedef bool const_reference;
    
    
    
    typedef  std::iterator<random_access_iterator_tag,
                                     value_type, difference_type,
                                     pointer,reference> __iterator_base;
      
    class iterator : public __iterator_base
    {



        friend class vector;
#line 880 "/opt/aCC/include_std/vector"

        friend class const_iterator;

    protected:

        unsigned int* _C_p;
        unsigned int  _C_offset;



    public:
        iterator () : _C_p(0), _C_offset(0) {}

        iterator (unsigned int* __x, unsigned int __y) :
            _C_p(__x), _C_offset(__y) {}

        typename __iterator_base::reference operator* () const { 
            return typename
                __iterator_base::reference(_C_p, 1U << _C_offset); 
        }
        
        
      iterator& operator++ ()
      {
          if (_C_offset++ == (int(8*sizeof(unsigned int))) - 1) {
              _C_offset = 0; 
              ++_C_p;
          }
          return *this;
      }
      iterator operator++ (int)
      {
        iterator __tmp = *this; ++(*this); return __tmp;
      }
      iterator& operator-- ()
      {
          if (_C_offset-- == 0) {
              _C_offset = (int(8*sizeof(unsigned int))) - 1; 
              --_C_p;
          }
          return *this;
      }
      iterator operator-- (int)
      {
        iterator __tmp = *this; --(*this); return __tmp;
      }
      iterator& operator+= (typename __iterator_base::difference_type __i) {
        typename __iterator_base::difference_type __n = __i + _C_offset;
        _C_p += __n / (int(8*sizeof(unsigned int)));
        __n = __n % (int(8*sizeof(unsigned int)));
        if (__n < 0)
        {
          _C_offset = (unsigned int)(__n + (int(8*sizeof(unsigned int)))); --_C_p;
        }
        else
          _C_offset = (unsigned int)__n;
        return *this;
      }
      iterator& operator-= (typename __iterator_base::difference_type __i)
      {
        *this += -__i; return *this;
      }

      iterator
      operator+ (typename __iterator_base::difference_type __i) const {
          iterator __tmp = *this; return __tmp += __i;
      }

      iterator
      operator- (typename __iterator_base::difference_type __i) const {
          iterator __tmp = *this; return __tmp -= __i;
      }

      typename __iterator_base::difference_type
      operator- (iterator __x) const {
          return (int(8*sizeof(unsigned int))) * (_C_p - __x._C_p) +
              _C_offset - __x._C_offset;
      }

      typename __iterator_base::reference
      operator[] (typename __iterator_base::difference_type __i) {
          return *(*this + __i);
      }

      bool operator== (const iterator& __x) const
      {
        return _C_p == __x._C_p && _C_offset == __x._C_offset;
      }
      bool operator< (const iterator& __x) const
      {
        return _C_p < __x._C_p ||
            (_C_p == __x._C_p && _C_offset < __x._C_offset);
      }
      bool operator!= (const iterator& __x) const
      {
        return !(*this == __x);
      }
      bool operator> (const iterator& __x) const
      {
        return __x < *this;
      }
      bool operator>= (const iterator& __x) const
      {
        return !(*this < __x);
      }
      bool operator<= (const iterator& __x) const
      {
        return !(*this > __x);
      }

      bool operator== (const const_iterator& __x) const
      {
        return __x == *this;
      }
      bool operator< (const const_iterator& __x) const
      {
        return __x > *this;
      }
      bool operator!= (const const_iterator& __x) const
      {
        return !(*this == __x);
      }
      bool operator> (const const_iterator& __x) const
      {
        return __x < *this;
      }
      bool operator>= (const const_iterator& __x) const
      {
        return !(*this < __x);
      }
      bool operator<= (const const_iterator& __x) const
      {
        return !(*this > __x);
      }

    };
    
    
    

    class const_iterator
      : public std::iterator<random_access_iterator_tag,
                        value_type, difference_type, 
                        const_pointer, const_reference>
    {



        friend class vector;
#line 1035 "/opt/aCC/include_std/vector"
    protected:

      unsigned int* _C_p;
      unsigned int _C_offset;



    public:
      const_iterator () : _C_p(0), _C_offset(0) {}
      const_iterator (unsigned int* __x, unsigned int __y) :
          _C_p(__x), _C_offset(__y) {}

       const_iterator (const typename vector<bool,_Allocator> :: iterator& __x) :
           _C_p(__x._C_p), _C_offset(__x._C_offset) {}

      const_reference operator* () const {
          return typename __iterator_base::reference(_C_p, 1U << _C_offset);
      }

      const_iterator& operator++ ()
      {
          if (_C_offset++ == (int(8*sizeof(unsigned int))) - 1) {
              _C_offset = 0; 
              ++_C_p;
          }
          return *this;
      }
      const_iterator operator++ (int)
      {
        const_iterator __tmp = *this; ++(*this); return __tmp;
      }
      const_iterator& operator-- ()
      {
        if (_C_offset-- == 0) {
          _C_offset = (int(8*sizeof(unsigned int))) - 1; 
          --_C_p;
        }
        return *this;
      }
      const_iterator operator-- (int)
      {
        const_iterator __tmp = *this; --(*this); return __tmp;
      }
      const_iterator&
      operator+= (typename __iterator_base::difference_type __i) {
        typename __iterator_base::difference_type __n = __i + _C_offset;
        _C_p += __n / (int(8*sizeof(unsigned int)));
        __n = __n % (int(8*sizeof(unsigned int)));
        if (__n < 0)
        {
          _C_offset = __n + (int(8*sizeof(unsigned int))); --_C_p;
        }
        else
          _C_offset = __n;
        return *this;
      }
      const_iterator&
      operator-= (typename __iterator_base::difference_type __i) {
        *this += -__i; return *this;
      }

      const_iterator
      operator+ (typename __iterator_base::difference_type __i) const {
        const_iterator __tmp = *this; return __tmp += __i;
      }

      const_iterator
      operator- (typename __iterator_base::difference_type __i) const {
        const_iterator __tmp = *this; return __tmp -= __i;
      }

      typename __iterator_base::difference_type
      operator- (const_iterator __x) const {
        return (int(8*sizeof(unsigned int))) * (_C_p - __x._C_p) + _C_offset - __x._C_offset;
      }

      const_reference
      operator[] (typename __iterator_base::difference_type __i) { 
        return *(*this + __i); 
      }
      bool operator== (const const_iterator& __x) const
      {
        return _C_p == __x._C_p && _C_offset == __x._C_offset;
      }
      bool operator< (const const_iterator& __x) const
      {
        return _C_p < __x._C_p ||
            (_C_p == __x._C_p && _C_offset < __x._C_offset);
      }
      bool operator!= (const const_iterator& __x) const
      {
        return !(*this == __x);
      }
      bool operator> (const const_iterator& __x) const
      {
        return __x < *this;
      }
      bool operator>= (const const_iterator& __x) const
      {
        return !(*this < __x);
      }
      bool operator<= (const const_iterator& __x) const
      {
        return !(*this > __x);
      }
    };




  
    
    
    

    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator>  reverse_iterator;
#line 1162 "/opt/aCC/include_std/vector"

  private:
    
    
    
    
    
    
    
    
  
    static void _C_fill (iterator __first, iterator __last, 
               const bool& __value)
    {
      while (__first != __last) *__first++ = __value;
    }
    static void _C_fill_n (iterator __first, size_type __n,
                 const bool& __value)
    {
      while (__n-- > 0) *__first++ = __value;
    }

    template <class _Iterator>
    static iterator _C_copy (_Iterator __first, _Iterator __last,
                   iterator __result)
    {
      while (__first != __last) *__result++ = *__first++;
      return __result;
    }
    template <class _Iterator>
    static iterator _C_copy_backward (_Iterator __first, _Iterator __last,
                            iterator __result)
    {
      while (__first != __last) *--__result = *--__last;
      return __result;
    }
#line 1224 "/opt/aCC/include_std/vector"

  protected:

    iterator                _C_start;
    iterator                _C_finish;
    unsigned int*           _C_end_of_storage;

    unsigned int* _C_bit_alloc (size_type __n)
    {
      return _C_value_alloc_type(*this).
          allocate((__n + (int(8*sizeof(unsigned int))) - 1)/(int(8*sizeof(unsigned int))),
                   pointer(_C_start._C_p));
    }
    void _C_init (size_type __n)
    {
      unsigned int* __q = _C_bit_alloc(__n);
      _C_end_of_storage = __q + (__n + (int(8*sizeof(unsigned int))) - 1)/(int(8*sizeof(unsigned int)));
      _C_start = iterator(__q, 0);
      _C_finish = _C_start + __n;
    }
    void _C_insert_aux (iterator __position, bool __x);

  public:

    
    
    

    vector (const _Allocator&  __alloc = _Allocator())
      : allocator_type (__alloc), _C_start(iterator()), _C_finish(iterator()), 
        _C_end_of_storage(0)
    { ; }
    explicit vector (size_type __n, bool __value = bool(), 
       const _Allocator&  __alloc = _Allocator())
      : allocator_type (__alloc), _C_end_of_storage(0)
    {
      _C_init(__n); 
      unsigned int * __first = _C_start._C_p;
      size_type __m = (__n + (int(8*sizeof(unsigned int))) - 1)/(int(8*sizeof(unsigned int)));
      while (__m-- > 0) *__first++ = __value ? ~0 : 0;
    }

    vector (const vector<bool,_Allocator> & __x)
      : allocator_type (__x.get_allocator()), _C_end_of_storage(0)
    {
      _C_init(__x.size()); 
      _C_copy(__x.begin(), __x.end(), _C_start);
    }


    template<class InputIterator>
    vector  (InputIterator __first, InputIterator __last)
      : _C_end_of_storage(0)
    {
      size_type __n = 0;
      distance(__first, __last, __n);
      _C_init(__n); 
      _C_copy(__first, __last, _C_start);
    }
#line 1301 "/opt/aCC/include_std/vector"
  
    ~vector () {
      _C_value_alloc_type(*this).deallocate(_C_start._C_p,  
        _C_end_of_storage - _C_start._C_p); 
    }
    vector<bool,_Allocator> & operator= (const vector<bool,_Allocator> & __x)
    {
      if (&__x == this) return *this;
      if (__x.size() > capacity())
      {
        _C_value_alloc_type(*this).deallocate(_C_start._C_p,
          _C_end_of_storage - _C_start._C_p); 
        _C_init(__x.size());
      }
      _C_copy(__x.begin(), __x.end(), begin());
      _C_finish = begin() + __x.size();
      return *this;
    }

    template<class InputIterator>
    void assign (InputIterator __first, InputIterator __last)
    { erase(begin(), end()); insert(begin(), __first, __last); }





    void assign (size_type __n, const bool& __t = bool())
    { 
        erase(begin(), end()); insert(begin(), __n, __t);  
    }

    allocator_type get_allocator() const
    {
      return *this;
    }

    
    
    
    iterator       begin ()       { return _C_start; }
    const_iterator begin () const 
    { return const_iterator(_C_start._C_p,_C_start._C_offset); }
    iterator       end   ()       { return _C_finish; }
    const_iterator end   () const 
    { return const_iterator(_C_finish._C_p,_C_finish._C_offset); }

    reverse_iterator       rbegin () { return reverse_iterator(end()); }
    const_reverse_iterator rbegin () const
    { 
      return const_reverse_iterator(end()); 
    }
    reverse_iterator       rend () { return reverse_iterator(begin()); }
    const_reverse_iterator rend () const
    { 
      return const_reverse_iterator(begin()); 
    }

    
    
    
    size_type size     () const { return size_type(end() - begin());  }
    size_type max_size () const {
        return _C_value_alloc_type(*this).max_size();
    }
    void resize (size_type __new_size, bool __c = false);
    size_type capacity () const
    {
      return size_type(const_iterator(_C_end_of_storage, 0) - begin());
    }
    bool empty () const { return begin() == end(); }
    void reserve (size_type __n)
    {
      (__n <= max_size ()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/vector" ":" "1374" ": "). _C_format ((0 + 8), "vector<bool>::reserve (size_type)", __n, max_size ());




      if (capacity() < __n)
      {
        unsigned int* __q = _C_bit_alloc(__n);
        _C_finish = _C_copy(begin(), end(), iterator(__q, 0));
        _C_value_alloc_type(*this).deallocate(_C_start._C_p,
                                             _C_end_of_storage - _C_start._C_p);
        _C_start = iterator(__q, 0);
        _C_end_of_storage = __q + (__n + (int(8*sizeof(unsigned int))) - 1)/(int(8*sizeof(unsigned int)));
      }
    }

    
    
    
    reference       operator[] (size_type __n)       
    { 
#line 1401 "/opt/aCC/include_std/vector"
      return *(begin() + __n); 
    }
    const_reference operator[] (size_type __n) const 
    { 
#line 1411 "/opt/aCC/include_std/vector"
      return *(begin() + __n); 
    }
    reference       at (size_type __n)               
    { 
      (__n < size ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/vector" ":" "1415" ": "). _C_format ((0 + 8), "vector<bool>::at(size_type)", __n, size());



      return *(begin() + __n); 
    }
    const_reference at (size_type __n)   const 
    {
      (__n < size ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/vector" ":" "1423" ": "). _C_format ((0 + 8), "vector<bool>::at(size_type) const", __n, size ());





      return *(begin() + __n); 
    }
    reference       front ()       { return *begin();     }
    const_reference front () const { return *begin();     }
    reference       back  ()       { return *(end() - 1); }
    const_reference back  () const { return *(end() - 1); }
    
    
    
    
    void push_back (const bool& __x)
    {
        if (_C_finish._C_p != _C_end_of_storage) {
            ++_C_finish;
            *(_C_finish-1) = __x;
        }
        else
            _C_insert_aux(end(), __x);
    }
    void pop_back () { --_C_finish; }

    iterator insert (iterator __position, const bool& __x = bool())
    {
      size_type __n = __position - begin();
      if (_C_finish._C_p != _C_end_of_storage && __position == end()) {
          ++_C_finish;
          *(_C_finish-1) = __x;
      }
      else
        _C_insert_aux(__position, __x);
      return begin() + __n;
    }
    void insert (iterator __position, size_type __n, const bool& __x);


    template<class InputIterator>
    void insert (iterator __position, InputIterator __first,
                 InputIterator __last);





    iterator erase (iterator __position)
    {
      if (!(__position + 1 == end()))
        _C_copy(__position + 1, end(), __position);
      --_C_finish;
      return __position;
    }
    iterator erase(iterator __first, iterator __last)
    {
      _C_finish = _C_copy(__last, end(), __first);
      return __first;
    }
    void swap (vector<bool,_Allocator> & __x)
    {
      if((_C_value_alloc_type)*this == (_C_value_alloc_type)__x)
      {
        std::swap(_C_start,          __x._C_start);
        std::swap(_C_finish,         __x._C_finish);
        std::swap(_C_end_of_storage, __x._C_end_of_storage);
      }
      else
      {
        vector<bool,_Allocator> _x = *this;
        *this = __x;
        __x=_x;
      } 
    }
    static void swap(reference __x, reference __y);
    void flip ();
    void clear()
    {
      erase(begin(),end());
    }

  };


  



  template <class _Allocator>

  inline bool operator== (const vector<bool,_Allocator >& __x, 
                          const vector<bool,_Allocator >& __y)
  {
    if (__x.size() == __y.size())
    {
        typename vector<bool,_Allocator >::const_iterator
        first1 = __x.begin(), 
        last1  = __x.end(),
        first2 = __y.begin();
            
      while (first1 != last1 && *first1 == *first2)
      {
        ++first1;
        ++first2;
      }
      return first1 == last1;
    }
    return false;
  }


  template <class _Allocator>

  inline bool operator< (const vector<bool,_Allocator >& __x, 
                         const vector<bool,_Allocator >& __y)
  {
    typename vector<bool,_Allocator >::const_iterator
        first1 = __x.begin(), 
        last1  = __x.end(),
        first2 = __y.begin(),
        last2  = __y.end();

    while (first1 != last1 && first2 != last2)
    {
      if ((int)*first1 < (int)*first2)     return true;
      if ((int)*first2++ < (int)*first1++) return false;
    }
    return first1 == last1 && first2 != last2;
  }
#line 1597 "/opt/aCC/include_std/vector"






  template <class _Allocator>

  inline bool operator!= (const vector<bool,_Allocator >& __x, 
                          const vector<bool,_Allocator >& __y)
  {
    return !(__x == __y);
  }


  template <class _Allocator>

  inline bool operator> (const vector<bool,_Allocator >& __x, 
                         const vector<bool,_Allocator >& __y)
  {
    return __y < __x;
  }


  template <class _Allocator>

  inline bool operator>= (const vector<bool,_Allocator >& __x, 
                          const vector<bool,_Allocator >& __y)
  {
    return !(__x < __y);
  }


  template <class _Allocator>

  inline bool operator<= (const vector<bool,_Allocator >& __x, 
                          const vector<bool,_Allocator >& __y)
  {
    return !(__y <  __x);
  }





  template <class _Allocator>

  inline void swap(vector<bool,_Allocator >& __a, vector<bool,_Allocator >& __b)
  {
    __a.swap(__b);
  }


#line 1690 "/opt/aCC/include_std/vector"







}   

#line 1 "/opt/aCC/include_std/vector.cc"








































 



namespace std {

template <class _TypeT, class _Allocator>
vector<_TypeT,_Allocator>&
vector<_TypeT,_Allocator>::operator= (const vector<_TypeT,_Allocator>& __x)
{
    if (&__x == this)
        return *this;

    if (__x.size() > capacity())  {
        size_t __new_capacity = 
            max (__x.size(), (size_t)__rw::__rw_new_capacity(size(),this));
        pointer __start = allocator_type::allocate(__new_capacity,0);

        
        try {
            uninitialized_copy(__x.begin(), __x.end(), __start,
                               static_cast< allocator_type& >(*this));
        }
        catch (...) {
            _C_destroy (_C_make_iter (__start),
                        _C_make_iter (__start + __x.size()));
            allocator_type::deallocate (__start,__x . size());

            throw;
        }
        
        _C_destroy(begin (), end ());
        allocator_type::deallocate(_C_start, capacity());

        _C_start = __start;
        _C_finish = _C_start + __x.size();
        _C_end_of_storage = _C_start + __new_capacity;
    }
    else if (size() >= __x.size()) {
        iterator __i = copy(__x.begin(), __x.end(), begin());
        _C_destroy(__i, end());
        _C_finish = _C_start + __x.size();
    }
    else {   
         size_type __size = size ();
 
          
         copy (__x.begin (), __x.begin () + __size, begin ());
 
         
         _C_finish = _C_start + __x.size ();
  
          
         uninitialized_copy (__x.begin () + __size, __x.end (),
                             begin () + __size,
                             static_cast< allocator_type& >(*this));
    }
      return *this;
}
 

template <class _TypeT, class _Allocator>
void vector<_TypeT,_Allocator>::_C_insert_aux ( iterator __position,
                                                const_reference __x)
{
    if (capacity () > size ()) {
        
        pointer __old_end = _C_finish;
        ++_C_finish;
        try {
            allocator_type::construct(__old_end, *(__old_end - 1));

        }
        catch (...) {
            allocator_type::destroy(__old_end);
            --_C_finish;
            throw;
        }
        copy_backward(__position, _C_make_iter(__old_end - 1) ,
                      _C_make_iter(__old_end));
        *__position = __x;
    }
    else {
        
        size_t __new_capacity = __rw::__rw_new_capacity(size(),this);
        pointer __start =
            allocator_type::allocate(__new_capacity,_C_start);

        try {
            uninitialized_copy(begin(), __position, __start,
                               static_cast< allocator_type& >(*this));
            allocator_type::construct((__start + (__position - begin())), __x);

            uninitialized_copy(__position, end(),
                               __start + (__position - begin()) + 1,
                               static_cast< allocator_type& >(*this)); 
        }
        catch (...) {
            _C_destroy (_C_make_iter (__start),
                        _C_make_iter (__start + __new_capacity));
            allocator_type::deallocate (__start,__new_capacity);

            throw;
        }
        
        
        size_type __size = size ();

        _C_destroy (begin(), end());

        
        allocator_type::deallocate(_C_start, capacity ());


        _C_start          = __start;
        _C_finish         = __start + __size + 1;
        _C_end_of_storage = __start + __new_capacity;
    }
}

template <class _TypeT, class _Allocator>
void vector<_TypeT,_Allocator>::_C_insert_aux (iterator __position,
                                               size_type __n,
                                               const_reference __x)
{
    if (__n == 0)
        return;
    if ((size () + __n) <= capacity ())  {
        iterator __old_end = end();
        
        _C_finish += __n;
        if (__position + __n < __old_end) { 
            try {
                uninitialized_copy (__old_end - __n, __old_end, __old_end,
                                    static_cast< allocator_type& >(*this));
            }
            catch (...) {
                _C_destroy (__old_end, end());
                _C_finish -= __n;
                throw;
            }
            copy_backward(__position, __old_end - __n, __old_end);
            fill(__position, __position + __n, __x);
        }
        else {
            size_type __first_part = __n - (__old_end - __position);
            try {
                uninitialized_fill_n (__old_end, __first_part, __x,
                                      static_cast< allocator_type& >(*this));
                uninitialized_copy(__position, __old_end, __position + __n,
                                   static_cast< allocator_type& >(*this));
            }
            catch (...) {
                _C_destroy (__old_end, __old_end + __n);
                _C_finish -= __n;
                throw;
            }
            fill(__position, __old_end, __x);
        }
    }

    else  { 

        size_t __new_capacity = 
            max ((size_t)(size() + __n), (size_t)__rw::__rw_new_capacity(size(),this));
        pointer __start =
            allocator_type::allocate(__new_capacity,_C_start);

        
        try {
            uninitialized_copy(begin(), __position, _C_make_iter (__start),
                               static_cast< allocator_type& >(*this));
            uninitialized_fill_n(__start + (__position - begin()), __n, __x,
                                 static_cast< allocator_type& >(*this));
            uninitialized_copy(__position, end(),
                               __start + (__position - begin() + __n),
                               static_cast< allocator_type& >(*this));
        }
        catch (...) {
            _C_destroy (_C_make_iter (__start),
                        _C_make_iter (__start + __new_capacity));
            allocator_type::deallocate(__start,__new_capacity);

            throw;
        }

        
        size_type __size = size ();

        _C_destroy (begin(), end());

        
        allocator_type::deallocate(_C_start, _C_end_of_storage - _C_start);


        _C_start          = __start;
        _C_finish         = __start + __size + __n;
        _C_end_of_storage = __start + __new_capacity;
    }
}



template<class _TypeT, class _Allocator>
template<class InputIterator>
void vector<_TypeT,_Allocator>::_C_insert_aux2 (iterator __position, 
                                                InputIterator __first, 
                                                InputIterator __last)
#line 255 "/opt/aCC/include_std/vector.cc"
{
    if (__first == __last) return;
    size_type __n = 0;
    distance(__first, __last, __n);

    if ((size () + __n) <= capacity ()) {
        iterator __old_end= end();
        
        _C_finish += __n;
        if (__position + __n < __old_end) { 
            try {
                uninitialized_copy (__old_end - __n, __old_end, __old_end,
                                    static_cast< allocator_type& >(*this));
            }
            catch (...) {
                _C_destroy (__old_end, end ());
                _C_finish -= __n;
                throw;
            }
            copy_backward(__position, __old_end - __n, __old_end);
            copy(__first, __last, __position);
        }
        else {
            size_type __first_part = __old_end - __position;

            InputIterator __iter(__first);



            advance(__iter, __first_part);
            try {
                uninitialized_copy(__iter, __last, __old_end,
                                   static_cast< allocator_type& >(*this));
                uninitialized_copy(__position, __old_end, __position + __n,
                                   static_cast< allocator_type& >(*this));
            }
            catch (...) {
                _C_destroy (__old_end, end());
                _C_finish -= __n;
                throw;
            }
            copy(__first, __iter, __position);
        }
    }
    else {
        size_t __new_capacity = 
            max ((size_t)(size() + __n), (size_t)__rw::__rw_new_capacity(size(),this));
        pointer __start =
            allocator_type::allocate(__new_capacity,_C_start);

        
        try {
            uninitialized_copy(begin(), __position, __start,
                               static_cast< allocator_type& >(*this));
            uninitialized_copy(__first, __last,
                               __start + (__position - begin()),
                               static_cast< allocator_type& >(*this));
            uninitialized_copy(__position, end(),
                               __start + (__position - begin() + __n),
                               static_cast< allocator_type& >(*this));
        }
        catch (...) {
            _C_destroy (_C_make_iter (__start),
                        _C_make_iter (__start + __new_capacity));
            allocator_type::deallocate(__start,__new_capacity);

            throw;
        }
        
        
        size_type __size = size ();

        _C_destroy (begin (), end ());

        
        allocator_type::deallocate(_C_start, capacity());


        _C_start          = __start;
        _C_finish         = __start + __size + __n;
        _C_end_of_storage = __start + __new_capacity;
    }
}







  template <class _Allocator>
  template<class InputIterator>
  void vector<bool, _Allocator >::insert 




  (iterator __position, 
   InputIterator __first,
   InputIterator __last)

  {
    if (__first == __last) return;
    size_type __n = 0;
    distance(__first, __last, __n);
    if (capacity() - size() >= __n)
    {
      copy_backward(__position, end(), _C_finish + __n);
      copy(__first, __last, __position);
      _C_finish += __n;
    }
    else
    {
      size_type __len = size() + max(size(), __n);
      unsigned int* __q = _C_bit_alloc(__len);
      iterator __i = copy(begin(), __position, iterator(__q, 0));
      __i = copy(__first, __last, __i);
      _C_finish = copy(__position, end(), __i);
      _C_value_alloc_type (*this).
          deallocate((pointer)_C_start._C_p,_C_end_of_storage - _C_start._C_p);
      _C_end_of_storage = __q + (__len + (int(8*sizeof(unsigned int))) - 1)/(int(8*sizeof(unsigned int)));
      _C_start = iterator(__q, 0);
    }
  }







  template <class _Allocator>
  void vector<bool,_Allocator >::flip ()
  {
    for (iterator __i = begin(); !(__i == end()); __i++)
      *__i = !(*__i);
  }

  template <class _Allocator>
  void vector<bool,_Allocator >::swap (reference __x, reference __y)
  {
    bool __tmp = __x; __x = __y; __y = __tmp;
  }

  template <class _Allocator>
  void vector<bool,_Allocator >::_C_insert_aux (iterator __position, bool __x)
  {
    if (_C_finish._C_p != _C_end_of_storage)
    {
      _C_copy_backward(__position, _C_finish, _C_finish + size_type(1));
      *__position = __x;
      ++_C_finish;
    }
    else
    {
      size_type __len = size() ? 2 * size() : (int(8*sizeof(unsigned int)));
      unsigned int* __q = _C_bit_alloc(__len);
      iterator __i = _C_copy(begin(), __position, iterator(__q, 0));
      *__i++ = __x;
      _C_finish = _C_copy(__position, end(), __i);
      _C_value_alloc_type (*this).
          deallocate((pointer)_C_start._C_p,_C_end_of_storage - _C_start._C_p);
      _C_end_of_storage = __q + (__len + (int(8*sizeof(unsigned int))) - 1)/(int(8*sizeof(unsigned int)));
      _C_start = iterator(__q, 0);
    }
  }

  template <class _Allocator>
  void vector<bool,_Allocator >::insert (iterator __position, size_type __n,
                                         const bool& __x)
  {
    if (__n == 0) return;
    if (capacity() - size() >= __n)
    {
      _C_copy_backward(__position, end(), _C_finish + __n);
      _C_fill(__position, __position + __n, __x);
      _C_finish += __n;
    }
    else
    {
      size_type __len = size() + max(size(), __n);
      unsigned int* __q = _C_bit_alloc(__len);
      iterator __i = _C_copy(begin(), __position, iterator(__q, 0));
      _C_fill_n(__i, __n, __x);
      _C_finish = _C_copy(__position, end(), __i + __n);
      _C_value_alloc_type (*this).
          deallocate((pointer)_C_start._C_p,_C_end_of_storage - _C_start._C_p);
      _C_end_of_storage = __q + (__len + (int(8*sizeof(unsigned int))) - 1)/(int(8*sizeof(unsigned int)));
      _C_start = iterator(__q, 0);
    }
  }


#line 477 "/opt/aCC/include_std/vector.cc"

  template <class _Allocator>
  void vector<bool,_Allocator >::resize (size_type __new_size, bool __c)
  {
    if (__new_size > size())
      insert(end(), __new_size - size(), __c);             
    else if (__new_size < size())
      erase(begin() + __new_size, end());
  }




}   
#line 1701 "/opt/aCC/include_std/vector"















#line 5 "ABMException.h"


using namespace std;

struct ExceptMsg {
    char m_sFileName[32];       
    int  m_iLineNo;            
    char m_sMsg[256];            
};	

#line 25 "ABMException.h"
	
class ABMException {
public:
    ABMException() {
        m_oErrBuf.resize (16);
        m_oErrBuf.clear ();
    }

    
    void clear() {
        m_oErrBuf.clear ();
    }

    
    vector<ExceptMsg> const * getErrs() {
        return &m_oErrBuf;
    }

    
    
    void printErr(char *sLineHead=0, FILE *pFile = 0);

    
    void addErr(char const *sFile, int const iLine, char const *sFormat, ...);

private:
    vector<ExceptMsg> m_oErrBuf;
};




#line 9 "Application.cpp"
#line 1 "LogV2.h"










class LogV2;
extern LogV2 *g_po3Log;


extern bool init3Log();

#line 27 "LogV2.h"
					






				
#line 49 "LogV2.h"
			



				



																										



				



				
class LogV2
{

public:

	LogV2();

	~LogV2();

	static void setFileName(const char *sName);

	static void log(const char *sFile, const int iLine, int iLogLevel, char const * sFormt, ...);

	static void logExcep(ABMException &oExp);


	static int m_iLogLevel;

	static char m_sLogName[256];
	
	
	void  log(int iCodeId,int iLogLevel,int iLogClassId,int iLogTypeId,               int iAction,char *pExpand,char* format,...) {

        return;            
    }

};



#line 10 "Application.cpp"
#line 1 "HSSLogV3.h"



 




#line 1 "/hss/opt/opthss/src/include/MBC_HSS.h"








































































































































































  


































































































































































































































































 









































#line 10 "HSSLogV3.h"


























struct HSSLogStruct
{

    int m_iModuID;    
    int m_iProcID;
    int m_iLevel;
    int m_iTypeID;
    int m_iErrNo;    
    int m_iTime;
    char m_sErrMsg[512];
};

    
    
extern void directLog(int iLevel, int iTypeID, int iErrNo, char *fmt, ...);
    
    
    
    
    
   

extern void authLog(int iNeID, int iServiceID, char *pServiceName, char *pErrMsg);


class CommandCom;

extern CommandCom* getKernel();      

#line 11 "Application.cpp"
#line 1 "Application.h"






class ABMException;
class Application;

extern int g_iModuID;    
extern int g_iProcID;    
extern int g_iNodeID;    
extern char g_sAppName[32];  


 

 
extern int SigHandlerSet(int sig, void (*handler)(int));
 
extern bool ReceiveStop(void);
extern bool RcvExcepSig(void);
extern void SigHandler(int sig);


class Application 
{	

public:

	Application();

	virtual ~Application();

	int appInit(ABMException &oExp); 

	virtual int init(ABMException &oExp);
	
	static int tryLock(const char *pfname, ABMException &oExp);

	virtual int destory();

	virtual int run() = 0;		           

    char const * getHomeDir() { return m_sEnvAppDly; }

protected:

	char m_sEnvAppDly[128];

	char m_sHostName[64];   

};





#line 12 "Application.cpp"
#line 1 "/hss/opt/opthss/src/bill/src/app_guard/mntapi.h"
  



#line 1 "/opt/aCC/include_std/stdarg.h"





#line 14 "/opt/aCC/include_std/stdarg.h"

#line 6 "/hss/opt/opthss/src/bill/src/app_guard/mntapi.h"
#line 1 "/opt/aCC/include_std/map"














































 

#line 1 "/opt/aCC/include_std/functional"













































 




namespace std {






  template <class Arg, class Result>
  struct unary_function
  {
    typedef Arg argument_type;
    typedef Result result_type;
  };

  template <class Arg1, class Arg2, class Result>
  struct binary_function
  {
    typedef Arg1 first_argument_type;
    typedef Arg2 second_argument_type;
    typedef Result result_type;
  };





  template <class T>
  struct plus : public binary_function<T, T, T>
  {
    typedef typename binary_function<T, T, T>::second_argument_type second_argument_type;
    typedef typename binary_function<T, T, T>::first_argument_type first_argument_type;
    typedef typename binary_function<T, T, T>::result_type result_type;
    T operator() (const T& x, const T& y) const { return x + y; }
  };

  template <class T>
  struct minus : public binary_function<T, T, T>
  {
    typedef typename binary_function<T, T, T>::second_argument_type second_argument_type;
    typedef typename binary_function<T, T, T>::first_argument_type first_argument_type;
    typedef typename binary_function<T, T, T>::result_type result_type;
    T operator() (const T& x, const T& y) const { return x - y; }
  };

  template <class T>
  struct multiplies : public binary_function<T, T, T>
  {
    typedef typename binary_function<T, T, T>::second_argument_type second_argument_type;
    typedef typename binary_function<T, T, T>::first_argument_type first_argument_type;
    typedef typename binary_function<T, T, T>::result_type result_type;
    T operator() (const T& x, const T& y) const { return x * y; }
  };

  template <class T>
  struct divides : public binary_function<T, T, T>
  {
    typedef typename binary_function<T, T, T>::second_argument_type second_argument_type;
    typedef typename binary_function<T, T, T>::first_argument_type first_argument_type;
    typedef typename binary_function<T, T, T>::result_type result_type;
    T operator() (const T& x, const T& y) const { return x / y; }
  };

  template <class T>
  struct modulus : public binary_function<T, T, T>
  {
    typedef typename binary_function<T, T, T>::second_argument_type second_argument_type;
    typedef typename binary_function<T, T, T>::first_argument_type first_argument_type;
    typedef typename binary_function<T, T, T>::result_type result_type;
    T operator() (const T& x, const T& y) const { return x % y; }
  };

  template <class T>
  struct negate : public unary_function<T, T>
  {
    typedef typename unary_function<T,T>::argument_type argument_type;
    typedef typename unary_function<T,T>::result_type result_type;
    T operator() (const T& x) const { return -x; }
  };





  template <class T>
  struct equal_to : public binary_function<T, T, bool>
  {
    typedef typename binary_function<T, T, bool>::second_argument_type second_argument_type;
    typedef typename binary_function<T, T, bool>::first_argument_type first_argument_type;
    typedef typename binary_function<T, T, bool>::result_type result_type;
    bool operator() (const T& x, const T& y) const { return x == y; }
  };

  template <class T>
  struct not_equal_to : public binary_function<T, T, bool>
  {
    typedef typename binary_function<T, T, bool>::second_argument_type second_argument_type;
    typedef typename binary_function<T, T, bool>::first_argument_type first_argument_type;
    typedef typename binary_function<T, T, bool>::result_type result_type;
    bool operator() (const T& x, const T& y) const { return x != y; }
  };

  template <class T>
  struct greater : public binary_function<T, T, bool>
  {
    typedef typename binary_function<T, T, bool>::second_argument_type second_argument_type;
    typedef typename binary_function<T, T, bool>::first_argument_type first_argument_type;
    typedef typename binary_function<T, T, bool>::result_type result_type;
    bool operator() (const T& x, const T& y) const { return x > y; }
  };

  template <class T>
  struct less : public binary_function<T, T, bool>
  {
    typedef typename binary_function<T, T, bool>::second_argument_type second_argument_type;
    typedef typename binary_function<T, T, bool>::first_argument_type first_argument_type;
    typedef typename binary_function<T, T, bool>::result_type result_type;
    bool operator() (const T& x, const T& y) const { return x < y; }
  };

  template <class T>
  struct greater_equal : public binary_function<T, T, bool>
  {
    typedef typename binary_function<T, T, bool>::second_argument_type second_argument_type;
    typedef typename binary_function<T, T, bool>::first_argument_type first_argument_type;
    typedef typename binary_function<T, T, bool>::result_type result_type;
    bool operator() (const T& x, const T& y) const { return x >= y; }
  };

  template <class T>
  struct less_equal : public binary_function<T, T, bool>
  {
    typedef typename binary_function<T, T, bool>::second_argument_type second_argument_type;
    typedef typename binary_function<T, T, bool>::first_argument_type first_argument_type;
    typedef typename binary_function<T, T, bool>::result_type result_type;
    bool operator() (const T& x, const T& y) const { return x <= y; }
  };





  template <class T>
  struct logical_and : public binary_function<T, T, bool>
  {
    typedef typename binary_function<T, T, bool>::second_argument_type second_argument_type;
    typedef typename binary_function<T, T, bool>::first_argument_type first_argument_type;
    typedef typename binary_function<T, T, bool>::result_type result_type;
    bool operator() (const T& x, const T& y) const { return x && y; }
  };

  template <class T>
  struct logical_or : public binary_function<T, T, bool>
  {
    typedef typename binary_function<T, T, bool>::second_argument_type second_argument_type;
    typedef typename binary_function<T, T, bool>::first_argument_type first_argument_type;
    typedef typename binary_function<T, T, bool>::result_type result_type;
    bool operator() (const T& x, const T& y) const { return x || y; }
  };

  template <class T>
  struct logical_not : public unary_function<T, bool>
  {
    typedef typename unary_function<T,bool>::argument_type argument_type;
    typedef typename unary_function<T,bool>::result_type result_type;
    bool operator() (const T& x) const { return !x; }
  };





  template <class Predicate>
  class unary_negate : public unary_function<typename Predicate::argument_type,
  bool>
  {
  protected:
    Predicate pred;
  public:
    typedef typename unary_function<typename Predicate::argument_type,bool>::argument_type argument_type;
    typedef typename unary_function<typename Predicate::argument_type,bool>::result_type result_type;
    explicit unary_negate (const Predicate& x) : pred(x) {}
    bool operator() (const typename unary_function<
                     typename Predicate::argument_type,bool>::argument_type& x) const
    { return !pred(x); }
  };

  template <class Predicate>
  inline unary_negate<Predicate> not1(const Predicate& pred)
  {
    return unary_negate<Predicate>(pred);
  }

  template <class Predicate> 
  class binary_negate
    : public binary_function<typename Predicate::first_argument_type,
  typename Predicate::second_argument_type, bool>
  {
  protected:
    Predicate pred;
  public:
    typedef typename binary_function<typename Predicate::first_argument_type,
    typename Predicate::second_argument_type, bool>::second_argument_type second_argument_type;
    typedef typename binary_function<typename Predicate::first_argument_type,
    typename Predicate::second_argument_type, bool>::first_argument_type first_argument_type;
    typedef typename binary_function<typename Predicate::first_argument_type,
    typename Predicate::second_argument_type, bool>::result_type result_type;
    explicit binary_negate (const Predicate& x) : pred(x) {}
    bool operator() (const typename binary_function<typename Predicate::first_argument_type,
                     typename Predicate::second_argument_type, bool>::first_argument_type& x, 
                     const typename binary_function<typename Predicate::first_argument_type,
                     typename Predicate::second_argument_type, bool>::second_argument_type& y) const
    {
      return !pred(x, y); 
    }
  };

  template <class Predicate>
  inline binary_negate<Predicate> not2(const Predicate& pred)
  {
    return binary_negate<Predicate>(pred);
  }





  template <class Operation> 
  class binder1st :public unary_function<typename Operation::second_argument_type,
  typename Operation::result_type>
  {
  protected:
    Operation op;
    typename Operation::first_argument_type value;
  public:
    typedef typename unary_function<typename Operation::second_argument_type,
    typename Operation::result_type>::argument_type argument_type;
    typedef typename unary_function<typename Operation::second_argument_type,
    typename Operation::result_type>::result_type result_type;
    binder1st (const Operation& x,
               const typename Operation::first_argument_type& y)
      : op(x), value(y) {}
    typename unary_function<typename Operation::second_argument_type,
      typename Operation::result_type>::result_type
    operator() (const typename unary_function<typename Operation::second_argument_type,
                typename Operation::result_type>::argument_type& x) const
    {
      return op(value, x); 
    }
  };

  template <class Operation, class T>
  inline binder1st<Operation> bind1st (const Operation& op, const T& x)
  {
    typedef typename Operation::first_argument_type the_argument_type;
    return binder1st<Operation>(op, the_argument_type(x));
  }

  template <class Operation> 
  class binder2nd : public unary_function<typename Operation::first_argument_type,
  typename Operation::result_type>
  {
  protected:
    Operation op;
    typename Operation::second_argument_type value;
  public:
    typedef typename unary_function<typename Operation::first_argument_type,
    typename Operation::result_type>::argument_type argument_type;
    typedef typename unary_function<typename Operation::first_argument_type,
    typename Operation::result_type>::result_type result_type;
    binder2nd (const Operation& x,
               const typename Operation::second_argument_type& y) 
      : op(x), value(y) {}
    typename unary_function<typename Operation::first_argument_type,
      typename Operation::result_type>::result_type
    operator() (const typename unary_function<typename Operation::first_argument_type,
                typename Operation::result_type>::argument_type& x) const
    {
      return op(x, value); 
    }
  };

  template <class Operation, class T>
  inline binder2nd<Operation> bind2nd (const Operation& op, const T& x)
  {
    typedef typename Operation::second_argument_type the_argument_type;
    return binder2nd<Operation>(op, the_argument_type(x));
  }






  template <class Arg, class Result>
  class pointer_to_unary_function : public unary_function<Arg, Result>
  {
  protected:
    Result (*ptr)(Arg);
  public:
    typedef typename unary_function<Arg,Result>::argument_type argument_type;
    typedef typename unary_function<Arg,Result>::result_type result_type;
    explicit pointer_to_unary_function (Result (*x)(Arg)) : ptr(x) {}
    Result operator() (Arg x) const { return ptr(x); }
  };

  template <class Arg, class Result>
  inline pointer_to_unary_function<Arg, Result> ptr_fun(Result (*x)(Arg))
  {
    return pointer_to_unary_function<Arg, Result>(x);
  }

  template <class Arg1, class Arg2, class Result>
  class pointer_to_binary_function : public binary_function<Arg1, Arg2, Result>
  {
  protected:
    Result (*ptr)(Arg1, Arg2);
  public:
    typedef typename binary_function<Arg1, Arg2, Result>::second_argument_type second_argument_type;
    typedef typename binary_function<Arg1, Arg2, Result>::first_argument_type first_argument_type;
    typedef typename binary_function<Arg1, Arg2, Result>::result_type result_type;
    explicit pointer_to_binary_function (Result (*x)(Arg1, Arg2)) : ptr(x) {}
    Result operator() (Arg1 x, Arg2 y) const
    {
      return ptr(x, y); 
    }
  };

  template <class Arg1, class Arg2, class Result>
  inline pointer_to_binary_function<Arg1, Arg2, Result> 
  ptr_fun(Result (*x)(Arg1, Arg2))
  {
    return pointer_to_binary_function<Arg1, Arg2, Result>(x);
  }







  template <class S, class T> 
  class mem_fun_t  : public unary_function<T*,S>
  {
    S (T::*pmf)();

  public:
    explicit mem_fun_t(S (T::*p)()) : pmf(p)
    { ; }
    S operator()(T* p) const
    { return (p->*pmf)(); }
  };


  template <class S, class T, class A> 
  class mem_fun1_t : public binary_function<T*,A,S>
  {
    S (T::*pmf)(A);

  public:
    explicit mem_fun1_t(S (T::*p)(A)) : pmf(p)
    { ; }
    S operator()(T* p, A a) const
    { return (p->*pmf)(a); }
  };

  template <class S, class T> 
  inline mem_fun_t<S,T> mem_fun(S (T::*f)())
  {
    return mem_fun_t<S,T>(f);
  }

  template <class S, class T, class A> 
  inline mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A))
  {
    return mem_fun1_t<S,T,A>(f);
  }





  template <class S, class T> 
  class mem_fun_ref_t  : public unary_function<T,S>
  {
    S (T::*pmf)();

  public:
    explicit mem_fun_ref_t(S (T::*p)()) : pmf(p)
    { ; }
    S operator()(T& p) const
    { return (p.*pmf)(); }
  };


  template <class S, class T, class A> 
  class mem_fun1_ref_t : public binary_function<T,A,S>
  {
    S (T::*pmf)(A);

  public:
    explicit mem_fun1_ref_t(S (T::*p)(A)) : pmf(p) 
    { ; }
    S operator()(T& p, A a) const
    { return (p.*pmf)(a); }
  };

  template <class S, class T> 
  inline mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)())
  {
    return mem_fun_ref_t<S,T>(f);
  }

  template <class S, class T, class A> 
  inline mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A))
  {
    return mem_fun1_ref_t<S,T,A>(f);
  }

  
  
  

  template <class S, class T> 
  class const_mem_fun_t  : public unary_function<T*,S>
  {
    S (T::*pmf)() const;

  public:
    explicit const_mem_fun_t(S (T::*p)() const) : pmf(p)
    { ; }
    S operator()(const T* p) const
    { return (p->*pmf)(); }
  };


  template <class S, class T, class A> 
  class const_mem_fun1_t : public binary_function<T*,A,S>
  {
    S (T::*pmf)(A) const;

  public:
    explicit const_mem_fun1_t(S (T::*p)(A) const) : pmf(p)
    { ; }
    S operator()(const T* p, A a) const
    { return (p->*pmf)(a); }
  };

  template <class S, class T> 
  inline const_mem_fun_t<S,T> mem_fun(S (T::*f)() const)
  {
    return const_mem_fun_t<S,T>(f);
  }

  template <class S, class T, class A> 
  inline const_mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A) const)
  {
    return const_mem_fun1_t<S,T,A>(f);
  }





  template <class S, class T> 
  class const_mem_fun_ref_t  : public unary_function<T,S>
  {
    S (T::*pmf)() const;

  public:
    explicit const_mem_fun_ref_t(S (T::*p)() const) : pmf(p)
    { ; }
    S operator()(const T& p) const
    { return (p.*pmf)(); }
  };


  template <class S, class T, class A> 
  class const_mem_fun1_ref_t : public binary_function<T,A,S>
  {
    S (T::*pmf)(A) const;

  public:
    explicit const_mem_fun1_ref_t(S (T::*p)(A) const) : pmf(p) 
    { ; }
    S operator()(const T& p, A a) const
    { return (p.*pmf)(a); }
  };

  template <class S, class T> 
  inline const_mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)() const)
  {
    return const_mem_fun_ref_t<S,T>(f);
  }

  template <class S, class T, class A> 
  inline const_mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A) const)
  {
    return const_mem_fun1_ref_t<S,T,A>(f);
  }


}   


namespace __rw {

using namespace std;



template <class _TypeT>
struct identity : public unary_function<_TypeT, _TypeT>
{
    typedef typename
    unary_function<_TypeT, _TypeT>::argument_type argument_type;

    typedef typename
    unary_function<_TypeT, _TypeT>::result_type   result_type;

    result_type operator() (const argument_type &__val) const {
        return __val;
    }
};



template <class _TypeT>
struct unary_plus : public unary_function<_TypeT, _TypeT>
{
    typedef typename
    unary_function<_TypeT, _TypeT>::argument_type argument_type;

    typedef typename
    unary_function<_TypeT, _TypeT>::result_type   result_type;

    result_type operator() (const argument_type &__val) const {
        return +__val;
    }
};



template <class _TypeT>
struct bitwise_complement : public unary_function<_TypeT, _TypeT>
  {
    typedef typename
    unary_function<_TypeT, _TypeT>::argument_type argument_type;

    typedef typename
    unary_function<_TypeT, _TypeT>::result_type   result_type;

    result_type operator() (const argument_type &__val) const {
        return ~__val;
    }
};



template <class _TypeT>
struct bitwise_or : public binary_function<_TypeT, _TypeT, _TypeT>
{
    typedef typename
    binary_function<_TypeT, _TypeT, _TypeT>::first_argument_type
    first_argument_type;

    typedef typename
    binary_function<_TypeT, _TypeT, _TypeT>::second_argument_type
    second_argument_type;

    typedef typename
    binary_function<_TypeT, _TypeT, _TypeT>::result_type
    result_type;

    result_type operator() (const first_argument_type  &__x,
                            const second_argument_type &__y) const {
        return __x | __y;
    }
};



template <class _TypeT>
struct bitwise_and : public binary_function<_TypeT, _TypeT, _TypeT>
{
    typedef typename
    binary_function<_TypeT, _TypeT, _TypeT>::first_argument_type
    first_argument_type;

    typedef typename
    binary_function<_TypeT, _TypeT, _TypeT>::second_argument_type
    second_argument_type;

    typedef typename
    binary_function<_TypeT, _TypeT, _TypeT>::result_type
    result_type;

    result_type operator() (const first_argument_type  &__x,
                            const second_argument_type &__y) const {
        return __x & __y;
    }
};



template <class _TypeT>
struct exclusive_or : public binary_function<_TypeT, _TypeT, _TypeT>
{
    typedef typename
    binary_function<_TypeT, _TypeT, _TypeT>::first_argument_type
    first_argument_type;

    typedef typename
    binary_function<_TypeT, _TypeT, _TypeT>::second_argument_type
    second_argument_type;

    typedef typename
    binary_function<_TypeT, _TypeT, _TypeT>::result_type
    result_type;

    result_type operator() (const first_argument_type  &__x,
                            const second_argument_type &__y) const {
        return __x ^ __y;
    }
};



template <class _TypeT>
struct shift_left : public binary_function<_TypeT, _TypeT, _TypeT>
{
    typedef typename
    binary_function<_TypeT, _TypeT, _TypeT>::first_argument_type
    first_argument_type;

    typedef typename
    binary_function<_TypeT, _TypeT, _TypeT>::second_argument_type
    second_argument_type;

    typedef typename
    binary_function<_TypeT, _TypeT, _TypeT>::result_type
    result_type;

    result_type operator() (const first_argument_type  &__x,
                            const second_argument_type &__y) const {
        return __x << __y;
    }
};



template <class _TypeT>
struct shift_right : public binary_function<_TypeT, _TypeT, _TypeT>
{
    typedef typename
    binary_function<_TypeT, _TypeT, _TypeT>::first_argument_type
    first_argument_type;

    typedef typename
    binary_function<_TypeT, _TypeT, _TypeT>::second_argument_type
    second_argument_type;

    typedef typename
    binary_function<_TypeT, _TypeT, _TypeT>::result_type
    result_type;

    result_type operator() (const first_argument_type  &__x,
                            const second_argument_type &__y) const {
        return __x >> __y;
    }
};


}   


#line 51 "/opt/aCC/include_std/map"

#line 1 "/opt/aCC/include_std/rw/tree"














































 



















 






namespace __rw {

using namespace std;


template <class _Alloc, class _Val, class _Key, class _KeyOf>
struct __rw_rb_tree_node {

    enum _C_color_type { _C_rb_red, _C_rb_black };

    typedef typename _Alloc::template rebind < __rw_rb_tree_node > ::other     _C_node_alloc_type;
    typedef typename _Alloc::template rebind < _Key > ::other                     _C_key_alloc_type;

    typedef typename _C_node_alloc_type::pointer _C_link_type;
    typedef typename _C_key_alloc_type::const_reference _C_const_key_reference;

    typedef _Val&                                          reference;
    typedef _Alloc                                         allocator_type;

    _C_color_type   _C_color_field; 
    _C_link_type    _C_parent_link;
    _C_link_type    _C_left_link;
    _C_link_type    _C_right_link;
    _Val            _C_value_field;


    static _C_link_type _C_nil() {
        return 0L;
    }
    
    static bool _C_isNil (_C_link_type l) {
        return l == _C_nil();
    }
    
    static _C_link_type _C_minimum (_C_link_type __x)
    {
      while (!_C_isNil(__x->_C_left()))
          __x = __x->_C_left();
      return __x;
    }
    
    static _C_link_type _C_maximum (_C_link_type __x)
    {
      while (!_C_isNil(__x->_C_right()))
          __x = __x->_C_right();
      return __x;
    }


    _C_link_type& _C_left() {
        return _C_left_link;
    }
    
    _C_link_type& _C_right () {
        return _C_right_link;
    }
    
    _C_link_type& _C_parent () {
      return _C_parent_link;
    }
    
    reference _C_value () {
        return _C_value_field;
    }
    
    _C_const_key_reference _C_key () {
        return _KeyOf()(_C_value_field);
    }
    
    _C_color_type& _C_color () {
        return _C_color_field;
    }
    
};  



template <class _TypeT, class _DiffT,
          class _Pointer, class _Reference, class _Node>
class __rw_tree_iter
    : public std::iterator <bidirectional_iterator_tag,
                       _TypeT, _DiffT, _Pointer, _Reference>
{
    typedef std::iterator <bidirectional_iterator_tag,
                      _TypeT, _DiffT, _Pointer, _Reference> _C_iter_base;
public:

    typedef typename _C_iter_base::value_type value_type;
    typedef typename _C_iter_base::difference_type difference_type;
    typedef typename _C_iter_base::pointer pointer;
    typedef typename _C_iter_base::reference reference;
    typedef typename _C_iter_base::iterator_category iterator_category;
    typedef _Node                                     _C_tree_node;
    typedef typename _C_tree_node::allocator_type     allocator_type;
    typedef typename _C_tree_node::_C_link_type _C_link_type;

    typedef const value_type*                         const_pointer; 
    typedef const value_type&                         const_reference; 

    typedef __rw_tree_iter<_TypeT, _DiffT, value_type*, value_type&, _C_tree_node>
    _C_iterator;

    _C_link_type _C_node;

    __rw_tree_iter () {}

    
    
    __rw_tree_iter (const _C_iterator &__rhs)
        : _C_node (__rhs._C_node) { }

    __rw_tree_iter (_C_link_type __x)
        : _C_node(__x) {}        






    
    __rw_tree_iter& operator++ () {
        if (!_C_tree_node::_C_isNil(_C_node->_C_right())) {
            _C_node = _C_node->_C_right();
            while (!_C_tree_node::_C_isNil(_C_node->_C_left()))
                _C_node = _C_node->_C_left();
        }
        else {
            _C_link_type __y = _C_node->_C_parent();
            while (_C_node == __y->_C_right()) {
                _C_node = __y; __y = __y->_C_parent();
            }
            if (_C_node->_C_right() != __y) 
                _C_node = __y;
        }
        return *this;
    }
    
    __rw_tree_iter& operator-- () {
        if (_C_node->_C_color() == _C_tree_node::_C_rb_red
            && _C_node->_C_parent()->_C_parent() == _C_node)  
            
            
            
            _C_node = _C_node->_C_right();   
        else if (!_C_tree_node::_C_isNil(_C_node->_C_left())) {
            _C_link_type __y = _C_node->_C_left();
            while (!_C_tree_node::_C_isNil(__y->_C_right()))
                __y = __y->_C_right();
            _C_node = __y;
        }
        else {
          _C_link_type __y = _C_node->_C_parent();
          while (_C_node == __y->_C_left()) {
            _C_node = __y; __y = __y->_C_parent();
          }
          _C_node = __y;
        }
        return *this;
    }

    __rw_tree_iter operator++ (int) {
        __rw_tree_iter __tmp = *this;
        return ++*this, __tmp;
    }
    
    __rw_tree_iter operator-- (int) {
        __rw_tree_iter __tmp = *this;
        return --*this, __tmp;
    }

    reference operator* () const {
        return _C_node->_C_value();
    }

    pointer operator-> () const { return & * *this; };
};





template <class _TypeT, class _DiffT,
          class _Ptr1, class _Ref1, class _Ptr2, class _Ref2, class _Node>
inline bool
operator== (const __rw_tree_iter <_TypeT, _DiffT, _Ptr1, _Ref1, _Node>  &__x, const __rw_tree_iter <_TypeT, _DiffT, _Ptr2, _Ref2, _Node>  &__y)
{
    return __x._C_node == __y._C_node;
}

template <class _TypeT, class _DiffT,
          class _Ptr1, class _Ref1, class _Ptr2, class _Ref2, class _Node>
inline bool
operator!= (const __rw_tree_iter <_TypeT, _DiffT, _Ptr1, _Ref1, _Node> &__x, const __rw_tree_iter <_TypeT, _DiffT, _Ptr2, _Ref2, _Node> &__y)
{
    return !(__x == __y);
}





template <class _Key, class _Val, class _KeyOf, class _Comp, class _Alloc>
class __rb_tree : private _Alloc
{
protected:
    
    typedef __rw_rb_tree_node<_Alloc,_Val,_Key,_KeyOf>   _C_rb_tree_node; 
    typedef _Alloc                  _C_value_alloc_type;
    typedef typename _C_rb_tree_node::_C_key_alloc_type      _C_key_alloc_type;
    typedef typename _C_rb_tree_node::_C_node_alloc_type     _C_node_alloc_type;
    typedef typename _C_rb_tree_node::_C_link_type           _C_link_type;

public:
    
    typedef _Key                                            key_type;
    typedef _Val                                            value_type;
    typedef _Alloc                                          allocator_type;
      
    typedef typename _C_value_alloc_type::pointer           pointer;
    typedef typename _C_value_alloc_type::const_pointer     const_pointer;
    typedef typename _Alloc::size_type                     size_type;
    typedef typename _Alloc::difference_type               difference_type;
    typedef typename _C_value_alloc_type::reference         reference;
    typedef typename _C_value_alloc_type::const_reference   const_reference;
    
protected:

    struct _C_rb_tree_node_buffer;
    friend struct _C_rb_tree_node_buffer;
    
    typedef typename allocator_type::template rebind < _C_rb_tree_node_buffer > ::other _C_buffer_alloc_type;
    typedef typename _C_buffer_alloc_type::pointer _C_buffer_pointer;

    typedef __rw_tree_iter<value_type, difference_type, pointer,
                              reference, _C_rb_tree_node>        _C_tree_iter;

    typedef __rw_tree_iter<value_type, difference_type, const_pointer,
                              const_reference, _C_rb_tree_node>  _C_tree_citer;

public:

#line 332 "/opt/aCC/include_std/rw/tree"

    typedef _C_tree_iter         iterator;
    typedef _C_tree_citer        const_iterator;

    iterator _C_make_iter (_C_link_type __node) {
        return iterator (__node);
    }

    const_iterator _C_make_iter (const _C_link_type __node) const {
        return const_iterator (__node);
    }



protected:

    struct _C_rb_tree_node_buffer {
        _C_buffer_pointer    _C_next_buffer;
        size_type           size;
        _C_link_type         _C_buffer;
    };
    
    _C_buffer_pointer                                       _C_buffer_list;
    _C_link_type                                            _C_free_list;
    _C_link_type                                            _C_next_avail;
    _C_link_type                                            _C_last;
    

    static _C_link_type _C_nil() {
        return _C_rb_tree_node::_C_nil ();
    }

    static bool _C_isNil( _C_link_type l ) {
        return _C_rb_tree_node::_C_isNil (l);
    }

    void _C_add_new_buffer () {
        size_t __next_buffer_size = 0;
        if(_C_buffer_list) {
            __next_buffer_size = 
                __rw::__rw_new_capacity(_C_buffer_list->size,this);
        }
        else {
            __next_buffer_size = 
                __rw::__rw_new_capacity(0,this);
        }          
        _C_buffer_pointer __tmp = 
            _C_buffer_alloc_type(*this).
                allocate(static_cast< size_type >(1), _C_buffer_list);

        try {
            __tmp->_C_buffer = 
                _C_node_alloc_type(*this).
                    allocate(__next_buffer_size,_C_last);
        } catch(...) {
            _C_buffer_alloc_type(*this).deallocate(__tmp,1);
            throw;
        } 




        __tmp->_C_next_buffer   = _C_buffer_list;
        __tmp->size          = __next_buffer_size;
        _C_buffer_list        = __tmp;
        _C_next_avail         = _C_buffer_list->_C_buffer;
        _C_last               = _C_next_avail + __next_buffer_size;
    }
    void _C_deallocate_buffers ();
    
    
    
    
    _C_link_type _C_get_link() {
        _C_link_type __tmp = _C_free_list;
        _C_link_type __tmp2 = _C_free_list ? 
            (_C_free_list = static_cast< _C_link_type >((_C_free_list->_C_right_link)), __tmp) 
            : (_C_next_avail == _C_last ? (_C_add_new_buffer(), _C_next_avail++) 
               : _C_next_avail++);
        __tmp2->_C_parent_link = 0L;
        __tmp2->_C_left_link = 0L;
        __tmp2->_C_right_link = 0L;
        __tmp2->_C_color_field = _C_rb_tree_node::_C_rb_red;
        return __tmp2;
    }

    
    
    
    
    
    _C_link_type _C_get_node (const _Val& __v) {
        _C_link_type __tmp2 = _C_get_link();

        try {
            allocator_type::construct(allocator_type::address(__tmp2->_C_value()), __v);




        } catch(...) {
            _C_put_node(__tmp2,false);
            throw;
        }      
#line 442 "/opt/aCC/include_std/rw/tree"
        return __tmp2;
    }
    _C_link_type _C_get_node () {
        return _C_get_link();
    }
    
    
    
    
    void _C_put_node (_C_link_type __p, bool do_destroy = true) { 
        __p->_C_right_link = _C_free_list; 
        if (do_destroy)  {
            allocator_type::destroy (allocator_type::address(__p->_C_value()));  



        }
        _C_free_list = __p; 
    }
    
protected:

    _C_link_type  _C_header;  
    _C_link_type& _C_root      ()       { return _C_header->_C_parent (); }
    _C_link_type& _C_root      () const { return _C_header->_C_parent (); }
    _C_link_type& _C_leftmost  ()       { return _C_header->_C_left ();   }
    _C_link_type& _C_leftmost  () const { return _C_header->_C_left ();   }
    _C_link_type& _C_rightmost ()       { return _C_header->_C_right ();  }
    _C_link_type& _C_rightmost () const { return _C_header->_C_right();   }
    
    size_type  _C_node_count;    
    bool       _C_insert_always; 
    
    _Comp      _C_key_compare;

public:
    


    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator>  reverse_iterator;
#line 493 "/opt/aCC/include_std/rw/tree"

  private:

    iterator     _C_insert (_C_link_type __x, _C_link_type __y, 
                            const value_type& __v);
    _C_link_type _C_copy   (_C_link_type __x, _C_link_type __p);
    void         _C_erase  (_C_link_type __x);
    inline void  _C_erase_leaf  (_C_link_type __x);

    void _C_init ()
    {
      _C_buffer_list = 0;
      _C_free_list = _C_next_avail = _C_last = 0;
      _C_header        = _C_get_node();
      _C_root()        = 0;
      _C_leftmost()    = _C_header;
      _C_rightmost()   = _C_header;
    }

  public:

    __rb_tree (const _Comp& _RWSTD_COMP = _Comp(), bool __always = true,
             const _Alloc& __alloc = _Alloc()) 
      : allocator_type (__alloc),_C_buffer_list(0), _C_header(0), _C_node_count(0),
        _C_insert_always(__always), _C_key_compare(_RWSTD_COMP)
    {
      _C_init();
    }

#line 544 "/opt/aCC/include_std/rw/tree"


    template<class InputIterator>
    __rb_tree (InputIterator __first, InputIterator __last, 
             const _Comp& comp = _Comp(), bool __always = true,
             const _Alloc& __alloc = _Alloc())
      : allocator_type(__alloc),_C_buffer_list(0), _C_header(0), _C_node_count(0), 
        _C_insert_always(__always), _C_key_compare(comp)
    { 
      _C_init(); 

      try {
        insert(__first, __last);
      } catch(...) {
        _C_deallocate_buffers();
        throw;
      }



    }
#line 714 "/opt/aCC/include_std/rw/tree"

    __rb_tree (const __rb_tree<_Key,_Val,_KeyOf,_Comp,_Alloc>& __x,
             bool __always = true)
      : allocator_type(__x.get_allocator()), _C_buffer_list(0), _C_header(0), 
        _C_node_count(__x._C_node_count), _C_insert_always(__always), 
        _C_key_compare(__x._C_key_compare)
    { 
      _C_free_list     = _C_next_avail = _C_last = 0;
      _C_header        = _C_get_node();
      _C_header->_C_color() = _C_rb_tree_node::_C_rb_red;

      try { 
          _C_root()        = _C_copy(__x._C_root(), _C_header);
      } catch(...) {
          _C_deallocate_buffers();
          throw;
      }



      if (_C_isNil(_C_root()))
      {
        _C_leftmost() = _C_header; _C_rightmost() = _C_header;
      }
      else
      {
        _C_leftmost() = _C_rb_tree_node::_C_minimum(_C_root());
        _C_rightmost() = _C_rb_tree_node::_C_maximum(_C_root());
      }
    }

    ~__rb_tree ()
    {
      if (_C_header) {
        erase(begin(), end());
        _C_put_node(_C_header,false);
        _C_deallocate_buffers();
      }
    }

    __rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>& 
    operator= (const __rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>& __x);

    _Comp     key_comp () const { return _C_key_compare; }
    _C_value_alloc_type get_allocator() const
    {
      return _C_value_alloc_type(*this);
    }

    iterator begin () {
        return _C_make_iter (_C_leftmost ());
    }

    const_iterator begin () const {
        return _C_make_iter (_C_leftmost ());
    }

    iterator end () {
        return _C_make_iter (_C_header);
    }

    const_iterator end () const {
        return _C_make_iter (_C_header);
    }

    reverse_iterator rbegin () { 
        return reverse_iterator(end());
    }
    
    reverse_iterator rend () { 
        return reverse_iterator (begin());
    } 

    const_reverse_iterator rbegin () const { 
        return const_reverse_iterator (end());
    }
    
    const_reverse_iterator rend () const { 
        return const_reverse_iterator(begin());
    } 

    bool      empty    () const {
        return _C_node_count == 0;
    }

    size_type size     () const {
        return _C_node_count;
    }

    size_type max_size () const { 
      return _C_node_alloc_type(*this).max_size(); 
    }
    
    void swap (__rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>& t)
    {
      if(get_allocator() == t.get_allocator()) {
        std::swap(_C_buffer_list, t._C_buffer_list);
        std::swap(_C_free_list, t._C_free_list);
        std::swap(_C_next_avail, t._C_next_avail);
        std::swap(_C_last, t._C_last);
        std::swap(_C_header, t._C_header);
        std::swap(_C_node_count, t._C_node_count);
        std::swap(_C_insert_always, t._C_insert_always);
        std::swap(_C_key_compare, t._C_key_compare);
      }
      else {
        __rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc> _x = *this;
        *this = t;
        t = _x;
      } 
    }

    typedef std::pair<iterator, bool> pair_iterator_bool;
    typedef std::pair<const_iterator, bool> pair_const_iterator_bool;
    
    
    


    std::pair<iterator,bool> insert (const value_type& __x);




    iterator  insert (iterator position, const value_type& __x);


    template<class _Iterator>
    void      insert (_Iterator __first, _Iterator __last);





    iterator  erase  (iterator position);
    size_type erase  (const key_type& __x);
    iterator  erase  (iterator __first, iterator __last);
    void      erase  (const key_type* __first, const key_type* __last);

    iterator find (const key_type& __x);

    const_iterator find (const key_type& __x) const {
        return const_cast< __rb_tree* >(this)->find (__x);
    }

    size_type count (const key_type& __x) const;

    iterator lower_bound (const key_type& __x);

    const_iterator lower_bound (const key_type& __x) const {
        return const_cast< __rb_tree* >(this)->lower_bound (__x);
    }

    iterator upper_bound (const key_type& __x);

    const_iterator upper_bound (const key_type& __x) const {
        return const_cast< __rb_tree* >(this)->upper_bound (__x);
    }

    typedef std::pair<iterator, iterator> pair_iterator_iterator; 

    typedef std::pair<const_iterator, const_iterator>
        pair_const_iterator_iterator; 
    
    
    

    std::pair<iterator, iterator> equal_range (const key_type& __x);




    pair_const_iterator_iterator
    equal_range (const key_type& __x) const {
        std::pair<iterator, iterator> __tmp =
            const_cast< __rb_tree* >(this)->equal_range (__x);
        return std::pair<const_iterator, const_iterator>
            (__tmp.first, __tmp.second);
    }

    inline void __rotate_left  (_C_link_type __x);
    inline void __rotate_right (_C_link_type __x);

};






  template <class _Key, class _Val, class _KeyOf, 
  class _Comp, class _Alloc>
  inline bool operator== (const __rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>& __x, 
                          const __rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>& __y)
  {
    return __x.size() == __y.size() && std::equal(__x.begin(), __x.end(), __y.begin());
  }

  template <class _Key, class _Val, class _KeyOf, 
  class _Comp, class _Alloc>
  inline bool operator< (const __rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>& __x, 
                         const __rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>& __y)
  {
    return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
  }

  template <class _Key,class _Val,class _KeyOf,class _Comp,class _Alloc>
  inline  void   
  __rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::_C_erase_leaf (_C_link_type __x)
  {
    
    _C_link_type __y = __x->_C_parent();
    if (__y == _C_header)
    {
      _C_leftmost() = _C_rightmost() = __y;
      _C_root() = 0;
    }
    else if (__y->_C_left() == __x)
    {
      __y->_C_left() = 0;
      if (_C_leftmost() == __x)
        _C_leftmost() = __y;
    }
    else
    {
      __y->_C_right() = 0;
      if (_C_rightmost() == __x)
        _C_rightmost() = __y;
    }
  }

  template <class _Key, class _Val, class _KeyOf, class _Comp, class _Alloc>
  inline void 
  __rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::__rotate_left (_C_link_type __x)
  {
      _C_link_type __y = __x->_C_right();
    __x->_C_right() = __y->_C_left();
    if (!_C_isNil(__y->_C_left()))
      __y->_C_left()->_C_parent() = __x;
    __y->_C_parent() = __x->_C_parent();
    if (__x == _C_root())
      _C_root() = __y;
    else if (__x == __x->_C_parent()->_C_left())
      __x->_C_parent()->_C_left() = __y;
    else
      __x->_C_parent()->_C_right() = __y;
    __y->_C_left() = __x;
    __x->_C_parent() = __y;
  }


  template <class _Key, class _Val, class _KeyOf, 
  class _Comp, class _Alloc>
  inline void 
  __rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::__rotate_right (_C_link_type __x)
  {
    _C_link_type __y = __x->_C_left();
    __x->_C_left()= __y->_C_right();
    if (!_C_isNil(__y->_C_right()))
      __y->_C_right()->_C_parent() = __x;
    __y->_C_parent() = __x->_C_parent();
    if (__x == _C_root())
      _C_root() = __y;
    else if (__x == __x->_C_parent()->_C_right())
      __x->_C_parent()->_C_right() = __y;
    else
      __x->_C_parent()->_C_left() = __y;
    __y->_C_right() = __x;
    __x->_C_parent() = __y;
  }




template <class _Key, class _Val, class _KeyOf, class _Comp, class _Alloc>
template<class _Iterator>
inline void __rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::
insert (_Iterator __first, _Iterator __last)
{
    for (; __first != __last; ++__first)
        insert(*__first);
}

#line 1016 "/opt/aCC/include_std/rw/tree"
         

template <class _Key, class _Val, class _KeyOf, class _Comp, class _Alloc>
void __rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::
erase (const _Key* __first, const _Key* __last)
{
    for (; __first != __last; ++__first)
        erase(*__first);
}


template <class _Key, class _Val, class _KeyOf, class _Comp, class _Alloc>
inline typename __rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::size_type 
__rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::count (const _Key& __k) const
{
    std::pair<const_iterator, const_iterator> __p = equal_range(__k);
    size_type __n = std::distance (__p . first, __p . second);
    return __n;
}


template <class _Key, class _Val, class _KeyOf, class _Comp, class _Alloc>
inline
typename __rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::pair_iterator_iterator 
__rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::equal_range (const _Key& __k)
{
    pair_iterator_iterator __tmp(lower_bound(__k), upper_bound(__k));
    return __tmp;
}


}   


#line 1 "/opt/aCC/include_std/rw/tree.cc"










































 




namespace __rw {


template <class _Key, class _Val, class _KeyOf, class _Comp, class _Alloc>
void __rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::_C_deallocate_buffers ()
{
    while (_C_buffer_list)    {
      _C_buffer_pointer __tmp = _C_buffer_list;
      _C_buffer_list        = (_C_buffer_pointer)(_C_buffer_list->_C_next_buffer);
      _C_node_alloc_type(*this).deallocate(__tmp->_C_buffer,__tmp->size);
      _C_buffer_alloc_type(*this).deallocate(__tmp,1);
    }
}


template <class _Key, class _Val, class _KeyOf, class _Comp, class _Alloc>
__rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>& 
__rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::
operator= (const __rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>& __x)
{
    if (!(this == &__x)) {
      
      
      
      erase(begin(), end());
      _C_root() = _C_copy(__x._C_root(), _C_header);
      if (_C_isNil(_C_root())) {
        _C_leftmost()  = _C_header; _C_rightmost() = _C_header;
      }
      else {
        _C_leftmost()  = _C_rb_tree_node::_C_minimum(_C_root());
        _C_rightmost() = _C_rb_tree_node::_C_maximum(_C_root());
      }
      _C_node_count = __x._C_node_count;
      _C_key_compare = __x. _C_key_compare;
    }
    return *this;
  }


template <class _Key, class _Val, class _KeyOf, class _Comp, class _Alloc>
typename __rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::iterator
__rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::
_C_insert (_C_link_type __x, _C_link_type __y, const _Val& __v)
{
    _C_link_type __z = _C_get_node(__v);
    ++_C_node_count;
    if (__y == _C_header || !_C_isNil(__x) || _C_key_compare(_KeyOf()(__v), __y->_C_key())) {
      __y->_C_left() = __z;  
      if (__y == _C_header) {
        _C_root() = __z; _C_rightmost() = __z;
      }
      else if (__y == _C_leftmost())
        _C_leftmost() = __z;   
    }
    else {
      __y->_C_right() = __z;
      if (__y == _C_rightmost())
        _C_rightmost() = __z;  
    }
    __z->_C_parent() = __y;
    __x = __z;  
    while (__x != _C_root() && __x->_C_parent()->_C_color() == _C_rb_tree_node::_C_rb_red) {
      if (__x->_C_parent() == __x->_C_parent()->_C_parent()->_C_left()) {
        __y = __x->_C_parent()->_C_parent()->_C_right();
        if (!_C_isNil(__y) && __y->_C_color() == _C_rb_tree_node::_C_rb_red) {
          __x->_C_parent()->_C_color()         = _C_rb_tree_node::_C_rb_black;
          __y->_C_color()                 = _C_rb_tree_node::_C_rb_black;
          __x->_C_parent()->_C_parent()->_C_color() = _C_rb_tree_node::_C_rb_red;
          __x                        = __x->_C_parent()->_C_parent();
        }
        else {
          if (__x == __x->_C_parent()->_C_right()) {
            __x = __x->_C_parent(); 
            __rotate_left(__x);
          }
          __x->_C_parent()->_C_color() = _C_rb_tree_node::_C_rb_black;
          __x->_C_parent()->_C_parent()->_C_color() = _C_rb_tree_node::_C_rb_red;
          __rotate_right(__x->_C_parent()->_C_parent());
        }
      }
      else {
        __y = __x->_C_parent()->_C_parent()->_C_left();
        if (!_C_isNil(__y) && __y->_C_color() == _C_rb_tree_node::_C_rb_red) {
          __x->_C_parent()->_C_color()         = _C_rb_tree_node::_C_rb_black;
          __y->_C_color()                 = _C_rb_tree_node::_C_rb_black;
          __x->_C_parent()->_C_parent()->_C_color() = _C_rb_tree_node::_C_rb_red;
          __x                        = __x->_C_parent()->_C_parent();
        }
        else {
          if (__x == __x->_C_parent()->_C_left()) {
            __x = __x->_C_parent(); 
            __rotate_right(__x);
          }
          __x->_C_parent()->_C_color()         = _C_rb_tree_node::_C_rb_black;
          __x->_C_parent()->_C_parent()->_C_color() = _C_rb_tree_node::_C_rb_red;
          __rotate_left(__x->_C_parent()->_C_parent());
        }
      }
    }
    _C_root()->_C_color() = _C_rb_tree_node::_C_rb_black;
    return _C_make_iter (__z);
}


template <class _Key, class _Val, class _KeyOf, class _Comp, class _Alloc>
typename __rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::pair_iterator_bool
__rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::insert (const _Val& __v)
{
    _C_link_type __y = _C_header;
    _C_link_type __x = _C_root();
    bool _RWSTD_COMP   = true;
    while (!_C_isNil(__x)) {
      __y    = __x;
      _RWSTD_COMP = _C_key_compare(_KeyOf()(__v), __x->_C_key());
      __x    = _RWSTD_COMP ? __x->_C_left() : __x->_C_right();
    }
    if (_C_insert_always) {
      pair_iterator_bool __tmp(_C_insert(__x, __y, __v), true); return __tmp;
    }
    iterator __j = _C_make_iter(__y);   
    if (_RWSTD_COMP) {
      if (__j == begin())   {
        pair_iterator_bool __tmp(_C_insert(__x, __y, __v), true); return __tmp;
      }
      else
        --__j;
    }
    if (_C_key_compare(((_C_tree_iter&)__j)._C_node->_C_key(), _KeyOf()(__v))) {
      pair_iterator_bool __tmp(_C_insert(__x, __y, __v), true); return __tmp;
    }
    pair_iterator_bool __tmp(__j, false);
    return __tmp;
}


template <class _Key, class _Val, class _KeyOf, class _Comp, class _Alloc>
typename __rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::iterator 
__rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::insert (iterator position,
                                                      const _Val& __v)
{
    if (position == begin()) {
      if (size() > 0 && _C_key_compare(_KeyOf()(__v),
                                      ((_C_tree_iter&)position)._C_node->_C_key()))
        return _C_insert (((_C_tree_iter&)position)._C_node,
                         ((_C_tree_iter&)position)._C_node, __v);
      
      
      
      else
        return insert(__v).first;
    }
    else if (position == end()) {
      if (_C_key_compare(_C_rightmost()->_C_key(), _KeyOf()(__v)))
        return _C_insert(0, _C_rightmost(), __v);
      else
        return insert(__v).first;
    }
    else {
      iterator before = --position;
      if (_C_key_compare(((_C_tree_iter&)before)._C_node->_C_key(), _KeyOf()(__v))
          && _C_key_compare(_KeyOf()(__v),
                           ((_C_tree_iter&)position)._C_node->_C_key())) {
        if (_C_isNil (((_C_tree_iter&)before)._C_node->_C_right()))
          return _C_insert(0, ((_C_tree_iter&)before)._C_node, __v); 
        else
          return _C_insert (((_C_tree_iter&)position)._C_node,
                           ((_C_tree_iter&)position)._C_node, __v);
        
        
        
      }
      else
        return insert(__v).first;
    }
}


template <class _Key, class _Val, class _KeyOf, class _Comp, class _Alloc>
typename __rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::iterator 
__rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::erase (iterator position)
{
    iterator __tmp = position; 

    if (__tmp == end())
        
        return end ();
    else
        
        ++__tmp;


    _C_link_type __z(((_C_tree_iter&)position)._C_node);
    _C_link_type __y = __z;
    _C_link_type __x;
    bool __deleted = false;
    if (_C_isNil(__y->_C_left())) {
      if (_C_isNil(__y->_C_right())) {
        __x = __y->_C_parent();
        _C_erase_leaf(__y);
        __deleted = true;
      }
      else
        __x = __y->_C_right(); 
    }
    else {
      if (_C_isNil(__y->_C_right())) 
        __x = __y->_C_left();
      else {
        __y = __y->_C_right();
        while (!_C_isNil(__y->_C_left()))
            __y = __y->_C_left();
        __x = __y->_C_right();
      }
    }
    if (!__deleted && __y != __z) {
      
      
      
      __z->_C_left()->_C_parent() = __y; 
      __y->_C_left() = __z->_C_left();
      if (__y != __z->_C_right()) {
        if (!_C_isNil(__x))
          __x->_C_parent()        = __y->_C_parent();
        __y->_C_parent()->_C_left()  = __x;         
        __y->_C_right()         = __z->_C_right();
        __z->_C_right()->_C_parent() = __y;
      }
      else if (!_C_isNil(__x))
        __x->_C_parent() = __y;  

      if (_C_root() == __z)
        _C_root() = __y;
      else if (__z->_C_parent()->_C_left() == __z)
        __z->_C_parent()->_C_left() = __y;
      else 
        __z->_C_parent()->_C_right() = __y;

      __y->_C_parent() = __z->_C_parent();
      if (_C_isNil(__x))
        __x = __y;       

      std::swap(__y->_C_color(), __z->_C_color());

      __y = __z;        
    }
    else if (!__deleted) {
      
      
      
      __x->_C_parent() = __y->_C_parent();   
      if (_C_root() == __z)
        _C_root() = __x;
      else  {
        if (__z->_C_parent()->_C_left() == __z)
          __z->_C_parent()->_C_left() = __x;
        else
          __z->_C_parent()->_C_right() = __x;
      }
      if (_C_leftmost() == __z)  {
        if (_C_isNil(__z->_C_right()))  
          _C_leftmost() = __z->_C_parent();
        else
          _C_leftmost() = _C_rb_tree_node::_C_minimum(__x);
      }
      if (_C_rightmost() == __z)   {
        if (_C_isNil(__z->_C_left())) 
          _C_rightmost() = __z->_C_parent();
        else
          _C_rightmost() = _C_rb_tree_node::_C_maximum(__x);
      }
    }
    if (__x != _C_header && __y->_C_color() != _C_rb_tree_node::_C_rb_red) {
      while (__x != _C_root() && __x->_C_color() == _C_rb_tree_node::_C_rb_black) {
        if (__x == __x->_C_parent()->_C_left()) {
          _C_link_type w = __x->_C_parent()->_C_right();
          if (_C_isNil(w)) {
            __x->_C_color() = _C_rb_tree_node::_C_rb_red;
            __x = __x->_C_parent();
          }
          else {
            if (w->_C_color() == _C_rb_tree_node::_C_rb_red) {
              w->_C_color()         = _C_rb_tree_node::_C_rb_black;
              __x->_C_parent()->_C_color() = _C_rb_tree_node::_C_rb_red;
              __rotate_left(__x->_C_parent());
              w = __x->_C_parent()->_C_right();
            }
            if (_C_isNil(w)) {
              __x->_C_color() = _C_rb_tree_node::_C_rb_red;
              __x = __x->_C_parent();
            }
            else if ((_C_isNil(w->_C_left()) || w->_C_left()->_C_color() == _C_rb_tree_node::_C_rb_black) && 
                (_C_isNil(w->_C_right()) || w->_C_right()->_C_color() == _C_rb_tree_node::_C_rb_black)) {
              w->_C_color() = _C_rb_tree_node::_C_rb_red;
              __x = __x->_C_parent();
            }
            else {
              if (_C_isNil(w->_C_right()) || w->_C_right()->_C_color() == _C_rb_tree_node::_C_rb_black) {
                if (!_C_isNil(w->_C_left()))
                  w->_C_left()->_C_color() = _C_rb_tree_node::_C_rb_black;
                w->_C_color()       = _C_rb_tree_node::_C_rb_red;
                __rotate_right(w);
                w = __x->_C_parent()->_C_right();
              }
              if (!_C_isNil(w)) {
                w->_C_color() = __x->_C_parent()->_C_color();
                __x->_C_parent()->_C_color() = _C_rb_tree_node::_C_rb_black;
                if (!_C_isNil(w->_C_right()))
                  w->_C_right()->_C_color()  = _C_rb_tree_node::_C_rb_black;
                __rotate_left(__x->_C_parent());
              }          
              break;
            }
          }
        }
        else {
          
          
          
          _C_link_type w = __x->_C_parent()->_C_left();
          if (_C_isNil(w)) {
            __x->_C_color() = _C_rb_tree_node::_C_rb_red;
            __x = __x->_C_parent();
          }
          else {
            if (w->_C_color() == _C_rb_tree_node::_C_rb_red) {
              w->_C_color()         = _C_rb_tree_node::_C_rb_black;
              __x->_C_parent()->_C_color() = _C_rb_tree_node::_C_rb_red;
              __rotate_right(__x->_C_parent());
              w = __x->_C_parent()->_C_left();
            }
            if (_C_isNil(w)) {
              __x->_C_color() = _C_rb_tree_node::_C_rb_red;
              __x = __x->_C_parent();
            }
            else if ((_C_isNil(w->_C_right()) || w->_C_right()->_C_color() == _C_rb_tree_node::_C_rb_black) &&
              (_C_isNil(w->_C_left()) || w->_C_left()->_C_color() == _C_rb_tree_node::_C_rb_black)) {
              w->_C_color() = _C_rb_tree_node::_C_rb_red; __x = __x->_C_parent();
            }
            else {
              if (_C_isNil(w->_C_left()) || w->_C_left()->_C_color() == _C_rb_tree_node::_C_rb_black) {
                if (!_C_isNil(w->_C_right()))
                  w->_C_right()->_C_color() = _C_rb_tree_node::_C_rb_black;
                w->_C_color()        = _C_rb_tree_node::_C_rb_red;
                __rotate_left(w);
                w = __x->_C_parent()->_C_left();
              }
              if (!_C_isNil(w)) {
                w->_C_color() = __x->_C_parent()->_C_color();
                __x->_C_parent()->_C_color() = _C_rb_tree_node::_C_rb_black;
                if (!_C_isNil(w->_C_left()))
                  w->_C_left()->_C_color()   = _C_rb_tree_node::_C_rb_black;
                __rotate_right(__x->_C_parent());
              }
              break;
            }
          }
        }
      }
      __x->_C_color() = _C_rb_tree_node::_C_rb_black;
    }
    _C_put_node(__y);
    --_C_node_count;
    return __tmp;
}


template <class _Key, class _Val, class _KeyOf, class _Comp, class _Alloc>
typename __rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::size_type 
__rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::erase (const _Key& __x)
{
    pair_iterator_iterator __p = equal_range(__x);
    size_type __n = std::distance (__p . first, __p . second);
    erase(__p.first, __p.second);
    return __n;
}


template <class _Key, class _Val, class _KeyOf, class _Comp, class _Alloc>
typename __rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::_C_link_type 
__rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::_C_copy (_C_link_type __x, _C_link_type __p)
{
    
    
    
    _C_link_type r = __x;
    while (!_C_isNil(__x)) {
      _C_link_type __y = _C_get_node(__x->_C_value());
      if (r == __x) r = __y;  
      __p->_C_left()   = __y;
      __y->_C_parent() = __p;
      __y->_C_color()  = __x->_C_color();
      __y->_C_right()  = _C_copy(__x->_C_right(), __y);
      __p         = __y;
      __x         = __x->_C_left();
    }
    __p->_C_left() = _C_nil();
    return r;
}


template <class _Key, class _Val, class _KeyOf, class _Comp, class _Alloc>
void __rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::_C_erase (_C_link_type __x)
{
    
    
    
    while (!_C_isNil(__x)) {
      _C_erase(__x->_C_right());
      _C_link_type __y = __x->_C_left();
      _C_put_node(__x);
      __x = __y;
    }
}


template <class _Key, class _Val, class _KeyOf, class _Comp, class _Alloc>
typename __rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::iterator 
__rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::erase (iterator __first, 
                                                     iterator __last)
{
    iterator __tmp = end();
    if (__first == begin() && __last == end() && _C_node_count != 0) {
      _C_erase(_C_root());
      _C_leftmost()  = _C_header;
      _C_root()      = _C_nil();
      _C_rightmost() = _C_header;
      _C_node_count  = 0;
      __tmp = end();
    } else {
        while (__first != __last)
            __tmp =  erase(__first++);
    }
    return __tmp;
}


template <class _Key, class _Val, class _KeyOf, class _Comp, class _Alloc>
typename __rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::iterator 
__rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::find (const _Key& __k)
{
    _C_link_type __y = _C_header;  
    _C_link_type __x = _C_root();  

    while (!_C_isNil(__x)) {
      if (!_C_key_compare(__x->_C_key(), __k))
        __y = __x, __x = __x->_C_left();
      else
        __x = __x->_C_right();
    }

    iterator __j = _C_make_iter (__y);
    return (   __j == end()
            || _C_key_compare(__k, ((_C_tree_iter&)__j)._C_node->_C_key())) ? end() : __j;
}


template <class _Key, class _Val, class _KeyOf, class _Comp, class _Alloc>
typename __rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::iterator 
__rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::lower_bound (const _Key& __k)
{
    _C_link_type __y = _C_header;  
    _C_link_type __x = _C_root();  

    while (!_C_isNil(__x)) {
      if (!_C_key_compare(__x->_C_key(), __k))
        __y = __x, __x = __x->_C_left();
      else
        __x = __x->_C_right();
    }

    return _C_make_iter (__y);
}


template <class _Key, class _Val, class _KeyOf, class _Comp, class _Alloc>
typename __rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::iterator 
__rb_tree<_Key, _Val, _KeyOf, _Comp, _Alloc>::upper_bound (const _Key& __k)
{
    _C_link_type __y = _C_header;  
    _C_link_type __x = _C_root();  

    while (!_C_isNil(__x)) {
      if (_C_key_compare(__k,__x->_C_key()))
        __y = __x, __x = __x->_C_left();
      else
        __x = __x->_C_right();
    }

    return _C_make_iter (__y);
}


}   
#line 1052 "/opt/aCC/include_std/rw/tree"


#line 53 "/opt/aCC/include_std/map"



namespace __rw {






  template <class _TypeT, class U>
  struct __select1st : public std::unary_function<_TypeT, U>
  {
    const U& operator() (const _TypeT& x) const { return x.first; }
  };


}   


namespace std {









template <class _Key, class _TypeT,
          class _Compare = less<_Key>, 
          class _Allocator
  = allocator<pair<const _Key, _TypeT> > >
class map
{
public:

    typedef _Key                                          key_type;
    typedef _TypeT                                        mapped_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef _Compare                                      key_compare;
    typedef _Allocator                                    allocator_type;
    
  private:
    
    typedef __rw::__rb_tree<key_type, value_type,
      __rw::__select1st<value_type, key_type>, 
      key_compare, allocator_type> __rep_type;
    __rep_type __t;

  public:
    
    
    
    typedef typename __rep_type::reference                reference;
    typedef typename __rep_type::const_reference          const_reference;
    typedef typename __rep_type::iterator                 iterator;
    typedef typename __rep_type::const_iterator           const_iterator;
    typedef typename __rep_type::size_type                size_type;
    typedef typename __rep_type::difference_type          difference_type;
    typedef typename __rep_type::pointer                  pointer;
    typedef typename __rep_type::const_pointer            const_pointer;
    typedef typename __rep_type::reverse_iterator         reverse_iterator;
    typedef typename __rep_type::const_reverse_iterator   const_reverse_iterator;

    class value_compare : public binary_function<value_type, value_type, bool>
    {
      friend class map<_Key, _TypeT, _Compare, _Allocator>;
    protected:
      _Compare comp;
      value_compare (_Compare c) : comp(c) {}
    public:
      bool operator() (const value_type& x, const value_type& y) const
      {
        return comp(x.first, y.first);
      }
    };


    
    
    
    explicit map (const _Compare& comp = _Compare(),
                   const _Allocator& alloc = _Allocator()) 
      : __t(comp, false, alloc) {}


#line 150 "/opt/aCC/include_std/map"




    template<class InputIterator>
    map (InputIterator first, InputIterator last, 
         const _Compare& comp = _Compare(),
         const _Allocator& alloc = _Allocator())
      : __t(first, last, comp, false, alloc) {}

#line 190 "/opt/aCC/include_std/map"


    map (const map<_Key, _TypeT, _Compare, _Allocator>& x) : __t(x.__t, false) {}
    map<_Key, _TypeT, _Compare, _Allocator>& 
    operator= (const map<_Key, _TypeT, _Compare, _Allocator>& x)
    {
      __t = x.__t; return *this; 
    }
    allocator_type get_allocator() const
    {
      return __t.get_allocator();
    }

    
    
    

    iterator               begin  ()       { return __t.begin();  }
    const_iterator         begin  () const { return __t.begin();  }
    iterator               end    ()       { return __t.end();    }
    const_iterator         end    () const { return __t.end();    }
    reverse_iterator       rbegin ()       { return __t.rbegin(); }
    const_reverse_iterator rbegin () const { return __t.rbegin(); }
    reverse_iterator       rend   ()       { return __t.rend();   }
    const_reverse_iterator rend   () const { return __t.rend();   }

    
    
    
    bool      empty    () const { return __t.empty();    }
    size_type size     () const { return __t.size();     }
    size_type max_size () const { return __t.max_size(); }

    
    
    
    mapped_type& operator[] (const key_type& k)
    {
      value_type tmp(k,_TypeT()); return (*((insert(tmp)).first)).second;
    }




    pair<iterator,bool> insert (const_reference __x) {
        return __t.insert (__x);
    }

#line 249 "/opt/aCC/include_std/map"

    iterator insert (iterator position, const value_type& x)
    {
      return __t.insert(position, x);
    }



    template<class InputIterator>
    void insert (InputIterator first, InputIterator last)
    {
      __t.insert(first, last);
    }

#line 283 "/opt/aCC/include_std/map"


    void  erase (iterator position)             { __t.erase(position);}
    size_type erase (const key_type& x)         { return __t.erase(x); }
    void  erase (iterator first, iterator last) { __t.erase(first,last);}
    void      swap  (map<_Key, _TypeT, _Compare, _Allocator>& x)       
    { __t.swap(x.__t);          }
    void      clear ()                              { erase(begin(),end()); }

    
    
    
    key_compare key_comp () const { return __t.key_comp(); }
    value_compare value_comp () const { return value_compare(__t.key_comp()); }

    
    
    
    iterator     find (const key_type& x)        { return __t.find(x);}
    const_iterator find (const key_type& x)  const { return __t.find(x); }
    size_type    count (const key_type& x) const { return __t.count(x); }
    iterator     lower_bound (const key_type& x) { return __t.lower_bound(x); }
    iterator     upper_bound (const key_type& x) { return __t.upper_bound(x); }
    const_iterator lower_bound (const key_type& x) const
    {
      return __t.lower_bound(x); 
    }
    const_iterator upper_bound (const key_type& x) const
    {
      return __t.upper_bound(x); 
    }

    pair<iterator,iterator> equal_range (const key_type& x)
#line 323 "/opt/aCC/include_std/map"
    {
      return __t.equal_range(x);
    }

    pair<const_iterator, const_iterator> equal_range (const key_type& x) const
#line 335 "/opt/aCC/include_std/map"
    {
      return __t.equal_range(x);
    }

  };


template <class _Key, class _TypeT,
          class _Compare = less<_Key>, 
          class _Allocator
    = allocator<pair<const _Key, _TypeT> > >
class multimap
{
public:

    typedef _Key                                          key_type;
    typedef _TypeT                                        mapped_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef _Compare                                      key_compare;
    typedef _Allocator                                    allocator_type;

  private:
    
    typedef __rw::__rb_tree<key_type, value_type, 
    __rw::__select1st<value_type, key_type>, 
    key_compare, allocator_type> __rep_type;
    __rep_type __t;

  public:
    
    
    
    typedef typename __rep_type::reference                reference;
    typedef typename __rep_type::const_reference          const_reference;
    typedef typename __rep_type::iterator                 iterator;
    typedef typename __rep_type::const_iterator           const_iterator; 
    typedef typename __rep_type::size_type                size_type;
    typedef typename __rep_type::difference_type          difference_type;
    typedef typename __rep_type::pointer                  pointer;
    typedef typename __rep_type::const_pointer            const_pointer; 
    typedef typename __rep_type::reverse_iterator         reverse_iterator;
    typedef typename __rep_type::const_reverse_iterator   const_reverse_iterator;

    class value_compare : public binary_function<value_type, value_type, bool>
    {
      friend class multimap<_Key, _TypeT, _Compare, _Allocator>;
    protected:
      _Compare comp;
      value_compare (_Compare c) : comp(c) {}
    public:
      bool operator() (const value_type& x, const value_type& y) const
      {
        return comp(x.first, y.first);
      }
    };

    
    
    
    explicit multimap (const _Compare& comp = _Compare(),
                        const _Allocator& alloc = _Allocator()) 
      : __t(comp, true, alloc) { }

#line 406 "/opt/aCC/include_std/map"




    template<class InputIterator>
    multimap (InputIterator first, InputIterator last, 
              const _Compare& comp = _Compare(),
              const _Allocator& alloc = _Allocator()) 
      : __t(first, last, comp, true, alloc) { }

#line 443 "/opt/aCC/include_std/map"


    multimap (const multimap<_Key, _TypeT, _Compare, _Allocator>& x) : __t(x.__t, true) { }
    multimap<_Key, _TypeT, _Compare, _Allocator>& 
    operator= (const multimap<_Key, _TypeT, _Compare, _Allocator>& x)
    {
      __t = x.__t; return *this; 
    }
    allocator_type get_allocator() const
    {
      return __t.get_allocator();
    }

    
    
    
    iterator                 begin  ()       { return __t.begin();  }
    const_iterator           begin  () const { return __t.begin();  }
    iterator                 end    ()       { return __t.end();    }
    const_iterator           end    () const { return __t.end();    }
    reverse_iterator         rbegin ()       { return __t.rbegin(); }
    const_reverse_iterator   rbegin () const { return __t.rbegin(); }
    reverse_iterator         rend   ()       { return __t.rend();   }
    const_reverse_iterator   rend   () const { return __t.rend();   }

    
    
    
    bool        empty   () const { return __t.empty();    }
    size_type   size    () const { return __t.size();     }
    size_type   max_size() const { return __t.max_size(); }

    
    
    
    iterator insert (const value_type& x) { return __t.insert(x).first; }
    iterator insert (iterator position, const value_type& x)
    {
      return __t.insert(position, x);
    }



    template<class InputIterator>
    void insert (InputIterator first, InputIterator last)
    {
      __t.insert(first, last);
    }

#line 505 "/opt/aCC/include_std/map"


    void  erase (iterator position)             { __t.erase(position); }
    size_type erase (const key_type& x)         { return __t.erase(x);    }
    void  erase (iterator first, iterator last) { __t.erase(first, last); }
    void      clear ()                          { erase(begin(),end()); }
    void      swap  (multimap<_Key, _TypeT, _Compare, _Allocator>& x)  
    { __t.swap(x.__t);          }

    
    
    
    key_compare   key_comp   () const { return __t.key_comp();                }
    value_compare value_comp () const { return value_compare(__t.key_comp()); }

    
    
    
    iterator    find (const key_type& x)        { return __t.find(x); }
    const_iterator  find (const key_type& x)  const { return __t.find(x); }
    size_type   count (const key_type& x) const { return __t.count(x); }
    iterator    lower_bound (const key_type& x) {return __t.lower_bound(x);}
    iterator    upper_bound (const key_type& x) {return __t.upper_bound(x);}
    const_iterator  lower_bound (const key_type& x) const
    {
      return __t.lower_bound(x); 
    }
    const_iterator  upper_bound (const key_type& x) const
    {
      return __t.upper_bound(x); 
    }

    pair<iterator,iterator> equal_range (const key_type& x)
#line 545 "/opt/aCC/include_std/map"
    {
      return __t.equal_range(x);
    }

    pair<const_iterator,const_iterator> equal_range (const key_type& x) const
#line 557 "/opt/aCC/include_std/map"
    {
      return __t.equal_range(x);
    }

  };

  template <class _Key, class _TypeT, class _Compare, class _Allocator>
  inline bool operator== (const map<_Key, _TypeT, _Compare, _Allocator>& x,
                          const map<_Key, _TypeT, _Compare, _Allocator>& y)
  {
    return x.size() == y.size() && equal(x.begin(), x.end(), y.begin());
  }

  template <class _Key, class _TypeT, class _Compare, class _Allocator>
  inline bool operator< (const map<_Key, _TypeT, _Compare, _Allocator>& x, 
                         const map<_Key, _TypeT, _Compare, _Allocator>& y)
  {
    return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
  }

  template <class _Key, class _TypeT, class _Compare, class _Allocator>
  inline bool operator!= (const map<_Key,_TypeT,_Compare,_Allocator>& x, 
                          const map<_Key,_TypeT,_Compare,_Allocator>& y)
  {
    return !(x == y);
  }

  template <class _Key, class _TypeT, class _Compare, class _Allocator>
  inline bool operator> (const map<_Key,_TypeT,_Compare,_Allocator>& x, 
                         const map<_Key,_TypeT,_Compare,_Allocator>& y)
  {
    return y < x;
  }

  template <class _Key, class _TypeT, class _Compare, class _Allocator>
  inline bool operator>= (const map<_Key,_TypeT,_Compare,_Allocator>& x, 
                          const map<_Key,_TypeT,_Compare,_Allocator>& y)
  {
    return !(x < y);
  }

  template <class _Key, class _TypeT, class _Compare, class _Allocator>
  inline bool operator<= (const map<_Key,_TypeT,_Compare,_Allocator>& x, 
                          const map<_Key,_TypeT,_Compare,_Allocator>& y)
  {
    return !(y <  x);
  }


  template <class _Key, class _TypeT, class _Compare, class _Allocator>
  void swap(map<_Key,_TypeT,_Compare,_Allocator>& a, 
            map<_Key,_TypeT,_Compare,_Allocator>& b)
  {
    a.swap(b);
  }


  template <class _Key, class _TypeT, class _Compare, class _Allocator>
  inline bool operator== (const multimap<_Key, _TypeT, _Compare, _Allocator>& x, 
                          const multimap<_Key, _TypeT, _Compare, _Allocator>& y)
  {
    return x.size() == y.size() && equal(x.begin(), x.end(), y.begin());
  }

  template <class _Key, class _TypeT, class _Compare, class _Allocator>
  inline bool operator< (const multimap<_Key, _TypeT, _Compare, _Allocator>& x, 
                         const multimap<_Key, _TypeT, _Compare, _Allocator>& y)
  {
    return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
  }

  template <class _Key, class _TypeT, class _Compare, class _Allocator>
  inline bool operator!= (const multimap<_Key,_TypeT,_Compare,_Allocator>& x, 
                          const multimap<_Key,_TypeT,_Compare,_Allocator>& y)
  {
    return !(x == y);
  }

  template <class _Key, class _TypeT, class _Compare, class _Allocator>
  inline bool operator> (const multimap<_Key,_TypeT,_Compare,_Allocator>& x, 
                         const multimap<_Key,_TypeT,_Compare,_Allocator>& y)
  {
    return y < x;
  }

  template <class _Key, class _TypeT, class _Compare, class _Allocator>
  inline bool operator>= (const multimap<_Key,_TypeT,_Compare,_Allocator>& x, 
                          const multimap<_Key,_TypeT,_Compare,_Allocator>& y)
  {
    return !(x < y);
  }

  template <class _Key, class _TypeT, class _Compare, class _Allocator>
  inline bool operator<= (const multimap<_Key,_TypeT,_Compare,_Allocator>& x, 
                          const multimap<_Key,_TypeT,_Compare,_Allocator>& y)
  {
    return !(y <  x);
  }


  template <class _Key, class _TypeT, class _Compare, class _Allocator>
  void swap(multimap<_Key,_TypeT,_Compare,_Allocator>& a, 
            multimap<_Key,_TypeT,_Compare,_Allocator>& b)
  {
    a.swap(b);
  }



}   


#line 7 "/hss/opt/opthss/src/bill/src/app_guard/mntapi.h"

#line 1 "/hss/opt/opthss/src/bill/src/public/IpcKey.h"
  



#line 1 "/hss/opt/opthss/src/bill/src/liboci/TOCIQuery.h"
  



#line 1 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"
 
 










































































































































































































































































































































































































































































 


extern "C" {


#line 1 "/oracle/app/oracle/product/10.2/plsql/public/oratypes.h"



 
 





#line 1 "/opt/aCC/include_std/stddef.h"





#line 15 "/opt/aCC/include_std/stddef.h"

#line 13 "/oracle/app/oracle/product/10.2/plsql/public/oratypes.h"



#line 1 "/opt/aCC/include_std/limits.h"









#line 18 "/oracle/app/oracle/product/10.2/plsql/public/oratypes.h"








 


  typedef unsigned char ub1;
  typedef   signed char sb1;
  typedef          char eb1;

























 


  typedef sb1 b1;







 


  typedef unsigned short ub2;
  typedef   signed short sb2;
  typedef          short eb2;






















 


  typedef sb2 b2;







 


  typedef unsigned int ub4;
  typedef   signed int sb4;
  typedef          int eb4;






















 



  typedef unsigned long oraub8;
  typedef   signed long orasb8;





typedef oraub8 ub8;
typedef orasb8 sb8;

#line 159 "/oracle/app/oracle/product/10.2/plsql/public/oratypes.h"

#line 170 "/oracle/app/oracle/product/10.2/plsql/public/oratypes.h"

 


  typedef sb4 b4;







 




  typedef unsigned char oratext;












   typedef oratext text;
   typedef oratext OraText;









  typedef unsigned short utext;




 



   typedef int boolean;





 


  typedef          int eword;
  typedef unsigned int uword;
  typedef   signed int sword;

























  typedef unsigned long  ubig_ora;             
  typedef   signed long  sbig_ora;             



















 




 



typedef void (*lgenfp_t)( void );














#line 469 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"

 
#line 1 "/oracle/app/oracle/product/10.2/rdbms/public/ocidfn.h"


 

 
 
























































 








 
 






 

struct cda_head {
    sb2          v2_rc;
    ub2          ft;
    ub4          rpc;
    ub2          peo;
    ub1          fc;
    ub1          rcs1;
    ub2          rc;
    ub1          wrn;
    ub1          rcs2;
    sword        rcs3;
    struct {
        struct {
           ub4    rcs4;
           ub2    rcs5;
           ub1    rcs6;
        } rd;
        ub4    rcs7;
        ub2    rcs8;
    } rid;
    sword        ose;
    ub1           chk;
    void        *rcsp;
};





 













 
struct cda_def {
    sb2          v2_rc;                                     
    ub2          ft;                                     
    ub4          rpc;                                 
    ub2          peo;                                   
    ub1          fc;                                     
    ub1          rcs1;                                         
    ub2          rc;                                        
    ub1          wrn;                                        
    ub1          rcs2;                                            
    sword        rcs3;                                            
    struct {                                               
        struct {
           ub4    rcs4;
           ub2    rcs5;
           ub1    rcs6;
        } rd;
        ub4    rcs7;
        ub2    rcs8;
    } rid;
    sword        ose;                                  
    ub1           chk;
    void        *rcsp;                           
    ub1          rcs9[64 - sizeof (struct cda_head)];         
};

typedef struct cda_def Cda_Def;


 
typedef struct cda_def Lda_Def;

 



 






 




 








 
#line 213 "/oracle/app/oracle/product/10.2/rdbms/public/ocidfn.h"

#line 224 "/oracle/app/oracle/product/10.2/rdbms/public/ocidfn.h"

 
#line 234 "/oracle/app/oracle/product/10.2/rdbms/public/ocidfn.h"




 



 
 






#line 473 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"





 


 

#line 772 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"



 

 
                                            
#line 810 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"



 


 
                                     
#line 825 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"
                                       
#line 851 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"

 

 


 

 



 

 







 
 


#line 892 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"
                     


                                           


                                           
#line 919 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"
                                  



                                          

                                  

                















#line 952 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"
                                                    
#line 959 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"








               







 


                                  

 











#line 998 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"










#line 1044 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"

 






 




  



 

#line 1071 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"








 



 

#line 1093 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"

 


 
#line 1106 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"

 









 

 





 



 






 


 





 






 







 





 





 




 





 











 


 


 

 




 


 

 


 
#line 1224 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"

 
#line 1234 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"

 



 



 


 


 






 




 
#line 1268 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"

  



 

 

 



 

 






 





 

 
#line 1307 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"
 

 


 

 

 
#line 1330 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"
                                  





 
#line 1347 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"
                                             


                                             


                                            


 



                      
 




 
#line 1379 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"

 

 
#line 1393 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"
 

 

                           
 
#line 1405 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"
 


                                          

 

 




                              


        
#line 1427 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"


 
 



 
 






 
 





 
 

#line 1458 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"
 
 
 




 
 




 
 




 
 
 





 

 








 


 





 

 




 

 

 


 
#line 1529 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"
          
#line 1536 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"

 

 
#line 1554 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"

 

 


 

 



 

#line 1575 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"



 




 


 


 

 


 

 
 








                                         











 

 





 





 
 



 






 





 


 





 



 



 



 


 






 





 

 

 
 
 
#line 1702 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"
 

 



 
 
 
#line 1719 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"
   



                     
 





 





 
#line 1743 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"

 
#line 1763 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"

 


 
#line 1783 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"



 
#line 1794 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"

 




 


 
#line 1815 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"

 






 


 












 


 


 
 





 

 

 
#line 1865 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"
 
 
 
#line 1874 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"

 
 




 


 


 

 


 

 


 



 
#line 1915 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"

 




 


 






 
#line 1939 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"


 














 



 
 

#line 1973 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"





 
#line 1986 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"








 



 







 
 
 
 
 
 

 











             


     




             


     






 












 




 
#line 2071 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"

 
#line 2083 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"

 









 



 


 

 

 

 
 


 

 



 



 



 



 



 



 




 

 



 





 

 





 

 

 

 




 

 
#line 2184 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"
  




                                                       


                                                                 


                                                              





                                                             




                                                                 



                                              
                                          
#line 2219 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"
                                                                 





 

#line 2233 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"
                                                                 
#line 2244 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"

#line 2255 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"

#line 2265 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"













                            








#line 2307 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"



 


 

 
typedef struct OCIEnv           OCIEnv;             
typedef struct OCIError         OCIError;                 
typedef struct OCISvcCtx        OCISvcCtx;              
typedef struct OCIStmt          OCIStmt;              
typedef struct OCIBind          OCIBind;                   
typedef struct OCIDefine        OCIDefine;               
typedef struct OCIDescribe      OCIDescribe;           
typedef struct OCIServer        OCIServer;               
typedef struct OCISession       OCISession;      
typedef struct OCIComplexObject OCIComplexObject;           
typedef struct OCITrans         OCITrans;           
typedef struct OCISecurity      OCISecurity;           
typedef struct OCISubscription  OCISubscription;       

typedef struct OCICPool         OCICPool;           
typedef struct OCISPool         OCISPool;              
typedef struct OCIAuthInfo      OCIAuthInfo;                   
typedef struct OCIAdmin         OCIAdmin;                     
typedef struct OCIEvent         OCIEvent;                  

 
typedef struct OCISnapshot      OCISnapshot;       
typedef struct OCIResult        OCIResult;       
typedef struct OCILobLocator    OCILobLocator;  
typedef struct OCIParam         OCIParam;         
typedef struct OCIComplexObjectComp OCIComplexObjectComp;
                                                        
typedef struct OCIRowid OCIRowid;                     

typedef struct OCIDateTime OCIDateTime;            
typedef struct OCIInterval OCIInterval;            

typedef struct OCIUcb           OCIUcb;       
typedef struct OCIServerDNs     OCIServerDNs;     

 
typedef struct OCIAQEnqOptions    OCIAQEnqOptions;  
typedef struct OCIAQDeqOptions    OCIAQDeqOptions;  
typedef struct OCIAQMsgProperties OCIAQMsgProperties;   
typedef struct OCIAQAgent         OCIAQAgent;          
typedef struct OCIAQNfyDescriptor OCIAQNfyDescriptor;    
typedef struct OCIAQSignature     OCIAQSignature;             
typedef struct OCIAQListenOpts    OCIAQListenOpts;       
typedef struct OCIAQLisMsgProps   OCIAQLisMsgProps;    

 
 
 
typedef struct OCILobLocator OCIClobLocator;     
typedef struct OCILobLocator OCIBlobLocator;        
typedef struct OCILobLocator OCIBFileLocator;  
 

 


   




 








 
typedef ub4 OCILobOffset;








 
typedef ub4 OCILobLength;










 
enum OCILobMode
{
  OCI_LOBMODE_READONLY = 1,                                      
  OCI_LOBMODE_READWRITE = 2              
};
typedef enum OCILobMode OCILobMode;

 


 

 




 

#line 2435 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"
 

 

 
 



 


 

 

#line 2460 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"
 

 
#line 2488 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"

 

 
#line 2507 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"

 

 


 
typedef struct OCIPicklerTdsCtx OCIPicklerTdsCtx;
typedef struct OCIPicklerTds OCIPicklerTds;
typedef struct OCIPicklerImage OCIPicklerImage;
typedef struct OCIPicklerFdo OCIPicklerFdo;
typedef ub4 OCIPicklerTdsElement;

typedef struct OCIAnyData OCIAnyData;

typedef struct OCIAnyDataSet OCIAnyDataSet;
typedef struct OCIAnyDataCtx OCIAnyDataCtx;

 

 




 

 
#line 2609 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"










#line 2626 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"
                                      

                                      

typedef struct OCIMsg  OCIMsg;
typedef ub4            OCIWchar;





 



 



 






 





 
 
 



 

 
 


 

 

 



 

#line 1 "/oracle/app/oracle/product/10.2/rdbms/public/oci1.h"


 

  
 


 
 










































 












 

 

#line 89 "/oracle/app/oracle/product/10.2/rdbms/public/oci1.h"




 

 
 



 
#line 107 "/oracle/app/oracle/product/10.2/rdbms/public/oci1.h"

 







 






 
typedef struct OCIFileObject OCIFileObject;


 

 
typedef struct OCIThreadContext OCIThreadContext;

 
typedef struct OCIThreadMutex   OCIThreadMutex; 

 
typedef struct OCIThreadKey     OCIThreadKey;  

 
typedef struct OCIThreadId      OCIThreadId;  

 
typedef struct OCIThreadHandle  OCIThreadHandle;  


 

 
typedef void (*OCIThreadKeyDestFunc)( );


 
#line 160 "/oracle/app/oracle/product/10.2/rdbms/public/oci1.h"

 








 




 




 


#line 2682 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"


#line 1 "/oracle/app/oracle/product/10.2/rdbms/public/oro.h"
 












































































































































































 













 
 
 

#line 266 "/oracle/app/oracle/product/10.2/rdbms/public/oro.h"


 
 
 

 
 
 

 

typedef struct OCIRef OCIRef;







 


 

typedef sb2 OCIInd;


 






 
 
 

 





 





 


 

enum OCIPinOpt
{
   
  OCI_PIN_DEFAULT = 1,                                  
  OCI_PIN_ANY = 3,                           
  OCI_PIN_RECENT = 4,                     
  OCI_PIN_LATEST = 5                      
};
typedef enum OCIPinOpt OCIPinOpt;































 



 

enum OCILockOpt
{
   
  OCI_LOCK_NONE = 1,                                
  OCI_LOCK_X = 2,                                           
  OCI_LOCK_X_NOWAIT = 3                       
};
typedef enum OCILockOpt OCILockOpt;





 


 

enum OCIMarkOpt
{
   
  OCI_MARK_DEFAULT = 1,         
  OCI_MARK_NONE = OCI_MARK_DEFAULT,    
  OCI_MARK_UPDATE                                
};
typedef enum OCIMarkOpt OCIMarkOpt;





 

 
 
typedef ub2 OCIDuration;



                                            

                                                             



                                                     

                                                   

                                               



 

                                        




 



                                              





  

 




















 

 
 



 
enum OCIObjectProperty
{
   
  OCI_OBJECTPROP_DIRTIED = 1,                                
  OCI_OBJECTPROP_LOADED,                 
  OCI_OBJECTPROP_LOCKED                                     
};
typedef enum OCIObjectProperty OCIObjectProperty;



 

 

enum OCIRefreshOpt
{
   
  OCI_REFRESH_LOADED = 1         
};
typedef enum OCIRefreshOpt OCIRefreshOpt; 






 

 




 
enum OCIObjectEvent
{
    
   OCI_OBJECTEVENT_BEFORE_FLUSH = 1,             
   OCI_OBJECTEVENT_AFTER_FLUSH,                   
   OCI_OBJECTEVENT_BEFORE_REFRESH,             
   OCI_OBJECTEVENT_AFTER_REFRESH,               
   OCI_OBJECTEVENT_WHEN_MARK_UPDATED,     
   OCI_OBJECTEVENT_WHEN_MARK_DELETED,     
   OCI_OBJECTEVENT_WHEN_UNMARK,           
   OCI_OBJECTEVENT_WHEN_LOCK                
};
typedef enum OCIObjectEvent OCIObjectEvent;





 

 






 

 










 

 

typedef ub1 OCIObjectPropId;
#line 557 "/oracle/app/oracle/product/10.2/rdbms/public/oro.h"




 

 

enum OCIObjectLifetime
{
    
   OCI_OBJECT_PERSISTENT = 1,                           
   OCI_OBJECT_TRANSIENT,                                 
   OCI_OBJECT_VALUE                                          
};
typedef enum OCIObjectLifetime OCIObjectLifetime;




 

 

typedef uword OCIObjectMarkStatus;






 

  






 
 
 

 












 

#line 628 "/oracle/app/oracle/product/10.2/rdbms/public/oro.h"
                                        

                                        
#line 639 "/oracle/app/oracle/product/10.2/rdbms/public/oro.h"
                                      


                                        
#line 649 "/oracle/app/oracle/product/10.2/rdbms/public/oro.h"
                                             





 


















 






 





 


 



 
typedef ub2 OCITypeCode;


 

enum OCITypeGetOpt
{
  OCI_TYPEGET_HEADER,
                 
  OCI_TYPEGET_ALL        
};
typedef enum OCITypeGetOpt OCITypeGetOpt;
















 


 

enum OCITypeEncap
{
   
  OCI_TYPEENCAP_PRIVATE,                 
  OCI_TYPEENCAP_PUBLIC  
};
typedef enum OCITypeEncap OCITypeEncap;


 


 

enum OCITypeMethodFlag
{
  OCI_TYPEMETHOD_INLINE = 0x0001,                                   
  OCI_TYPEMETHOD_CONSTANT = 0x0002,                               
  OCI_TYPEMETHOD_VIRTUAL = 0x0004,                                 
  OCI_TYPEMETHOD_CONSTRUCTOR = 0x0008,                         
  OCI_TYPEMETHOD_DESTRUCTOR = 0x0010,                           
  OCI_TYPEMETHOD_OPERATOR  = 0x0020,                              
  OCI_TYPEMETHOD_SELFISH = 0x0040,      

  OCI_TYPEMETHOD_MAP = 0x0080,                     
  OCI_TYPEMETHOD_ORDER  = 0x0100,                
   

  OCI_TYPEMETHOD_RNDS= 0x0200,                
  OCI_TYPEMETHOD_WNDS= 0x0400,                         
  OCI_TYPEMETHOD_RNPS= 0x0800,                       
  OCI_TYPEMETHOD_WNPS= 0x1000,                      
  OCI_TYPEMETHOD_ABSTRACT = 0x2000,     
  OCI_TYPEMETHOD_OVERRIDING = 0x4000,                    
  OCI_TYPEMETHOD_PIPELINED = 0x8000                    
};
typedef enum OCITypeMethodFlag OCITypeMethodFlag;

 
#line 783 "/oracle/app/oracle/product/10.2/rdbms/public/oro.h"

#line 803 "/oracle/app/oracle/product/10.2/rdbms/public/oro.h"

 
#line 820 "/oracle/app/oracle/product/10.2/rdbms/public/oro.h"

 
#line 839 "/oracle/app/oracle/product/10.2/rdbms/public/oro.h"

 

enum OCITypeParamMode
{
   
  OCI_TYPEPARAM_IN = 0,                                                 
  OCI_TYPEPARAM_OUT,                                                   
  OCI_TYPEPARAM_INOUT,                                              
  OCI_TYPEPARAM_BYREF,               
  OCI_TYPEPARAM_OUTNCPY,                          
  OCI_TYPEPARAM_INOUTNCPY                      
};
typedef enum OCITypeParamMode OCITypeParamMode;


 

 



                                         

 


                           


 


 
 


 







#line 2686 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"


#line 1 "/oracle/app/oracle/product/10.2/rdbms/public/ori.h"
 








































































































































































































































































































































































































































































































 


#line 1 "/oracle/app/oracle/product/10.2/rdbms/public/ort.h"
 

 





















































































































































































































































































































































































































































































































































































































 

#line 612 "/oracle/app/oracle/product/10.2/rdbms/public/ort.h"




 
 
 

#line 675 "/oracle/app/oracle/product/10.2/rdbms/public/ort.h"


         
 
 

 










 

typedef struct OCIType OCIType;

 















 

typedef struct OCITypeElem OCITypeElem;


 











 

typedef struct OCITypeMethod OCITypeMethod;


 









 

typedef struct OCITypeIter OCITypeIter;


 
 
 

 
 
 

 

 
sword OCITypeIterNew(    OCIEnv *env, OCIError *err, OCIType *tdo, 
                         OCITypeIter **iterator_ort    );





















 

 

 
sword OCITypeIterSet(    OCIEnv *env, OCIError *err, OCIType *tdo, 
                  OCITypeIter *iterator_ort    );




















 

 

 
sword OCITypeIterFree(    OCIEnv *env, OCIError *err, OCITypeIter
                          *iterator_ort    );


















 


 
 
 

 
sword OCITypeByName(    OCIEnv *env, OCIError *err, const OCISvcCtx *svc, 
                        const oratext *schema_name, ub4 s_length,
                        const oratext *type_name, ub4 t_length,
                        const oratext *version_name, ub4 v_length,
                        OCIDuration pin_duration, OCITypeGetOpt get_option,
                        OCIType **tdo    );








































 

sword OCITypeArrayByName(    OCIEnv *env, OCIError *err, const OCISvcCtx *svc,
                             ub4 array_len,
                             const oratext *schema_name[], ub4 s_length[],
                             const oratext *type_name[], ub4 t_length[],
                             const oratext *version_name[], ub4 v_length[],
                             OCIDuration pin_duration,
                             OCITypeGetOpt get_option, OCIType **tdo    );





























































 

sword   OCITypeByRef(    OCIEnv *env, OCIError *err,
                         const OCIRef *type_ref, OCIDuration pin_duration,
                         OCITypeGetOpt get_option, OCIType **tdo    );
































 

sword   OCITypeArrayByRef(    OCIEnv *env, OCIError *err,
                              ub4 array_len, const OCIRef **type_ref,
                              OCIDuration pin_duration,
                              OCITypeGetOpt get_option, OCIType **tdo    );





































 


 
 
 

 

 
oratext* OCITypeName(    OCIEnv *env, OCIError *err, const OCIType *tdo, 
                      ub4 *n_length    );
























 

 

 
oratext* OCITypeSchema(    OCIEnv *env, OCIError *err, const OCIType *tdo, 
                   ub4 *n_length    );
























 

 

 
OCITypeCode OCITypeTypeCode(    OCIEnv *env, OCIError *err,
                                const OCIType *tdo    );




















 

 

 
OCITypeCode OCITypeCollTypeCode(    OCIEnv *env, OCIError *err,
                                    const OCIType *tdo    );























 

 

 
oratext* OCITypeVersion(    OCIEnv *env, OCIError *err, const OCIType *tdo, 
                         ub4 *v_length    );
























 

 

 
ub4 OCITypeAttrs(    OCIEnv *env, OCIError *err, const OCIType *tdo    );




















 

 

 
ub4 OCITypeMethods(    OCIEnv *env, OCIError *err, const OCIType *tdo    );




















 


 
 
 

 

 
oratext* OCITypeElemName(    OCIEnv *env, OCIError *err, 
                           const OCITypeElem *elem, ub4 *n_length    );
























 

 

 
OCITypeCode OCITypeElemTypeCode(    OCIEnv *env, OCIError *err,
                                    const OCITypeElem *elem    );




























 

 

 
sword OCITypeElemType(    OCIEnv *env, OCIError *err, const OCITypeElem *elem, 
                          OCIType **elem_tdo    );





























 

 

 
ub4 OCITypeElemFlags(    OCIEnv *env, OCIError *err,
                         const OCITypeElem *elem    );
























 

 

 
ub1 OCITypeElemNumPrec(    OCIEnv *env, OCIError *err,
                           const OCITypeElem *elem    );


















 

 

 
sb1 OCITypeElemNumScale(    OCIEnv *env, OCIError *err,
                            const OCITypeElem *elem    );















 

 

 
ub4 OCITypeElemLength(    OCIEnv *env, OCIError *err,
                          const OCITypeElem *elem    );
















 

 

 
ub2 OCITypeElemCharSetID(    OCIEnv *env, OCIError *err,
                             const OCITypeElem *elem    );
















 

 

 
ub2 OCITypeElemCharSetForm(    OCIEnv *env, OCIError *err,
                               const OCITypeElem *elem    );






















 

 

 
sword OCITypeElemParameterizedType(    OCIEnv *env, OCIError *err,
                                       const OCITypeElem *elem, 
                                       OCIType **type_stored    );





































 

 
 
 
OCITypeCode OCITypeElemExtTypeCode(    OCIEnv *env, OCIError *err,
                                       const OCITypeElem *elem    );






















 

 
 
 

 

 
sword OCITypeAttrByName(    OCIEnv *env, OCIError *err, const OCIType *tdo, 
                            const oratext *name, ub4 n_length,
                            OCITypeElem **elem    );

































 

 

 
sword OCITypeAttrNext(    OCIEnv *env, OCIError *err, 
                        OCITypeIter *iterator_ort, OCITypeElem **elem    );































 

 
 
 

 

 
sword OCITypeCollElem(    OCIEnv *env, OCIError *err, const OCIType *tdo,
                          OCITypeElem **element    );






































 

 

 
sword OCITypeCollSize(    OCIEnv *env, OCIError *err, const OCIType *tdo, 
                          ub4 *num_elems    );




























 

 
 
 
sword OCITypeCollExtTypeCode(    OCIEnv *env, OCIError *err,
                               const OCIType *tdo, OCITypeCode *sqt_code    );



























 
 

 
 
 

 

 
ub4 OCITypeMethodOverload(    OCIEnv *env, OCIError *err, const OCIType *tdo, 
                              const oratext *method_name, ub4 m_length    );


























 

 

 
sword OCITypeMethodByName(    OCIEnv *env, OCIError *err, const OCIType *tdo, 
                              const oratext *method_name, ub4 m_length,
                              OCITypeMethod **mdos    );




































 

 

 
sword OCITypeMethodNext(    OCIEnv *env, OCIError *err, 
                            OCITypeIter *iterator_ort,
                            OCITypeMethod **mdo   );


































 

 

 
oratext *OCITypeMethodName(    OCIEnv *env, OCIError *err,
                            const OCITypeMethod *mdo, ub4 *n_length    );






















 

 

 
OCITypeEncap OCITypeMethodEncap(    OCIEnv *env, OCIError *err,
                                    const OCITypeMethod *mdo    );




















 

 

 
OCITypeMethodFlag OCITypeMethodFlags(    OCIEnv *env, OCIError *err,
                                         const OCITypeMethod *mdo    );
























 

 

 
sword OCITypeMethodMap(    OCIEnv *env, OCIError *err, const OCIType *tdo, 
                           OCITypeMethod **mdo    );






























 

 

 
sword OCITypeMethodOrder(    OCIEnv *env, OCIError *err, const OCIType *tdo, 
                             OCITypeMethod **mdo    );






























 

 

 
ub4 OCITypeMethodParams(    OCIEnv *env, OCIError *err,
                            const OCITypeMethod *mdo    );




















 


 
 
 

 

 
sword OCITypeResult(    OCIEnv *env, OCIError *err, const OCITypeMethod *mdo,
                        OCITypeElem **elem    );


























 


 
 
 

 

 
sword OCITypeParamByPos(    OCIEnv *env, OCIError *err,
                            const OCITypeMethod *mdo, ub4 position, 
                            OCITypeElem **elem    );




























 

 

 
sword OCITypeParamByName(    OCIEnv *env, OCIError *err,
                             const OCITypeMethod *mdo, 
                             const oratext *name, ub4 n_length,
                             OCITypeElem **elem    );





























 

 

 
sword OCITypeParamPos(    OCIEnv *env, OCIError *err,
                          const OCITypeMethod *mdo, 
                          const oratext *name, ub4 n_length, ub4 *position, 
                          OCITypeElem **elem    );

































 

 

 
OCITypeParamMode OCITypeElemParamMode(    OCIEnv *env, OCIError *err,
                                          const OCITypeElem *elem    );





















 

 

 
oratext* OCITypeElemDefaultValue(    OCIEnv *env, OCIError *err,
                                  const OCITypeElem *elem,
                                  ub4 *d_v_length    );

























 
 

 
 
 



 


 
 
 
sword OCITypeVTInit(    OCIEnv *env, OCIError *err    );

















 
 
 
 
 
sword OCITypeVTInsert(    OCIEnv *env, OCIError *err, 
                          const oratext *schema_name, ub4 s_n_length, 
                          const oratext *type_name, ub4 t_n_length, 
                          const oratext *user_version, ub4 u_v_length    );





























 

 

 
 
sword OCITypeVTSelect(    OCIEnv *env, OCIError *err, 
                          const oratext *schema_name, ub4 s_n_length, 
                          const oratext *type_name, ub4 t_n_length, 
                          oratext **user_version, ub4 *u_v_length,
                        ub2 *version );




























 


 
sword ortgcty(    OCIEnv *env, OCIError *err, OCIType *coll_tdo,
                  OCIType **collelem_tdo    );

 
 
 

sword OCITypeBeginCreate(OCISvcCtx *svchp, OCIError *errhp, OCITypeCode tc,
                         OCIDuration dur, OCIType **type);







































 


sword OCITypeSetCollection(OCISvcCtx *svchp, OCIError *errhp, OCIType *type,
                           OCIParam *collelem_info, ub4 coll_count);






















 

sword OCITypeSetBuiltin(OCISvcCtx *svchp, OCIError *errhp, OCIType *type,
                        OCIParam *builtin_info);






















 

sword OCITypeAddAttr(OCISvcCtx *svchp, OCIError *errhp, OCIType *type,
                     const oratext *a_name, ub4 a_length, 
                     OCIParam *attr_info);





















 

sword OCITypeEndCreate(OCISvcCtx *svchp, OCIError *errhp, OCIType *type);















 

 
 
 

 
 
 




 








#line 504 "/oracle/app/oracle/product/10.2/rdbms/public/ori.h"





 
 
 

#line 564 "/oracle/app/oracle/product/10.2/rdbms/public/ori.h"

 
 
 

 

 
 
 
 
 
 

 
sword OCIObjectNew(    OCIEnv *env, OCIError *err, const OCISvcCtx *svc,
                       OCITypeCode typecode, OCIType *tdo, void *table, 
                       OCIDuration duration, boolean value, 
                       void **instance    );

















































































 

 
sword OCIObjectPin(    OCIEnv *env, OCIError *err, OCIRef *object_ref, 
                       OCIComplexObject *corhdl, OCIPinOpt pin_option, 
                       OCIDuration pin_duration, 
                       OCILockOpt lock_option, void **object    );






















































































 

 
sword OCIObjectUnpin(    OCIEnv *env, OCIError *err, void *object    );











































 

 
sword OCIObjectPinCountReset(    OCIEnv *env, OCIError *err, void *object   );




































 

 
sword OCIObjectLock(    OCIEnv *env, OCIError *err, void *object    );



























 

 
sword OCIObjectLockNoWait(    OCIEnv *env, OCIError *err, void *object    );





























 

 
sword OCIObjectMarkUpdate(    OCIEnv *env, OCIError *err, void *object    );




































 

 
sword OCIObjectUnmark(    OCIEnv *env, OCIError *err, void *object    );



























 

 
sword OCIObjectUnmarkByRef(    OCIEnv *env, OCIError *err, OCIRef *ref    );



























 

 
sword OCIObjectFree(    OCIEnv *env, OCIError *err, void *instance, 
                        ub2 flags   );



















































 

 
sword OCIObjectMarkDeleteByRef(    OCIEnv *env, OCIError *err, 
                                   OCIRef *object_ref);































 

 
sword OCIObjectMarkDelete(    OCIEnv *env, OCIError *err, void *instance    );






























 

 
sword OCIObjectFlush(    OCIEnv *env, OCIError *err, void *object    );




























 

 
sword OCIObjectRefresh(    OCIEnv *env, OCIError *err, void *object    );















































 

 
sword OCIObjectCopy(    OCIEnv *env, OCIError *err, const OCISvcCtx *svc, 
                        void *source, void *null_source,
                        void *target, void *null_target, OCIType *tdo, 
                        OCIDuration duration, ub1 option    );

















































 

 
sword OCIObjectGetTypeRef(    OCIEnv *env, OCIError *err, void *instance, 
                              OCIRef *type_ref    );























 

 
sword OCIObjectGetObjectRef(    OCIEnv *env, OCIError *err, void *object, 
                                OCIRef *object_ref    );
























 

 
sword OCIObjectMakeObjectRef(    OCIEnv *env, OCIError *err, 
                                 const OCISvcCtx *svc, void * table,
                                 void **values, ub4 array_len, 
                                 OCIRef *object_ref    );


































 

  
sword OCIObjectGetPrimaryKeyTypeRef( OCIEnv *env, OCIError *err,
                                     const OCISvcCtx *svc, void *table, 
                                     OCIRef *type_ref );

























 

 
sword OCIObjectGetInd(    OCIEnv *env, OCIError *err, void *instance, 
                          void **null_struct    );

























 

 
sword OCIObjectExists(OCIEnv *env, OCIError *err, void *ins, boolean *exist); 






















 

 
sword OCIObjectGetProperty(OCIEnv *envh, OCIError *errh, const void *obj, 
                           OCIObjectPropId propertyId,
                           void *property, ub4 *size );



























































































































 

 
sword OCIObjectIsLocked(    OCIEnv *env, OCIError *err, void *ins,
                              boolean *lock);






















 

 
sword OCIObjectIsDirty(    OCIEnv *env, OCIError *err, void *ins,
                           boolean *dirty);






















 

 
sword OCIObjectPinTable(    OCIEnv *env, OCIError *err, const OCISvcCtx *svc, 
                  const oratext *schema_name, 
                  ub4 s_n_length, const oratext *object_name, ub4 o_n_length, 
                  const OCIRef *scope_obj_ref, OCIDuration pin_duration, 
                  void** object    );




























 

 
sword OCIObjectArrayPin(OCIEnv *env, OCIError *err, OCIRef **ref_array, 
                  ub4 array_size, OCIComplexObject **cor_array,
                  ub4 cor_array_size, OCIPinOpt pin_option, 
                  OCIDuration pin_duration, OCILockOpt lock, 
                  void **obj_array, ub4 *pos    );





































 

 
 
 

 
sword OCICacheFlush(    OCIEnv *env, OCIError *err, const OCISvcCtx *svc, 
                  void *context, OCIRef *(*get)(void *context, ub1 *last),
                  OCIRef **ref  );






















































 

 
sword OCICacheRefresh(OCIEnv *env, OCIError *err, const OCISvcCtx *svc,
                  OCIRefreshOpt option, void *context,
                  OCIRef *(*get)(void *context), OCIRef **ref);


















































 

 
sword OCICacheUnpin(    OCIEnv *env, OCIError *err, const OCISvcCtx *svc    );
























 

 
sword OCICacheFree(    OCIEnv *env, OCIError *err, const OCISvcCtx *svc    ); 
























 

 
sword OCICacheUnmark(    OCIEnv *env, OCIError *err, const OCISvcCtx *svc    );























 


sword OCIDurationBegin(    OCIEnv *env, OCIError *err, const OCISvcCtx *svc, 
                           OCIDuration parent, OCIDuration *dur    );






























































 


sword OCIDurationEnd(    OCIEnv *env, OCIError *err, const OCISvcCtx *svc, 
                         OCIDuration duration    );











































 





 

sword OCIDurationGetParent(    OCIEnv *env, OCIError *err, 
                               OCIDuration duration, OCIDuration *parent    );

sword OCIObjectAlwaysLatest(    OCIEnv *env, OCIError *err, void *object    );

sword OCIObjectNotAlwaysLatest(    OCIEnv *env, OCIError *err, 
                                   void *object    );

sword OCIObjectFlushRefresh(    OCIEnv *env, OCIError *err, void *object);

sword OCIObjectIsLoaded(    OCIEnv *env, OCIError *err, void *ins, 
                              boolean *load);

sword OCIObjectIsDirtied(    OCIEnv *env, OCIError *err, void *ins,
                              boolean *dirty);

sword OCICacheGetObjects(       OCIEnv *env, OCIError *err,
                                const OCISvcCtx *svc,
                                OCIObjectProperty property,
                                void *client_context,
                                void (*client_callback)(
                                    void *client_context,
                                    void *object  ));

sword OCICacheRegister(      OCIEnv *env, OCIError *err,
                             OCIObjectEvent event,
                             void *client_context,
                             void (*client_callback)(
                                    void *client_context,
                                    OCIObjectEvent event,
                                    void *object));

sword OCICacheFlushRefresh(    OCIEnv *env, OCIError *err, 
                               const OCISvcCtx *svc, void *context,
                               OCIRef *(*get)(void *context, ub1 *last),
                               OCIRef **ref    );

sword OCIObjectSetData(OCIEnv *env, OCIError *err, void *obj_hdr, 
        void *data);

sword OCIObjectGetNewOID(OCIEnv *env, OCIError *err, OCISvcCtx *svc, 
        ub1 *oid);


#line 2690 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"


#line 1 "/oracle/app/oracle/product/10.2/rdbms/public/orl.h"
 


































































































































































































































































































































 




















 
 
 

#line 473 "/oracle/app/oracle/product/10.2/rdbms/public/orl.h"

 
 
 


struct OCINumber
{
  ub1 OCINumberPart[22];
};
typedef struct OCINumber OCINumber;










 






































































































 

 

sword OCINumberInc(    OCIError *err, OCINumber *number    );


















 

 

sword OCINumberDec(    OCIError *err, OCINumber *number    );


















 

 

void OCINumberSetZero(    OCIError *err, OCINumber *num    );







 

 

void OCINumberSetPi(    OCIError *err, OCINumber *num    );






 

 

sword OCINumberAdd(    OCIError *err, const OCINumber *number1, 
                       const OCINumber *number2, OCINumber *result    );
















 

 

sword OCINumberSub(    OCIError *err, const OCINumber *number1, 
                       const OCINumber *number2, OCINumber *result    );
















 

 

sword OCINumberMul(    OCIError *err, const OCINumber *number1, 
                       const OCINumber *number2, OCINumber *result    );
















 

 

sword OCINumberDiv(    OCIError *err, const OCINumber *number1, 
                       const OCINumber *number2, OCINumber *result    );




















 

 

sword OCINumberMod(    OCIError *err, const OCINumber *number1, 
                       const OCINumber *number2, OCINumber *result    );


















 

 

sword OCINumberIntPower(    OCIError *err, const OCINumber *base,
                            const sword exp, OCINumber *result    );


















 

 

sword OCINumberShift(    OCIError *err, const OCINumber *number,
                            const sword nDig, OCINumber *result    );


















 

 

sword OCINumberNeg(    OCIError *err, const OCINumber *number,
                       OCINumber *result    );
















 

 

sword OCINumberToText(    OCIError *err, const OCINumber *number, 
                          const oratext *fmt, ub4 fmt_length,
                          const oratext *nls_params, ub4 nls_p_length,
                          ub4 *buf_size, oratext *buf    );





































 

 

sword OCINumberFromText(    OCIError *err, const oratext *str, 
                          ub4 str_length, const oratext *fmt, ub4 fmt_length, 
                          const oratext *nls_params, ub4 nls_p_length, 
                          OCINumber *number    );






























 

 




sword OCINumberToInt(    OCIError *err, const OCINumber *number,
                         uword rsl_length, uword rsl_flag, void *rsl    );























 

 

sword OCINumberFromInt(    OCIError *err, const void *inum, uword inum_length,
                         uword inum_s_flag, OCINumber *number    );























 

 

sword OCINumberToReal(    OCIError *err, const OCINumber *number,
                          uword rsl_length, void *rsl    );






















 

 

sword OCINumberToRealArray(  OCIError *err, const OCINumber **number,
                             uword elems, uword rsl_length, void *rsl    );























 

 

sword OCINumberFromReal(    OCIError *err, const void *rnum,
                            uword rnum_length, OCINumber *number    );




















 

 

sword OCINumberCmp(    OCIError *err, const OCINumber *number1, 
                       const OCINumber *number2, sword *result    );

















 

 

sword OCINumberSign(    OCIError *err, const OCINumber *number,
                        sword *result    );

















 

 

sword OCINumberIsZero(    OCIError *err, const OCINumber *number,
                          boolean *result    );
















 

 

sword OCINumberIsInt(    OCIError *err, const OCINumber *number,
                          boolean *result    );
















 

 
 
sword OCINumberAssign(    OCIError *err, const OCINumber *from,
                          OCINumber *to    );
















 

 

sword OCINumberAbs(    OCIError *err, const OCINumber *number,
                       OCINumber *result    );

















 

 

sword OCINumberCeil(    OCIError *err, const OCINumber *number,
                        OCINumber *result    );

















 

 

sword OCINumberFloor(    OCIError *err, const OCINumber *number, 
                         OCINumber *result    );

















 

 

sword OCINumberSqrt(    OCIError *err, const OCINumber *number, 
                       OCINumber *result    );


















 

 

sword OCINumberTrunc(    OCIError *err, const OCINumber *number, 
                         sword decplace, OCINumber *result    );



















 

 

sword OCINumberPower(    OCIError *err, const OCINumber *base, 
                         const OCINumber *number, OCINumber *result    );


















 

 

sword OCINumberRound(    OCIError *err, const OCINumber *number,
                         sword decplace, OCINumber *result    );



















 

 

sword OCINumberPrec(    OCIError *err, const OCINumber *number,
                         eword nDigs, OCINumber *result    );



















 

 

sword OCINumberSin(    OCIError *err, const OCINumber *number,
                       OCINumber *result    );
















 

 

sword OCINumberArcSin(    OCIError *err, const OCINumber *number,
                          OCINumber *result    );

















 

 

sword OCINumberHypSin(    OCIError *err, const OCINumber *number, 
                          OCINumber *result    );



















 

 

sword OCINumberCos(    OCIError *err, const OCINumber *number, 
                       OCINumber *result    );
















 

 

sword OCINumberArcCos(    OCIError *err, const OCINumber *number, 
                          OCINumber *result    );

















 

 

sword OCINumberHypCos(    OCIError *err, const OCINumber *number, 
                          OCINumber *result    );



















 

 

sword OCINumberTan(    OCIError *err, const OCINumber *number, 
                       OCINumber *result    );
















 

 

sword OCINumberArcTan(    OCIError *err, const OCINumber *number, 
                          OCINumber *result    );
















 

 

sword OCINumberArcTan2(    OCIError *err, const OCINumber *number1, 
                           const OCINumber *number2, OCINumber *result    );




















 

 

sword OCINumberHypTan(    OCIError *err, const OCINumber *number, 
                          OCINumber *result    );



















 

 

sword OCINumberExp(    OCIError *err, const OCINumber *number, 
                       OCINumber *result    );
















 

 

sword OCINumberLn(    OCIError *err, const OCINumber *number, 
                      OCINumber *result    );


















 

 

sword OCINumberLog(    OCIError *err, const OCINumber *base, 
                       const OCINumber *number, OCINumber *result    );



















 

 
 
 
 
struct OCITime
{
  ub1 OCITimeHH;                           
  ub1 OCITimeMI;                      
  ub1 OCITimeSS;                      
};
typedef struct OCITime OCITime;







 

struct OCIDate
{
  sb2 OCIDateYYYY;          
  ub1 OCIDateMM;                           
  ub1 OCIDateDD;                              
  OCITime OCIDateTime;                                                
};
typedef struct OCIDate OCIDate;












 
















































 

 

 
#line 1791 "/oracle/app/oracle/product/10.2/rdbms/public/orl.h"












 

 

 
#line 1814 "/oracle/app/oracle/product/10.2/rdbms/public/orl.h"











 

 

 
#line 1836 "/oracle/app/oracle/product/10.2/rdbms/public/orl.h"











 

 
 
#line 1857 "/oracle/app/oracle/product/10.2/rdbms/public/orl.h"











 

 

sword OCIDateAssign(    OCIError *err, const OCIDate *from, 
                        OCIDate *to    );













 

 

sword OCIDateToText(    OCIError *err, const OCIDate *date, 
                        const oratext *fmt, ub1 fmt_length, 
                        const oratext *lang_name, ub4 lang_length, 
                        ub4 *buf_size, oratext *buf    );





































 

 

sword OCIDateFromText(    OCIError *err, const oratext *date_str, 
                        ub4 d_str_length, const oratext *fmt, ub1 fmt_length, 
                        const oratext *lang_name, ub4 lang_length, 
                        OCIDate *date    );































 

 

sword OCIDateCompare(    OCIError *err, const OCIDate *date1, 
                     const OCIDate *date2, sword *result    );




















 

 

sword OCIDateAddMonths(    OCIError *err, const OCIDate *date, sb4 num_months,
                           OCIDate *result    );

























 

 

sword OCIDateAddDays(    OCIError *err, const OCIDate *date, sb4 num_days,
                         OCIDate *result    );




















 

 

sword OCIDateLastDay(    OCIError *err, const OCIDate *date, 
                         OCIDate *last_day    );


















 

 

sword OCIDateDaysBetween(    OCIError *err, const OCIDate *date1, 
                             const OCIDate *date2, sb4 *num_days    );


















 

 

sword OCIDateZoneToZone(    OCIError *err, const OCIDate *date1,
                            const oratext *zon1,
                            ub4 zon1_length, const oratext *zon2, 
                            ub4 zon2_length, OCIDate *date2    );
























 

 

sword OCIDateNextDay(    OCIError *err, const OCIDate *date, 
                         const oratext *day_p, ub4 day_length, 
                         OCIDate *next_day    );





















 

 

 
#line 2177 "/oracle/app/oracle/product/10.2/rdbms/public/orl.h"
                                            


                                            

                                   



sword OCIDateCheck(    OCIError *err, const OCIDate *date, uword *valid    );










































 

 

sword OCIDateSysDate(    OCIError *err, OCIDate *sys_date    );















 

 
 
 




 

 
 
 












 
typedef struct OCIString OCIString;

 
 
sword OCIStringAssign(    OCIEnv *env, OCIError *err, const OCIString *rhs, 
                          OCIString **lhs    );




















 
 
 
 
sword OCIStringAssignText(    OCIEnv *env, OCIError *err, const oratext *rhs, 
                              ub4 rhs_len, OCIString **lhs    );





















 

 

sword OCIStringResize(    OCIEnv *env, OCIError *err, ub4 new_size, 
                          OCIString **str    );





























 

 

ub4 OCIStringSize(    OCIEnv *env, const OCIString *vs    );









 

 

oratext *OCIStringPtr(    OCIEnv *env, const OCIString *vs    );









 

 
 
sword OCIStringAllocSize(    OCIEnv *env, OCIError *err, const OCIString *vs, 
                             ub4 *allocsize    );




















 

 
 
 












 
typedef struct OCIRaw OCIRaw;

 
 
sword OCIRawAssignRaw(    OCIEnv *env, OCIError *err, const OCIRaw *rhs, 
                          OCIRaw **lhs    );



















 
 
 
 
sword OCIRawAssignBytes(    OCIEnv *env, OCIError *err, const ub1 *rhs, 
                            ub4 rhs_len, OCIRaw **lhs    );




















 

 
 
sword OCIRawResize(    OCIEnv *env, OCIError *err, ub4 new_size, 
                       OCIRaw **raw    );



























 

 

ub4 OCIRawSize(    OCIEnv * env, const OCIRaw *raw    );









 

 
ub1 *OCIRawPtr(    OCIEnv * env, const OCIRaw *raw    );









 

 
 
sword OCIRawAllocSize(    OCIEnv *env, OCIError *err, const OCIRaw *raw,
                          ub4 *allocsize    );



















 

 
 
 







 

 
void OCIRefClear(    OCIEnv *env, OCIRef *ref    );
















 

 
sword OCIRefAssign(    OCIEnv *env, OCIError *err, const OCIRef *source, 
                       OCIRef **target    );




















 

 
boolean OCIRefIsEqual(    OCIEnv *env, const OCIRef *x, const OCIRef *y    );
















 

 
boolean OCIRefIsNull(    OCIEnv *env, const OCIRef *ref    );

















 

 
ub4 OCIRefHexSize(    OCIEnv *env, const OCIRef *ref    );












 

 
sword OCIRefFromHex(    OCIEnv *env, OCIError *err, const OCISvcCtx *svc, 
                        const oratext *hex, ub4 length, OCIRef **ref    );


























 

 
sword OCIRefToHex(    OCIEnv *env, OCIError *err, const OCIRef *ref, 
                      oratext *hex, ub4 *hex_length    );


























 


 
 
 


















































 

 
typedef struct OCIColl OCIColl;

 
typedef OCIColl OCIArray;

 
typedef OCIColl OCITable;

 
typedef struct OCIIter OCIIter;

 

sword OCICollSize( OCIEnv *env, OCIError *err, const OCIColl *coll, 
                   sb4 *size );









































 

 

sb4 OCICollMax(    OCIEnv *env, const OCIColl *coll    );














 

 

sword OCICollGetElem(    OCIEnv *env, OCIError *err, const OCIColl *coll, 
                         sb4 index, boolean *exists, void **elem, 
                         void **elemind    );







































































 

 

sword OCICollGetElemArray(  OCIEnv *env, OCIError *err, const OCIColl *coll, 
                            sb4 index, boolean *exists, void **elem, 
                            void **elemind, uword *nelems);








































































 

 

sword OCICollAssignElem(    OCIEnv *env, OCIError *err, sb4 index, 
                            const void *elem, 
                            const void *elemind, OCIColl *coll    );































 

 

sword OCICollAssign(    OCIEnv *env, OCIError *err, const OCIColl *rhs, 
                        OCIColl *lhs    );






























 

 

sword OCICollAppend(    OCIEnv *env, OCIError *err, const void *elem, 
                        const void *elemind, OCIColl *coll    );

































 

 

sword OCICollTrim(    OCIEnv *env, OCIError *err, sb4 trim_num, 
                      OCIColl *coll    );























 

 

sword OCICollIsLocator(OCIEnv *env, OCIError *err, const OCIColl *coll,
                       boolean *result );


















 

 

sword OCIIterCreate(    OCIEnv *env, OCIError *err, const OCIColl *coll, 
                        OCIIter **itr    );






























 

 

sword OCIIterDelete(    OCIEnv *env, OCIError *err, OCIIter **itr    );



















 

 

sword OCIIterInit(    OCIEnv *env, OCIError *err, const OCIColl *coll, 
                      OCIIter *itr    );























 

 

sword OCIIterGetCurrent(    OCIEnv *env, OCIError *err, const OCIIter *itr, 
                            void **elem, void **elemind    );






















 

 

sword OCIIterNext(    OCIEnv *env, OCIError *err, OCIIter *itr, 
                      void **elem, void **elemind, boolean *eoc    );





























 

 

sword OCIIterPrev(    OCIEnv *env, OCIError *err, OCIIter *itr, 
                      void **elem, void **elemind, boolean *boc    );






























 

 
 
 

 

sword OCITableSize( OCIEnv *env, OCIError *err, const OCITable *tbl, 
                    sb4 *size);





































 

 

sword OCITableExists(    OCIEnv *env, OCIError *err, const OCITable *tbl,
                             sb4 index, boolean *exists    );




















 

 

sword OCITableDelete(    OCIEnv *env, OCIError *err, sb4 index, 
                      OCITable *tbl    );























 

 

sword OCITableFirst(    OCIEnv *env, OCIError *err, const OCITable *tbl, 
                        sb4 *index     );



















 

 

sword OCITableLast(    OCIEnv *env, OCIError *err, const OCITable *tbl, 
                       sb4 *index     );



















 

 

sword OCITableNext(    OCIEnv *env, OCIError *err, sb4 index, 
                       const OCITable *tbl, sb4 *next_index,
                       boolean *exists    );






















 

 

sword OCITablePrev(    OCIEnv *env, OCIError *err, sb4 index, 
                       const OCITable *tbl, sb4 *prev_index,
                       boolean *exists    );






















 

 
 













 

 
typedef struct OCIXMLType OCIXMLType;

 
typedef struct OCIDOMDocument OCIDOMDocument;

#line 2694 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"






#line 1 "/oracle/app/oracle/product/10.2/rdbms/public/ociextp.h"


 

 
 










































 

 










 


 







 




 








 
typedef struct OCIExtProcContext OCIExtProcContext;

 






 




























 






 
























 







 

























 





 

















 





 


















 








 




 




 



void *ociepacm(OCIExtProcContext *with_context, size_t amount);



size_t ocieperr(OCIExtProcContext *with_context, int error_number);



size_t ociepmsg(OCIExtProcContext *with_context, int error_number,
                oratext *error_message, size_t len );



sword ociepgoe(OCIExtProcContext *with_context, OCIEnv **envh, 
               OCISvcCtx **svch, OCIError **errh);


#line 2702 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"


#line 1 "/oracle/app/oracle/product/10.2/rdbms/public/ociapr.h"


 

 



















 




 














 
sword  obindps(struct cda_def *cursor, ub1 opcode, OraText *sqlvar, 
	       sb4 sqlvl, ub1 *pvctx, sb4 progvl, 
	       sword ftype, sword scale,
	       sb2 *indp, ub2 *alen, ub2 *arcode, 
	       sb4 pv_skip, sb4 ind_skip, sb4 alen_skip, sb4 rc_skip,
	       ub4 maxsiz, ub4 *cursiz,
	       OraText *fmt, sb4 fmtl, sword fmtt);
sword  obreak(struct cda_def *lda);
sword  ocan  (struct cda_def *cursor);
sword  oclose(struct cda_def *cursor);
sword  ocof  (struct cda_def *lda);
sword  ocom  (struct cda_def *lda);
sword  ocon  (struct cda_def *lda);




 
sword  odefinps(struct cda_def *cursor, ub1 opcode, sword pos,ub1 *bufctx,
		sb4 bufl, sword ftype, sword scale, 
		sb2 *indp, OraText *fmt, sb4 fmtl, sword fmtt, 
		ub2 *rlen, ub2 *rcode,
		sb4 pv_skip, sb4 ind_skip, sb4 alen_skip, sb4 rc_skip);
sword  odessp(struct cda_def *cursor, OraText *objnam, size_t onlen,
              ub1 *rsv1, size_t rsv1ln, ub1 *rsv2, size_t rsv2ln,
              ub2 *ovrld, ub2 *pos, ub2 *level, OraText **argnam,
              ub2 *arnlen, ub2 *dtype, ub1 *defsup, ub1* mode,
              ub4 *dtsiz, sb2 *prec, sb2 *scale, ub1 *radix,
              ub4 *spare, ub4 *arrsiz);
sword  odescr(struct cda_def *cursor, sword pos, sb4 *dbsize,
                 sb2 *dbtype, sb1 *cbuf, sb4 *cbufl, sb4 *dsize,
                 sb2 *prec, sb2 *scale, sb2 *nullok);
sword  oerhms   (struct cda_def *lda, sb2 rcode, OraText *buf,
                 sword bufsiz);
sword  oermsg   (sb2 rcode, OraText *buf);
sword  oexec    (struct cda_def *cursor);
sword  oexfet   (struct cda_def *cursor, ub4 nrows,
                 sword cancel, sword exact);
sword  oexn     (struct cda_def *cursor, sword iters, sword rowoff);
sword  ofen     (struct cda_def *cursor, sword nrows);
sword  ofetch   (struct cda_def *cursor);
sword  oflng    (struct cda_def *cursor, sword pos, ub1 *buf,
                 sb4 bufl, sword dtype, ub4 *retl, sb4 offset);
sword  ogetpi   (struct cda_def *cursor, ub1 *piecep, void **ctxpp, 
                 ub4 *iterp, ub4 *indexp);
sword  oopt     (struct cda_def *cursor, sword rbopt, sword waitopt);
sword  opinit   (ub4 mode);
sword  olog     (struct cda_def *lda, ub1* hda,
                 OraText *uid, sword uidl,
                 OraText *pswd, sword pswdl, 
                 OraText *conn, sword connl, 
                 ub4 mode);
sword  ologof   (struct cda_def *lda);
sword  oopen    (struct cda_def *cursor, struct cda_def *lda,
                 OraText *dbn, sword dbnl, sword arsize,
                 OraText *uid, sword uidl);
sword  oparse   (struct cda_def *cursor, OraText *sqlstm, sb4 sqllen,
                 sword defflg, ub4 lngflg);
sword  orol     (struct cda_def *lda);
sword  osetpi   (struct cda_def *cursor, ub1 piece, void *bufp, ub4 *lenp);

void sqlld2     (struct cda_def *lda, OraText *cname, sb4 *cnlen);
void sqllda     (struct cda_def *lda);

 
sword onbset    (struct cda_def *lda ); 
sword onbtst    (struct cda_def *lda ); 
sword onbclr    (struct cda_def *lda ); 
sword ognfd     (struct cda_def *lda, void *fdp);




 



 
sword  obndra(struct cda_def *cursor, OraText *sqlvar, sword sqlvl,
                 ub1 *progv, sword progvl, sword ftype, sword scale,
                 sb2 *indp, ub2 *alen, ub2 *arcode, ub4 maxsiz,
                 ub4 *cursiz, OraText *fmt, sword fmtl, sword fmtt);
sword  obndrn(struct cda_def *cursor, sword sqlvn, ub1 *progv,
                 sword progvl, sword ftype, sword scale, sb2 *indp,
                 OraText *fmt, sword fmtl, sword fmtt);
sword  obndrv(struct cda_def *cursor, OraText *sqlvar, sword sqlvl,
                 ub1 *progv, sword progvl, sword ftype, sword scale,
                 sb2 *indp, OraText *fmt, sword fmtl, sword fmtt);



 
sword  odefin(struct cda_def *cursor, sword pos, ub1 *buf,
	      sword bufl, sword ftype, sword scale, sb2 *indp,
	      OraText *fmt, sword fmtl, sword fmtt, ub2 *rlen, ub2 *rcode);

 

sword  oname    (struct cda_def *cursor, sword pos, sb1 *tbuf,
                 sb2 *tbufl, sb1 *buf, sb2 *bufl);
sword  orlon    (struct cda_def *lda, ub1 *hda, 
                 OraText *uid, sword uidl, 
                 OraText *pswd, sword pswdl, 
                 sword audit);
sword  olon     (struct cda_def *lda, OraText *uid, sword uidl,
                 OraText *pswd, sword pswdl, sword audit);
sword  osql3    (struct cda_def *cda, OraText *sqlstm, sword sqllen);
sword  odsc     (struct cda_def *cursor, sword pos, sb2 *dbsize,
                 sb2 *fsize, sb2 *rcode, sb2 *dtype, sb1 *buf,
                 sb2 *bufl, sb2 *dsize);

#line 2705 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"
#line 1 "/oracle/app/oracle/product/10.2/rdbms/public/ociap.h"


 

 
 


 
 







































































































































































































 

 






 









#line 1 "/oracle/app/oracle/product/10.2/rdbms/public/nzt.h"
 

 
 



 






























































































































 
   
 








#line 1 "/oracle/app/oracle/product/10.2/rdbms/public/nzerror.h"
 





 

 


































































































 
















 

typedef enum nzerror
{
  NZERROR_OK = 0,
  NZERROR_GENERIC = 28750,                           
  NZERROR_NO_MEMORY = 28751,                                
  NZERROR_DATA_SOURCE_INIT_FAILED = 28752,      
  NZERROR_DATA_SOURCE_TERM_FAILED = 28753, 
  NZERROR_OBJECT_STORE_FAILED = 28754,  
  NZERROR_OBJECT_GET_FAILED = 28755,
                                  
  NZERROR_MEMORY_ALLOC_FAILED = 28756,
                                        
  NZERROR_MEMORY_ALLOC_0_BYTES = 28757,
                                    
  NZERROR_MEMORY_FREE_FAILED = 28758,
                                            
  NZERROR_FILE_OPEN_FAILED = 28759,
                                                       
  NZERROR_LIST_CREATION_FAILED = 28760,
                                                   
  NZERROR_NO_ELEMENT = 28761,
                                                     
  NZERROR_ELEMENT_ADD_FAILED = 28762,
                                           
  NZERROR_PARAMETER_BAD_TYPE = 28763,
                                    
  NZERROR_PARAMETER_RETRIEVAL = 28764,       
                             
  NZERROR_NO_LIST = 28765,                 
  NZERROR_TERMINATE_FAIL = 28766,                      
  NZERROR_BAD_VERSION_NUMBER = 28767,                   
  NZERROR_BAD_MAGIC_NUMBER = 28768,                       
  NZERROR_METHOD_NOT_FOUND = 28769,
                            
  NZERROR_ALREADY_INITIALIZED = 28770,
                                     
  NZERROR_NOT_INITIALIZED = 28771,      
  NZERROR_BAD_FILE_ID = 28772,                              
  NZERROR_WRITE_MAGIC_VERSION = 28773,   
  NZERROR_FILE_WRITE_FAILED = 28774,               
  NZERROR_FILE_CLOSE_FAILED = 28775,                  
  NZERROR_OUTPUT_BUFFER_TOO_SMALL = 28776,
                            
  NZERROR_BINDING_CREATION_FAILED = 28777, 
  NZERROR_PARAMETER_MALFORMED = 28778,     
  NZERROR_PARAMETER_NO_METHOD = 28779,
                                   
  NZERROR_BAD_PARAMETER_METHOD = 28780,       
  NZERROR_PARAMETER_NO_DATA = 28781,     
  NZERROR_NOT_ALLOCATED = 28782,              
  NZERROR_INVALID_PARAMETER = 28783,                
  NZERROR_FILE_NAME_TRANSLATION = 28784, 
  NZERROR_NO_SUCH_PARAMETER = 28785,    

  NZERROR_DECRYPT_FAILED = 28786,  
                                   
  NZERROR_ENCRYPT_FAILED = 28787,      
 
  NZERROR_INVALID_INPUT = 28788,       

  NZERROR_NAME_TYPE_NOT_FOUND = 28789,
                                   
  NZERROR_NLS_STRING_OPEN_FAILED = 28790,
                                         
  NZERROR_CERTIFICATE_VERIFY = 28791,       
  NZERROR_OCI_PLSQL_FAILED = 28792,
                                  
  NZERROR_OCI_BIND_FAILED = 28793,
                               
  NZERROR_ATTRIBUTE_INIT = 28794,            
  NZERROR_ATTRIBUTE_FINISH_FAILED = 28795, 
  NZERROR_UNSUPPORTED_METHOD = 28796,  
  NZERROR_INVALID_KEY_DATA_TYPE = 28797,
                                       
  NZEROR_BIND_SUBKEY_COUNT = 28798,
        
  NZERROR_AUTH_SHARED_MEMORY = 28799,
     
  NZERROR_RIO_OPEN = 28800,                                
  NZERROR_RIO_OBJECT_TYPE = 28801,                 
  NZERROR_RIO_MODE = 28802,                               
  NZERROR_RIO_IO = 28803,                      
  NZERROR_RIO_CLOSE = 28804,                              
  NZERROR_RIO_RETRIEVE = 28805,                        
  NZERROR_RIO_STORE = 28806,                              
  NZERROR_RIO_UPDATE = 28807,                            
  NZERROR_RIO_INFO = 28808,                                
  NZERROR_RIO_DELETE = 28809,                            
  NZERROR_KD_CREATE = 28810,                  
  NZERROR_RIO_ACCESS_DESCRIPTOR = 28811,         
  NZERROR_RIO_RECORD = 28812,                               
  NZERROR_RIO_RECORD_TYPE = 28813,     
  NZERROR_PLSQL_ORACLE_TO_REAL = 28814,
           
  NZERROR_PLSQL_REAL_TO_ORACLE = 28815,
        
  NZERROR_TK_PLSQL_NO_PASSWORD = 28816,
                          
  NZERROR_TK_PLSQL_GENERIC = 28817,
                                       
  NZERROR_TK_PLSQL_NO_CONTEXT = 28818,
                
  NZERROR_TK_PLSQL_NO_DIST_NAME = 28819,
       
  NZERROR_TK_PLSQL_NO_STATE = 28820,
 
  NZERROR_TK_PLSQL_NO_INPUT = 28821,
                        
  NZERROR_TK_PLSQL_NO_SEED = 28822,
          
  NZERROR_TK_PLSQL_NO_BYTES = 28823,
   
  NZERROR_TK_INVALID_STATE = 28824,
                      
  NZERROR_TK_PLSQL_NO_ENG_FUNC = 28825,
                                   
  NZERROR_TK_INV_ENG_FUNC = 28826,
                           
  NZERROR_TK_INV_CIPHR_TYPE = 28827,
                                      
  NZERROR_TK_INV_IDENT_TYPE = 28828,
                                    
  NZERROR_TK_PLSQL_NO_CIPHER_TYPE = 28829,
                                              
  NZERROR_TK_PLSQL_NO_IDENT_TYPE = 28830,
                                            
  NZERROR_TK_PLSQL_NO_DATA_FMT = 28831,
                                         
  NZERROR_TK_INV_DATA_FMT = 28832,
                         
  NZERROR_TK_PLSQL_INSUFF_INFO = 28833,
        
  NZERROR_TK_PLSQL_BUF_TOO_SMALL = 28834,
            
  NZERROR_TK_PLSQL_INV_IDENT_DESC = 28835,
                              
  NZERROR_TK_PLSQL_WALLET_NOTOPEN = 28836,
                                            
  NZERROR_TK_PLSQL_NO_WALLET = 28837,
                         
  NZERROR_TK_PLSQL_NO_IDENTITY = 28838,
                       
  NZERROR_TK_PLSQL_NO_PERSONA = 28839,
                    
  NZERROR_TK_PLSQL_WALLET_OPEN = 28840,
                                                 
  NZERROR_UNSUPPORTED = 28841,                  
  NZERROR_FILE_BAD_PERMISSION = 28842,       
  NZERROR_FILE_OSD_ERROR = 28843,              
  NZERROR_NO_WALLET  = 28844,   
  NZERROR_NO_CERTIFICATE_ALERT    = 28845,   
  NZERROR_NO_PRIVATE_KEY          = 28846,   
  NZERROR_NO_CLEAR_PRIVATE_KEY_FILE   = 28847,    
  NZERROR_NO_ENCRYPTED_PRIVATE_KEY_FILE = 28848,   
  NZERROR_NO_TRUSTPOINTS     = 28849,        
  NZERROR_NO_CLEAR_TRUSTPOINT_FILE    = 28850,    
  NZERROR_NO_ENCRYPTED_TRUSTPOINT_FILE = 28851,    
  NZERROR_BAD_PASSWORD    = 28852,    
  NZERROR_INITIALIZATION_FAILED   =  28853, 
 
   
  









 
  NZERROR_SSLMemoryErr = 28854,
  NZERROR_SSLUnsupportedErr = 28855,
  NZERROR_SSLOverflowErr = 28856,
  NZERROR_SSLUnknownErr = 28857,
  NZERROR_SSLProtocolErr = 28858,
  NZERROR_SSLNegotiationErr = 28859,
  NZERROR_SSLFatalAlert = 28860,
  NZERROR_SSLWouldBlockErr = 28861,
  NZERROR_SSLIOErr = 28862,
  NZERROR_SSLSessionNotFoundErr = 28863,
  NZERROR_SSLConnectionClosedGraceful = 28864,
  NZERROR_SSLConnectionClosedError = 28865,
  NZERROR_ASNBadEncodingErr = 28866,
  NZERROR_ASNIntegerTooBigErr = 28867,
  NZERROR_X509CertChainInvalidErr = 28868,
  NZERROR_X509CertExpiredErr = 28869,
  NZERROR_X509NamesNotEqualErr = 28870,
  NZERROR_X509CertChainIncompleteErr = 28871,
  NZERROR_X509DataNotFoundErr = 28872,
  NZERROR_SSLBadParameterErr = 28873,
  NZERROR_SSLIOClosedOverrideGoodbyeKiss = 28874,
  NZERROR_X509MozillaSGCErr  =  28875,
  NZERROR_X509IESGCErr       =  28876,
  NZERROR_ImproperServerCredentials = 28877,
  NZERROR_ImproperClientCredentials = 28878,
  NZERROR_NoProtocolSideSet = 28879,
  NZERROR_setPersonaFailed = 28880,
  NZERROR_setCertFailed = 28881,
  NZERROR_setVKeyFailed = 28882,
  NZERROR_setTPFailed = 28883,
  NZERROR_BadCipherSuite = 28884,
  NZERROR_NoKeyPairForKeyUsage = 28885,

 
  NZERROR_EntrustLoginFailed = 28890,
  NZERROR_EntrustGetInfoFailed = 28891,
  NZERROR_EntrustLoadCertificateFailed = 28892,
  NZERROR_EntrustGetNameFailed = 28893,

 
  NZERROR_CertNotInstalled = 29000,
  NZERROR_ServerDNMisMatched = 29002,
  NZERROR_ServerDNMisConfigured = 29003,

 

 
  NZERROR_CIC_ERR_SSL_ALERT_CB_FAILURE = 29004,
  NZERROR_CIC_ERR_SSL_BAD_CERTIFICATE = 29005,
  NZERROR_CIC_ERR_SSL_BAD_CERTIFICATE_REQUEST = 29006,
  NZERROR_CIC_ERR_SSL_BAD_CLEAR_KEY_LEN = 29007,
  NZERROR_CIC_ERR_SSL_BAD_DHPARAM_KEY_LENGTH = 29008,
  NZERROR_CIC_ERR_SSL_BAD_ENCRYPTED_KEY_LEN = 29009,
  NZERROR_CIC_ERR_SSL_BAD_EXPORT_KEY_LENGTH = 29010,
  NZERROR_CIC_ERR_SSL_BAD_FINISHED_MESSAGE = 29011,
  NZERROR_CIC_ERR_SSL_BAD_KEY_ARG_LEN = 29012,
  NZERROR_CIC_ERR_SSL_BAD_MAC = 29013,
  NZERROR_CIC_ERR_SSL_BAD_MAX_FRAGMENT_LENGTH_EXTENSION = 29014,
  NZERROR_CIC_ERR_SSL_BAD_MESSAGE_LENGTH = 29015,
  NZERROR_CIC_ERR_SSL_BAD_PKCS1_PADDING = 29016,
  NZERROR_CIC_ERR_SSL_BAD_PREMASTER_SECRET_LENGTH = 29017,
  NZERROR_CIC_ERR_SSL_BAD_PREMASTER_SECRET_VERSION = 29018,
  NZERROR_CIC_ERR_SSL_BAD_PROTOCOL_VERSION = 29019,
  NZERROR_CIC_ERR_SSL_BAD_RECORD_LENGTH = 29020,
  NZERROR_CIC_ERR_SSL_BAD_SECRET_KEY_LEN = 29021,
  NZERROR_CIC_ERR_SSL_BAD_SIDE = 29022,
  NZERROR_CIC_ERR_SSL_BUFFERS_NOT_EMPTY = 29023,
  NZERROR_CIC_ERR_SSL_CERTIFICATE_VALIDATE_FAILED = 29024,
  NZERROR_CIC_ERR_SSL_CERT_CHECK_CALLBACK = 29025,
  NZERROR_CIC_ERR_SSL_DECRYPT_FAILED = 29026,
  NZERROR_CIC_ERR_SSL_ENTROPY_COLLECTION = 29027,
  NZERROR_CIC_ERR_SSL_FAIL_SERVER_VERIFY = 29028,
  NZERROR_CIC_ERR_SSL_HANDSHAKE_ALREADY_COMPLETED = 29029,
  NZERROR_CIC_ERR_SSL_HANDSHAKE_REQUESTED = 29030,
  NZERROR_CIC_ERR_SSL_HANDSHAKE_REQUIRED = 29031,
  NZERROR_CIC_ERR_SSL_INCOMPLETE_IDENTITY = 29032,
  NZERROR_CIC_ERR_SSL_INVALID_PFX = 29033,
  NZERROR_CIC_ERR_SSL_NEEDS_CIPHER_OR_CLIENTAUTH = 29034,
  NZERROR_CIC_ERR_SSL_NEEDS_PRNG = 29035,
  NZERROR_CIC_ERR_SSL_NOT_SUPPORTED = 29036,
  NZERROR_CIC_ERR_SSL_NO_CERTIFICATE = 29037,
  NZERROR_CIC_ERR_SSL_NO_MATCHING_CERTIFICATES = 29038,
  NZERROR_CIC_ERR_SSL_NO_MATCHING_CIPHER_SUITES = 29039,
  NZERROR_CIC_ERR_SSL_NO_SUPPORTED_CIPHER_SUITES = 29040,
  NZERROR_CIC_ERR_SSL_NULL_CB = 29041,
  NZERROR_CIC_ERR_SSL_READ_BUFFER_NOT_EMPTY = 29042,
  NZERROR_CIC_ERR_SSL_READ_REQUIRED = 29043,
  NZERROR_CIC_ERR_SSL_RENEGOTIATION_ALREADY_REQUESTED = 29044,
  NZERROR_CIC_ERR_SSL_RENEGOTIATION_REFUSED = 29045,
  NZERROR_CIC_ERR_SSL_RESUMABLE_SESSION = 29046,
  NZERROR_CIC_ERR_SSL_TLS_EXTENSION_MISMATCH = 29047,
  NZERROR_CIC_ERR_SSL_UNEXPECTED_MSG = 29048,
  NZERROR_CIC_ERR_SSL_UNKNOWN_RECORD = 29049,
  NZERROR_CIC_ERR_SSL_UNSUPPORTED_CLIENT_AUTH_MODE = 29050,
  NZERROR_CIC_ERR_SSL_UNSUPPORTED_PUBKEY_TYPE = 29051,
  NZERROR_CIC_ERR_SSL_WRITE_BUFFER_NOT_EMPTY = 29052,
  NZERROR_CIC_ERR_PKCS12_MISSING_ALG = 29053,
  NZERROR_CIC_ERR_PKCS_AUTH_FAILED = 29054,
  NZERROR_CIC_ERR_PKCS_BAD_CONTENT_TYPE = 29055,
  NZERROR_CIC_ERR_PKCS_BAD_INPUT = 29056,
  NZERROR_CIC_ERR_PKCS_BAD_PADDING = 29057,
  NZERROR_CIC_ERR_PKCS_BAD_SN = 29058,
  NZERROR_CIC_ERR_PKCS_BAD_SN_LENGTH = 29059,
  NZERROR_CIC_ERR_PKCS_BAD_VERSION = 29060,
  NZERROR_CIC_ERR_PKCS_BASE = 29061,
  NZERROR_CIC_ERR_PKCS_FIELD_NOT_PRESENT = 29062,
  NZERROR_CIC_ERR_PKCS_NEED_CERTVAL = 29063,
  NZERROR_CIC_ERR_PKCS_NEED_PASSWORD = 29064,
  NZERROR_CIC_ERR_PKCS_NEED_PKC = 29065,
  NZERROR_CIC_ERR_PKCS_NEED_PRV_KEY = 29066,
  NZERROR_CIC_ERR_PKCS_NEED_TRUSTED = 29067,
  NZERROR_CIC_ERR_PKCS_UNSUPPORTED_CERT_FORMAT = 29068,
  NZERROR_CIC_ERR_PKCS_UNSUP_PRVKEY_TYPE = 29069,
  NZERROR_CIC_ERR_CODING_BAD_PEM = 29070,
  NZERROR_CIC_ERR_CODING_BASE = 29071, 
  NZERROR_CIC_ERR_DER_BAD_ENCODING = 29072,
  NZERROR_CIC_ERR_DER_BAD_ENCODING_LENGTH = 29073,
  NZERROR_CIC_ERR_DER_BASE = 29074,
  NZERROR_CIC_ERR_DER_ELEMENT_TOO_LONG = 29075,
  NZERROR_CIC_ERR_DER_INDEFINITE_LENGTH = 29076,
  NZERROR_CIC_ERR_DER_NO_MORE_ELEMENTS = 29077,
  NZERROR_CIC_ERR_DER_OBJECT_TOO_LONG = 29078,
  NZERROR_CIC_ERR_DER_TAG_SIZE = 29079,
  NZERROR_CIC_ERR_DER_TIME_OUT_OF_RANGE = 29080,
  NZERROR_CIC_ERR_DER_UNUSED_BITS_IN_BIT_STR = 29081,
  NZERROR_CIC_ERR_GENERAL_BASE = 29082,
  NZERROR_CIC_ERR_HASH_BASE = 29083,
  NZERROR_CIC_ERR_ILLEGAL_PARAM = 29084,
  NZERROR_CIC_ERR_MEM_NOT_OURS = 29085,
  NZERROR_CIC_ERR_MEM_OVERRUN = 29086,
  NZERROR_CIC_ERR_MEM_UNDERRUN = 29087,
  NZERROR_CIC_ERR_MEM_WAS_FREED = 29088,
  NZERROR_CIC_ERR_NOT_FOUND = 29090,
  NZERROR_CIC_ERR_NO_PTR = 29091,
  NZERROR_CIC_ERR_TIMEOUT = 29092,
  NZERROR_CIC_ERR_UNIT_MASK = 29093,
  NZERROR_CIC_ERR_BAD_CTX = 29094,
  NZERROR_CIC_ERR_BAD_INDEX = 29095,
  NZERROR_CIC_ERR_BAD_LENGTH = 29096,
  NZERROR_CIC_ERR_CODING_BAD_ENCODING = 29097,
  NZERROR_CIC_ERR_SSL_NO_CLIENT_AUTH_MODES = 29098,

   
  
  NZERROR_LOCKEYID_CREATE_FAILED = 29100,
  NZERROR_P12_ADD_PVTKEY_FAILED = 29101,
  NZERROR_P12_ADD_CERT_FAILED = 29102,
  NZERROR_P12_WLT_CREATE_FAILED = 29103,
  NZERROR_P12_ADD_CERTREQ_FAILED = 29104,
  NZERROR_P12_WLT_EXP_FAILED = 29105,
  NZERROR_P12_WLT_IMP_FAILED = 29106,
  NZERROR_P12_CREATE_FAILED = 29107,
  NZERROR_P12_DEST_FAILED = 29107,
  NZERROR_P12_RAND_ERROR = 29108, 
  NZERROR_P12_PVTKEY_CRT_FAILED = 29109,
  NZERROR_P12_INVALID_BAG = 29110,
  NZERROR_P12_INVALID_INDEX = 29111,
  NZERROR_P12_GET_CERT_FAILED = 29112,
  NZERROR_P12_GET_PVTKEY_FAILED = 29113,
  NZERROR_P12_IMP_PVTKEY_FAILED = 29114,
  NZERROR_P12_EXP_PVTKEY_FAILED = 29115,
  NZERROR_P12_GET_ATTRIB_FAILED = 29116,
  NZERROR_P12_ADD_ATTRIB_FAILED = 29117,
  NZERROR_P12_CRT_ATTRIB_FAILED = 29118,
  NZERROR_P12_IMP_CERT_FAILED = 29119,
  NZERROR_P12_EXP_CERT_FAILED = 29120,
  NZERROR_P12_ADD_SECRET_FAILED = 29121,
  NZERROR_P12_ADD_PKCS11INFO_FAILED = 29122,
  NZERROR_P12_GET_PKCS11INFO_FAILED = 29123,
  NZERROR_P12_MULTIPLE_PKCS11_LIBNAME = 29124,
  NZERROR_P12_MULTIPLE_PKCS11_TOKENLABEL = 29125,
  NZERROR_P12_MULTIPLE_PKCS11_TOKENPASSPHRASE = 29126,
  NZERROR_P12_UNKNOWN_PKCS11INFO = 29127,
  NZERROR_P12_PKCS11_LIBNAME_NOT_SET = 29128,
  NZERROR_P12_PKCS11_TOKENLABEL_NOT_SET = 29129,
  NZERROR_P12_PKCS11_TOKENPASSPHRASE_NOT_SET = 29130,
  NZERROR_P12_MULTIPLE_PKCS11_CERTLABEL = 29131,

 
  NZERROR_CIC_ERR_RANDOM = 29135,
  NZERROR_CIC_ERR_SMALL_BUFFER = 29136,
  NZERROR_CIC_ERR_SSL_BAD_CONTEXT = 29137,

 
  NZERROR_MUTEX_INITIALIZE_FAILED = 29138,
  NZERROR_MUTEX_DESTROY_FAILED = 29139,


 
  NZERROR_BS_CERTOBJ_CREAT_FAILED = 29140,
  NZERROR_BS_DER_IMP_FAILED = 29141,


 
  NZERROR_DES_SELF_TEST_FAILED = 29150,
  NZERROR_3DES_SELF_TEST_FAILED = 29151,
  NZERROR_SHA_SELF_TEST_FAILED = 29152,
  NZERROR_RSA_SELF_TEST_FAILED = 29153,
  NZERROR_DRNG_SELF_TEST_FAILED = 29154,
  NZERROR_CKEYPAIR_SELF_TEST_FAILED = 29155,
  NZERROR_CRNG_SELF_TEST_FAILED = 29156,
  NZERROR_FIPS_PATHNAME_ERROR = 29157,
  NZERROR_FIPS_LIB_OPEN_FAILED = 29158,
  NZERROR_FIPS_LIB_READ_ERROR = 29159,
  NZERROR_FIPS_LIB_DIFFERS = 29160,
  NZERROR_DAC_SELF_TEST_FAILED = 29161,
  NZERROR_NONFIPS_CIPHERSUITE = 29162,
  NZERROR_VENDOR_NOT_SUPPORTED_FIPS_MODE = 29163,
  NZERROR_EXTERNAL_PKCS12_NOT_SUPPORTED_FIPS_MODE = 29164,
  NZERROR_AES_SELF_TEST_FAILED = 29165,

 
  NZERROR_CRL_SIG_VERIFY_FAILED = 29176,   
  NZERROR_CERT_NOT_IN_CRL = 29177, 
                                   
  NZERROR_CERT_IN_CRL = 29178,             
  NZERROR_CERT_IN_CRL_CHECK_FAILED = 29179,   
  NZERROR_INVALID_CERT_STATUS_PROTOCOL = 29180, 
  NZERROR_LDAP_OPEN_FAILED = 29181,   
  NZERROR_LDAP_BIND_FAILED = 29182,   
  NZERROR_LDAP_SEARCH_FAILED = 29183,   
  NZERROR_LDAP_RESULT_FAILED = 29184,   
  NZERROR_LDAP_FIRSTATTR_FAILED = 29185,   
  NZERROR_LDAP_GETVALUESLEN_FAILED = 29186,   
  NZERROR_LDAP_UNSUPPORTED_VALMEC = 29187, 
                                        
  NZERROR_LDAP_COUNT_ENTRIES_FAILED = 29188, 
  NZERROR_LDAP_NO_ENTRY_FOUND = 29189,  
  NZERROR_LDAP_MULTIPLE_ENTRIES_FOUND = 29190,  
  NZERROR_OID_INFO_NOT_SET = 29191, 
  NZERROR_LDAP_VALMEC_NOT_SET = 29192,  
                                      
  NZERROR_CRLDP_NO_CRL_FOUND = 29193,  
                                      
  NZERROR_CRL_NOT_IN_CACHE = 29194,   
  NZERROR_CRL_EXPIRED = 29195,        

 
  NZERROR_DN_MATCH  =            29222,   
  NZERROR_CERT_CHAIN_CREATION  = 29223,  


 
  NZERROR_NO_MATCHING_CERT_REQ = 29224,  



 
  NZERROR_CERT_ALREADY_INSTALLED = 29225, 



 
  NZERROR_NO_MATCHING_PRIVATE_KEY = 29226, 



 
  NZERROR_VALIDITY_EXPIRED = 29227,  
  NZERROR_TK_BYTES_NEEDED = 29228,    
  NZERROR_TK_BAD_MAGIC_NUMBER = 29229,
                      
  NZERROR_TK_BAD_HEADER_LENGTH = 29230,
                 
  NZERROR_TK_CE_INIT = 29231,           
  NZERROR_TK_CE_KEYINIT = 29232,   
  NZERROR_TK_CE_ENCODE_KEY = 29233,            
  NZERROR_TK_CE_DECODE_KEY = 29234,       
  NZERROR_TK_CE_GEYKEYINFO = 29235,   
  NZERROR_TK_SEED_RANDOM = 29236,    
  NZERROR_TK_CE_ALGFINISH = 29237,               
  NZERROR_TK_CE_ALGAPPLY = 29238,         
  NZERROR_TK_CE_ALGINIT = 29239,            
  NZERROR_TK_ALGORITHM = 29240,       
  NZERROR_TK_CANNOT_GROW = 29241,          
  NZERROR_TK_KEYSIZE = 29242,                
  NZERROR_TK_KEYTYPE = 29243,                            

  NZERROR_TK_PLSQL_NO_WRL = 29244,
                  

  NZERROR_TK_CE_FUNC = 29245,               
  NZERROR_TK_TDU_FORMAT = 29246,                        
  NZERROR_TK_NOTOPEN = 29247,                          
  NZERROR_TK_WRLTYPE = 29248,                                 
  NZERROR_TK_CE_STATE = 29249,   

   
  NZERROR_PKCS11_LIBRARY_NOT_FOUND = 43000,  
  NZERROR_PKCS11_TOKEN_NOT_FOUND = 43001, 
                                          
  NZERROR_PKCS11_BAD_PASSPHRASE = 43002,   
  NZERROR_PKCS11_GET_FUNC_LIST = 43003,   
  NZERROR_PKCS11_INITIALIZE = 43004,      
  NZERROR_PKCS11_NO_TOKENS_PRESENT = 43005,  
  NZERROR_PKCS11_GET_SLOT_LIST = 43006,   

  NZERROR_PKCS11_GET_TOKEN_INFO = 43008,   
  NZERROR_PKCS11_SYMBOL_NOT_FOUND = 43009,  

  NZERROR_PKCS11_TOKEN_LOGIN_FAILED = 43011,  

  NZERROR_PKCS11_CHANGE_PROVIDERS_ERROR = 43013,  
  NZERROR_PKCS11_GET_PRIVATE_KEY_ERROR = 43014, 
                               
  NZERROR_PKCS11_CREATE_KEYPAIR_ERROR = 43015,  
  NZERROR_PKCS11_WALLET_CONTAINS_P11_INFO = 43016, 
 
  NZERROR_PKCS11_NO_CERT_ON_TOKEN = 43017,       
  NZERROR_PKCS11_NO_USER_CERT_ON_TOKEN = 43018,  
  NZERROR_PKCS11_NO_CERT_ON_TOKEN_WITH_GIVEN_LABEL = 43019,  
  NZERROR_PKCS11_MULTIPLE_CERTS_ON_TOKEN_WITH_GIVEN_LABEL = 43020,  
  NZERROR_PKCS11_CERT_WITH_LABEL_NOT_USER_CERT  = 43021,  

   
  NZERROR_BIND_SERVICE_ERROR = 43050,     
  NZERROR_CREATE_KEY_OBJ_ERROR = 43051,   
  NZERROR_GET_CERT_FIELDS = 43052,        
  NZERROR_CREATE_PKCS10_OBJECT = 43053,  
                                       
  NZERROR_SET_PKCS10_FIELDS = 43054,      
  NZERROR_SIGN_CERT_REQUEST = 43055,      
  NZERROR_GET_PKCS10_DER = 43056,         
  NZERROR_INITIALIZE_CERTC = 43057,       
  NZERROR_INSERT_PRIVATE_KEY = 43058,    
  NZERROR_RSA_ERROR = 43059,             

   
  NZERROR_SLTSCTX_INIT_FAILED = 43060,     
  NZERROR_SLTSKYC_FAILED = 43061,          
  NZERROR_SLTSCTX_TERM_FAILED = 43062,     
  NZERROR_SLTSKYS_FAILED = 43063,          

  NZERROR_INVALID_HEADER_LENGTH = 43070,        
  NZERROR_WALLET_CONTAINS_USER_CREDENTIALS = 43071,  

  NZERROR_LAST_ERROR = 43499,                         
                                             

  



 
  NZERROR_THIS_MUST_BE_LAST

} nzerror;







 
#line 148 "/oracle/app/oracle/product/10.2/rdbms/public/nzt.h"






 
 
 





















 



 
#line 190 "/oracle/app/oracle/product/10.2/rdbms/public/nzt.h"
          
enum nzttwrl 
{
   NZTTWRL_DEFAULT = 1,     
   NZTTWRL_SQLNET,          
   NZTTWRL_FILE,            
   NZTTWRL_ENTR,            
   NZTTWRL_MCS,             
   NZTTWRL_ORACLE,       
   NZTTWRL_NULL,            
   NZTTWRL_REGISTRY         
};
typedef enum nzttwrl nzttwrl;


   


 
   typedef struct nzctx nzctx;
   typedef struct nzstrc nzstrc;
   typedef struct nzosContext nzosContext;


 

typedef struct nzttIdentity nzttIdentity;
typedef struct nzttIdentityPrivate nzttIdentityPrivate;
typedef struct nzttPersona nzttPersona;
typedef struct nzttPersonaPrivate nzttPersonaPrivate;
typedef struct nzttWallet nzttWallet;
typedef struct nzttWalletPrivate nzttWalletPrivate;
typedef struct nzttWalletObj nzttWalletObj;  
typedef struct nzssEntry nzssEntry;  
typedef struct nzpkcs11_Info nzpkcs11_Info;










 
enum nzttces 
{
   NZTTCES_CONTINUE = 1,     
   NZTTCES_END,              
   NZTTCES_RESET             
};
typedef enum nzttces nzttces;






 
enum nzttcef
{
   NZTTCEF_DETACHEDSIGNATURE = 1,    
   NZTTCEF_SIGNATURE,                
   NZTTCEF_ENVELOPING,               
   NZTTCEF_PKENCRYPTION,             
   NZTTCEF_ENCRYPTION,               
   NZTTCEF_KEYEDHASH,                
   NZTTCEF_HASH,                     
   NZTTCEF_RANDOM,                   

   NZTTCEF_LAST                      
};
typedef enum nzttcef nzttcef;



 
enum nzttState
{
   NZTTSTATE_EMPTY = 0,      
   NZTTSTATE_REQUESTED,      
   NZTTSTATE_READY,          
   NZTTSTATE_INVALID,          
   NZTTSTATE_RENEWAL         
};
typedef enum nzttState nzttState;





 
enum nzttVersion
{
   NZTTVERSION_X509v1 = 1,         
   NZTTVERSION_X509v3,             



   NZTTVERSION_INVALID_TYPE        
};
typedef enum nzttVersion nzttVersion;






 
enum nzttCipherType 
{
   NZTTCIPHERTYPE_RSA = 1,           
   NZTTCIPHERTYPE_DES,               
   NZTTCIPHERTYPE_RC4,               
   NZTTCIPHERTYPE_MD5DES,            
   NZTTCIPHERTYPE_MD5RC2,            
   NZTTCIPHERTYPE_MD5,               
   NZTTCIPHERTYPE_SHA                
};
typedef enum nzttCipherType nzttCipherType;






 
enum nztttdufmt
{
   NZTTTDUFMT_PKCS7 = 1,             
   NZTTTDUFMT_RSAPAD,                
   NZTTTDUFMT_ORACLEv1,              
   NZTTTDUFMT_LAST                   
};
typedef enum nztttdufmt nztttdufmt;





 
enum nzttValState
{
   NZTTVALSTATE_NONE = 1,         
   NZTTVALSTATE_GOOD,             
   NZTTVALSTATE_REVOKED           
};
typedef enum nzttValState nzttValState;





 
enum nzttPolicy
{
   NZTTPOLICY_NONE = 0,
   NZTTPOLICY_RETRY_1,  
   NZTTPOLICY_RETRY_2,  
   NZTTPOLICY_RETRY_3   
};
typedef enum nzttPolicy nzttPolicy;





 

#line 368 "/oracle/app/oracle/product/10.2/rdbms/public/nzt.h"




 
typedef ub1 nzttID[16];





 
enum nzttIdentType 
{
   NZTTIDENTITYTYPE_INVALID_TYPE = 0,  
   NZTTIDENTITYTYPE_CERTIFICTAE,      
   NZTTIDENTITYTYPE_CERT_REQ,      
   NZTTIDENTITYTYPE_RENEW_CERT_REQ,      
   NZTTIDENTITYTYPE_CLEAR_ETP,      
   NZTTIDENTITYTYPE_CLEAR_UTP,      
   NZTTIDENTITYTYPE_CLEAR_PTP       
};
typedef enum nzttIdentType nzttIdentType;

typedef ub4 nzttKPUsage;
 
#line 402 "/oracle/app/oracle/product/10.2/rdbms/public/nzt.h"




 
typedef ub1 nzttTStamp[4];























 
struct nzttBufferBlock
{


   uword flags_nzttBufferBlock;      
   ub4 buflen_nzttBufferBlock;    
   ub4 usedlen_nzttBufferBlock;   
   ub1 *buffer_nzttBufferBlock;      
};
typedef struct nzttBufferBlock nzttBufferBlock;



 
struct nzttWallet
{
   ub1 *ldapName_nzttWallet;               
   ub4  ldapNamelen_nzttWallet;            
   nzttPolicy securePolicy_nzttWallet;     
   nzttPolicy openPolicy_nzttWallet;       
   nzttPersona *persona_nzttWallet;        
   nzttWalletPrivate *private_nzttWallet;  



};







 





 
struct nzttPersona
{
   ub1 *genericName_nzttPersona;               
   ub4  genericNamelen_nzttPersona;            
   nzttPersonaPrivate *private_nzttPersona;    
   nzttIdentity *mycertreqs_nzttPersona;       
   nzttIdentity *mycerts_nzttPersona;          
   nzttIdentity *mytps_nzttPersona;            
   nzssEntry *mystore_nzttPersona;             
   nzpkcs11_Info *mypkcs11Info_nzttPersona;    
   struct nzttPersona *next_nzttPersona;       
#line 493 "/oracle/app/oracle/product/10.2/rdbms/public/nzt.h"
};









 
struct nzttIdentity
{
   text *dn_nzttIdentity;                       
   ub4 dnlen_nzttIdentity;                   
   text *comment_nzttIdentity;                  
   ub4 commentlen_nzttIdentity;              
   nzttIdentityPrivate *private_nzttIdentity;   
   nzttIdentity *next_nzttIdentity;             
};

struct nzttB64Cert
{
   ub1 *b64Cert_nzttB64Cert;
   ub4  b64Certlen_nzttB64Cert;
   struct nzttB64Cert *next_nzttB64Cert;
};
typedef struct nzttB64Cert nzttB64Cert;


struct nzttPKCS7ProtInfo
{
   nzttCipherType mictype_nzttPKCS7ProtInfo;     
   nzttCipherType symmtype_nzttPKCS7ProtInfo;    
   ub4 keylen_nzttPKCS7ProtInfo;              
};
typedef struct nzttPKCS7ProtInfo nzttPKCS7ProtInfo;





 
union nzttProtInfo
{
   nzttPKCS7ProtInfo pkcs7_nzttProtInfo;
};
typedef union nzttProtInfo nzttProtInfo;














 
struct nzttPersonaDesc
{
   ub4 privlen_nzttPersonaDesc;         
   ub1 *priv_nzttPersonaDesc;              
   ub4 prllen_nzttPersonaDesc;          
   text *prl_nzttPersonaDesc;              
   ub4 aliaslen_nzttPersonaDesc;        
   text *alias_nzttPersonaDesc;            
   ub4 longlen_nzttPersonaDesc;         
   text *long_nzttPersonaDesc;             
};
typedef struct nzttPersonaDesc nzttPersonaDesc;








 
struct nzttIdentityDesc
{
   ub4 publen_nzttIdentityDesc;         
   ub1 *pub_nzttIdentityDesc;              
   ub4 dnlen_nzttIdentityDesc;          
   text *dn_nzttIdentityDesc;              
   ub4 longlen_nzttIdentityDesc;        
   text *long_nzttIdentityDesc;            
   ub4 quallen_nzttIdentityDesc;        
   text *trustqual_nzttIdentityDesc;       
};
typedef struct nzttIdentityDesc nzttIdentityDesc;

 
 
 

 









































 




nzerror nztwOpenWallet(
 );



 



















 



nzerror nztwCloseWallet( );


 
 
 
nzerror nztwGetCertInfo(


 );


 










 

 





















 



nzerror nztwRetrievePersonaCopy(
 );



 





















 




nzerror nztwRetrievePersonaCopyByName(
 );


 
















 



nzerror nzteOpenPersona( );


 















 



nzerror nzteClosePersona( );


 





















 



nzerror nzteDestroyPersona( );


 






















 




nzerror nzteRetrieveTrustedIdentCopy(
 );


 























 



nzerror nztePriKey( );


 






















 



nzerror nzteMyCert( );


 


















 



nzerror nzteX509CreatePersona( );


 





















 




nzerror nztiCreateIdentity(
 );


#line 1012 "/oracle/app/oracle/product/10.2/rdbms/public/nzt.h"

 


















 



nzerror nztiAbortIdentity( );


#line 1090 "/oracle/app/oracle/product/10.2/rdbms/public/nzt.h"

 














 


 




nzerror nztific_FreeIdentityContent(
 );



 




















 




nzerror nztSign(
 );


 























 





nzerror nztVerify(

 );


 

















 



nzerror nztValidate( );


 




















 




nzerror nztsd_SignDetached(
 );


 























 





nzerror nztved_VerifyDetached(

 );


 
























 




nzerror nztkec_PKEncrypt(
 );


 


















 




nzerror nztxkec_PKEncryptExpansion(
 );


 




















 




nzerror nztkdc_PKDecrypt(
 );


 




















 




nzerror nztHash(
 );


 

















 



nzerror nztSeedRandom( );


 


















 




nzerror nztrb_RandomBytes(
 );


 
















 



nzerror nztrn_RandomNumber( );


 















 



nzerror nztbbInitBlock( );


 
















 



nzerror nztbbReuseBlock( );


 














 



nzerror nztbbSizeBlock( );


 














 



nzerror nztbbGrowBlock( );


 















 



nzerror nztbbPurgeBlock( );


 






















 




nzerror nztbbSetBlock(
 );



 



















 




nzerror nztiGetSecInfo(
 );



 
















 





nzerror nztiGetDName(
 );


 
















 




nzerror nztiGetIssuerName(
 );



 
















 




nzerror nztgch_GetCertHash(
 );


 














 



nzerror nztdbuf_DestroyBuf( );



 













 



nzerror nztGetCertChain( );


 

















 



nzerror nztCompareDN( );



#line 1955 "/oracle/app/oracle/product/10.2/rdbms/public/nzt.h"

 

















 



nzerror nztCheckValidity( );


 




























 




nzerror nztwCreateWallet(
 );



 


















 



nzerror nztwDestroyWallet( );


 







































 



nzerror nzteStorePersona( );


 






















 



nzerror nzteRemovePersona( );


 






















 




nzerror nzteCreatePersona(
 );



 



















 




nzerror nztiStoreTrustedIdentity(
 );


 


















 




nzerror nzteSetProtection(
 );


 
















 




nzerror nzteGetProtection(
 );


 




















 



nzerror nztiRemoveIdentity( );


 
















 
#line 2291 "/oracle/app/oracle/product/10.2/rdbms/public/nzt.h"
nzerror nztifdn(


 );


 

















 



nzerror nztxSignExpansion( );


 

















 




nzerror nztxsd_SignDetachedExpansion(
 );


 



















 




nzerror nztEncrypt(
 );


 

















 



nzerror nztxEncryptExpansion( );


 




















 




nzerror nztDecrypt(
 );


 






















 




nzerror nztEnvelope(
 );


 























 





nzerror nztDeEnvelope(

 );


 




















 




nzerror nztKeyedHash(
 );


 

















 




nzerror nztxKeyedHashExpansion(
 );


 

















 



nzerror nztxHashExpansion( );


 
















 




nzerror nztiae_IsAuthEnabled(

 );


 















 




nzerror nztiee_IsEncrEnabled(

 );

 















 




nzerror nztihe_IsHashEnabled(

 );




 




nzerror nztGetIssuerName(


 );





nzerror nztGetSubjectName(


 );






nzerror nztGetBase64Cert(


 );





nzerror nztGetSerialNumber(


 );





nzerror nztGetValidDate(


 );





nzerror nztGetVersion(

 );





nzerror nztGetPublicKey(


 );






nzerror nztGenericDestroy(
 );





nzerror nztSetAppDefaultLocation(

 );





nzerror nztSearchNZDefault(
 );





#line 231 "/oracle/app/oracle/product/10.2/rdbms/public/ociap.h"

 












 




 




 






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































 
 
 
 
typedef sb4 (*OCICallbackInBind)(void *ictxp, OCIBind *bindp, ub4 iter,
                                  ub4 index, void **bufpp, ub4 *alenp,
                                  ub1 *piecep, void **indp);
 
typedef sb4 (*OCICallbackOutBind)(void *octxp, OCIBind *bindp, ub4 iter,
                                 ub4 index, void **bufpp, ub4 **alenp,
                                 ub1 *piecep, void **indp,
                                 ub2 **rcodep);
 
typedef sb4 (*OCICallbackDefine)(void *octxp, OCIDefine *defnp, ub4 iter,
                                 void **bufpp, ub4 **alenp, ub1 *piecep,
                                 void **indp, ub2 **rcodep);

typedef sword (*OCIUserCallback)(void *ctxp, void *hndlp, ub4 type,
                                 ub4 fcode, ub4 when, sword returnCode,
                                 sb4 *errnop, va_list arglist);

typedef sword (*OCIEnvCallbackType)(OCIEnv *env, ub4 mode,
                                   size_t xtramem_sz, void *usrmemp,
                                   OCIUcb *ucbDesc); 

typedef sb4 (*OCICallbackLobRead)(void *ctxp, const void *bufp,
                                             ub4 len, ub1 piece);

typedef sb4 (*OCICallbackLobWrite)(void *ctxp, void *bufp, 
                                          ub4 *lenp, ub1 *piece);



typedef sb4 (*OCICallbackLobRead2)(void *ctxp, const void *bufp, oraub8 len,
                                   ub1 piece, void **changed_bufpp,
                                   oraub8 *changed_lenp);

typedef sb4 (*OCICallbackLobWrite2)(void *ctxp, void *bufp, oraub8 *lenp,
                                    ub1 *piece, void **changed_bufpp,
                                    oraub8 *changed_lenp);

typedef sb4 (*OCICallbackLobArrayRead)(void *ctxp, ub4 array_iter,
                                       const void *bufp, oraub8 len,
                                       ub1 piece, void **changed_bufpp,
                                       oraub8 *changed_lenp);

typedef sb4 (*OCICallbackLobArrayWrite)(void *ctxp, ub4 array_iter,
                                        void *bufp, oraub8 *lenp,
                                        ub1 *piece, void **changed_bufpp,
                                        oraub8 *changed_lenp);



typedef sb4 (*OCICallbackAQEnq)(void *ctxp, void **payload, 
                                void **payload_ind);

typedef sb4 (*OCICallbackAQDeq)(void *ctxp, void **payload, 
                                void **payload_ind);

 
typedef sb4 (*OCICallbackFailover)(void *svcctx, void *envctx,
                                   void *fo_ctx, ub4 fo_type,
                                   ub4 fo_event);

typedef struct
{
  OCICallbackFailover callback_function;
  void *fo_ctx;
} 
OCIFocbkStruct;

 

typedef sword (*OCICallbackStmtCache)(void *ctx, OCIStmt *stmt, ub4 mode);

 
typedef void (*OCIEventCallback)(void *evtctx, OCIEvent *eventhp);




 

sword   OCIInitialize   (ub4 mode, void *ctxp, 
                 void *(*malocfp)(void *ctxp, size_t size),
                 void *(*ralocfp)(void *ctxp, void *memptr, size_t newsize),
                 void   (*mfreefp)(void *ctxp, void *memptr) );

sword   OCITerminate( ub4 mode);

sword   OCIEnvCreate (OCIEnv **envp, ub4 mode, void *ctxp,
                 void *(*malocfp)(void *ctxp, size_t size),
                 void *(*ralocfp)(void *ctxp, void *memptr, size_t newsize),
                 void   (*mfreefp)(void *ctxp, void *memptr),
                 size_t xtramem_sz, void **usrmempp);

sword   OCIEnvNlsCreate (OCIEnv **envp, ub4 mode, void *ctxp,
                 void *(*malocfp)(void *ctxp, size_t size),
                 void *(*ralocfp)(void *ctxp, void *memptr, size_t newsize),
                 void   (*mfreefp)(void *ctxp, void *memptr),
                 size_t xtramem_sz, void **usrmempp,
                 ub2 charset, ub2 ncharset);

sword   OCIFEnvCreate (OCIEnv **envp, ub4 mode, void *ctxp,
                 void *(*malocfp)(void *ctxp, size_t size),
                 void *(*ralocfp)(void *ctxp, void *memptr, size_t newsize),
                 void   (*mfreefp)(void *ctxp, void *memptr),
                 size_t xtramem_sz, void **usrmempp, void *fupg);

sword   OCIHandleAlloc(const void *parenth, void **hndlpp, const ub4 type, 
                       const size_t xtramem_sz, void **usrmempp);

sword   OCIHandleFree(void *hndlp, const ub4 type);


sword   OCIDescriptorAlloc(const void *parenth, void **descpp, 
                           const ub4 type, const size_t xtramem_sz, 
                           void **usrmempp);

sword   OCIDescriptorFree(void *descp, const ub4 type);

sword   OCIEnvInit (OCIEnv **envp, ub4 mode, 
                    size_t xtramem_sz, void **usrmempp);

sword   OCIServerAttach  (OCIServer *srvhp, OCIError *errhp,
                          const OraText *dblink, sb4 dblink_len, ub4 mode);

sword   OCIServerDetach  (OCIServer *srvhp, OCIError *errhp, ub4 mode);

sword   OCISessionBegin  (OCISvcCtx *svchp, OCIError *errhp, OCISession *usrhp,
                          ub4 credt, ub4 mode);

sword   OCISessionEnd   (OCISvcCtx *svchp, OCIError *errhp, OCISession *usrhp, 
                         ub4 mode);

sword   OCILogon (OCIEnv *envhp, OCIError *errhp, OCISvcCtx **svchp, 
                  const OraText *username, ub4 uname_len, 
                  const OraText *password, ub4 passwd_len, 
                  const OraText *dbname, ub4 dbname_len);

sword   OCILogon2 (OCIEnv *envhp, OCIError *errhp, OCISvcCtx **svchp,
                  const OraText *username, ub4 uname_len,
                  const OraText *password, ub4 passwd_len,
                  const OraText *dbname, ub4 dbname_len,
                  ub4 mode);

sword   OCILogoff (OCISvcCtx *svchp, OCIError *errhp);


sword   OCIPasswordChange   (OCISvcCtx *svchp, OCIError *errhp, 
                             const OraText *user_name, ub4 usernm_len, 
                             const OraText *opasswd, ub4 opasswd_len, 
                             const OraText *npasswd, ub4 npasswd_len, 
                             ub4 mode);

sword   OCIStmtPrepare   (OCIStmt *stmtp, OCIError *errhp, const OraText *stmt,
                          ub4 stmt_len, ub4 language, ub4 mode);

sword OCIStmtPrepare2 ( OCISvcCtx *svchp, OCIStmt **stmtp, OCIError *errhp,
                     const OraText *stmt, ub4 stmt_len, const OraText *key,
                     ub4 key_len, ub4 language, ub4 mode);

sword OCIStmtRelease ( OCIStmt *stmtp, OCIError *errhp, const OraText *key,
                       ub4 key_len, ub4 mode);

sword   OCIBindByPos  (OCIStmt *stmtp, OCIBind **bindp, OCIError *errhp,
                       ub4 position, void *valuep, sb4 value_sz,
                       ub2 dty, void *indp, ub2 *alenp, ub2 *rcodep,
                       ub4 maxarr_len, ub4 *curelep, ub4 mode);

sword   OCIBindByName   (OCIStmt *stmtp, OCIBind **bindp, OCIError *errhp,
                         const OraText *placeholder, sb4 placeh_len, 
                         void *valuep, sb4 value_sz, ub2 dty, 
                         void *indp, ub2 *alenp, ub2 *rcodep, 
                         ub4 maxarr_len, ub4 *curelep, ub4 mode);

sword   OCIBindObject  (OCIBind *bindp, OCIError *errhp, const OCIType *type, 
                        void **pgvpp, ub4 *pvszsp, void **indpp, 
                        ub4 *indszp);

sword   OCIBindDynamic   (OCIBind *bindp, OCIError *errhp, void *ictxp,
                          OCICallbackInBind icbfp, void *octxp,
                          OCICallbackOutBind ocbfp);

sword   OCIBindArrayOfStruct   (OCIBind *bindp, OCIError *errhp, 
                                ub4 pvskip, ub4 indskip,
                                ub4 alskip, ub4 rcskip);

sword   OCIStmtGetPieceInfo   (OCIStmt *stmtp, OCIError *errhp, 
                               void **hndlpp, ub4 *typep,
                               ub1 *in_outp, ub4 *iterp, ub4 *idxp, 
                               ub1 *piecep);

sword   OCIStmtSetPieceInfo   (void *hndlp, ub4 type, OCIError *errhp, 
                               const void *bufp, ub4 *alenp, ub1 piece, 
                               const void *indp, ub2 *rcodep);

sword   OCIStmtExecute  (OCISvcCtx *svchp, OCIStmt *stmtp, OCIError *errhp, 
                         ub4 iters, ub4 rowoff, const OCISnapshot *snap_in, 
                         OCISnapshot *snap_out, ub4 mode);

sword   OCIDefineByPos  (OCIStmt *stmtp, OCIDefine **defnp, OCIError *errhp,
                         ub4 position, void *valuep, sb4 value_sz, ub2 dty,
                         void *indp, ub2 *rlenp, ub2 *rcodep, ub4 mode);

sword   OCIDefineObject  (OCIDefine *defnp, OCIError *errhp, 
                          const OCIType *type, void **pgvpp, 
                          ub4 *pvszsp, void **indpp, ub4 *indszp);

sword   OCIDefineDynamic   (OCIDefine *defnp, OCIError *errhp, void *octxp,
                            OCICallbackDefine ocbfp);

sword   OCIRowidToChar  (OCIRowid *rowidDesc, OraText *outbfp, ub2 *outbflp,
                         OCIError *errhp);

sword   OCIDefineArrayOfStruct  (OCIDefine *defnp, OCIError *errhp, ub4 pvskip,
                                 ub4 indskip, ub4 rlskip, ub4 rcskip);

sword   OCIStmtFetch   (OCIStmt *stmtp, OCIError *errhp, ub4 nrows, 
                        ub2 orientation, ub4 mode);

sword   OCIStmtFetch2   (OCIStmt *stmtp, OCIError *errhp, ub4 nrows, 
                        ub2 orientation, sb4 scrollOffset, ub4 mode);

sword   OCIStmtGetBindInfo   (OCIStmt *stmtp, OCIError *errhp, ub4 size, 
                              ub4 startloc,
                              sb4 *found, OraText *bvnp[], ub1 bvnl[],
                              OraText *invp[], ub1 inpl[], ub1 dupl[],
                              OCIBind **hndl);

sword   OCIDescribeAny  (OCISvcCtx *svchp, OCIError *errhp, 
                         void *objptr, 
                         ub4 objnm_len, ub1 objptr_typ, ub1 info_level,
                         ub1 objtyp, OCIDescribe *dschp);

sword   OCIParamGet (const void *hndlp, ub4 htype, OCIError *errhp, 
                     void **parmdpp, ub4 pos);

sword   OCIParamSet(void *hdlp, ub4 htyp, OCIError *errhp, const void *dscp,
                    ub4 dtyp, ub4 pos);

sword   OCITransStart  (OCISvcCtx *svchp, OCIError *errhp, 
                        uword timeout, ub4 flags );

sword   OCITransDetach  (OCISvcCtx *svchp, OCIError *errhp, ub4 flags );

sword   OCITransCommit  (OCISvcCtx *svchp, OCIError *errhp, ub4 flags);

sword   OCITransRollback  (OCISvcCtx *svchp, OCIError *errhp, ub4 flags);

sword   OCITransPrepare (OCISvcCtx *svchp, OCIError *errhp, ub4 flags);

sword   OCITransMultiPrepare (OCISvcCtx *svchp, ub4 numBranches, 
                              OCITrans **txns, OCIError **errhp);

sword   OCITransForget (OCISvcCtx *svchp, OCIError *errhp, ub4 flags);

sword   OCIErrorGet   (void *hndlp, ub4 recordno, OraText *sqlstate,
                       sb4 *errcodep, OraText *bufp, ub4 bufsiz, ub4 type);

sword   OCILobAppend  (OCISvcCtx *svchp, OCIError *errhp, 
                       OCILobLocator *dst_locp,
                       OCILobLocator *src_locp);

sword   OCILobAssign (OCIEnv *envhp, OCIError *errhp, 
                      const OCILobLocator *src_locp, 
                      OCILobLocator **dst_locpp);

sword   OCILobCharSetForm (OCIEnv *envhp, OCIError *errhp, 
                           const OCILobLocator *locp, ub1 *csfrm);

sword   OCILobCharSetId (OCIEnv *envhp, OCIError *errhp, 
                         const OCILobLocator *locp, ub2 *csid);

sword   OCILobCopy (OCISvcCtx *svchp, OCIError *errhp, OCILobLocator *dst_locp,
                    OCILobLocator *src_locp, ub4 amount, ub4 dst_offset, 
                    ub4 src_offset);

sword OCILobCreateTemporary(OCISvcCtx          *svchp,
                            OCIError           *errhp,
                            OCILobLocator      *locp,
                            ub2                 csid,
                            ub1                 csfrm,
                            ub1                 lobtype,
                            boolean             cache,
                            OCIDuration         duration);


sword OCILobClose( OCISvcCtx        *svchp,
                   OCIError         *errhp,
                   OCILobLocator    *locp );


sword   OCILobDisableBuffering (OCISvcCtx      *svchp,
                                OCIError       *errhp,
                                OCILobLocator  *locp);

sword   OCILobEnableBuffering (OCISvcCtx      *svchp,
                               OCIError       *errhp,
                               OCILobLocator  *locp);

sword   OCILobErase (OCISvcCtx *svchp, OCIError *errhp, OCILobLocator *locp,
                      ub4 *amount, ub4 offset);

sword   OCILobFileClose (OCISvcCtx *svchp, OCIError *errhp, 
                         OCILobLocator *filep);

sword   OCILobFileCloseAll (OCISvcCtx *svchp, OCIError *errhp);

sword   OCILobFileExists (OCISvcCtx *svchp, OCIError *errhp, 
                          OCILobLocator *filep,
                          boolean *flag);

sword   OCILobFileGetName (OCIEnv *envhp, OCIError *errhp, 
                           const OCILobLocator *filep, 
                           OraText *dir_alias, ub2 *d_length, 
                           OraText *filename, ub2 *f_length);

sword   OCILobFileIsOpen (OCISvcCtx *svchp, OCIError *errhp, 
                          OCILobLocator *filep,
                          boolean *flag);

sword   OCILobFileOpen (OCISvcCtx *svchp, OCIError *errhp, 
                        OCILobLocator *filep,
                        ub1 mode);

sword   OCILobFileSetName (OCIEnv *envhp, OCIError *errhp, 
                           OCILobLocator **filepp, 
                           const OraText *dir_alias, ub2 d_length, 
                           const OraText *filename, ub2 f_length);

sword   OCILobFlushBuffer (OCISvcCtx       *svchp,
                           OCIError        *errhp,
                           OCILobLocator   *locp,
                           ub4              flag);

sword OCILobFreeTemporary(OCISvcCtx          *svchp,
                          OCIError           *errhp,
                          OCILobLocator      *locp);

sword OCILobGetChunkSize(OCISvcCtx         *svchp,
                         OCIError          *errhp,
                         OCILobLocator     *locp,
                         ub4               *chunksizep);

sword   OCILobGetLength  (OCISvcCtx *svchp, OCIError *errhp, 
                          OCILobLocator *locp,
                          ub4 *lenp);

sword   OCILobIsEqual  (OCIEnv *envhp, const OCILobLocator *x, 
                        const OCILobLocator *y, 
                        boolean *is_equal);

sword OCILobIsOpen( OCISvcCtx     *svchp,
                    OCIError      *errhp,
                    OCILobLocator *locp,
                    boolean       *flag);

sword OCILobIsTemporary(OCIEnv            *envp,
                        OCIError          *errhp,
                        OCILobLocator     *locp,
                        boolean           *is_temporary);

sword   OCILobLoadFromFile (OCISvcCtx *svchp, OCIError *errhp, 
                            OCILobLocator *dst_locp,
                            OCILobLocator *src_filep, 
                            ub4 amount, ub4 dst_offset, 
                            ub4 src_offset);

sword   OCILobLocatorAssign  (OCISvcCtx *svchp, OCIError *errhp, 
                            const OCILobLocator *src_locp, 
                            OCILobLocator **dst_locpp);


sword   OCILobLocatorIsInit (OCIEnv *envhp, OCIError *errhp, 
                             const OCILobLocator *locp, 
                             boolean *is_initialized);

sword   OCILobOpen( OCISvcCtx        *svchp,
                   OCIError         *errhp,
                   OCILobLocator    *locp,
                   ub1               mode );
 
sword   OCILobRead  (OCISvcCtx *svchp, OCIError *errhp, OCILobLocator *locp,
                     ub4 *amtp, ub4 offset, void *bufp, ub4 bufl, void *ctxp,
                     OCICallbackLobRead cbfp, ub2 csid, ub1 csfrm);

sword   OCILobTrim  (OCISvcCtx *svchp, OCIError *errhp, OCILobLocator *locp,
                     ub4 newlen);

sword   OCILobWrite  (OCISvcCtx *svchp, OCIError *errhp, OCILobLocator *locp,
                      ub4 *amtp, ub4 offset, void *bufp, ub4 buflen, ub1 piece,
                      void *ctxp, OCICallbackLobWrite cbfp, ub2 csid,
                      ub1 csfrm);

sword OCILobWriteAppend(OCISvcCtx *svchp, OCIError *errhp, OCILobLocator *lobp,
                        ub4 *amtp, void *bufp, ub4 bufl, ub1 piece, void *ctxp,
                        OCICallbackLobWrite cbfp, ub2 csid, ub1 csfrm);

sword   OCIBreak (void *hndlp, OCIError *errhp);

sword   OCIReset (void *hndlp, OCIError *errhp);

sword   OCIServerVersion  (void *hndlp, OCIError *errhp, OraText *bufp, 
                           ub4 bufsz,
                           ub1 hndltype);

sword   OCIServerRelease  (void *hndlp, OCIError *errhp, OraText *bufp,
                           ub4 bufsz,
                           ub1 hndltype, ub4 *version);

sword   OCIAttrGet (const void *trgthndlp, ub4 trghndltyp, 
                    void *attributep, ub4 *sizep, ub4 attrtype, 
                    OCIError *errhp);

sword   OCIAttrSet (void *trgthndlp, ub4 trghndltyp, void *attributep,
                    ub4 size, ub4 attrtype, OCIError *errhp);

sword   OCISvcCtxToLda (OCISvcCtx *svchp, OCIError *errhp, Lda_Def *ldap);

sword   OCILdaToSvcCtx (OCISvcCtx **svchpp, OCIError *errhp, Lda_Def *ldap);

sword   OCIResultSetToStmt (OCIResult *rsetdp, OCIError *errhp);

sword OCIFileClose ( void  *hndl, OCIError *err, OCIFileObject *filep );

sword   OCIUserCallbackRegister(void *hndlp, ub4 type, void *ehndlp,
                                    OCIUserCallback callback, void *ctxp,
                                    ub4 fcode, ub4 when, OCIUcb *ucbDesc);

sword   OCIUserCallbackGet(void *hndlp, ub4 type, void *ehndlp,
                               ub4 fcode, ub4 when, OCIUserCallback *callbackp,
                               void **ctxpp, OCIUcb *ucbDesc);

sword   OCISharedLibInit(void *metaCtx, void *libCtx, ub4 argfmt, sword argc,
                         void **argv, OCIEnvCallbackType envCallback);

sword OCIFileExists ( void  *hndl, OCIError *err, OraText *filename,
                     OraText *path, ub1 *flag  );

sword OCIFileFlush( void *hndl, OCIError *err, OCIFileObject *filep  );


sword OCIFileGetLength( void *hndl, OCIError *err, OraText *filename,
                        OraText *path, ubig_ora *lenp  );

sword OCIFileInit ( void *hndl, OCIError *err );

sword OCIFileOpen ( void *hndl, OCIError *err, OCIFileObject **filep,
                    OraText *filename, OraText *path, ub4 mode, ub4 create, 
                    ub4 type );

sword OCIFileRead ( void *hndl, OCIError *err, OCIFileObject *filep,
                    void *bufp, ub4 bufl, ub4 *bytesread );

sword OCIFileSeek ( void *hndl, OCIError *err, OCIFileObject *filep,
                     uword origin, ubig_ora offset, sb1 dir );

sword OCIFileTerm ( void *hndl, OCIError *err );


sword OCIFileWrite ( void *hndl, OCIError *err, OCIFileObject   *filep,
                     void *bufp, ub4 buflen, ub4 *byteswritten );




sword   OCILobCopy2 (OCISvcCtx *svchp, OCIError *errhp, OCILobLocator *dst_locp,
                     OCILobLocator *src_locp, oraub8 amount, oraub8 dst_offset, 
                     oraub8 src_offset);

sword   OCILobErase2 (OCISvcCtx *svchp, OCIError *errhp, OCILobLocator *locp,
                      oraub8 *amount, oraub8 offset);

sword   OCILobGetLength2 (OCISvcCtx *svchp, OCIError *errhp, 
                          OCILobLocator *locp, oraub8 *lenp);

sword   OCILobLoadFromFile2 (OCISvcCtx *svchp, OCIError *errhp, 
                             OCILobLocator *dst_locp,
                             OCILobLocator *src_filep, 
                             oraub8 amount, oraub8 dst_offset, 
                             oraub8 src_offset);

sword   OCILobRead2 (OCISvcCtx *svchp, OCIError *errhp, OCILobLocator *locp,
                     oraub8 *byte_amtp, oraub8 *char_amtp, oraub8 offset,
                     void *bufp, oraub8 bufl, ub1 piece, void *ctxp,
                     OCICallbackLobRead2 cbfp, ub2 csid, ub1 csfrm);

sword   OCILobArrayRead (OCISvcCtx *svchp, OCIError *errhp, ub4 *array_iter,
                         OCILobLocator **lobp_arr, oraub8 *byte_amt_arr,
                         oraub8 *char_amt_arr, oraub8 *offset_arr,
                         void **bufp_arr, oraub8 *bufl_arr, ub1 piece,
                         void *ctxp, OCICallbackLobArrayRead cbfp, ub2 csid,
                         ub1 csfrm);

sword   OCILobTrim2 (OCISvcCtx *svchp, OCIError *errhp, OCILobLocator *locp,
                     oraub8 newlen);

sword   OCILobWrite2 (OCISvcCtx *svchp, OCIError *errhp, OCILobLocator *locp,
                      oraub8 *byte_amtp, oraub8 *char_amtp, oraub8 offset,
                      void *bufp, oraub8 buflen, ub1 piece, void *ctxp, 
                      OCICallbackLobWrite2 cbfp, ub2 csid, ub1 csfrm);

sword   OCILobArrayWrite (OCISvcCtx *svchp, OCIError *errhp, ub4 *array_iter,
                          OCILobLocator **lobp_arr, oraub8 *byte_amt_arr,
                          oraub8 *char_amt_arr, oraub8 *offset_arr,
                          void **bufp_arr, oraub8 *bufl_arr, ub1 piece,
                          void *ctxp, OCICallbackLobArrayWrite cbfp, ub2 csid,
                          ub1 csfrm);

sword OCILobWriteAppend2 (OCISvcCtx *svchp, OCIError *errhp, OCILobLocator *lobp,
                          oraub8 *byte_amtp, oraub8 *char_amtp, void *bufp,
                          oraub8 bufl, ub1 piece, void *ctxp,
                          OCICallbackLobWrite2 cbfp, ub2 csid, ub1 csfrm);

sword OCILobGetStorageLimit (OCISvcCtx *svchp, OCIError *errhp,
                             OCILobLocator *lobp, oraub8 *limitp);





 
sword   OCISecurityInitialize (OCISecurity *sechandle, OCIError *error_handle);

sword   OCISecurityTerminate (OCISecurity *sechandle, OCIError *error_handle);

sword OCISecurityOpenWallet(OCISecurity *osshandle,
                            OCIError *error_handle,
                            size_t wrllen,
                            OraText *wallet_resource_locator,
                            size_t pwdlen,
                            OraText *password,
                            nzttWallet *wallet);

sword OCISecurityCloseWallet(OCISecurity *osshandle,
                             OCIError *error_handle,
                             nzttWallet *wallet);

sword OCISecurityCreateWallet(OCISecurity *osshandle,
                              OCIError *error_handle,
                              size_t wrllen,
                              OraText *wallet_resource_locator,
                              size_t pwdlen,
                              OraText *password,
                              nzttWallet *wallet);

sword OCISecurityDestroyWallet(OCISecurity *osshandle,
                               OCIError *error_handle,
                               size_t wrllen,
                               OraText *wallet_resource_locator,
                               size_t pwdlen,
                               OraText *password);

sword OCISecurityStorePersona(OCISecurity *osshandle,
                              OCIError *error_handle,
                              nzttPersona **persona,
                              nzttWallet *wallet);

sword OCISecurityOpenPersona(OCISecurity *osshandle,
                             OCIError *error_handle,
                             nzttPersona *persona);

sword OCISecurityClosePersona(OCISecurity *osshandle,
                              OCIError *error_handle,
                              nzttPersona *persona);

sword OCISecurityRemovePersona(OCISecurity *osshandle,
                               OCIError *error_handle,
                               nzttPersona **persona);

sword OCISecurityCreatePersona(OCISecurity *osshandle,
                               OCIError *error_handle,
                               nzttIdentType identity_type,
                               nzttCipherType cipher_type,
                               nzttPersonaDesc *desc,
                               nzttPersona **persona);

sword OCISecuritySetProtection(OCISecurity *osshandle,
                               OCIError *error_handle,
                               nzttPersona *persona,
                               nzttcef crypto_engine_function,
                               nztttdufmt data_unit_format,
                               nzttProtInfo *protection_info);

sword OCISecurityGetProtection(OCISecurity *osshandle,
                               OCIError *error_handle,
                               nzttPersona *persona,
                               nzttcef crypto_engine_function,
                               nztttdufmt * data_unit_format_ptr,
                               nzttProtInfo *protection_info);

sword OCISecurityRemoveIdentity(OCISecurity *osshandle,
                                OCIError *error_handle,
                                nzttIdentity **identity_ptr);

sword OCISecurityCreateIdentity(OCISecurity *osshandle,
                                OCIError *error_handle,
                                nzttIdentType type,
                                nzttIdentityDesc *desc,
                                nzttIdentity **identity_ptr);

sword OCISecurityAbortIdentity(OCISecurity *osshandle,
                               OCIError *error_handle,
                               nzttIdentity **identity_ptr);

sword OCISecurityFreeIdentity(OCISecurity *osshandle,
                              OCIError *error_handle,
                              nzttIdentity **identity_ptr);


sword OCISecurityStoreTrustedIdentity(OCISecurity *osshandle,
                                      OCIError *error_handle,
                                      nzttIdentity **identity_ptr,
                                      nzttPersona *persona);

sword OCISecuritySign(OCISecurity *osshandle,
                      OCIError *error_handle,
                      nzttPersona *persona,
                      nzttces signature_state,
                      size_t input_length,
                      ub1 *input,
                      nzttBufferBlock *buffer_block);

sword OCISecuritySignExpansion(OCISecurity *osshandle,
                               OCIError *error_handle,
                               nzttPersona *persona,
                               size_t inputlen,
                               size_t *signature_length);

sword OCISecurityVerify(OCISecurity *osshandle,
                        OCIError *error_handle,
                        nzttPersona *persona,
                        nzttces signature_state,
                        size_t siglen,
                        ub1 *signature,
                        nzttBufferBlock *extracted_message,
                        boolean *verified,
                        boolean *validated,
                        nzttIdentity **signing_party_identity);

sword OCISecurityValidate(OCISecurity *osshandle,
                          OCIError *error_handle,
                          nzttPersona *persona,
                          nzttIdentity *identity,
                          boolean *validated);

sword OCISecuritySignDetached(OCISecurity *osshandle,
                              OCIError *error_handle,
                              nzttPersona *persona,
                              nzttces signature_state,
                              size_t input_length,
                              ub1 * input,
                              nzttBufferBlock *signature);

sword OCISecuritySignDetExpansion(OCISecurity *osshandle,
                                  OCIError *error_handle,
                                  nzttPersona *persona,
                                  size_t input_length,
                                  size_t *required_buffer_length);

sword OCISecurityVerifyDetached(OCISecurity *osshandle,
                                OCIError *error_handle,
                                nzttPersona *persona,
                                nzttces signature_state,
                                size_t data_length,
                                ub1 *data,
                                size_t siglen,
                                ub1 *signature,
                                boolean *verified,
                                boolean *validated,
                                nzttIdentity **signing_party_identity);

sword OCISecurity_PKEncrypt(OCISecurity *osshandle,
                            OCIError *error_handle,
                            nzttPersona *persona,
                            size_t number_of_recipients,
                            nzttIdentity *recipient_list,
                            nzttces encryption_state,
                            size_t input_length,
                            ub1 *input,
                            nzttBufferBlock *encrypted_data);

sword OCISecurityPKEncryptExpansion(OCISecurity *osshandle,
                                    OCIError *error_handle,
                                    nzttPersona *persona,
                                    size_t number_recipients,
                                    size_t input_length,
                                    size_t *buffer_length_required);

sword OCISecurityPKDecrypt(OCISecurity *osshandle,
                           OCIError *error_handle,
                           nzttPersona *persona,
                           nzttces encryption_state,
                           size_t input_length,
                           ub1 *input,
                           nzttBufferBlock *encrypted_data);

sword OCISecurityEncrypt(OCISecurity *osshandle,
                         OCIError *error_handle,
                         nzttPersona *persona,
                         nzttces encryption_state,
                         size_t input_length,
                         ub1 *input,
                         nzttBufferBlock *encrypted_data);

sword OCISecurityEncryptExpansion(OCISecurity *osshandle,
                                  OCIError *error_handle,
                                  nzttPersona *persona,
                                  size_t input_length,
                                  size_t *encrypted_data_length);

sword OCISecurityDecrypt(OCISecurity *osshandle,
                         OCIError *error_handle,
                         nzttPersona *persona,
                         nzttces decryption_state,
                         size_t input_length,
                         ub1 *input,
                         nzttBufferBlock *decrypted_data);

sword OCISecurityEnvelope(OCISecurity *osshandle,
                          OCIError *error_handle,
                          nzttPersona *persona,
                          size_t number_of_recipients,
                          nzttIdentity *identity,
                          nzttces encryption_state,
                          size_t input_length,
                          ub1 *input,
                          nzttBufferBlock *enveloped_data);

sword OCISecurityDeEnvelope(OCISecurity *osshandle,
                            OCIError *error_handle,
                            nzttPersona *persona,
                            nzttces decryption_state,
                            size_t input_length,
                            ub1 *input,
                            nzttBufferBlock *output_message,
                            boolean *verified,
                            boolean *validated,
                            nzttIdentity **sender_identity);

sword OCISecurityKeyedHash(OCISecurity *osshandle,
                           OCIError *error_handle,
                           nzttPersona *persona,
                           nzttces hash_state,
                           size_t input_length,
                           ub1 *input,
                           nzttBufferBlock *keyed_hash);

sword OCISecurityKeyedHashExpansion(OCISecurity *osshandle,
                                    OCIError *error_handle,
                                    nzttPersona *persona,
                                    size_t input_length,
                                    size_t *required_buffer_length);

sword OCISecurityHash(OCISecurity *osshandle,
                      OCIError *error_handle,
                      nzttPersona *persona,
                      nzttces hash_state,
                      size_t input,
                      ub1 *input_length,
                      nzttBufferBlock *hash);

sword OCISecurityHashExpansion(OCISecurity *osshandle,
                               OCIError *error_handle,
                               nzttPersona *persona,
                               size_t input_length,
                               size_t *required_buffer_length);

sword OCISecuritySeedRandom(OCISecurity *osshandle,
                            OCIError *error_handle,
                            nzttPersona *persona,
                            size_t seed_length,
                            ub1 *seed);

sword OCISecurityRandomBytes(OCISecurity *osshandle,
                             OCIError *error_handle,
                             nzttPersona *persona,
                             size_t number_of_bytes_desired,
                             nzttBufferBlock *random_bytes);

sword OCISecurityRandomNumber(OCISecurity *osshandle,
                              OCIError *error_handle,
                              nzttPersona *persona,
                              uword *random_number_ptr);

sword OCISecurityInitBlock(OCISecurity *osshandle,
                           OCIError *error_handle,
                           nzttBufferBlock *buffer_block);

sword OCISecurityReuseBlock(OCISecurity *osshandle,
                            OCIError *error_handle,
                            nzttBufferBlock *buffer_block);

sword OCISecurityPurgeBlock(OCISecurity *osshandle,
                            OCIError *error_handle,
                            nzttBufferBlock *buffer_block);

sword OCISecuritySetBlock(OCISecurity *osshandle,
                          OCIError *error_handle,
                          uword flags_to_set,
                          size_t buffer_length,
                          size_t used_buffer_length,
                          ub1 *buffer,
                          nzttBufferBlock *buffer_block);

sword OCISecurityGetIdentity(OCISecurity   *osshandle,
                             OCIError      *error_handle,
                             size_t         namelen,
                             OraText          *distinguished_name,
                             nzttIdentity **identity);

sword OCIAQEnq(OCISvcCtx *svchp, OCIError *errhp, OraText *queue_name,
                 OCIAQEnqOptions *enqopt, OCIAQMsgProperties *msgprop,
                 OCIType *payload_tdo, void **payload, void **payload_ind, 
                 OCIRaw **msgid, ub4 flags); 

sword OCIAQDeq(OCISvcCtx *svchp, OCIError *errhp, OraText *queue_name,
                 OCIAQDeqOptions *deqopt, OCIAQMsgProperties *msgprop,
                 OCIType *payload_tdo, void **payload, void **payload_ind, 
                 OCIRaw **msgid, ub4 flags); 

sword OCIAQEnqArray(OCISvcCtx *svchp, OCIError *errhp, OraText *queue_name,
                    OCIAQEnqOptions *enqopt, ub4 *iters,
                    OCIAQMsgProperties **msgprop, OCIType *payload_tdo,
                    void **payload, void **payload_ind, OCIRaw **msgid,
                    void *ctxp, OCICallbackAQEnq enqcbfp, ub4 flags);

sword OCIAQDeqArray(OCISvcCtx *svchp, OCIError *errhp, OraText *queue_name,
                    OCIAQDeqOptions *deqopt, ub4 *iters,
                    OCIAQMsgProperties **msgprop, OCIType *payload_tdo,
                    void **payload, void **payload_ind, OCIRaw **msgid,
                    void *ctxp, OCICallbackAQDeq deqcbfp, ub4 flags);

sword OCIAQListen(OCISvcCtx *svchp, OCIError *errhp, 
                      OCIAQAgent **agent_list, ub4 num_agents,
                      sb4 wait, OCIAQAgent **agent,
                      ub4 flags);

sword OCIAQListen2(OCISvcCtx *svchp, OCIError *errhp, 
                   OCIAQAgent **agent_list, ub4 num_agents,
                   OCIAQListenOpts  *lopts, OCIAQAgent **agent, 
                   OCIAQLisMsgProps *lmops, ub4 flags);

sword OCIExtractInit(void *hndl, OCIError *err);

sword OCIExtractTerm(void *hndl, OCIError *err);

sword OCIExtractReset(void *hndl, OCIError *err);

sword OCIExtractSetNumKeys(void *hndl, OCIError *err, uword numkeys);

sword OCIExtractSetKey(void *hndl, OCIError *err, const OraText *name, 
                       ub1 type, ub4 flag, const void *defval, 
                       const sb4 *intrange, const OraText *const *strlist);

sword OCIExtractFromFile(void *hndl, OCIError *err, ub4 flag, 
                         OraText *filename);

sword OCIExtractFromStr(void *hndl, OCIError *err, ub4 flag, OraText *input);

sword OCIExtractToInt(void *hndl, OCIError *err, OraText *keyname, 
                      uword valno, sb4 *retval);

sword OCIExtractToBool(void *hndl, OCIError *err, OraText *keyname, 
                       uword valno, ub1 *retval);

sword OCIExtractToStr(void *hndl, OCIError *err, OraText *keyname, 
                      uword valno, OraText *retval, uword buflen);

sword OCIExtractToOCINum(void *hndl, OCIError *err, OraText *keyname, 
                         uword valno, OCINumber *retval);

sword OCIExtractToList(void *hndl, OCIError *err, uword *numkeys);

sword OCIExtractFromList(void *hndl, OCIError *err, uword index, 
                         OraText **name, 
                         ub1 *type, uword *numvals, void ***values);

 

sword OCIMemoryAlloc(void *hdl, OCIError *err, void **mem,
        OCIDuration dur, ub4 size, ub4 flags);

sword OCIMemoryResize(void *hdl, OCIError *err, void **mem,
                        ub4 newsize, ub4 flags);
                        
sword OCIMemoryFree(void *hdl, OCIError *err, void *mem);

sword OCIContextSetValue(void *hdl, OCIError *err, OCIDuration duration,
                        ub1 *key, ub1 keylen, void *ctx_value);

sword OCIContextGetValue(void *hdl, OCIError *err, ub1 *key,
                        ub1 keylen, void **ctx_value);

sword OCIContextClearValue(void *hdl, OCIError *err, ub1 *key, 
                        ub1 keylen);

sword OCIContextGenerateKey(void *hdl, OCIError *err, ub4 *key);

sword OCIMemorySetCurrentIDs(void *hdl, OCIError *err, 
                             ub4 curr_session_id, ub4 curr_trans_id, 
                             ub4 curr_stmt_id);

sword OCIPicklerTdsCtxInit(OCIEnv *env, OCIError *err, 
                           OCIPicklerTdsCtx **tdsc);

sword OCIPicklerTdsCtxFree(OCIEnv *env, OCIError *err, OCIPicklerTdsCtx *tdsc);

sword OCIPicklerTdsInit(OCIEnv *env, OCIError *err, OCIPicklerTdsCtx *tdsc, 
                                        OCIPicklerTds **tdsh);

sword OCIPicklerTdsFree(OCIEnv *env, OCIError *err, OCIPicklerTds *tdsh);

sword OCIPicklerTdsCreateElementNumber(OCIEnv *env, OCIError *err, 
                                        OCIPicklerTds *tdsh, ub1 prec, 
                                        sb1 scale, OCIPicklerTdsElement *elt);

sword OCIPicklerTdsCreateElementChar(OCIEnv *env, OCIError *err, 
                                     OCIPicklerTds *tdsh, ub2 len, 
                                     OCIPicklerTdsElement *elt);

sword OCIPicklerTdsCreateElementVarchar(OCIEnv *env, OCIError *err, 
                                        OCIPicklerTds *tdsh, ub2 len, 
                                        OCIPicklerTdsElement *elt);

sword OCIPicklerTdsCreateElementRaw(OCIEnv *env, OCIError *err, 
                                    OCIPicklerTds *tdsh, ub2 len, 
                                    OCIPicklerTdsElement *elt);

sword OCIPicklerTdsCreateElement(OCIEnv *env, OCIError *err, 
                                 OCIPicklerTds *tdsh, OCITypeCode dty, 
                                 OCIPicklerTdsElement *elt);

sword OCIPicklerTdsAddAttr(OCIEnv *env, OCIError *err, 
                           OCIPicklerTds *tdsh, OCIPicklerTdsElement elt);

sword OCIPicklerTdsGenerate(OCIEnv *env, OCIError *err, 
                                OCIPicklerTds *tdsh);

sword OCIPicklerTdsGetAttr(OCIEnv *env, OCIError *err, 
                                const OCIPicklerTds *tdsh, ub1  attrno,
                                OCITypeCode *typ, ub2  *len);

sword OCIPicklerFdoInit(OCIEnv *env, OCIError *err, 
                                OCIPicklerFdo **fdoh);

sword OCIPicklerFdoFree(OCIEnv *env, OCIError *err, 
                                OCIPicklerFdo *fdoh);

sword OCIPicklerImageInit(OCIEnv *env, OCIError *err, 
                          OCIPicklerFdo *fdoh, 
                          OCIPicklerTds *tdsh,
                          OCIPicklerImage **imgh);

sword OCIPicklerImageFree(OCIEnv *env, OCIError *err, 
                                OCIPicklerImage *imgh);
 
sword OCIPicklerImageAddScalar(OCIEnv *env, OCIError *err,  
                               OCIPicklerImage *imgh, 
                               void *scalar, ub4  len);
 
sword OCIPicklerImageAddNullScalar(OCIEnv *env, OCIError *err, 
                                OCIPicklerImage *imgh);
 
sword OCIPicklerImageGenerate(OCIEnv *env, OCIError *err, 
                                OCIPicklerImage *imgh);
 
sword OCIPicklerImageGetScalarSize(OCIEnv *env, OCIError *err, 
                                OCIPicklerImage *imgh, 
                                ub4  attrno, ub4  *size);
 
sword OCIPicklerImageGetScalar(OCIEnv *env, OCIError *err, 
                                OCIPicklerImage *imgh, ub4  attrno, 
                                void *buf, ub4  *len, OCIInd *ind);

sword OCIPicklerImageCollBegin(OCIEnv *env, OCIError *err,
                OCIPicklerImage *imgh, const OCIPicklerTds *colltdsh);
 
sword OCIPicklerImageCollAddScalar( OCIEnv *env, OCIError *err,
                OCIPicklerImage *imgh, void *scalar,
                ub4 buflen, OCIInd ind);
 
sword OCIPicklerImageCollEnd(OCIEnv *env, OCIError *err,
                OCIPicklerImage *imgh);
 
 
sword OCIPicklerImageCollBeginScan(OCIEnv *env, OCIError *err,
                OCIPicklerImage *imgh, const OCIPicklerTds *coll_tdsh,
                ub4 attrnum, ub4 startidx, OCIInd *ind);
 
sword OCIPicklerImageCollGetScalarSize(OCIEnv *env, OCIError *err,
                const OCIPicklerTds *coll_tdsh, ub4 *size);
 
sword OCIPicklerImageCollGetScalar(OCIEnv *env, OCIError *err,
                                   OCIPicklerImage *imgh, void *buf,
                                   ub4 *buflen, OCIInd *ind);

sword OCIAnyDataGetType(OCISvcCtx *svchp, OCIError *errhp, OCIAnyData *sdata,
        OCITypeCode *tc, OCIType **type);

sword OCIAnyDataIsNull(OCISvcCtx *svchp, OCIError *errhp, OCIAnyData *sdata,
        boolean *isnull);

sword OCIAnyDataConvert(OCISvcCtx *svchp, OCIError *errhp, OCITypeCode tc,
        OCIType *type, OCIDuration dur, void *ind, void *data_val,
        ub4 len, OCIAnyData **sdata);

sword OCIAnyDataBeginCreate(OCISvcCtx *svchp, OCIError *errhp, OCITypeCode tc,
        OCIType *type, OCIDuration dur, OCIAnyData **sdata);

sword OCIAnyDataDestroy(OCISvcCtx *svchp, OCIError *errhp, OCIAnyData *sdata);

sword OCIAnyDataAttrSet(OCISvcCtx *svchp, OCIError *errhp, OCIAnyData *sdata,
        OCITypeCode tc, OCIType *type, void *ind, void *attr_val,
        ub4 length, boolean is_any);

sword OCIAnyDataCollAddElem(OCISvcCtx *svchp, OCIError *errhp,
        OCIAnyData *sdata, OCITypeCode tc, OCIType *type, void *ind,
        void *attr_val, ub4 length, boolean is_any, boolean last_elem);

sword OCIAnyDataEndCreate(OCISvcCtx *svchp, OCIError *errhp,
                          OCIAnyData *sdata);

sword OCIAnyDataAccess(OCISvcCtx *svchp, OCIError *errhp, OCIAnyData *sdata,
        OCITypeCode tc, OCIType *type, void *ind, void *attr_val,
        ub4 *length);

sword OCIAnyDataGetCurrAttrNum(OCISvcCtx *svchp, OCIError *errhp, 
                               OCIAnyData *sdata, ub4 *attrnum);

sword OCIAnyDataAttrGet(OCISvcCtx *svchp, OCIError *errhp, OCIAnyData *sdata,
  OCITypeCode tc, OCIType *type, void *ind, void *attr_val,
        ub4 *length, boolean is_any);

sword OCIAnyDataCollGetElem(OCISvcCtx *svchp, OCIError *errhp,
  OCIAnyData *sdata,
  OCITypeCode tc, OCIType *type, void *ind, void *celem_val,
  ub4 *length, boolean is_any);


 





























 
sword OCIAnyDataSetBeginCreate(OCISvcCtx *svchp, OCIError *errhp,
     OCITypeCode typecode, const OCIType *type, OCIDuration dur,
     OCIAnyDataSet ** data_set);













 
sword OCIAnyDataSetDestroy(OCISvcCtx *svchp, OCIError *errhp,
     OCIAnyDataSet *data_set);


































 
sword OCIAnyDataSetAddInstance(OCISvcCtx *svchp, OCIError *errhp,
     OCIAnyDataSet *data_set, OCIAnyData **data);
















 
sword OCIAnyDataSetEndCreate(OCISvcCtx *svchp, OCIError *errhp,
     OCIAnyDataSet *data_set);



















 
sword OCIAnyDataSetGetType (OCISvcCtx *svchp, OCIError *errhp,
     OCIAnyDataSet *data_set, OCITypeCode *tc, OCIType **type);













 
sword OCIAnyDataSetGetCount(OCISvcCtx *svchp, OCIError *errhp,
     OCIAnyDataSet *data_set, ub4 *count);
































 
sword OCIAnyDataSetGetInstance(OCISvcCtx *svchp, OCIError *errhp,
     OCIAnyDataSet *data_set, OCIAnyData **data);

 

sword OCIFormatInit(void *hndl, OCIError *err);

sword OCIFormatString(void *hndl, OCIError *err, OraText *buffer,
                      sbig_ora bufferLength, sbig_ora *returnLength,
                      const OraText *formatString, ...);

sword OCIFormatTerm(void *hndl, OCIError *err);

sword OCIFormatTUb1(void);
sword OCIFormatTUb2(void);
sword OCIFormatTUb4(void);
sword OCIFormatTUword(void);
sword OCIFormatTUbig_ora(void);
sword OCIFormatTSb1(void);
sword OCIFormatTSb2(void);
sword OCIFormatTSb4(void);
sword OCIFormatTSword(void);
sword OCIFormatTSbig_ora(void);
sword OCIFormatTEb1(void);
sword OCIFormatTEb2(void);
sword OCIFormatTEb4(void);
sword OCIFormatTEword(void);
sword OCIFormatTChar(void);
sword OCIFormatTText(void);
sword OCIFormatTDouble(void);
sword OCIFormatTDvoid(void);
sword OCIFormatTEnd(void);

 
 








 
OCISvcCtx *xaosvch(OraText *dbname);

 











 
OCISvcCtx *xaoSvcCtx(OraText *dbname);

 











 
OCIEnv *xaoEnv(OraText *dbname);

 





 
int xaosterr(OCISvcCtx *svch, sb4 error);
 
 
 

















































































 
sword OCINlsGetInfo(void *envhp, OCIError *errhp, OraText *buf,
                    size_t buflen, ub2 item);

 
























 
sword OCINlsNumericInfoGet(void *envhp, OCIError *errhp, sb4 *val, ub2 item);

 














 
ub2 OCINlsCharSetNameToId(void *envhp, const oratext *name);

 



















 
sword OCINlsCharSetIdToName(void *envhp, oratext *buf, size_t buflen, ub2 id);

 

































 
sword OCINlsNameMap(void *envhp, oratext *buf, size_t buflen,
                    const oratext *srcbuf, ub4 flag);

 


















 
sword OCIMultiByteToWideChar(void *envhp, OCIWchar *dst, const OraText *src,
                             size_t *rsize);


 





























 
sword OCIMultiByteInSizeToWideChar(void *envhp, OCIWchar *dst,
                                  size_t dstsz, const OraText *src, 
                                  size_t srcsz, size_t *rsize);


 


















 
sword OCIWideCharToMultiByte(void *envhp, OraText *dst, const OCIWchar *src,
                             size_t *rsize);


 





























 
sword OCIWideCharInSizeToMultiByte(void *envhp, OraText *dst,
                                    size_t dstsz, const OCIWchar *src,
                                    size_t srcsz, size_t *rsize);



 











 
boolean OCIWideCharIsAlnum(void *envhp, OCIWchar wc);


 











 
boolean OCIWideCharIsAlpha(void *envhp, OCIWchar wc);


 











 
boolean OCIWideCharIsCntrl(void *envhp, OCIWchar wc);


 











 
boolean OCIWideCharIsDigit(void *envhp, OCIWchar wc);


 













 
boolean OCIWideCharIsGraph(void *envhp, OCIWchar wc);


 











 
boolean OCIWideCharIsLower(void *envhp, OCIWchar wc);


 











 
boolean OCIWideCharIsPrint(void *envhp, OCIWchar wc);


 











 
boolean OCIWideCharIsPunct(void *envhp, OCIWchar wc);


 













 
boolean OCIWideCharIsSpace(void *envhp, OCIWchar wc);


 











 
boolean OCIWideCharIsUpper(void *envhp, OCIWchar wc);


 











 
boolean OCIWideCharIsXdigit(void *envhp, OCIWchar wc);


 












 
boolean OCIWideCharIsSingleByte(void *envhp, OCIWchar wc);


 












 
OCIWchar OCIWideCharToLower(void *envhp, OCIWchar wc);


 












 
OCIWchar OCIWideCharToUpper(void *envhp, OCIWchar wc);


 























 
int OCIWideCharStrcmp(void *envhp, const OCIWchar *wstr1, 
                const OCIWchar *wstr2, int flag);


 




























 
int OCIWideCharStrncmp(void *envhp, const OCIWchar *wstr1, size_t len1,
                 const OCIWchar *wstr2, size_t len2, int flag);


 

















 
size_t OCIWideCharStrcat(void *envhp, OCIWchar *wdststr,
                         const OCIWchar *wsrcstr);


 















 
OCIWchar *OCIWideCharStrchr(void *envhp, const OCIWchar *wstr,
                            OCIWchar wc);


 















 
size_t OCIWideCharStrcpy(void *envhp, OCIWchar *wdststr,
                         const OCIWchar *wsrcstr);


 













 
size_t OCIWideCharStrlen(void *envhp, const OCIWchar *wstr);


 



















 
size_t OCIWideCharStrncat(void *envhp, OCIWchar *wdststr,
                          const OCIWchar *wsrcstr, size_t n);


 


















 
size_t OCIWideCharStrncpy(void *envhp, OCIWchar *wdststr,
                          const OCIWchar *wsrcstr, size_t n);


 















 
OCIWchar *OCIWideCharStrrchr(void *envhp, const OCIWchar *wstr,
                             OCIWchar wc);


 






















 
size_t OCIWideCharStrCaseConversion(void *envhp, OCIWchar *wdststr,
                                    const OCIWchar *wsrcstr, ub4 flag);


 













 
size_t OCIWideCharDisplayLength(void *envhp, OCIWchar wc );


 












 
size_t OCIWideCharMultiByteLength(void *envhp, OCIWchar wc);


 























 
int OCIMultiByteStrcmp(void *envhp, const OraText *str1,
                       const OraText *str2, int flag);


 




























 
int OCIMultiByteStrncmp(void *envhp, const OraText *str1, size_t len1,
                        OraText *str2, size_t len2, int flag);


 

















 
size_t OCIMultiByteStrcat(void *envhp, OraText *dststr,
                          const OraText *srcstr);


 
















 
size_t OCIMultiByteStrcpy(void *envhp, OraText *dststr,
                          const OraText *srcstr);


 











 
size_t OCIMultiByteStrlen(void *envhp, const OraText *str);


 



















 
size_t OCIMultiByteStrncat(void *envhp, OraText *dststr,
                           const OraText *srcstr, size_t n);


 



















 
size_t OCIMultiByteStrncpy(void *envhp, OraText *dststr,
                           const OraText *srcstr, size_t n);


 















 
size_t OCIMultiByteStrnDisplayLength(void *envhp, const OraText *str1,
                                     size_t n);


 





















 
size_t OCIMultiByteStrCaseConversion(void *envhp, OraText *dststr,
                                     const OraText *srcstr, ub4 flag);


 

























 
sword OCICharSetToUnicode(void *envhp, ub2 *dst, size_t dstlen,
                          const OraText *src, size_t  srclen, size_t *rsize);


 




























 
sword OCIUnicodeToCharSet(void *envhp, OraText *dst, size_t dstlen, 
                           const ub2 *src, size_t srclen, size_t *rsize);

 









































 
sword OCINlsCharSetConvert(void *envhp, OCIError *errhp, 
                        ub2 dstid, void *dstp, size_t dstlen,
                        ub2 srcid, const void *srcp, size_t srclen,
                        size_t *rsize);


 














 
boolean OCICharSetConversionIsReplacementUsed(void *envhp);

 


































 
sword OCINlsEnvironmentVariableGet(void  *valp, size_t size, ub2 item,
                                   ub2 charset, size_t *rsize);


 









































 
sword OCIMessageOpen(void *envhp, OCIError *errhp, OCIMsg **msghp,
                      const OraText *product, const OraText *facility, 
                      OCIDuration dur);
 

 























 
OraText *OCIMessageGet(OCIMsg *msgh, ub4 msgno, OraText *msgbuf,
                       size_t buflen);

 

















 
sword OCIMessageClose(void *envhp, OCIError *errhp, OCIMsg *msghp);

 


 



























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































 



 

void OCIThreadProcessInit();

sword OCIThreadInit(void *hndl, OCIError *err);

sword OCIThreadTerm(void *hndl, OCIError *err);

boolean OCIThreadIsMulti();

sword OCIThreadMutexInit(void *hndl, OCIError *err,  
                         OCIThreadMutex **mutex); 

sword OCIThreadMutexDestroy(void *hndl, OCIError *err, 
                            OCIThreadMutex **mutex);

sword OCIThreadMutexAcquire(void *hndl, OCIError *err,
                            OCIThreadMutex *mutex);

sword OCIThreadMutexRelease(void *hndl, OCIError *err,
                            OCIThreadMutex *mutex);

sword OCIThreadKeyInit(void *hndl, OCIError *err, OCIThreadKey **key,
                       OCIThreadKeyDestFunc destFn);

sword OCIThreadKeyDestroy(void *hndl, OCIError *err, 
                          OCIThreadKey **key);

sword OCIThreadKeyGet(void *hndl, OCIError *err, OCIThreadKey *key,
                      void **pValue);

sword OCIThreadKeySet(void *hndl, OCIError *err, OCIThreadKey *key,
                      void *value);

sword OCIThreadIdInit(void *hndl, OCIError *err, OCIThreadId **tid);

sword OCIThreadIdDestroy(void *hndl, OCIError *err, OCIThreadId **tid);

sword OCIThreadIdSet(void *hndl, OCIError *err, 
                     OCIThreadId *tidDest, OCIThreadId *tidSrc);

sword OCIThreadIdSetNull(void *hndl, OCIError *err, OCIThreadId *tid);

sword OCIThreadIdGet(void *hndl, OCIError *err, OCIThreadId *tid);

sword OCIThreadIdSame(void *hndl, OCIError *err,
                      OCIThreadId *tid1, OCIThreadId *tid2,
                      boolean *result);

sword OCIThreadIdNull(void *hndl, OCIError *err,
                      OCIThreadId *tid, boolean *result);

sword OCIThreadHndInit(void *hndl, OCIError *err, OCIThreadHandle **thnd);

sword OCIThreadHndDestroy(void *hndl, OCIError *err, OCIThreadHandle **thnd);

sword OCIThreadCreate(void *hndl, OCIError *err,
                      void (*start)(void *), void *arg,
                      OCIThreadId *tid, OCIThreadHandle *tHnd);

sword OCIThreadJoin(void *hndl, OCIError *err, OCIThreadHandle *tHnd);

sword OCIThreadClose(void *hndl, OCIError *err, OCIThreadHandle *tHnd);

sword OCIThreadHandleGet(void *hndl, OCIError *err, OCIThreadHandle *tHnd);
 

 

typedef sword (*OCIBindRowCallback)(void *ctx);
typedef sword (*OCIFetchRowCallback)(void *ctx);

 

 

typedef ub4 (*OCISubscriptionNotify)(void *ctx, OCISubscription *subscrhp, 
                                     void *pay, ub4 payl, 
                                     void *desc, ub4 mode);

sword OCISubscriptionRegister(OCISvcCtx *svchp, OCISubscription **subscrhpp, 
                              ub2 count, OCIError *errhp, ub4 mode);


sword OCISubscriptionPost(OCISvcCtx *svchp, OCISubscription **subscrhpp, 
                              ub2 count, OCIError *errhp, ub4 mode);

sword OCISubscriptionUnRegister(OCISvcCtx *svchp, OCISubscription *subscrhp, 
                              OCIError *errhp, ub4 mode);

sword OCISubscriptionDisable(OCISubscription *subscrhp, 
                           OCIError *errhp, ub4 mode);

sword OCISubscriptionEnable(OCISubscription *subscrhp, 
                          OCIError *errhp, ub4 mode);

 

 
 
sword OCIDateTimeGetTime(void *hndl, OCIError *err, OCIDateTime *datetime, 
                         ub1 *hr, ub1 *mm, ub1 *ss, ub4 *fsec);

sword OCIDateTimeGetDate(void *hndl, OCIError *err,  const OCIDateTime *date, 
                 sb2 *yr, ub1 *mnth, ub1 *dy );

sword OCIDateTimeGetTimeZoneOffset(void *hndl,OCIError *err,
                                   const OCIDateTime *datetime,
                                   sb1 *hr,sb1 *mm);

sword OCIDateTimeConstruct(void  *hndl,OCIError *err,OCIDateTime *datetime,
               sb2 yr,ub1 mnth,ub1 dy,ub1 hr,ub1 mm,ub1 ss,ub4 fsec,
               OraText  *timezone,size_t timezone_length);

sword OCIDateTimeSysTimeStamp(void *hndl, OCIError *err, 
                              OCIDateTime *sys_date );

sword OCIDateTimeAssign(void *hndl, OCIError *err, const OCIDateTime *from, 
                       OCIDateTime *to);

sword OCIDateTimeToText(void *hndl, OCIError *err, const OCIDateTime *date, 
                        const OraText *fmt, ub1 fmt_length, ub1 fsprec, 
                        const OraText *lang_name, size_t lang_length, 
                        ub4 *buf_size, OraText *buf );

sword OCIDateTimeFromText(void *hndl, OCIError *err, const OraText *date_str, 
             size_t dstr_length, const OraText *fmt, ub1 fmt_length,
             const OraText *lang_name, size_t lang_length, OCIDateTime *date );

sword OCIDateTimeCompare(void *hndl, OCIError *err, const OCIDateTime *date1, 
                     const OCIDateTime *date2,  sword *result );

sword OCIDateTimeCheck(void *hndl, OCIError *err, const OCIDateTime *date, 
                 ub4 *valid );

sword OCIDateTimeConvert(void *hndl, OCIError *err, OCIDateTime *indate,
                                OCIDateTime *outdate);

sword OCIDateTimeSubtract(void *hndl, OCIError *err, OCIDateTime *indate1, 
                OCIDateTime *indate2,    OCIInterval *inter);

sword OCIDateTimeIntervalAdd(void *hndl, OCIError *err, OCIDateTime *datetime,
         OCIInterval *inter, OCIDateTime *outdatetime);

sword OCIDateTimeIntervalSub(void *hndl, OCIError *err, OCIDateTime *datetime,
         OCIInterval *inter, OCIDateTime *outdatetime);

sword OCIIntervalSubtract(void *hndl, OCIError *err, OCIInterval *minuend, 
                            OCIInterval *subtrahend, OCIInterval *result );

sword OCIIntervalAdd(void *hndl, OCIError *err, OCIInterval *addend1, 
                        OCIInterval *addend2, OCIInterval *result );

sword OCIIntervalMultiply(void *hndl, OCIError *err, const OCIInterval *inter,
                        OCINumber *nfactor, OCIInterval *result );

sword OCIIntervalDivide(void *hndl, OCIError *err, OCIInterval *dividend, 
                OCINumber *divisor, OCIInterval *result );

sword OCIIntervalCompare(void *hndl, OCIError *err, OCIInterval *inter1, 
                        OCIInterval *inter2, sword *result );

sword OCIIntervalFromNumber(void *hndl, OCIError *err, OCIInterval *inter, 
                        OCINumber *number);

sword OCIIntervalFromText( void *hndl, OCIError *err, const OraText *inpstr, 
                size_t str_len, OCIInterval *result );

sword OCIIntervalToText( void *hndl, OCIError *err, const OCIInterval *inter,
                         ub1 lfprec, ub1 fsprec, 
                        OraText *buffer, size_t buflen, size_t *resultlen );

sword OCIIntervalToNumber(void *hndl, OCIError *err,const OCIInterval *inter, 
                        OCINumber *number);

sword OCIIntervalCheck(void *hndl, OCIError *err, const OCIInterval *interval,
                         ub4 *valid );

sword OCIIntervalAssign(void *hndl, OCIError *err, const OCIInterval *ininter,
                        OCIInterval *outinter );

sword OCIIntervalSetYearMonth(void *hndl, OCIError *err, sb4 yr, sb4 mnth,
                        OCIInterval *result );

sword OCIIntervalGetYearMonth(void *hndl, OCIError *err, sb4 *yr, sb4 *mnth,
                        const OCIInterval *result );

sword OCIIntervalSetDaySecond(void *hndl, OCIError *err, sb4 dy, sb4 hr,
                        sb4 mm, sb4 ss, sb4 fsec, OCIInterval *result );

sword OCIIntervalGetDaySecond(void *hndl, OCIError *err, sb4 *dy, sb4 *hr,
                     sb4 *mm, sb4 *ss, sb4 *fsec, const OCIInterval *result );

sword OCIDateTimeToArray(void *hndl, OCIError *err,
                         const OCIDateTime *datetime, const OCIInterval *reftz,
                         ub1 *outarray, ub4 *len, ub1 fsprec);

sword OCIDateTimeFromArray(void *hndl, OCIError *err, ub1 *inarray, ub4 len,
                           ub1 type, OCIDateTime *datetime,
                           const OCIInterval *reftz, ub1 fsprec);

sword OCIDateTimeGetTimeZoneName(void *hndl, OCIError *err,
                                 const OCIDateTime *datetime, 
                                 ub1 *buf, ub4 *buflen);

sword OCIIntervalFromTZ(void *hndl, OCIError *err, const oratext *inpstring,
                        size_t str_len, OCIInterval *result);

 

 
sword OCIConnectionPoolCreate(OCIEnv *envhp, OCIError *errhp, OCICPool *poolhp,
                              OraText **poolName, sb4 *poolNameLen,  
                              const OraText *dblink, sb4 dblinkLen,
                              ub4 connMin, ub4 connMax, ub4 connIncr,
                              const OraText *poolUserName, sb4 poolUserLen,
                              const OraText *poolPassword, sb4 poolPassLen,
                              ub4 mode);

sword OCIConnectionPoolDestroy(OCICPool *poolhp,
                               OCIError *errhp, ub4 mode);

 

 

sword OCISessionPoolCreate (OCIEnv *envhp, OCIError *errhp, OCISPool *spoolhp, 
                            OraText **poolName, ub4 *poolNameLen, 
                            const OraText *connStr, ub4 connStrLen,
                            ub4 sessMin, ub4 sessMax, ub4 sessIncr,
                            OraText *userid, ub4 useridLen,
                            OraText *password, ub4 passwordLen,
                            ub4 mode);
                                                  
sword OCISessionPoolDestroy (OCISPool *spoolhp,
                             OCIError *errhp,
                             ub4 mode);
                             
sword OCISessionGet (OCIEnv *envhp, OCIError *errhp, OCISvcCtx **svchp,
                     OCIAuthInfo *authhp,
                     OraText *poolName, ub4 poolName_len, 
                     const OraText *tagInfo, ub4 tagInfo_len,
                     OraText **retTagInfo, ub4 *retTagInfo_len,
                     boolean *found, ub4 mode);

sword OCISessionRelease (OCISvcCtx *svchp, OCIError *errhp,
                         OraText *tag, ub4 tag_len,
                         ub4 mode);

 

 


sword OCIAppCtxSet(void * sesshndl, void *nsptr, ub4 nsptrlen,
                   void *attrptr,  ub4 attrptrlen,
                   void *valueptr, ub4 valueptrlen,
                   OCIError *errhp, ub4 mode);

sword OCIAppCtxClearAll(void *sesshndl, void *nsptr, ub4 nsptrlen,
                        OCIError *errhp, ub4 mode);

 
sword OCIPing (OCISvcCtx *svchp, OCIError *errhp, ub4 mode);

 

sword OCIKerbAttrSet(OCISession *trgthndlp, ub4 cred_use, ub1 *ftgt_ticket, 
                     ub4 ticket_len, ub1 *session_key, ub4 skey_len, 
                     ub2 ftgt_keytype, ub4 ftgt_ticket_flags, 
                     sb4 ftgt_auth_time, sb4 ftgt_start_time, 
                     sb4 ftgt_end_time, sb4 ftgt_renew_time, 
                     oratext *ftgt_client_principal, 
                     ub4 ftgt_client_principal_len, oratext *ftgt_client_realm,
                     ub4 ftgt_client_realm_len, OCIError *errhp);

 

 

sword OCIDBStartup (OCISvcCtx     *svchp,
                    OCIError      *errhp,
                    OCIAdmin      *admhp,
                    ub4            mode,
                    ub4            flags);

sword OCIDBShutdown(OCISvcCtx     *svchp,
                    OCIError      *errhp,
                    OCIAdmin      *admhp,
                    ub4            mode);

 

 
void OCIClientVersion(sword *major_version,
                      sword *minor_version,
                      sword *update_num,
                      sword *patch_num,
                      sword *port_update_num);
 

 

sword OCIInitEventHandle(OCIError *errhp, 
                         OCIEvent *event,
                         text     *str,
                         ub4       size);

 



 

             
#line 10406 "/oracle/app/oracle/product/10.2/rdbms/public/ociap.h"

#line 2706 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"

#line 1 "/oracle/app/oracle/product/10.2/rdbms/public/ocixmldb.h"
 
 
































 




 










 




 
struct xmlctx; typedef struct xmlctx xmlctx;


typedef enum 
{
  XCTXINIT_OCIDUR  = 1,
  XCTXINIT_ERRHDL  = 2
} ocixmldbpname;

typedef struct ocixmldbparam
{
  ocixmldbpname   name_ocixmldbparam;
  void           *value_ocixmldbparam;
} ocixmldbparam;





 




 










































 

struct xmlctx *OCIXmlDbInitXmlCtx(OCIEnv *, OCISvcCtx *, OCIError *, 
                            ocixmldbparam *, int);

void    OCIXmlDbFreeXmlCtx(struct xmlctx *xctx);


 


#line 2709 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"


#line 1 "/oracle/app/oracle/product/10.2/rdbms/public/oci8dp.h"


 

 
 
































 



















 

 

typedef struct OCIDirPathCtx      OCIDirPathCtx;                   
typedef struct OCIDirPathFuncCtx  OCIDirPathFuncCtx;      
typedef struct OCIDirPathColArray OCIDirPathColArray;         
typedef struct OCIDirPathStream   OCIDirPathStream;                 
typedef struct OCIDirPathDesc     OCIDirPathDesc;   

                  

                  




     










 
     




            




      




           


 


   







 

 












 
sword
OCIDirPathAbort( OCIDirPathCtx *dpctx, OCIError *errhp );












 
sword
OCIDirPathDataSave( OCIDirPathCtx *dpctx, OCIError *errhp, ub4 action );











 
sword
OCIDirPathFinish( OCIDirPathCtx *dpctx, OCIError  *errhp );











 
sword
OCIDirPathFlushRow( OCIDirPathCtx *dpctx, OCIError  *errhp );











 
sword
OCIDirPathPrepare( OCIDirPathCtx *dpctx, OCISvcCtx *svchp,
                      OCIError  *errhp );












 
sword
OCIDirPathLoadStream( OCIDirPathCtx *dpctx, OCIDirPathStream *dpstr,
                         OCIError      *errhp );


 












 
sword
OCIDirPathColArrayEntryGet( OCIDirPathColArray *dpca, OCIError *errhp,
                              ub4 rownum, ub2 colIdx, ub1 **cvalpp, ub4 *clenp,
                              ub1 *cflgp );












 
sword
OCIDirPathColArrayEntrySet( OCIDirPathColArray *dpca, OCIError *errhp,
                               ub4 rownum, ub2 colIdx, ub1 *cvalp, ub4 clen,
                               ub1 cflg );














 
sword
OCIDirPathColArrayRowGet( OCIDirPathColArray *dpca, OCIError *errhp,
                         ub4 rownum, ub1 ***cvalppp, ub4 **clenpp,
                         ub1 **cflgpp );













 
sword
OCIDirPathColArrayReset( OCIDirPathColArray *dpca, OCIError *errhp );












 
sword
OCIDirPathColArrayToStream( OCIDirPathColArray *dpca,  OCIDirPathCtx *dpctx,
                               OCIDirPathStream   *dpstr, OCIError      *errhp,
                               ub4 rowcnt, ub4 rowoff );



 










 
sword
OCIDirPathStreamReset( OCIDirPathStream *dpstr, OCIError *errhp );

#line 2713 "/oracle/app/oracle/product/10.2/rdbms/public/oci.h"







}


#line 6 "/hss/opt/opthss/src/bill/src/liboci/TOCIQuery.h"
#line 1 "/hss/opt/opthss/src/bill/src/liboci/exception.h"
  



class TException
{
public:
  TException();
  TException(const char* err);
  virtual ~TException();
  
  virtual char* GetErrMsg() const;
private:
  char errMsg[1024+1];
};
#pragma push binding
#pragma binding default
#line 1 "/usr/include/strings.h"
 







 



    










extern "C" {








#line 49 "/usr/include/strings.h"


      
#    pragma builtin_milli ffs  
#    pragma extern ffs

#      pragma builtin index
#      pragma extern index


#      pragma builtin rindex
#      pragma extern rindex


#      pragma builtin bcopy 
#      pragma extern bcopy 


#      pragma builtin bcmp 
#      pragma extern bcmp 


#      pragma builtin bzero 
#      pragma extern bzero 




     extern char *index(const char *, int);
     extern char *rindex(const char *, int);
     extern void bcopy(const void *, void *, size_t);
     extern int bcmp(const void *, const void *, size_t);
     extern void bzero(void *, size_t);

	
 


          
#        pragma extern strcasecmp, strncasecmp 


       extern int strcasecmp(const char *, const char *);
       extern int strncasecmp(const char *, const char *, size_t);

     extern int ffs(int);
#line 104 "/usr/include/strings.h"


}


#pragma pop
#line 18 "/hss/opt/opthss/src/bill/src/liboci/exception.h"


#line 8 "/hss/opt/opthss/src/bill/src/liboci/TOCIQuery.h"


typedef signed int dword;
const int PREFETCH_ROWS = 200;						
const	int MAX_STRING_VALUE_LENGTH = 255;			
const	int MAX_LOB_BUFFER_LENGTH = 1024;			
const	int MAX_ERRMSG_LENGTH = 1024;					
const	int MAX_SQLSTMT_LENGTH = 1024;				

const   int MAX_PARAMS_COUNT = 150;     
const	int MAX_ERR_CAT_LENGTH = 50;					
const	int LOB_FLUSH_BUFFER_SIZE = 400*1024;		


const	char* const ERR_GENERAL = "General Error: %s"; 
const	char* const ERR_INDEX_OUT_OF_BOUND = "%s";    
const	char* const ERR_DB_INIT = "OCI: OCI handles init fail in TDatabase constructor: @line:%d";
const	char* const ERR_SET_LOGIN = "OCI: You can only set login infomation on disconnect status: line %d";
const	char* const ERR_CONNECT_NO_LOGIN_INFO = "No login information provided before Connect(), call SetLogin first, line:%d";
const	char* const ERR_NO_DATASET = "OCI: function:%s , Result Dataset is on Bof/Eof. field:%s"; 
const	char* const ERR_DATA_TYPE_CONVERT = "Data type convertion error: field:%s data type:%d can not be access by %s"; 
const	char* const ERR_NOMORE_MEMORY_BE_ALLOCATED = "no more memory can be allocate when :%s, source code:%d"; 
const	char* const ERR_FILE_IO = "%s: can not open file:%s"; 
const	char* const ERR_MEM_BUFFER_IO = "asBlobWriter() error: read from file to buffer, field:%s, file:%s, @line:%d"; 
const	char* const ERR_DATA_TYPE_NOT_SUPPORT = "field:%s, datatype:%d not yet supported"; 
const	char* const ERR_PARAM_NOT_EXISTS = "param:%s does not exists."; 
const	char* const ERR_FIELD_NOT_EXISTS = "field:%s does not exists.";
const	char* const ERR_INVALID_METHOD_CALL	= "%s: invalid call method:%s";
const	char* const ERR_CAPABILITY_NOT_YET_SUPPORT = "capability not support yet:%s"; 
const	char* const ERR_READ_PARAM_DATA = "read parameter value data type error, parameter name:%s, method:%s";


const char* const NULL_STRING = "";
const int NULL_NUMBER = 0;

 
class TOCIException;
class TOCIDatabase;
class TOCIQuery;
class TOCIField;
class TOCIParam;
class TOCISession;
class TOCIDirPath;	

class TOCIException : public TException
{
public:
	char *getErrMsg() const;
	char *getErrSrc() const;
	int getErrCode() const;

public:
	TOCIException(sword errNumb, OCIError *err, char const *cat, char const *sql);
	TOCIException(int errNumb, const char* errFormat, ...);
	TOCIException(const char *sql, const char* errFormat, ...);	
	~TOCIException();

private:
	char	errCategory[MAX_ERR_CAT_LENGTH+1];	
	text	errMessage[MAX_ERRMSG_LENGTH+1];		
	char	errSQL[MAX_SQLSTMT_LENGTH+1];			
	int	errNo;										
	int	m_iErrCode;
};

class TOCIDatabase
{
friend class TOCIQuery;
friend class TOCISession;
friend class TOCIDirPath;
public:

public:
	TOCIDatabase();
	~TOCIDatabase();
	void setLogin(char *user, char *password, char *tnsString) ;
	bool connect();
	bool connect(char *usr, char *pwd, char *tns) ;
	void disconnect();
	void commit();
	void rollback();
	OCISession *hUser;
	
	OCISvcCtx *hDBSvc;		

private:
	char *usr, *pwd, *tns;	
	bool fConnected;			
	sword fErrorNo;						
	void checkError() ;					
	
	OCIError *hDBErr;
	
	OCIEnv *hEnv;
	OCIServer *hSvr;
};

class TOCIParam
{
friend class TOCIQuery;
public:
	~TOCIParam();
	char	*name;

	int		asInteger();	
	double	asFloat();
	long		asLong();
	char		*asString();
	bool		isNULL();
	TOCIParam();
private:
	ub2		dataType;
	
	int		intValue;
	double	dblValue;			
	long		longValue;			
	char		*stringValue;		
	
	int    * intArray;    
	double * dblArray;    
	long   * longArray;  
	char ** stringArray; 
	int   stringSize;    
	
	bool		fIsOutput;			
	sb2		indicator;			
	OCIBind  *hBind;
};

class TOCIField
{
friend class TOCIQuery;

public:	
	~TOCIField(); 
	char	*name;				
	long	size;					
	long	type;					
	int	precision;			
	int	scale;				
	bool	nullable;			

	bool		isNULL();			
	char		*asString();
	double	asFloat();
	int		asInteger();
	long		asLong();
	
	void		asBlobFile(const char *fileName);			
	void		loadFromFile(const char *fileName);			
	void		loadFromBuffer(unsigned char *buf, unsigned int bufLength);	
	void		asBlobBuffer(unsigned char* &buf, unsigned int *bufLength);	
	
	
	char		*asDateTimeString();	
	void		asDateTime(int &year, int &month, int &day, int &hour, int &minute, int &second); 
	TOCIField();
private:
	
	void		asDateTimeInternal(int &year, int &month, int &day, int &hour, int &minute, int &second); 
	TOCIQuery *fParentQuery;					
	
	ub1	fStrBuffer[MAX_STRING_VALUE_LENGTH];	
	ub1	*fDataBuf;						
	OCILobLocator *hBlob;				
	sb2	*fDataIndicator;				

	ub2   fReturnDataLen;				
	ub2	fInternalType;					
	ub2	fRequestType;					
	OCIDefine *hDefine;					
	int	  iBlobBufCnt;					
};

class TOCIQuery
{
friend class TOCIField;

public:
	
	void close();													
	void setSQL(const char *inSqlstmt);								
	void open(int prefetchRows=PREFETCH_ROWS);			
	bool next();													
	bool execute(int iters=1);	                          
	bool commit();													
	bool rollback();												

    int executeDebug(int iters=1);
    int  rowsAffected() { return fTotalRowsFetched;};	
	int  getSQLCode() { return fErrorNo;};				

	
	int fieldCount();												
	TOCIField& field(int index)		;						
	TOCIField& field(char const *fieldName) ;						
	
	
	int paramCount();
	TOCIParam& param(int index);								
	TOCIParam& param(char *paramName);						
																		
	void setParameter(const char *paramName, const char* paramValue, bool isOutput = false); 	
	void setParameter(const char *paramName, int paramValue, bool isOutput = false); 
	void setParameter(const char *paramName, double paramValue, bool isOutput = false) ;
	void setParameter(const char *paramName, long paramValue, bool isOutput = false);
	void setParameterNULL(const char *paramName);

	 
    void setLongRawParameter(char *paramName, char* paramValue, bool isOutput = false);
	 
    void setParameter(char *paramName, void* paramValue, int iLen,bool isOutput = false);
	void setCBlobParameter(char *paramName, void* paramValue, int iLen,bool isOutput=false );
	void freeCBlob();

    
	void setParamArray(char const *paramName, char ** paramValue,int iStructSize,int iStrSize ,bool isOutput = false); 	
	void setParamArray(char const *paramName, int * paramValue,int iStructSize, bool isOutput = false); 
	void setParamArray(char const *paramName, double * paramValue, int iStructSize,bool isOutput = false) ;
	void setParamArray(char const *paramName, long * paramValue, int iStructSize,bool isOutput = false);
	 
	void setParamArray(char const *paramName, void ** paramValue,int iStructSize,int iStrSize,  bool isOutput=false);
	
	TOCIQuery(TOCIDatabase *oradb);
	TOCIQuery(TOCIDatabase *oradb,TOCISession *session);
	~TOCIQuery();
	
private:
	char *fSqlStmt;						
	ub2 fStmtType;							
	bool fActivated;						

	unsigned	fFetched;					
	unsigned	fPrefetchRows;				
	unsigned	fCurrRow;					
	unsigned	fTotalRowsFetched;		

	int fFieldCount;						
	TOCIDatabase *db;						
	TOCIField *fieldList;				
	void getFieldsDef();					

	TOCIParam *paramByName(const char *paramName);
	
	void checkError() ;					

	int fParamCount;						
	TOCIParam *paramList;				
	void getParamsDef();					
	int nTransTimes;						

	
	OCIStmt *hStmt;						
	OCIError *hErr;						
	sword fErrorNo;						
	bool fEof;								
	bool fBof;								
	bool fOpened;							
	OCILobLocator *hBlob;				



};

class TOCISession
{	
public:
	TOCISession(TOCIDatabase *pDB);
	~TOCISession();
	
	void sessionBegin();
	void sessionEnd();

private:
	
	OCISvcCtx	*m_hSrvCtx;
	OCISession	*m_hSession;
	OCIError	*m_hError;
	
	bool	m_bActive;
	
	int	m_iErrorNo;
	
	void checkError();

friend	class TOCIDirPath;
friend  class TOCIQuery;	
};

#line 6 "/hss/opt/opthss/src/bill/src/public/IpcKey.h"

class IpcKeyMgr {
  public:
    






 
    static long getIpcKey (int _iBillFlowID, char const * _sIpcName);
    static long getIpcKeyEx (int _iBillFlowID, char const * _sIpcName);
	static long getIpcKey(bool bForceBillFlow,int _iBillFlowID, char const * _sIpcName);
  static long getNextIpcKey(int iHostID,char const * pUserName,char const * _sIpcName,long lKeyBegin,long lKeyEnd);
    
    static long getIpcKey (char const * _sIpcName);
    
    
    
    static int getHostInfo (char *_sHostName);
	static int getHostInfo (char *_sHostName,TOCIQuery &qry);

    

 
    static bool setIpcKey(int _iBillFlowID, char const * _sIpcName,char const * sRemark, int _iIpcKey);
    static bool setIpcKey(char const * _sIpcName,char const * sRemark);
    static bool seekIpcKey(int iHostID,long lIpcKey);
};



#line 9 "/hss/opt/opthss/src/bill/src/app_guard/mntapi.h"
#line 1 "/hss/opt/opthss/src/bill/src/app_guard/WfPublic.h"
  



#line 1 "/opt/aCC/include_std/stdlib.h"





#line 48 "/opt/aCC/include_std/stdlib.h"

#line 8 "/hss/opt/opthss/src/bill/src/app_guard/WfPublic.h"
#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/ipc.h"


 






 









   

    
   struct ipc_perm {
#line 34 "/usr/include/sys/ipc.h"
        uid_t        	uid;     
        gid_t	        gid;     
        uid_t	        cuid;    
        gid_t	        cgid;    


	mode_t		mode;	 
	unsigned short	__seq16; 
	key_t		key;	 

	unsigned short	__ndx;	 
	unsigned short	__wait;	
 

	unsigned int	seq;	 

	cid_t		cid;	 



	char		pad[12]; 
   };









 
#line 74 "/usr/include/sys/ipc.h"


					 









 










 


    


    
#line 111 "/usr/include/sys/ipc.h"





 



      extern "C" {



       
#    pragma extern ftok



       extern key_t ftok(const char *, int);





      }








    
    




   







 
   struct oipc_perm {
	unsigned short	uid;	 
	unsigned short	gid;	 
	unsigned short	cuid;	 
	unsigned short	cgid;	 
	unsigned short	mode;	 
	unsigned short	seq;	 
	key_t		key;	 
	unsigned short	ndx;	 
	unsigned short	wait;	
 
   };

   struct ipcmap {
	unsigned int	m_size;
	unsigned int	m_addr;
   };












 








#pragma pop
#line 10 "/hss/opt/opthss/src/bill/src/app_guard/WfPublic.h"
#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/sem.h"

































 















   

 




   

 

#line 68 "/usr/include/sys/sem.h"

   

 

struct __sem;

   


 

   struct semid_ds {
     struct ipc_perm	sem_perm;	 
     struct __sem	*sem_base;	 
     time_t		sem_otime;	 
     time_t		sem_ctime;	 
     unsigned short int	sem_nsems;	 
     unsigned int	sem_spare;
     char		sem_pad[16];	 
   };


   

 

   struct sembuf {
     unsigned short int	sem_num;	 
     short		sem_op;		 
     short		sem_flg;	 
   };


    



     extern "C" {


    








 

       
#    pragma extern semctl, semget, semop

#      pragma extern semtimedop




     extern int semctl(int, int, int, ...);
     extern int semget(key_t, int, int);

     extern int semop(int, struct sembuf *, size_t);




     extern int semtimedop(int, struct sembuf *, size_t, const struct timespec *);
#line 146 "/usr/include/sys/sem.h"


     }












 






 






 




 
#line 187 "/usr/include/sys/sem.h"



 









 
    struct osemid_ds {
	 struct oipc_perm sem_perm;	 
	 struct __sem     *sem_base;	 
	 unsigned short   sem_nsems;	 
	 time_t         sem_otime;	 
	 time_t         sem_ctime;	 
    };




 
    typedef struct __undo {
		short	un_aoe;	 
		short	un_num;	 
		int	un_id;	 
    } __undo_t;

   struct sem_undo {
	struct sem_undo	*un_np;	 
	short		un_cnt;	 
	struct __undo	un_ent[1];	 
   };









 
   struct	seminfo	{
	int	   pad;		  
	int	semmni;		 
	int	semmns;		 
	int	semmnu;		 
	int	semmsl;		 
	int	semopm;		 
	int	semume;		 
	int	semusz;		 
	int	semvmx;		 
	int	semaem;		 
   };

#line 261 "/usr/include/sys/sem.h"

#pragma pop
#line 11 "/hss/opt/opthss/src/bill/src/app_guard/WfPublic.h"
#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/shm.h"
 

































 







#pragma push binding
#pragma binding default
#line 1 "/usr/include/machine/sys/param_shm.h"


































 

















 


#pragma pop
#line 45 "/usr/include/sys/shm.h"



    
    


   

 




   


 


     typedef unsigned short int __shmatt16_t;
     typedef unsigned int shmatt_t;


   

 

   




 

struct shmid_ds {
        struct ipc_perm	shm_perm;	 

	size_t		shm_segsz;	 




        struct vas	*shm_vas;        
#line 98 "/usr/include/sys/shm.h"
	pid_t		shm_lpid;	 
	pid_t		shm_cpid;	 



 
        __shmatt16_t	__shm16_nattch;	 
        __shmatt16_t	__shm16_cnattch; 

        time_t		shm_atime;	 
        time_t		shm_dtime;	 
        time_t		shm_ctime;	 

        shmatt_t	shm_nattch;	 
        shmatt_t	shm_cnattch;	 
        char		shm_pad[16];	 
};



    



     extern "C" {



       
#    pragma extern shmat, shmctl, shmdt, shmget



     extern void *shmat(int, const void *, int);
     extern int shmctl(int, int, struct shmid_ds *);
     extern int shmdt(const void *);



     extern int shmget(key_t, size_t, int);
#line 149 "/usr/include/sys/shm.h"


     }











 







 




			       



 







 
   struct oshmid_ds {
        struct oipc_perm   shm_perm;	 
        unsigned long	   shm_segsz;	 
        struct vas	  *shm_vas;        
        unsigned short int shm_lpid;	 
        unsigned short int shm_cpid;	 
        unsigned short int shm_nattch;	 
        unsigned short int shm_cnattch;	 
        time_t		   shm_atime;	 
        time_t		   shm_dtime;	 
        time_t		   shm_ctime;	 




        char		   shm_pad[148]; 

   };


   struct	shminfo {
	long	shmmax;	   
	long	shmmin;	   
	int	shmmni;    
	int	shmseg;    
   };






#pragma pop
#line 12 "/hss/opt/opthss/src/bill/src/app_guard/WfPublic.h"





#line 1 "/opt/aCC/include_std/time.h"





#line 29 "/opt/aCC/include_std/time.h"

#line 19 "/hss/opt/opthss/src/bill/src/app_guard/WfPublic.h"

#line 1 "/hss/opt/opthss/src/bill/src/lib/Exception.h"
  






#line 1 "/opt/aCC/include_std/errno.h"



#line 1 "/opt/aCC/include_std/cerrno"











namespace std
{



using ::perror;
using ::strerror;

}



#line 5 "/opt/aCC/include_std/errno.h"

#line 14 "/opt/aCC/include_std/errno.h"

#line 9 "/hss/opt/opthss/src/bill/src/lib/Exception.h"


class Exception
{
  public:
    
    Exception(int code, int err, int line, char *file);
    Exception(int code, int err, int line, char const *file); 
        

    
    char *descript();

  private:
    
    int m_iCode;

    
    int m_iErrNo;

    
    int m_iLineNo;

    
    char  m_sFile[200];
    
    char m_sBuf[1024];


};




#line 21 "/hss/opt/opthss/src/bill/src/app_guard/WfPublic.h"
#line 1 "/hss/opt/opthss/src/bill/src/lib/Date.h"
  





class DateDiff
{
	public:
		int days; 
		int secs; 
		int milsecs;

		DateDiff (int iDays, int iSecs, int iMilSecs)
		: days (iDays), secs(iSecs), milsecs(iMilSecs) {}

		DateDiff ()
		: days(0), secs(0), milsecs(0) {}

		DateDiff (const DateDiff & right)
		{
			days = right.days;
			secs = right.secs;
			milsecs = right.milsecs;
		}

};


class Date
{
public:
    
    Date();

    
    Date(char const *sDateStr, char const *sFormat = 0);

    

    int operator- (const Date& right);

    long diffSec (Date & right);

    int diffMon (Date & right);

    int diffStrictYear (Date & right);
    int diffStrictMon (Date & right);
    int diffStrictDay (Date & right);

    
    void getCurDate();

    
    virtual ~Date();

    
    bool operator==(const Date& right);

    
    bool operator!=(const Date& right);

    
    bool operator<(const Date& right);

    
    bool operator<=(const Date& right);

    
    bool operator>(const Date& right);

    
    bool operator>=(const Date& right);

    
    int getDay() {
        return m_iDay;
    }

    
    void setDay(int iDay);

    
    int getHour() {
        return m_iHour;
    }

    
    void setHour(int iHour);

    
    int getMilSec();

    
    void setMilSec(int iMilSec);

    
    int getMin() {
        return m_iMin;
    }

    
    void setMin(int iMin);

    
    int getMonth() {
        return m_iMon;
    }

    
    void setMonth(int iMonth);

    
    int getSec();

    
    void setSec(int iSec);

    
    int getWeek();

    
    int getYear() {
        return m_iYear + 1600;
    }

    
    void setYear(int iYear);

    
    char *toString(char * sFormat = 0);

    operator char * ();
    
    void addDay(int iDay);

    
    void addYear(int iYear);
    void addYearAsOracle(int iYear);

    
    void addSec(int iSec);

    
    void addMilSec(int iMidSec);

    
    void addMin(int iMin);

    
    void addMonth(int iMonth);
    void addMonthAsOracle(int iMonth);

    
    void addHour(int iHour);

    
    int getDayNumInMonth(int iMonth);

    
    bool isLeapYear(int iYear = 0);

    
    bool parse(char const *sDateStr, char const *sFormat = 0);

    
    void parseToDay(char const *sDateStr);

    
    char *getTimeString(char *sDestination, char const *sFormat = 0);

public:
    static int checkDate(const char *pchString);

    static int checkTime(const char *pchString) ;
public:
    static char m_sDateMin[16][9];


  private:
    
    inline void stdToInner();
    inline void stdToInnerF();

    
    
    inline void innerToStd();

    inline void stdToInnerA();
    inline void innerToStdA();

    
    int m_iYear;

    
    int m_iMon;

    
    int m_iDay;

    
    int m_iHour;

    
    int m_iMin;

    
    int m_iSec;

    
    int m_iWeek;

    
    int m_iMilSec;
    
    
    
    static short m_iDaysSumOfOneYear[2][14];
    static short m_iDaysOfOneYear[2][13];

    
    
    
    static int m_iYearsSumDays[401];

    
    static char m_iYearsDays[400];
    
    
    
    
    int m_iDays;

    
    int m_iSeconds;

    char m_sOutBuf[32];
};



#line 22 "/hss/opt/opthss/src/bill/src/app_guard/WfPublic.h"
#line 1 "/hss/opt/opthss/src/bill/src/public/StdEvent.h"
  








 




#line 1 "/hss/opt/opthss/src/bill/src/lib/CommonMacro.h"
  



#line 1 "/hss/opt/opthss/src/include/../../etc/LocalDefine.h"












    
#line 23 "/hss/opt/opthss/src/include/../../etc/LocalDefine.h"
    

                                                     

                                                     
                                
#line 37 "/hss/opt/opthss/src/include/../../etc/LocalDefine.h"















const int  CONST_CARRIER_TYPE_CARD_IP1  = 545; 
const int  CONST_CARRIER_TYPE_CARD_IP2  = 546; 
const int  CONST_PATER_TT = 30 ; 

const int  CONST_LONGTYPE_LATN   = 1000;
const int  CONST_LONGTYPE_PROV   = 2000;
const int  CONST_LONGTYPE_NATION = 3000;
const int  CONST_LONGTYPE_KONG   = 3333;
const int  CONST_LONGTYPE_INTER  = 4000;
const int  CONST_LONGTYPE_HAIS   = 5000;
const int   HK_MAX_SEQKEY_LEN  = 30;








 





 






#line 6 "/hss/opt/opthss/src/bill/src/lib/CommonMacro.h"


























int const ID_BILLING_MODE = 403;







#line 1 "/hss/opt/opthss/src/bill/src/lib/MBC.h"
  








#line 1 "/hss/opt/opthss/src/bill/src/lib/MBC_28.h"


















#line 140 "/hss/opt/opthss/src/bill/src/lib/MBC_28.h"









#line 183 "/hss/opt/opthss/src/bill/src/lib/MBC_28.h"




#line 207 "/hss/opt/opthss/src/bill/src/lib/MBC_28.h"



#line 234 "/hss/opt/opthss/src/bill/src/lib/MBC_28.h"



















      















      

























      















      










      















      















      















      



































      










      




















































































































































































																				









	















































#line 11 "/hss/opt/opthss/src/bill/src/lib/MBC.h"













#line 145 "/hss/opt/opthss/src/bill/src/lib/MBC.h"








#line 187 "/hss/opt/opthss/src/bill/src/lib/MBC.h"


#line 209 "/hss/opt/opthss/src/bill/src/lib/MBC.h"



#line 236 "/hss/opt/opthss/src/bill/src/lib/MBC.h"



















      















      

























      















      










      















      















      















      



































      










      




















































































































































































																				









	












































































































































































































































































































































#line 955 "/hss/opt/opthss/src/bill/src/lib/MBC.h"








































































































































#line 1097 "/hss/opt/opthss/src/bill/src/lib/MBC.h"




































#line 1139 "/hss/opt/opthss/src/bill/src/lib/MBC.h"




#line 1151 "/hss/opt/opthss/src/bill/src/lib/MBC.h"















#line 1182 "/hss/opt/opthss/src/bill/src/lib/MBC.h"















































#line 1238 "/hss/opt/opthss/src/bill/src/lib/MBC.h"













































#line 1292 "/hss/opt/opthss/src/bill/src/lib/MBC.h"






















































































































































































































































































































































































































































































































































































































































































#line 41 "/hss/opt/opthss/src/bill/src/lib/CommonMacro.h"













#line 62 "/hss/opt/opthss/src/bill/src/lib/CommonMacro.h"


#line 76 "/hss/opt/opthss/src/bill/src/lib/CommonMacro.h"






#line 108 "/hss/opt/opthss/src/bill/src/lib/CommonMacro.h"

























#line 153 "/hss/opt/opthss/src/bill/src/lib/CommonMacro.h"



#line 167 "/hss/opt/opthss/src/bill/src/lib/CommonMacro.h"







#line 250 "/hss/opt/opthss/src/bill/src/lib/CommonMacro.h"






















#line 279 "/hss/opt/opthss/src/bill/src/lib/CommonMacro.h"





#line 292 "/hss/opt/opthss/src/bill/src/lib/CommonMacro.h"





#line 309 "/hss/opt/opthss/src/bill/src/lib/CommonMacro.h"

#line 316 "/hss/opt/opthss/src/bill/src/lib/CommonMacro.h"










#line 338 "/hss/opt/opthss/src/bill/src/lib/CommonMacro.h"


























const int  EVENT_ID_INCREMENT = 1000;









const int  ROAMTYPE_NOT_ROAM = 0;         
const int  ROAMTYPE_ROAM_PROV = 1;        
const int  ROAMTYPE_ROAM_NATION_IN = 2;   
const int  ROAMTYPE_ROAM_NATION_OUT = 3;  
const int  ROAMTYPE_ROAM_INTER_IN = 4;    
const int  ROAMTYPE_ROAM_INTER_OUT = 5;   
const int  ROAMTYPE_ROAM_BORD = 6;        
const int  ROAMTYPE_ROAM_SAME = 7;        
const int  ROAMTYPE_ROAM_BORD_EX= 8 ;



 
const int  LONGTYPE_LONG = 1;          
const int  LONGTYPE_PROV = 10;         
const int  LONGTYPE_NATION = 11;       
const int  LONGTYPE_INTER = 12;        
const int  LONGTYPE_THIRT = 13;        
const int  LONGTYPE_AMERC = 14;        
const int  LONGTYPE_KONG = 15;         
const int  LONGTYPE_LATN = 2;          
const int  LONGTYPE_LATN_XK = 151; 
const int  LONGTYPE_LATN_AM = 152; 
const int  LONGTYPE_LATN_TW = 153; 
const int  LONGTYPE_LATN_HS = 16;  
const int  LONGTYPE_LATN_PROV_NATION = 17;  
const int  LONGTYPE_LATN_NATION_PROV = 18;  
const int  LONGTYPE_LATN_PROV_PROV = 19;  
const int  LONGTYPE_LATN_NATION_NATION = 19;  



const int LONGTYPE_LATN_EX = 1000;          


const int  LONG_GROUPTYPE_PROV = 10;         
const int  LONG_GROUPTYPE_NATION = 20;       
const int  LONG_GROUPTYPE_INTER = 30;        
const int  LONG_GROUPTYPE_THIRT = 31;        
const int  LONG_GROUPTYPE_AMERC = 32;        
const int  LONG_GROUPTYPE_KONG = 40;         
const int  LONG_GROUPTYPE_XK = 401; 
const int  LONG_GROUPTYPE_AM = 402; 
const int  LONG_GROUPTYPE_TW = 403; 
const int  LONG_GROUPTYPE_HS = 50; 




const int  FORWARDTYPE_UNCOND = 33; 
const int  FORWARDTYPE_DEFLECTION = 36; 
const int  FORWARDTYPE_COND = 40; 
const int  FORWARDTYPE_BUSY = 41; 
const int  FORWARDTYPE_NOREPLAY = 42; 
const int  FORWARDTYPE_NOTREACH = 43; 


const int  FORWARDTYPE_UNCOND_EX = 1;
const int  BUSINESSKEY_FORWARDTYPE_UNCOND = 1001;  
const int  BUSINESSKEY_FORWARDTYPE_COND = 1002;    

const int  D_M_ACCNBR_LEN = 8;   
const int  D_M_MOBNBR_LEN = 11;  

const int  MAX_FORMAT_RECORD_LEN = 8000; 



const int MAX_SPFLAG_LEN = 80;  
































 




const int ALERT_SIG_ERR = 100;  













const int  ALERT_RCVMODE_ERR  = 2001;
const int  ALERT_NO_BATCHTIME = 2002;
const int  PRE_GET_FILEID_ERR = 2003;
const int  GET_EVENTIDSEQ_ERR = 2004; 























































#line 576 "/hss/opt/opthss/src/bill/src/lib/CommonMacro.h"



const int PRE_NO_FORMAT_RULE  =   1000; 
const int START_TIME_YEAR_INVALID = 1001;
const int START_TIME_MONTH_INVALID = 1002;
const int START_TIME_DATE_INVALID = 1003;
const int START_TIME_HOUR_INVALID = 1004;
const int START_TIME_MINUTE_INVALID = 1005;
const int START_TIME_SECOND_INVALID = 1006;

const int NBR_EXIST_CHAR = 1010;


const int CALLED_NUMBER_OWNERID=    21;
const int JUDGE_AGREEMENT_EVENT_TYPE    = 20;

const int ALL_INFO                                      = 0;
const int A_SERV_TYPE_CHANGE            = 1;
const int SERV_LOCATION                 = 2;
const int SERV_STATE_ATTR                       = 3;
const int SERV_ATTR                             = 4;
const int SERV_IDEN                             = 5;
const int SERV_PRODUCT_ANDATTR          = 6;
const int SERV_ACCT                             = 7;
const int ACCT                                          = 8;
const int PRODUCT_OFFER_INFO            = 9;
const int A_ACC_NBR_OFFER_TYPE  =20;

const int CUST                                          = 10;
const int SERV                                          = 11;
const int SERV_PRODUCT                          = 12;
const int SERV_PRODUCT_ATTR             = 13;
const int OFFER_INSTANCE                        = 14;
const int INSTANCE_DETAIL                       = 15;


const int USER_INFO_BASE                    = 1;
const int USRE_INFO_NOITEMGROUP     = 2;






const int UIO_PARTITION_ID_INIT = 1;
const int UIO_PARTITION_ID_MODACCT      = 2;
const int UIO_PARTITION_ID_OTHER        = 3;


const int B_NP            = 10000;


const int MEM_VER_OLD  = 0;
const int MEM_VER_SHMDATA_A   = 1;
const int MEM_VER_SHMDATA_B   = 2;
const int MEM_VER_INTINDEX_A  = 3;


const int MAX_ARRARY_LEN      = 10;
	

const int MAX_ITEM_RECORD     = 10;


const int ACCT_ITEM_TRANS     = 9999;


const int AGGR_VERSION_INITVAL		= 0;




#line 16 "/hss/opt/opthss/src/bill/src/public/StdEvent.h"

class ChargeInfo;
class ServProductAttr;




struct StdChargeInfo
{
	long m_lStdCharge;
	int m_iStdAcctItemTypeID;
};
struct ChargeInfo
{
	long m_lCharge;
	int  m_iAcctItemTypeID;
	long m_lBillMeasure;
	int  m_iMeasureType;
	long m_lAcctID;
	long m_lOfferInstID;
    int  m_iItemSourceID;
};

#line 47 "/hss/opt/opthss/src/bill/src/public/StdEvent.h"































 






class StdEventExt
{
  public:
    
    long m_lExtendValue[10];
    char m_sExtendValue[10][31];
    
    
    
    
    int m_iRoamTypeID;
	
	



    int m_iStdRoamTypeID;	
    int m_iStdLongTypeID;



    
    
    
    int m_iLongTypeID;
    
    
    
    
    
    
    char m_sFileName[200];

    
    
    
    int m_iSourceEventType;
    
    
    
    
    int m_iCarrierTypeID;

    
    int m_iCallingLongGroupTypeID;

    
    int m_iCalledLongGroupTypeID;

    
    
    
    int m_iCallingOrgID;

    
    
    
    int m_iCalledOrgID;

    
    
    
    char m_sOrgSequence[32];

    
    
    
    int m_iPartialIndicator;

	
	
	int m_iMiddleSequnce;
	
	
	int m_iSwitchLongType;
	
	
	int  m_iHotBillingTag;
	
	
	int m_iCausefortermination;
	
	
	char m_sSwitchAreaCode[11];
	
	
	char   m_sCallingVisitAreaCode[11];

	
	char   m_sCalledVisitAreaCode[11];
    
    
    char m_sThirdPartyVisitAreaCode[11];
    
	
	char m_sIMSI[21];
	
	
	char m_sIMEI[21];

	
	char m_sAccessPointName[260];
	
	
	int m_iNodeID;
};





class StdEvent
{
  public:
    
    
    
    
    long m_lEventID;
	



    
    
    
    int m_iBillingCycleID;

    
    
    
    int m_iEventTypeID;

    
    
    
    char m_sBillingAreaCode[11];
	
    
    
    
    char m_sBillingNBR[41];

    
    
    
    char m_sBillingVisitAreaCode[11];

    
    
    
    char m_sCallingAreaCode[11];

    
    
    
    char m_sCallingNBR[33];

    
    
    
    char m_sCallingPhysicalNBR[33];

    
    
    
    char m_sOrgCallingNBR[33];
    
     
    
    
    char m_sOrgCallingPhysicalNBR[33];

    
    
    
    int m_iCallingSPTypeID;

    
    
    
    int m_iCallingServiceTypeID;

    
    
    
    char m_sCalledAreaCode[11];

    
    
    
    char m_sCalledNBR[33];
    
    
    
    
    char m_sCalledPhysicalNBR[33];

    
    
    
    char m_sOrgCalledNBR[33];
    
    
    
    
    char m_sOrgCalledPhysicalNBR[33];

    
    
    
    int m_iCalledSPTypeID;

    
    
    
    int m_iCalledServiceTypeID;

    
    
    
    char m_sThirdPartyAreaCode[11];

    
    
    
    char m_sThirdPartyNBR[33];
    
     
    
    
    char m_sThirdPartyPhysicalNBR[33];

    
    
    
    char  m_sStartDate[18];


    
    
    
    char  m_sEndDate[18];

    
    
    
    
    long  m_lDuration;
    
    
    int m_iIPType;
    
    
    long  m_lRecvAmount;
    
    
    long  m_lSendAmount;
    
    
    long  m_lRecvAmountV6;
    
    
    long  m_lSendAmountV6;
    
    
    long  m_lSumAmountV4;
    
    
    long  m_lSumAmountV6;
    
    
    long  m_lSumAmount;

    
    
    
    char m_sTrunkIn[13];

    
    
    
    int m_iTrunkInTypeID;

    
    
    
    char m_sTrunkOut[13];

    
    
    
    int m_iTrunkOutTypeID;

    
    
    
    int m_iFileID;

    
    
    
    char m_sEventState[4];

    
    
    
    char  m_sCreatedDate[15];

    
    
    
    char   m_sStateDate[15];

    
    
    
    char m_sCardID[41];

    
    
    
    int m_iBillingTypeID;

    
    
    
    int m_iParterID;

    
    
    
    long m_iServID;

    
    
    
    long m_iCustID;

    
    
    
    int m_iProdID;

    
    
    
    long m_iServProdID;

    
    long  m_lOffers[5];

    
    
    
    char m_sBillingRecord[101];

    
    
    
    int m_iErrorID;

    
    
    
    char m_sAccountAreaCode[11];

    
    
    
    char m_sAccountNBR[33];

    
    
    
    char m_sNASIp[17];

    
    
    
    int m_iNASPortID;

    
    
    
    int m_iNegotiatedQoS;

    
    
    
    int m_iExtUsedNum;

    
    
    
    int    m_aiExtFieldID[10];

    
    
    
    char   m_asExtValue[10][33];

    
    
    
    int m_iSwitchID;
   
    
    
    
    int m_iBusinessKey;

    
    
    
    
    long m_lOrgCharge[2];

    ChargeInfo m_oChargeInfo[6];
    
    StdChargeInfo m_oStdChargeInfo[6];
    
    
    
    
    int m_iBillingOrgID;

    
    
    
    int m_iCallTypeID;

    
    int m_iPricingCombineID;
    
  
    
    
    
    
    
    
    
    
    
    int m_iEventSourceType;
    
    
    int m_iNoBillFlag;

	
	char  m_sMSC[16];
	
	
	char  m_sLAC[9];
	char  m_sCalledMSC[16];

	char  m_sCalledLAC[9];
	char  m_sCalledCellID[9];
	
	char  m_sCellID[9];

	
	char m_sRomingNBR[31];
    
    
    
    StdEventExt m_oEventExt;

	
	char m_sSPFLAG[MAX_SPFLAG_LEN];
	
    
    int m_iSPID;
    
    
    int m_iSuppleServiceCode;
    
    
    int m_iCUGCode;
    
    char m_sReservedField[5][41];
    
    
    
    int m_iTimes;
    
    int m_iNetworkID;
    
    int m_iFlowID;
    
    
    char m_sGateWay[11];       
    int  m_iCallingPA;                     
    int  m_iCalledPA;                      
    char m_sCallingRP[16];         
    char m_sCalledRP[16];          
    int  m_iCallingRPArea;                
    int  m_iCalledRPArea;                 
    char m_sSessionID[56];               
    char m_sOrgThirdPartyNBR[33];   
    char m_sOrgThirdPartyPhysicalNBR[33];
    
    
    
    int  m_iEventSeq;
    
    
    char m_sDomainName[21]; 
    int  m_iGroupID;                         
    int  m_iRoamFlag;                        
    char m_sBindAttr[101];     
    int  m_iServiceType;    
    int  m_iUserType;       
    char m_sAreaNo[21];         
    long m_lSepRecID;       
    int  m_iSepRecSeq;      
    long m_lResourceID;     
    int  m_iQueryFlag;      
                            
                            
    
    int  m_iProcessID;




    char m_sAccuRecord[200];    
};




struct StdAcctItem {
	int iFileID; 
	long lEventID;
	long iServID;
	long iAcctID;
	int iOrgID;
	int iBillingCycleID;
	int iAcctItemTypeID;
	long lCharge;
	int iCombineID; 
	char sStateDate[16]; 
	int iItemGroupID;
};



#line 23 "/hss/opt/opthss/src/bill/src/app_guard/WfPublic.h"
#line 1 "/hss/opt/opthss/src/bill/src/framework/Environment.h"
  








class AggrMgr;
class TransactionMgr;
class Serv;

class SHMFileInfo;
#line 1 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoReader.h"
  



#line 1 "/hss/opt/opthss/src/include/../../etc/LocalDefine.h"
#line 81 "/hss/opt/opthss/src/include/../../etc/LocalDefine.h"



#line 6 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoReader.h"

#line 1 "/hss/opt/opthss/src/bill/src/mmdb/UserInfo.h"
  







 


 

#line 1 "/hss/opt/opthss/src/bill/src/public/SHMData.h"
  






#line 1 "/hss/opt/opthss/src/bill/src/lib/HashList.h"
  








#line 1 "/hss/opt/opthss/src/bill/src/lib/KeyList.h"
  













template <class T>
class KeyList
{

  public:
    
    KeyList(long key, T data);
    KeyList(char *key, T data);

    
    void add(char *key, T data);

    
    void add(long key, T data);

    
    bool get(long key, 
        
        
        T *vlaue);

    
    bool get(char *key, T *value) const;

    void remove(KeyList<T> **pList, long key);
    void remove(KeyList<T> **pList, char *key);

    
    ~KeyList();


	KeyList<T> *m_poNext;	
	T m_oData;
	char *m_sOriKey;
	long m_iOriKey;
};


template <class T>
KeyList<T>::KeyList(long key, T data) 
: m_poNext(0),m_oData(data),m_sOriKey(0),m_iOriKey(key)
{
}

template <class T>
KeyList<T>::KeyList(char * key, T data) 
: m_poNext(0),m_oData(data),m_iOriKey(0)
{
	m_sOriKey = new char[strlen(key)+1];
	if (!m_sOriKey)
		throw Exception((100100000+1), (*__errno()), 65, "/hss/opt/opthss/src/bill/src/lib/KeyList.h");
	strcpy (m_sOriKey, key);
}


template <class T>
void KeyList<T>::add(char *key, T data)
{
	
	KeyList<T> * p = (KeyList<T> *) this;

	while (p) {
		if (p->m_sOriKey&&!strcmp(key, p->m_sOriKey)) {
			p->m_oData = data;
			return;
		}
		p = p->m_poNext;
	}

	
	p = new KeyList<T> (key, data);
	if (!p)
		throw Exception((100100000+1), (*__errno()), 87, "/hss/opt/opthss/src/bill/src/lib/KeyList.h");

	p->m_poNext = this->m_poNext;
	this->m_poNext = p;
}


template <class T>
void KeyList<T>::add(long key, T data)
{
	
	KeyList<T> * p = (KeyList<T> *) this;

    

 
	while (p) {
		if (key == p->m_iOriKey) {
			p->m_oData = data;
			return;
		}
		p = p->m_poNext;
	}

	
	p = new KeyList<T> (key, data);
	if (!p)
		throw Exception((100100000+1), (*__errno()), 114, "/hss/opt/opthss/src/bill/src/lib/KeyList.h");

	p->m_poNext = this->m_poNext;
	this->m_poNext = p;
}


template <class T>
bool KeyList<T>::get(long key, T *value)
{
	
	KeyList<T> * p = (KeyList<T> *) this;

	while (p) {
		if (key == p->m_iOriKey) {
			*value = p->m_oData;
			return true;
		}
		p = p->m_poNext;
	}

	return false;
}


template <class T>
bool KeyList<T>::get(char *key, T *value) const
{
	
	KeyList<T> * p = (KeyList<T> *) this;

	
	int iFlag=0;
	
	while (p) {
		if (p->m_sOriKey&&!strcmp(key, p->m_sOriKey)) {
			*value = p->m_oData;
			iFlag =1;
			break;
			
		}
		p = p->m_poNext;
	}
	
	if (iFlag) 
		return true;
	else
		return false;
}

template <class T>
void KeyList<T>::remove(KeyList<T> ** ppList, long key)
{
	KeyList<T> * p;

	while ((p = *ppList) != 0) {
		if (p->m_iOriKey == key) {
			*ppList = p->m_poNext;
			p->m_poNext = 0;
			delete p;
			return;
		}

		ppList = &(p->m_poNext);
	}
}

template <class T>
void KeyList<T>::remove(KeyList<T> ** ppList, char *key)
{
	KeyList<T> * p;
	while ((p = *ppList) != 0) {
		if (!strcmp(key, p->m_sOriKey)) {
			*ppList = p->m_poNext;
			p->m_poNext = 0;
			delete p;
			return;
		}

		ppList = &(p->m_poNext);
	}
}


template <class T>
KeyList<T>::~KeyList()
{
	
	KeyList<T> * p;

	if (m_sOriKey) 
		delete [] m_sOriKey;
	
	while (m_poNext) {
		p = m_poNext;
		m_poNext = p->m_poNext;
		p->m_poNext = 0;
		delete p;
	}
}

#line 13 "/hss/opt/opthss/src/bill/src/lib/HashList.h"


template <class T>
class HashList
{
  public:
	friend class Iteration;

	class Iteration
	{
	  public:
		bool next(T &value)
		{
			while (!m_poCur && m_iHashIndex<m_poHashList->m_iHashValue) {
				m_poCur = m_poHashList->m_poKeyList[m_iHashIndex];
				m_iHashIndex++;
			}

			if (!m_poCur) return false;

			value = m_poCur->m_oData;
			m_poCur = m_poCur->m_poNext;
			return true;		
		}

		Iteration (long i, KeyList<T> *p1, HashList<T> *p2):
		m_iHashIndex(i), m_poCur(p1), m_poHashList(p2)
		{}

		Iteration (const Iteration & right)
		{
			m_iHashIndex = right.m_iHashIndex;
			m_poCur = right.m_poCur;
			m_poHashList = right.m_poHashList;
		}

	  private:
		unsigned long m_iHashIndex;
		KeyList<T> * m_poCur;
		HashList<T> * m_poHashList;
	};


	



 
	
	Iteration getIteration ()
	{
		return Iteration (0, 0, this);
	}	
	
    
    void add(long key, T data) ;

    
    bool get(long key, T *value) ;

    
    void destroy();

    void clearAll();

    
    HashList(unsigned long hashvalue);

    
    ~HashList();

    
    void add(char *key, T data) ;

    
    bool get(char *key, T *value) ;
    
    
    void remove(long key);
    void remove(char *key);
    

  private:
    
    long calKey(long key);

    
    long calKey(char *key);

  public:
    
    
    
    unsigned long m_iHashValue;

    
    unsigned long m_iCount;

    
    KeyList<T> **m_poKeyList;

};



template <class T>
void HashList<T>::add(long key, T data) 
{
	long i = calKey (key);
	if (m_poKeyList[i]) {
		m_poKeyList[i]->add (key, data);
	} else {
		m_poKeyList[i] = new KeyList<T> (key, data);
		if (!m_poKeyList[i])
			throw Exception((100090000+1), (*__errno()), 127, "/hss/opt/opthss/src/bill/src/lib/HashList.h");
	}
}


template <class T>
bool HashList<T>::get(long key, T *value) 
{
	long i = calKey (key);
	if (m_poKeyList[i]) {
		return m_poKeyList[i]->get (key, value);
	} else {
		return false;
	}

}


template <class T>
void HashList<T>::remove(long key)
{
	long i = calKey (key);
	if (m_poKeyList[i]) {
		m_poKeyList[i]->remove(&(m_poKeyList[i]), key);
	}
}

template <class T>
void HashList<T>::remove(char *key)
{
	long i = calKey (key);
	if (m_poKeyList[i]) {
		m_poKeyList[i]->remove(&(m_poKeyList[i]), key);
	}
}

template <class T>
void HashList<T>::clearAll()
{
	unsigned long i;
	if (!m_poKeyList)
		return;

	for (i=0; i<m_iHashValue; i++) {
		if (m_poKeyList[i]) {
			delete m_poKeyList[i];
			m_poKeyList[i] = 0;
		}		
	}
}



template <class T>
void HashList<T>::destroy()
{
	unsigned long i;
	if (!m_poKeyList)
		return;

	for (i=0; i<m_iHashValue; i++) {
		if (m_poKeyList[i])
			delete m_poKeyList[i];
	}

	delete [] m_poKeyList;
	m_poKeyList = 0;
}


template <class T>
HashList<T>::HashList(unsigned long hashvalue) : m_iHashValue(hashvalue)
{
	if (!hashvalue)
		throw Exception((100090000+2), (*__errno()), 201, "/hss/opt/opthss/src/bill/src/lib/HashList.h");

	m_poKeyList = new KeyList<T> * [hashvalue];
	if (!m_poKeyList)
		throw Exception((100090000+1), (*__errno()), 205, "/hss/opt/opthss/src/bill/src/lib/HashList.h");

	memset (m_poKeyList, 0, sizeof(KeyList<T> *) * hashvalue);
}


template <class T>
HashList<T>::~HashList()
{
	destroy ();
}


template <class T>
void HashList<T>::add(char *key, T data) 
{	
	long i = calKey (key);
	if (m_poKeyList[i]) {
		m_poKeyList[i]->add (key, data);
	} else {
		m_poKeyList[i] = new KeyList<T> (key, data);
		if (!m_poKeyList[i])
			throw Exception((100090000+1), (*__errno()), 227, "/hss/opt/opthss/src/bill/src/lib/HashList.h");
	}
}


template <class T>
bool HashList<T>::get(char *key, T *value) 
{
	long i = calKey (key);
	if (m_poKeyList[i]) {
		return m_poKeyList[i]->get (key, value);
	} else {
		return false;
	}
}


template <class T>
long HashList<T>::calKey(long key)
{
	return key % m_iHashValue;
}


template <class T>
long HashList<T>::calKey(char *key)
{
	long i ,j;
	
	i = 0;
	for (j = 1; *key && (j<13); j++) {
		i += ((*key) * j);  
		key++;
	}
	
	return i % m_iHashValue;
}

#line 9 "/hss/opt/opthss/src/bill/src/public/SHMData.h"
#line 1 "/hss/opt/opthss/src/bill/src/public/SHMAccess.h"
  






#line 1 "/hss/opt/opthss/src/bill/src/lib/SimpleSHM.h"
  







using namespace std;
#line 16 "/hss/opt/opthss/src/bill/src/lib/SimpleSHM.h"



class SimpleSHM
{
  public:
    
    void close();

    
    void remove();

    
    bool exist();
	long getIPCKey();
    
    SimpleSHM(long key, unsigned long size, char * pNeed =0 );

    
    SimpleSHM(char *name, unsigned long size, bool bShm = true, char * pNeed =0 );

    
    void open(bool ifcreate = true);

    
    operator char *();

    
    unsigned long size(); 
    unsigned long getLastSize();
    void setLastSize(unsigned long ulsize ) ;
  	 time_t  getShmTime();
        
    
    ~SimpleSHM();
    
    int nattch();



    
    unsigned long getlba();
    unsigned long expand( unsigned long xSize );

  private:
    
    bool _create();

    
    bool _open();

    
    int m_iSysID;

    
    long m_lKey;

    
    bool m_bAttached;

    
    unsigned long m_ulSize;

    
    char *m_pPointer;
    char * m_pNeedPos ;
    
    bool m_bSHMFile;
    string m_sFileName;
};



#line 10 "/hss/opt/opthss/src/bill/src/public/SHMAccess.h"

const int MAX_SHM_EX_CNT = 8;


class SHMAccess
{
  public:
    
    SHMAccess(char *shmname, bool bShm = true);

    
    SHMAccess(long shmkey);
	SHMAccess(unsigned int iType,char *pAddr);
    SHMAccess(char *sType,char *pAddr);
    SHMAccess(long shmkey , long iNextSize, int iMaxExCnt );
    
    
    ~SHMAccess();

    
    
    
    bool exist();

    
    
    
    void remove();
	
  public:
  	int connnum();
  	void initExpand(unsigned int * pExCnt, int iUnitSize, unsigned int * pSeg );
  	unsigned long expandit();
  	unsigned long totalSize();
    void setExpandNull();
  	void showExpandInfo();
	char *getMemAddr();
  	
	long getKey();
    
	void close();
    
    
    void create(unsigned long size);
  	bool reopen();


  protected:

    
    unsigned int *m_piSize;

    
    SimpleSHM *m_poSHM;
    SimpleSHM *m_poExSHM[MAX_SHM_EX_CNT];
    int m_iExShmCnt;
    int m_iMaxExCnt;
    long m_lNextSize;
    unsigned int *m_piExpandCnt;
    int m_iUnitSize;
    


    
    char *m_sSHMName;
    char *m_sExSHMName[MAX_SHM_EX_CNT];
    
    long m_lSHMKey;
    long m_lExSHMKey[MAX_SHM_EX_CNT];






    bool m_bShm;

public:


    char *       m_sSegment[MAX_SHM_EX_CNT+1];

    unsigned int * m_piSeg;


  private:
    
    void open();
    bool openEx(int i);





};



#line 10 "/hss/opt/opthss/src/bill/src/public/SHMData.h"

#line 20 "/hss/opt/opthss/src/bill/src/public/SHMData.h"







template <class T>
class SHMData : public SHMAccess
{
  public:
    typedef T value_type;
    
    
    
    SHMData(char *shmname, bool bShm = true);

    
    SHMData(long shmkey);

    
    ~SHMData();

    
    operator T *();

    
    
    
    void create(
        
        
        unsigned int itemnumber) ;

    void reset();

    
    
    
    
    unsigned int malloc();
    
    unsigned int getCount();
	

	void	setCount(unsigned int iCount);

	unsigned int getTotal();
		
	time_t getLoadTime();

	unsigned  int  getMemSize();
	unsigned  long getRealSize();

	unsigned  int  getUsedSize();
	
	unsigned long   getMemAdress();
  private:
    
    void open();

    
    unsigned int *m_piTotal;

    
    unsigned int *m_piUsed;

 
    
    T *m_pPointer;

};




template <class T>
SHMData<T>::SHMData(char *shmname, bool bShm) :
SHMAccess (shmname, bShm)
{
	if (m_poSHM)
		open ();
}


template <class T>
void SHMData<T>::setCount(unsigned int iCount)
{
	if(*m_piTotal<iCount)
		return ;
	(*m_piUsed)=iCount;
}

template <class T>
SHMData<T>::SHMData(long shmkey) :
SHMAccess (shmkey)
{
	if (m_poSHM)
		open ();
}



template <class T>
SHMData<T>::~SHMData()
{
}


template <class T>
SHMData<T>::operator T *()
{
	return m_pPointer;
}


template <class T>
void SHMData<T>::create(unsigned int itemnumber) 
{
	SHMAccess::create(((itemnumber+1)*sizeof(T)));
	open ();
	*m_piTotal = itemnumber + 1;
	*m_piUsed = 1;
}

template <class T>
void SHMData<T>::reset()
{
	*m_piUsed = 1;
}


template <class T>
unsigned int SHMData<T>::malloc()
{
	if (*m_piTotal == *m_piUsed)
		return 0;

	return ((*m_piUsed)++);
}


template <class T>
void SHMData<T>::open()
{
	m_piTotal = (unsigned *)((char *)(*m_poSHM)) + 1;
	m_piUsed = m_piTotal + 1;
	m_pPointer = (T *)((char *)(*m_poSHM));
}


template <class T>
unsigned int SHMData<T>::getCount()
{
	if (*m_piUsed)
		return (*m_piUsed)-1;

	return 0;
}


template <class T>
unsigned int SHMData<T>::getTotal()
{
	if (*m_piTotal)
		return (*m_piTotal)-1;

	return 0;	
}
template <class T>
unsigned int SHMData<T>::getMemSize()
{
	 if (*m_piTotal)
		 return (*m_piTotal)* sizeof(T);

		    return 0;
}
template <class T>
unsigned int SHMData<T>::getUsedSize()
{
	if (*m_piUsed)
		return (*m_piUsed)* sizeof(T);

		 return 0;
}

template <class T>
unsigned long SHMData<T>::getMemAdress()
{		
	if (m_poSHM)
	{
		return   (unsigned long)m_poSHM;
	}
	
	return 0;
}
template <class T>
time_t SHMData<T>::getLoadTime()
{
	time_t shm_ctime;
	
	if (m_poSHM)
	{
		shm_ctime = m_poSHM->getShmTime();	
		
		return shm_ctime ;
	}
	return  0;
}

template <class T>
unsigned long SHMData<T>::getRealSize()
{
	  unsigned long size = m_poSHM->size();
		 return size;

}


#line 15 "/hss/opt/opthss/src/bill/src/mmdb/UserInfo.h"
#line 1 "/hss/opt/opthss/src/bill/src/public/SHMData_A.h"
  

































using namespace std;

#line 46 "/hss/opt/opthss/src/bill/src/public/SHMData_A.h"





template <class T>
class SHMData_A : public SHMAccess
{
  public:
	  typedef T value_type;

	
	class Iteration
	{
      private:
        unsigned int m_iCurOffset;
        SHMData_A<T> * m_pDataA;
        unsigned char *pData;
        unsigned int m_iStateCnt;
    
	  private:

        unsigned int getInfo()
        {   
            
            unsigned int uiTemp = (*(m_pDataA->m_piTotalSE));
            
            pData = new unsigned char[uiTemp];
            memset(pData, '0', sizeof(unsigned char)*uiTemp );

            unsigned int i = (*(m_pDataA->m_piUsedSE));
            unsigned int j =0;

            if(i!=0  && 0==m_pDataA->m_pIArray[i]){
                
                uiTemp = i;
                i=0;
                
                for(; i != (*(m_pDataA->m_piDeledSE)); i++){
                    if( i>= uiTemp ){
                        
                        break;
                    }
                    j = m_pDataA->m_pIArray[i];
                    if( 0== j){
                        j = i;
                    }
                    pData[j]++;                       
                }
                return uiTemp;
            } 
            

            for(; i != (*(m_pDataA->m_piDeledSE)); i++){
                if( i>= uiTemp ){
                    i = 0;
                }
                j = m_pDataA->m_pIArray[i];
                if( 0== j){
                    j = i;
                }
                if( '0' == pData[j] ){
                    
                    pData[j] = '1';
                    
                }else{
                    
                    pData[j]++;
                }
            }
            
            return uiTemp;

        }

	  public:
	    void close(){ 
	        if(pData){ delete [] pData; pData =0;}
	        m_iCurOffset = 1;
	        m_iStateCnt = 0;
	    }
	    
	    
	    
		bool next(T & tOut, unsigned int &uiOffsetOut)
		{
			if(!pData){
			    m_iStateCnt = getInfo();
			}
			if(pData && m_iCurOffset>0){
			    while( m_iCurOffset< m_iStateCnt ){
    			    if('0' == pData[m_iCurOffset] ){
    			        uiOffsetOut = m_iCurOffset;
        			    tOut = m_pDataA->m_pPointer[ m_iCurOffset ];
        			    m_iCurOffset++;
        			    
        			    return true;
        			}
        			m_iCurOffset++;
        		}
    			return false;
			}      
			return false;		
		}

		bool nextBatch(unsigned int uiMax, T tOut[], unsigned int &iOutCnt)
		{
			if(!pData){
			    m_iStateCnt = getInfo();
			}
			unsigned int iTotal = (*(m_pDataA->m_piTotalSE));
			unsigned int iCnt=0;
			if(pData && m_iCurOffset>0 && uiMax){
			    while(iCnt<uiMax && m_iCurOffset < m_iStateCnt ){
    			    if('0' == pData[m_iCurOffset] ){
        			    tOut[iCnt] = m_pDataA->m_pPointer[ m_iCurOffset ];
        			    iCnt++;
        			}
        			m_iCurOffset++;
        			
        		}
        		if(iCnt){
        		    iOutCnt = iCnt;
        		    return true;
        		}
        		iOutCnt = 0;
    			return false;
			}      
			return false;		
		}

		Iteration ( unsigned int iCur, SHMData_A<T> * pSHMDataA):
		    m_iCurOffset(iCur), m_pDataA(pSHMDataA),pData(0),m_iStateCnt(0)
		{}

		Iteration (const Iteration & right)
		{
			m_iCurOffset = right.m_iCurOffset;
			m_pDataA = right.m_pDataA;
            pData = 0;
            m_iStateCnt = 0;
		}
		
		~Iteration () 
		{ if(pData)
		    { delete [] pData; pData =0;}
		}
		     

	};
	
	Iteration getIteration ()
	{
		return Iteration ( 1, this);
	}

  public:
	friend class Iteration;
    SHMData_A(char *shmname, bool bShm = true);

    SHMData_A(long shmkey);

    ~SHMData_A();
    
    operator T *();

    void create(
        unsigned int itemnumber) ;

    void reset();

    bool revoke( unsigned int uiOffset);
    void showDetail();
    bool checkHealth();
    unsigned int kick(unsigned int uiBeginOff, 
        int iNxtOffset, int iExpOffset, const char * sDate, unsigned int * o_uiKickSelf, bool * o_bKickSelf );
    unsigned int kickAndRevoke(unsigned int uiBeginOff, 
        int iNxtOffset, int iExpOffset, const char * sDate,
        int iChkOffset1, int iChkOffset2, unsigned int * o_uiKickSelf , bool * o_bKickSelf);
   
    unsigned int malloc();

    unsigned int getCount();

    unsigned int getTotal();

    unsigned long getDelTotal();
    unsigned int  getDelFree ();
    time_t getLoadTime();
	unsigned  int  getMemSize();
	unsigned  int  getUsedSize();
	unsigned long  getMemAdress();
	unsigned long getRealSize();
    
    
    inline void checkSafe(){
        if(0 == *m_piFlag) return;
        while(*m_piFlag){
            usleep(102400);
        }            
    };
    
    bool setRevokeFlag( unsigned int iFlag){
        if(m_poSHM && m_piFlag){
            *m_piFlag = iFlag; 
            return true;
        }
        return false;
    };
    
    bool ifSetRevokeFlag(){
        if( *m_piFlag )
            return true;
        return false;
        };

    
  private:

    void open();

  protected :
    unsigned int *m_piTotal;
    unsigned int *m_piUsed;
    T *m_pPointer;
    
    unsigned int *m_piVersion; 
    unsigned int *m_piTotalSE;
    unsigned int *m_piUsedSE;
    unsigned int *m_piDeledSE;
    unsigned int *m_piFlag;     
    unsigned int *m_piDelOver;  
    unsigned int *m_pIArray; 
};


template <class T>
SHMData_A<T>::SHMData_A(char *shmname, bool bShm) :
SHMAccess (shmname, bShm)
{
    if (m_poSHM){
        open ();
        if( 1 != *m_piVersion )
            throw Exception((110170000+1), (*__errno()), 289, "/hss/opt/opthss/src/bill/src/public/SHMData_A.h");
    }
}


template <class T>
SHMData_A<T>::SHMData_A(long shmkey) :
SHMAccess (shmkey)
{
    if (m_poSHM){
        open ();
        if( 1 != *m_piVersion )
            throw Exception((110170000+1), (*__errno()), 301, "/hss/opt/opthss/src/bill/src/public/SHMData_A.h");
    }

}



template <class T>
SHMData_A<T>::~SHMData_A()
{
}

template <class T>
SHMData_A<T>::operator T *()
{
    return m_pPointer;
}


template <class T>
void SHMData_A<T>::create(unsigned int itemnumber) 
{
    if( sizeof(T)< 16 )
        throw Exception((110170000+2), (*__errno()), 324, "/hss/opt/opthss/src/bill/src/public/SHMData_A.h");
    SHMAccess::create((itemnumber+2)* (sizeof(T)+sizeof(int))  );
    open ();

    
    *m_piTotal = 2;
    *m_piUsed = 2;

    *m_piVersion = 1;
    *m_piTotalSE = itemnumber + 1 ;
    
    m_pIArray =(unsigned int *) &m_pPointer[(*m_piTotalSE)+1];

    *m_piUsedSE = 1;
    *m_piDeledSE= 0;

    if( sizeof(T)< 32 ){
        
        
        *m_piUsedSE = 2;
        *m_piDeledSE = 1;
        m_pIArray[0] = itemnumber+1;
    }
}

template <class T>
void SHMData_A<T>::reset()
{
    *m_piUsedSE = 1;
    *m_piDeledSE= 0;
    memset( m_pIArray, 0, (*m_piTotalSE) * sizeof(int) );
    *m_piDelOver =0;
    
    if( sizeof(T)< 32 ){
        
        
        *m_piUsedSE  = 2;
        *m_piDeledSE = 1;
        m_pIArray[0] = *m_piTotalSE;
    }

}


template <class T>
unsigned int SHMData_A<T>::malloc()
{
    if (*m_piDeledSE == *m_piUsedSE)
        return 0;
    unsigned int uiRet = m_pIArray[(*m_piUsedSE)];
    if(!uiRet)
        uiRet = (*m_piUsedSE);
    
    (*m_piUsedSE)++;
    if( (*m_piUsedSE) >= (*m_piTotalSE) )
        (*m_piUsedSE) = 0 ;
   
    return uiRet;
    
}


template <class T>
void SHMData_A<T>::open()
{
    m_piTotal = (unsigned *)((char *)(*m_poSHM)) + 1;
    m_piUsed = m_piTotal + 1;
    m_pPointer = (T *)( (char *)(*m_poSHM));
    
    m_piVersion = m_piTotal - 1;
    m_piTotalSE = m_piTotal + 2;
    m_piFlag    = m_piTotal + 3;
    m_piUsedSE  = m_piTotal + 4;
    m_piDeledSE = m_piTotal + 5;
    m_piDelOver = m_piTotal + 6;
    if( (*m_piTotalSE) ) {
        m_pIArray =(unsigned int *) &m_pPointer[(*m_piTotalSE)+1];

    }else{
        m_pIArray = 0;
    }



}
template <class T>
unsigned int SHMData_A<T>::getCount()
{
    unsigned int iCnt = 0;

    if( (*m_piUsedSE) > (*m_piDeledSE) ){
        iCnt = ( (*m_piUsedSE) - (*m_piDeledSE) -1 );
    }else{
        iCnt = (*m_piTotalSE)- 1 -  (  (*m_piDeledSE) - (*m_piUsedSE) );    
    }

    return iCnt;
}


template <class T>
unsigned int SHMData_A<T>::getTotal()
{
    if (*m_piTotalSE)
        return (*m_piTotalSE)-1;

    return 0;   
}


template <class T>
bool SHMData_A<T>::revoke( unsigned int uiOffset)
{
    if(!m_poSHM)
        return false;
        
    if( ((*m_piDeledSE)+1 )%(*m_piTotalSE) == (*m_piUsedSE) )
        return false;
    
    T oTemp;
    memset(&oTemp, 0, sizeof(T) );
    if(memcmp(& m_pPointer[uiOffset], &oTemp, sizeof(T)) ==0){
        
        return false;
    }
    
    m_pIArray[(*m_piDeledSE)] = uiOffset;
    memset( & m_pPointer[uiOffset], 0, sizeof(T) );


    if( (*m_piDeledSE)+1 >= (*m_piTotalSE) ){
        (*m_piDeledSE) = 0;
        (*m_piDelOver)++;
    }else{
        (*m_piDeledSE)++;
    }
        
    return true;   

}


template <class T>
unsigned long SHMData_A<T>::getDelTotal( )
{
 
    
    if( sizeof(T) <32 )
        return ( (*m_piTotalSE) * (*m_piDelOver) + (*m_piDeledSE)  ) - 1;

    return ( (*m_piTotalSE) * (*m_piDelOver) + (*m_piDeledSE)  );
}



template <class T>
unsigned int SHMData_A<T>::getDelFree( )
{
    if( (*m_piDelOver) ){
        
        return getTotal()-getCount();
    }else{
        if( (*m_piUsedSE) > (*m_piDeledSE) ){
            if( sizeof(T) <32 )
                return (*m_piDeledSE)-1;
            else
                return (*m_piDeledSE) ;
        }else{
            return (*m_piDeledSE)-(*m_piUsedSE);
        }
    }
    
    
}



template <class T>
bool SHMData_A<T>::checkHealth()
{
    unsigned char * pData = new unsigned char[(*m_piTotalSE)];
    memset(pData, '0', sizeof(char)*(*m_piTotalSE)  );
    unsigned int i = (* m_piUsedSE );
    unsigned int j =0;
    bool bRet = true;
    
    for(; i != (* m_piDeledSE ); i++){
        if( i>= (* m_piTotalSE ) ){
            i = 0;
        }
        j = m_pIArray[i];
        if( 0== j){
            j = i;
        }
        if( '0' == pData[j] ){
            
            pData[j] = '1';
            
        }else{
            
            pData[j]++;
            bRet = false;
            cout<< pData[j]<<":"<< j<<",";
        }
        cout<<endl;
    }
    delete []pData;

    if( 0== m_pIArray[(* m_piTotalSE)]  ){
        
        if((*m_piDelOver)!=0 ){
            bRet = false;
            cout<<"1.";
        }
    }
    
    if( 0!= m_pIArray[(* m_piTotalSE)]  ){
        
        if( 0 == (*m_piDelOver) ){
            bRet = false;
            cout<<"2.";
        }
        unsigned int i = (* m_piUsedSE );
        if( i!=0  && 0== m_pIArray[i] ){
            bRet = false;
            cout<<"3.";
        }
        
        

    }

    return bRet;
    
}

template <class T>
void SHMData_A<T>::showDetail()
{
    if(!m_poSHM)
        return ;





    char sText[256];
    char keys[64];
    if(m_sSHMName) {
        strncpy(keys, m_sSHMName, sizeof(keys));
    }else{
        sprintf(keys, "%ld", m_lSHMKey);
    }
    if( !m_poSHM ){
    snprintf(sText, sizeof(sText), "%-10s 0x%-10lx %2u %-12s %-9d %-10u %-10u %4d%%",
        keys, 0,(*m_piVersion), "DATA_A", sizeof(T), 0, 0, 0 );
    }else{
    char * pp = (char * )(*m_poSHM);
    unsigned int uiTotal = getTotal();
    unsigned int uiCount = getCount();
    int percent = 100*uiCount/uiTotal;
    if( (100*uiCount)%uiTotal )
        percent++;
    snprintf(sText, sizeof(sText), "%-10s 0x%-10lx %2u %-12s %-9d %-10u %-10u %4u%% %-9u %-10lu",
        keys, pp,(*m_piVersion), "DATA_A", sizeof(T), uiTotal, uiCount, percent,
        getDelFree(), getDelTotal() );
    }
    cout<< sText<<endl;


}




template <class T>
unsigned int SHMData_A<T>::kick(unsigned int uiBeginOff, 
    int iNxtOffset, int iExpOffset, const char * sDate, unsigned int * o_uiKickSelf, bool * o_bKickSelf )
{
    if(!sDate || iNxtOffset<0 || iExpOffset<0 )
        return 0 ;

    unsigned int uiDataOff = uiBeginOff;
    unsigned int iCnt=0;
    *o_bKickSelf=false;
    if( uiDataOff ){
        unsigned int uiDataNext = *(unsigned int *)( ( (char *)&m_pPointer[uiDataOff] )+ iNxtOffset);
        unsigned int uiSelf= uiDataOff;
        
        while(uiDataNext){
            char * pExp = ( ( (char *)&m_pPointer[uiDataNext] ) + iExpOffset);
            if( strncmp(pExp, sDate, 8)<0 ){
                
                *(unsigned int *)( ( (char *)&m_pPointer[uiDataOff] )+ iNxtOffset) =
                *(unsigned int *)( ( (char *)&m_pPointer[uiDataNext])+ iNxtOffset);
                
                *(unsigned int *)( ( (char *)&m_pPointer[uiDataNext])+ iNxtOffset)=0;
                iCnt++;
                uiDataNext=*(unsigned int *)( ( (char *)&m_pPointer[uiDataOff] )+ iNxtOffset);
                continue;
            }
            uiDataOff = uiDataNext;
            uiDataNext=*(unsigned int *)( ( (char *)&m_pPointer[uiDataOff] )+ iNxtOffset);
        }
        char * pExp = ( ( (char *)&m_pPointer[uiSelf] ) + iExpOffset);
        if( strncmp(pExp, sDate, 8)<0 ){
            *o_uiKickSelf =
            *(unsigned int *)( ( (char *)&m_pPointer[uiSelf])+ iNxtOffset);
            
            *(unsigned int *)( ( (char *)&m_pPointer[uiSelf])+ iNxtOffset)=0;
            iCnt++;
            *o_bKickSelf = true;
            
        }
        
    }
    return iCnt;
}




template <class T>
unsigned int SHMData_A<T>::kickAndRevoke(unsigned int uiBeginOff, 
    int iNxtOffset, int iExpOffset, const char * sDate,
    int iChkOffset1, int iChkOffset2 , unsigned int  *o_uiKickSelf, bool * o_bKickSelf)
{
    if(!sDate || iNxtOffset<0 || iExpOffset<0 )
        return 0 ;

    unsigned int uiDataOff = uiBeginOff;
    unsigned int iCnt=0;
    *o_bKickSelf=false;
    
    if( uiDataOff ){
        unsigned int uiDataNext = *(unsigned int *)( ( (char *)&m_pPointer[uiDataOff] )+ iNxtOffset);
        unsigned int uiSelf= uiDataOff;
        
        while(uiDataNext){
            char * pExp = ( ( (char *)&m_pPointer[uiDataNext] ) + iExpOffset);
            if( strncmp(pExp, sDate, 8)<0 
                && ( iChkOffset1<0 
                    || 0 == *(unsigned int *)( ( (char *)&m_pPointer[uiDataOff] )+ iChkOffset1) )
                && ( iChkOffset2<0 
                    || 0 == *(unsigned int *)( ( (char *)&m_pPointer[uiDataOff] )+ iChkOffset2) )
                ){
                
                *(unsigned int *)( ( (char *)&m_pPointer[uiDataOff] )+ iNxtOffset) =
                *(unsigned int *)( ( (char *)&m_pPointer[uiDataNext])+ iNxtOffset);
                
                *(unsigned int *)( ( (char *)&m_pPointer[uiDataNext])+ iNxtOffset)=0;
                revoke(uiDataNext);
                iCnt++;
                uiDataNext=*(unsigned int *)( ( (char *)&m_pPointer[uiDataOff] )+ iNxtOffset);
                continue;
            }
            uiDataOff = uiDataNext;
            uiDataNext=*(unsigned int *)( ( (char *)&m_pPointer[uiDataOff] )+ iNxtOffset);
        }
        
        char * pExp = ( ( (char *)&m_pPointer[uiSelf] ) + iExpOffset);
        if( strncmp(pExp, sDate, 8)<0 
                && ( iChkOffset1<0 
                    || 0 == *(unsigned int *)( ( (char *)&m_pPointer[uiSelf] )+ iChkOffset1) )
                && ( iChkOffset2<0 
                    || 0 == *(unsigned int *)( ( (char *)&m_pPointer[uiSelf] )+ iChkOffset2) )
            ){
            *o_uiKickSelf =
            *(unsigned int *)( ( (char *)&m_pPointer[uiSelf])+ iNxtOffset);
            
            *(unsigned int *)( ( (char *)&m_pPointer[uiSelf])+ iNxtOffset)=0;
            iCnt++;
            revoke(uiSelf);
            *o_bKickSelf = true;
            
        }
    }
    return iCnt;
}
template <class T>
unsigned int SHMData_A<T>::getMemSize()
{
	unsigned int  size = 0;
	if (*m_piTotalSE)
	{
		size = (*m_piTotalSE)* sizeof(T);
	}
	if (size)
		return size ;
	
	return 0;
}
template <class T>
unsigned int SHMData_A<T>::getUsedSize()
{
	unsigned int size = 0;
	
	if (*m_piUsedSE)
	{
		 size = (*m_piUsedSE)* sizeof(T);
	}
	if (size)
		return size ;
	
	return 0;
}

template <class T>
unsigned long SHMData_A<T>::getMemAdress()
{		
	if (m_poSHM)
	{
		return   (unsigned long)m_poSHM;
	}
	
	return 0;
}

template <class T>
unsigned long SHMData_A<T>::getRealSize()
{
	  unsigned long size = m_poSHM->size();
		 return size;

}

template <class T>
time_t  SHMData_A<T>::getLoadTime()
{
	time_t shm_ctime;
	
	if (m_poSHM)
	{
		shm_ctime = m_poSHM->getShmTime();	
		
		return shm_ctime;
	}
	return  0;
	
}


















#line 16 "/hss/opt/opthss/src/bill/src/mmdb/UserInfo.h"
#line 1 "/hss/opt/opthss/src/bill/src/public/SHMData_B.h"
  










using namespace std;

#line 23 "/hss/opt/opthss/src/bill/src/public/SHMData_B.h"


const int SHM_BLOCK_NUM =250 ;       
const int SHM_BLOCK_KEY_NUM =250;    
const int SHM_BLOCK_MAX_KEY_VALUE = 999999999;  

class SHM_ARRAY{
    public:
unsigned int m_iTotalCnt;
unsigned int m_iUsedCnt;
int m_iKey;
};

class SHM_KEY_BLOCK_ARRAY{
    public:
SHM_ARRAY m_aBlock[SHM_BLOCK_NUM];
unsigned char m_icBKey[SHM_BLOCK_KEY_NUM];
unsigned char m_icBCur;

};




template <class T>
class SHMData_B : public SHMAccess
{
  public:

    SHMData_B(char *shmname);

    SHMData_B(long shmkey);

    ~SHMData_B();

    operator T *();
    
    void create(
        unsigned int itemnumber) ;

    void reset();


    unsigned int malloc(const int iKey);
    int  revoke(const int iKey);
    int  getAutoRevokeKey();
    void showDetail();
    int  getKeyByOffset(unsigned int iOffset);

    unsigned int getCount();
    unsigned int getCountMem();
    unsigned int getTotal();
     time_t getLoadTime();
	unsigned  int  getMemSize();
	unsigned  int  getUsedSize();
	unsigned long   getMemAdress();

    inline void checkSafe(){
        if(0 == *m_piFlag) return;
        while(*m_piFlag){
            usleep(102400);
        }            
    };
    
    bool setRevokeFlag( unsigned int iFlag){
        if(m_poSHM && m_piFlag){
            *m_piFlag = iFlag; 
            return true;
        }
        return false;
    };
    
    bool ifSetRevokeFlag(){
        if( *m_piFlag )
            return true;
        return false;
        };
    
    void getBlockInfo(SHM_KEY_BLOCK_ARRAY *pBlockArray ){
        *pBlockArray = *m_pBArray;
    };

  private:

    void open();
    unsigned char mallocBlock(const unsigned char icCurBlock, const int iKey);
  protected :
    unsigned int *m_piTotal;
    unsigned int *m_piUsed;
    T *m_pPointer;
    
    unsigned int *m_piVersion; 
    unsigned int *m_piTotalSE;
    unsigned int *m_piUsedSE;
    unsigned int *m_piDeledSE;
    unsigned int *m_piFlag;     

    SHM_KEY_BLOCK_ARRAY *m_pBArray;

};


template <class T>
SHMData_B<T>::SHMData_B(char *shmname) :
SHMAccess (shmname)
{
    if (m_poSHM){
        open ();
        if( 2 != *m_piVersion )
            throw Exception((110170000+1), (*__errno()), 132, "/hss/opt/opthss/src/bill/src/public/SHMData_B.h");
    }
}


template <class T>
SHMData_B<T>::SHMData_B(long shmkey) :
SHMAccess (shmkey)
{
    if (m_poSHM){
        open ();
        if( 2 != *m_piVersion )
            throw Exception((110170000+1), (*__errno()), 144, "/hss/opt/opthss/src/bill/src/public/SHMData_B.h");

    }
}



template <class T>
SHMData_B<T>::~SHMData_B()
{
}

template <class T>
SHMData_B<T>::operator T *()
{
	return m_pPointer;
}


template <class T>
void SHMData_B<T>::create(unsigned int itemnumber) 
{
    if( sizeof(T)<28 )
        throw Exception((110170000+3), (*__errno()), 167, "/hss/opt/opthss/src/bill/src/public/SHMData_B.h");
    SHMAccess::create((itemnumber+1)* sizeof(T)+ sizeof(SHM_KEY_BLOCK_ARRAY)  );
    open ();
    
    
	*m_piTotal = 1;
	*m_piUsed = 1;
        
    *m_piVersion = 2;
	*m_piTotalSE = itemnumber + 1 ;
	m_pBArray =(SHM_KEY_BLOCK_ARRAY *) &m_pPointer[(*m_piTotalSE)];

    for( int i=0; i<SHM_BLOCK_NUM; i++)
    {
        if( SHM_BLOCK_NUM-1 == i )
            m_pBArray->m_aBlock[i].m_iTotalCnt = *m_piTotalSE;
        else    
            m_pBArray->m_aBlock[i].m_iTotalCnt = ( (*m_piTotalSE)/SHM_BLOCK_NUM )*(i+1) + 1;
            
        if(0==i)
            m_pBArray->m_aBlock[i].m_iUsedCnt = 1;
        else
            m_pBArray->m_aBlock[i].m_iUsedCnt = m_pBArray->m_aBlock[i-1].m_iTotalCnt;
        
        m_pBArray->m_aBlock[i].m_iKey = 0;
    }
    for( int i=0; i<SHM_BLOCK_KEY_NUM; i++){
        m_pBArray->m_icBKey[i] = 255;
    }
    
    m_pBArray->m_icBCur = 0;
    (*m_piUsedSE) = 1;

}

template <class T>
void SHMData_B<T>::reset()
{
    for( int i=0; i<SHM_BLOCK_NUM; i++){
        if( SHM_BLOCK_NUM-1 == i )
            m_pBArray->m_aBlock[i].m_iTotalCnt = *m_piTotalSE;
        else    
            m_pBArray->m_aBlock[i].m_iTotalCnt = ( (*m_piTotalSE)/SHM_BLOCK_NUM )*i + 1;
            
        if(0==i)
            m_pBArray->m_aBlock[i].m_iUsedCnt = 1;
        else
            m_pBArray->m_aBlock[i].m_iUsedCnt = m_pBArray->m_aBlock[i-1].m_iTotalCnt;
        
        m_pBArray->m_aBlock[i].m_iKey = 0;
    }
    for( int i=0; i<SHM_BLOCK_KEY_NUM; i++){
        m_pBArray->m_icBKey[i] = 255;
    }
    
    m_pBArray->m_icBCur = 0;
    (*m_piUsedSE) = 1;

}

template <class T>
unsigned char SHMData_B<T>::mallocBlock(const unsigned char icCurBlock, const int iKey)
{
    unsigned char icRet;
    for(int j=0; j<SHM_BLOCK_NUM; j++){
        icRet = (j+icCurBlock)%SHM_BLOCK_NUM;
        if(0 == m_pBArray->m_aBlock[icRet].m_iKey ){
            m_pBArray->m_aBlock[icRet].m_iKey = iKey;
            return icRet;
        }
    }
    return 255;
}








template <class T>
unsigned int SHMData_B<T>::malloc(const int iKey)
{
    unsigned char icBlock = m_pBArray->m_icBCur;
         
    if(iKey != m_pBArray->m_aBlock[icBlock].m_iKey ){
        int i=0;
        int iFreeKey = -1;
 
        for(i=0; i<SHM_BLOCK_KEY_NUM; i++){
            if( m_pBArray->m_icBKey[i] >= SHM_BLOCK_NUM ){
                if(iFreeKey<0)  iFreeKey = i;
                continue;
            }
            if(iKey == m_pBArray->m_aBlock[  m_pBArray->m_icBKey[i] ].m_iKey ){
                icBlock = m_pBArray->m_icBKey[i];
                break;
            }
        }
        if(i== SHM_BLOCK_KEY_NUM && -1 == iFreeKey){
            
            return 0;
        }
        if(iKey != m_pBArray->m_aBlock[icBlock].m_iKey ){
            
            icBlock = mallocBlock( icBlock , iKey);
            if(255 == icBlock){
                return 0;
            }else{
                (*m_piUsedSE)++;
                m_pBArray->m_icBCur = icBlock;
                m_pBArray->m_icBKey[iFreeKey] = icBlock;
                return m_pBArray->m_aBlock[icBlock].m_iUsedCnt++;
            }
        }
    }
    
    
    if( m_pBArray->m_aBlock[icBlock].m_iTotalCnt 
        == m_pBArray->m_aBlock[icBlock].m_iUsedCnt){
        
        icBlock = mallocBlock( icBlock , iKey);
        if(255 == icBlock){
            return 0;
        }else{
            m_pBArray->m_icBCur = icBlock;
            int iTemp=0;
            for(iTemp=0; iTemp<SHM_BLOCK_KEY_NUM; iTemp++){
                if( m_pBArray->m_icBKey[iTemp] >= SHM_BLOCK_NUM ){
                    m_pBArray->m_icBKey[iTemp] = icBlock;
                    break;
                }
                if(iKey == m_pBArray->m_aBlock[  m_pBArray->m_icBKey[iTemp] ].m_iKey ){
                    m_pBArray->m_icBKey[iTemp] = icBlock;
                    break;
                }
            }
            (*m_piUsedSE)++;
            return m_pBArray->m_aBlock[icBlock].m_iUsedCnt++;
        }
        
    }
    (*m_piUsedSE)++;
    return m_pBArray->m_aBlock[icBlock].m_iUsedCnt++;
    
}


template <class T>
void SHMData_B<T>::open()
{
	m_piTotal = (unsigned *)((char *)(*m_poSHM)) + 1;
	m_piUsed = m_piTotal + 1;
	m_pPointer = (T *)((char *)(*m_poSHM));
    
    m_piVersion = m_piTotal - 1;

    m_piTotalSE = m_piTotal + 2;
    m_piFlag    = m_piTotal + 3;
    m_piUsedSE  = m_piTotal + 4;
    m_piDeledSE = m_piTotal + 5; 


    if( (*m_piTotalSE) )
        m_pBArray =(SHM_KEY_BLOCK_ARRAY *) &m_pPointer[(*m_piTotalSE)];
    else
        m_pBArray = 0;

}


template <class T>
unsigned int SHMData_B<T>::getCountMem()
{
    unsigned int uiRet = 0;
    for(int i=0;i<SHM_BLOCK_NUM; i++){
        if( m_pBArray->m_aBlock[i].m_iKey != 0 ){
            if(0 == i){
                uiRet += (m_pBArray->m_aBlock[i].m_iUsedCnt - 1 );
            }else{
                uiRet += (m_pBArray->m_aBlock[i].m_iUsedCnt - m_pBArray->m_aBlock[i-1].m_iTotalCnt );
            }
        }
    }

    return uiRet;
}


template <class T>
unsigned int SHMData_B<T>::getCount()
{
    if (*m_piUsedSE)
        return (*m_piUsedSE)-1;

    return 0;   
}


template <class T>
unsigned int SHMData_B<T>::getTotal()
{
    if (*m_piTotalSE)
        return (*m_piTotalSE)-1;

    return 0;   
}



template <class T>
int SHMData_B<T>::getAutoRevokeKey()
{
    if(!m_poSHM)
        return -1;
    int i = 0;
    int iBlock=0;
    int iKey = SHM_BLOCK_MAX_KEY_VALUE-1;
    
    for( i=0; i<SHM_BLOCK_KEY_NUM; i++){
        if( m_pBArray->m_icBKey[i]< SHM_BLOCK_NUM ){
            int iTemp =  m_pBArray->m_aBlock[ m_pBArray->m_icBKey[i] ].m_iKey;
            if( 0 == iTemp
              ||SHM_BLOCK_MAX_KEY_VALUE == iTemp){
                continue;
            }else{
                iBlock++;
            }
            if( iTemp < iKey )
                iKey = iTemp;

        }
    }
    
    if( iBlock < 2 ){
        return 0;
    }
    
    return iKey;
           
}



template <class T>
int SHMData_B<T>::revoke(const int iKey)
{
    if(!m_poSHM)
        return -1;
    if( 0==iKey)
        return -1;
            
    setRevokeFlag(1);
    
    int iRet = 0;
        
    int i = 0;

    for( i=0; i<SHM_BLOCK_KEY_NUM; i++){
        if( m_pBArray->m_icBKey[i]< SHM_BLOCK_NUM 
            && iKey == m_pBArray->m_aBlock[ m_pBArray->m_icBKey[i] ].m_iKey ){
            m_pBArray->m_icBKey[i] = 255;
            
        }
    }
    
    for(i=0;i<SHM_BLOCK_NUM; i++){
        if(iKey ==  m_pBArray->m_aBlock[i].m_iKey){
            iRet++;
            if(0==i){
                (*m_piUsedSE) -= (m_pBArray->m_aBlock[i].m_iUsedCnt -1);
                m_pBArray->m_aBlock[i].m_iUsedCnt = 1;
            }else{
                (*m_piUsedSE) -= (m_pBArray->m_aBlock[i].m_iUsedCnt - m_pBArray->m_aBlock[i-1].m_iTotalCnt);
                m_pBArray->m_aBlock[i].m_iUsedCnt = m_pBArray->m_aBlock[i-1].m_iTotalCnt;
            }
            
            m_pBArray->m_aBlock[i].m_iKey = 0;
            memset( & m_pPointer[m_pBArray->m_aBlock[i].m_iUsedCnt],
                0,
                (m_pBArray->m_aBlock[i].m_iTotalCnt - m_pBArray->m_aBlock[i].m_iUsedCnt )*sizeof(T) );
            
        }
    }

    setRevokeFlag(0);
    return iRet;   

}

template <class T>
void SHMData_B<T>::showDetail()
{
    if(!m_poSHM)
        return;
    
    int i;
    unsigned int iuse,itotal;
    
    iuse = 0;
    for( i=0; i<SHM_BLOCK_KEY_NUM; i++){
        if( m_pBArray->m_icBKey[i]< SHM_BLOCK_NUM){
            iuse++;
        }
    }
        
    cout<<""<<  (*m_piVersion) <<", "<< getCountMem() << endl;
    cout<<""<<  SHM_BLOCK_NUM << ","<< (int)m_pBArray->m_icBCur <<endl;
    cout<<""<<  SHM_BLOCK_KEY_NUM 
        << ","<< iuse <<endl;


    for(i=0;i<SHM_BLOCK_NUM; i++){
        cout<< "  " << i << "key"<< m_pBArray->m_aBlock[i].m_iKey;
        cout<<" /,:["; 
        if(0 == i){
            iuse = m_pBArray->m_aBlock[i].m_iUsedCnt -1 ;
            itotal = m_pBArray->m_aBlock[i].m_iTotalCnt - 1 ;
            
        }else{
            iuse = m_pBArray->m_aBlock[i].m_iUsedCnt - m_pBArray->m_aBlock[i-1].m_iTotalCnt ;
            itotal = m_pBArray->m_aBlock[i].m_iTotalCnt - m_pBArray->m_aBlock[i-1].m_iTotalCnt ;
        }
        cout<<iuse <<"/" << itotal<<",\t" << iuse*100/itotal <<"%]" <<endl ;

    }
    
    
}


template <class T>
int  SHMData_B<T>::getKeyByOffset(unsigned int iOffset)
{
    if(0 ==iOffset)
        return -1;
        
    unsigned int i = (iOffset-1)/( (*m_piTotalSE)/SHM_BLOCK_NUM ) ;
    if( i>=0 && i<SHM_BLOCK_NUM ){
        return  m_pBArray->m_aBlock[i].m_iKey;
    }
    return -1;
    
}
template <class T>
unsigned int SHMData_B<T>::getMemSize()
{
	unsigned int  size = 0;
		
	if (*m_piTotal)
	{
	 	size = (*m_piTotalSE+1)* sizeof(T)+ sizeof(SHM_KEY_BLOCK_ARRAY);
	}
	
	if (size)
		return size;
	
	return 0;
}
template <class T>
unsigned int SHMData_B<T>::getUsedSize()
{
	unsigned int size = 0;
	
	if (*m_piUsed)
	{
		size = (*m_piUsedSE+1)* sizeof(T)+ sizeof(SHM_KEY_BLOCK_ARRAY) ;
				
				
	}
	if (size)
		return size;
	
	return 0;
}

template <class T>
unsigned long SHMData_B<T>::getMemAdress()
{		
	if (m_poSHM)
	{
		return  (unsigned long )m_poSHM;	
	}
	return  0;
}
template <class T>
time_t  SHMData_B<T>::getLoadTime()
{
	time_t shm_ctime;
	
	if (m_poSHM)
	{
		shm_ctime = m_poSHM->getShmTime();
		

		return shm_ctime ;
	}
	return  0;
}

#line 17 "/hss/opt/opthss/src/bill/src/mmdb/UserInfo.h"
#line 1 "/hss/opt/opthss/src/bill/src/public/SHMStringTreeIndex.h"
  



#line 11 "/hss/opt/opthss/src/bill/src/public/SHMStringTreeIndex.h"

#line 21 "/hss/opt/opthss/src/bill/src/public/SHMStringTreeIndex.h"






class SHMStringList
{
    friend class SHMStringTreeIndex;

    
    unsigned int m_iValue;

    
    unsigned int m_iNext;

    
    char m_sKey[8];

};


class SHMStringTree
{
    friend class SHMStringTreeIndex;

    
    unsigned int m_iNext[10];

    
    unsigned int m_iValue;

};






class SHMStringTreeIndex : public SHMAccess
{
  public:
    
    SHMStringTreeIndex(char *shmname);

    
    SHMStringTreeIndex(long shmkey);

    
    ~SHMStringTreeIndex();

    
    void add(char *key, unsigned int value);

    
    bool get(char *key, unsigned int *pvalue);

    bool getMax(char *key, unsigned int *pvalue);
	bool getMax(char *key, unsigned int *pvalue,unsigned int *pMatchLen);
	
	
	int getAll(char *key, std::vector<unsigned int> &vec);

    
    
    
    void create(
        
        
        unsigned int itemnumber, 
        
        
        unsigned int keylen, 
        
        
        unsigned int multiple = 3) ;
    void empty();

   unsigned int getUsedSize();
    unsigned long   getMemAdress();
        
    time_t getLoadTime();
      
    unsigned int   getMemSize();
                  

	unsigned int getCount()
	{
		if (*m_piTreeUsed)
			return (*m_piTreeUsed);

		return 0;
	};

	unsigned int getTotal()
	{
		if (*m_piTreeTotal)
			return (*m_piTreeTotal);

		return 0;
	};

	unsigned int getlCount()
	{
		if (*m_piListUsed)
			return (*m_piListUsed);

		return 0;		
	};

	unsigned int getlTotal()
	{
		if (*m_piListTotal)
			return (*m_piListTotal);

		return 0;
	};
	
	
  private:
    
    void open();
    
    inline SHMStringList *getList(unsigned int offset);


    
    unsigned int *m_piListTotal;

    
    unsigned int *m_piListUsed;

    
    unsigned int *m_piTreeTotal;

    
    unsigned int *m_piTreeUsed;

    
    
    
    unsigned int *m_piListLen;

    
    char *m_poList;

    
    SHMStringTree *m_poTree;
    
    unsigned int *m_piKeyLen;
 


};


#line 18 "/hss/opt/opthss/src/bill/src/mmdb/UserInfo.h"
#line 1 "/hss/opt/opthss/src/bill/src/public/SHMStringTreeIndex_A.h"
  












#line 23 "/hss/opt/opthss/src/bill/src/public/SHMStringTreeIndex_A.h"







class SHMStringList_A
{
    friend class SHMStringTreeIndex_A;
public:

    
    unsigned int m_iValue;

    
    unsigned int m_iNext;

    
    char m_sKey[8];

};


class SHMStringTree_A
{
    friend class SHMStringTreeIndex_A;
public:
    
    unsigned int m_iNext[10];

    
    unsigned int m_iValue;

};


class SHMPreTree_A
{
public:
    SHMStringTree_A * pTree;
    unsigned int  iOffset;
};







class SHMStringTreeIndex_A : public SHMAccess
{
public:


	class Iteration
	{
	  public:
        
        bool next(const char * &pkey, unsigned int & value)
        {
            SHMStringList_A *pl;
            
            if(m_iCurI > m_pIdx->getlTotal() 
                || m_iCurJ >= m_iCount ){
                return false;
            }
            m_puiPrePosition = 0;
            m_iCurOffset = 0;
            m_iTreePre = 0;
            for( ; m_iCurI <= m_pIdx->getlTotal() ; m_iCurI++) {
                pl = m_pIdx->getList(m_iCurI);
                
                if(!pl)
                    continue;
                
                
            	if(! pl->m_sKey[0] || !pl->m_iValue )
            	    continue;
            	
            	unsigned int i, j;
            	char *p = pl->m_sKey;
            	unsigned int index = 0;
           	    
            	for(i=0; i<12 && *p; p++,i++) {
            		j = (*p)%10;
            		
            		if (m_pIdx->m_poTree[index].m_iNext[j]) {
            		    m_pPre[i].pTree = &m_pIdx->m_poTree[index];
            		    m_pPre[i].iOffset = j;
            			index = m_pIdx->m_poTree[index].m_iNext[j];
            		} else {
            			index = 0;
            			break;
            		}
            		
            	}
                if(0==index) 
                    continue;

                
                
            	if (!m_pIdx->m_poTree[index].m_iValue)
            	    continue;
            	
            	m_iTreePre = i-1;
            	

            	j = m_pIdx->m_poTree[index].m_iValue;
            	p = pl->m_sKey;
            	pl = m_pIdx->getList(j);
            	m_puiPrePosition = &m_pIdx->m_poTree[index].m_iValue;
            	m_iCurOffset = j;
            	m_iNextOffset = pl->m_iNext;
            	while ( pl ) {
            		if (!strncmp(pl->m_sKey, p, m_iStringKeyLen) ){
            			m_pl = pl;
                        pkey = m_pl->m_sKey;
                        value = m_pl->m_iValue;
                        m_iCurJ++;
                        m_iCurI++;
            			return true;
            		}
            		m_puiPrePosition = &pl->m_iNext;
            		m_iCurOffset = pl->m_iNext;
            		pl = m_pIdx->getList (pl->m_iNext);
            		m_iNextOffset = pl->m_iNext;
            	}

            }
            m_puiPrePosition = 0;
            m_iCurOffset = 0;
            m_iTreePre = 0;
            m_pl = 0;
            return false;
            
        }


		Iteration ( SHMStringTreeIndex_A * pIdx, int iKeyLen):
		m_iCurI(1),m_iCurJ(0), 
		m_iCurOffset(0),m_puiPrePosition(0),m_pl(0),m_iTreePre(0),
		m_pIdx(pIdx),m_iStringKeyLen(iKeyLen)
		{
		    memset(m_pPre,0,sizeof(m_pPre) );
		    m_iCount = pIdx->getlCount();
		}

		Iteration (const Iteration & right)
		{
			m_iCurI = right.m_iCurI;
			m_iCurJ = right.m_iCurJ;
			m_iCurOffset = right.m_iCurOffset;
			m_iNextOffset= right.m_iNextOffset;
			m_puiPrePosition = right.m_puiPrePosition;
			
			m_pIdx = right.m_pIdx;
			m_pl = right.m_pl;
			m_iStringKeyLen = right.m_iStringKeyLen;
            
            m_iTreePre = right.m_iTreePre;
            memcpy(m_pPre, right.m_pPre, sizeof(m_pPre) );
            m_iCount = right.m_iCount;
		}

        bool setValue( unsigned int iValue ){
            if( m_iCurOffset && m_pl){
                
                if(0 == iValue){
                    return removeMe();
                }
                m_pl->m_iValue = iValue;
                return true;
            }
            return false;
        }
        
        bool removeMe(){
            
            unsigned int j=0;
            unsigned int * m_piListUsed = m_pIdx->m_piListUsed;
            unsigned int * m_piListTotal = m_pIdx->m_piListTotal;
            unsigned int * m_piListTail = m_pIdx->m_piListTail;
            unsigned int * m_piListHead = m_pIdx->m_piListHead;

            if(m_puiPrePosition && (*m_puiPrePosition == m_iCurOffset) ){
                *m_puiPrePosition = m_iNextOffset;
                
                j = m_iCurOffset;
                m_pl->m_sKey[0] = 0;
                m_pl->m_iValue = 0;
                memset(m_pl->m_sKey, 0, m_iStringKeyLen );
                m_pl->m_iNext = 0;
                
                if( *m_piListUsed <= *m_piListTotal ){
                    
                    SHMStringList_A * pList = m_pIdx->getList(*m_piListTail);
                    pList->m_iNext = j;
                }else{
                    *m_piListHead = j;
                }
                *m_piListTail = j;
                (*m_piListUsed)--;

                j = m_pPre[m_iTreePre].pTree->m_iNext[ m_pPre[m_iTreePre].iOffset ];
    			if(m_iTreePre && 0 == m_pIdx->m_poTree[ j ].m_iValue ){
                    unsigned int * m_piTreeUsed = m_pIdx->m_piTreeUsed;
                    unsigned int * m_piTreeTotal = m_pIdx->m_piTreeTotal;
                    unsigned int * m_piTreeTail = m_pIdx->m_piTreeTail;
                    unsigned int * m_piTreeHead = m_pIdx->m_piTreeHead;    			    
    			    SHMStringTree_A treeTemp;
    			    memset(&treeTemp, 0, sizeof(SHMStringTree_A) );
    			    
    			    while(0==memcmp(&m_pIdx->m_poTree[j], &treeTemp, sizeof(SHMStringTree_A)) ){
    			        

                        m_pPre[m_iTreePre].pTree->m_iNext[ m_pPre[m_iTreePre].iOffset ] = 0;
                        if( *m_piTreeUsed < *m_piTreeTotal ){
                            
                            m_pIdx->m_poTree[*m_piTreeTail].m_iNext[0] = j;
                        }else{
                            *m_piTreeHead = j;
                        }
                        *m_piTreeTail = j;
                        (*m_piTreeUsed)--;
                        
                        if( 0==m_iTreePre )
                            break;
                        
    			        m_iTreePre--;
    			        j = m_pPre[m_iTreePre].pTree->m_iNext[ m_pPre[m_iTreePre].iOffset ];
    			        
    			    }
    			}

                return true;
            }
            return false;
            
        }
	  private:
		unsigned int m_iCurOffset;
		unsigned int m_iNextOffset;
		unsigned int * m_puiPrePosition;

        unsigned int m_iCurI;
        unsigned int m_iCurJ;
        SHMStringList_A *m_pl;
		SHMStringTreeIndex_A * m_pIdx;
		int m_iStringKeyLen;

		SHMPreTree_A m_pPre[12];
		int  m_iTreePre;
		unsigned int m_iCount;
	};
	
	    
  public:
    Iteration getIteration ()
	{
		return Iteration (this, *m_piKeyLen );
	}

	friend class Iteration;

    
    SHMStringTreeIndex_A(char *shmname);

    
    SHMStringTreeIndex_A(long shmkey);

    
    ~SHMStringTreeIndex_A();

    
    void add(char *key, unsigned int value);

    
    bool get(char *key, unsigned int *pvalue);

    bool getMax(char *key, unsigned int *pvalue);

    bool revokeIdx(char * key, unsigned int &value);
    void reset(){ empty(); };
    void empty();
    void showDetail();
    
    unsigned int mallocTree();
    unsigned int mallocList();
    

    
    
    
    void create(
        
        
        unsigned int itemnumber, 
        
        
        unsigned int keylen, 
        
        
        unsigned int multiple = 3) ;
            
    unsigned int getMemSize();

	int getUsedSize();
			
	unsigned long getMemAdress();
	
	time_t getLoadTime();
	
        

	unsigned int getCount()
	{
		if (*m_piTreeUsed)
			return (*m_piTreeUsed);

		return 0;
	};

	unsigned int getTotal()
	{
		if (*m_piTreeTotal)
			return (*m_piTreeTotal);

		return 0;
	};

	unsigned int getlCount()
	{
		if (*m_piListUsed)
			return (*m_piListUsed)-1;

		return 0;		
	};

	unsigned int getlTotal()
	{
		if (*m_piListTotal)
			return (*m_piListTotal);

		return 0;
	};
	
  private:
    
    void open();
    
    SHMStringList_A *getList(unsigned int offset);


    
    unsigned int *m_piListTotal;

    
    unsigned int *m_piListUsed;

    
    unsigned int *m_piTreeTotal;

    
    unsigned int *m_piTreeUsed;

    
    
    
    unsigned int *m_piListLen;

    
    char *m_poList;

    
    SHMStringTree_A *m_poTree;
    
    unsigned int *m_piKeyLen;



    unsigned int *m_piTreeHead;
    unsigned int *m_piTreeTail;
    unsigned int *m_piListHead;
    unsigned int *m_piListTail;
    unsigned int *m_piVersion; 

};


#line 19 "/hss/opt/opthss/src/bill/src/mmdb/UserInfo.h"
#line 1 "/hss/opt/opthss/src/bill/src/public/SHMIntHashIndex.h"
  









#line 20 "/hss/opt/opthss/src/bill/src/public/SHMIntHashIndex.h"


class SHMIntList
{
    friend class SHMIntHashIndex;

public:
    
    long m_lKey;

    
    unsigned int m_iValue;

    
    unsigned int m_iNext;

};





class SHMIntHashIndex : public SHMAccess
{
  public:


	class Iteration
	{
	  public:
		bool next(long & key, unsigned int & value)
		{
			unsigned int j;
            
            if(m_iCur>m_iHash){
                return false;
            }
            if( m_iNextOffset !=0
                && 0 != m_pIdx->m_poList[m_iNextOffset].m_iValue){
                m_iCurOffset = m_iNextOffset;
                
                value = m_pIdx->m_poList[m_iCurOffset].m_iValue;
                key = m_pIdx->m_poList[m_iCurOffset].m_lKey;
                m_iNextOffset = m_pIdx->m_poList[m_iCurOffset].m_iNext;
                return true;
                
            }
            if(0==m_iNextOffset){
                m_iCur++;
                m_iNextOffset = 0;
                m_iCurOffset = 0;
                if(m_iCur>m_iHash){
                    return false;
                }
            }
            while( 1 ){
                j=m_pIdx->m_poHash[m_iCur-1];
                if( 0 == j){
                    m_iCur++;
                    m_iNextOffset = 0;
                    m_iCurOffset = 0;
                    if(m_iCur>m_iHash){
                        return false;
                    }
                    continue;
                }
                if(0 == m_iNextOffset )
                    m_iNextOffset = j;
                    
                while( m_iNextOffset != 0 
                    && 0 == m_pIdx->m_poList[m_iNextOffset].m_iValue ){
                    m_iNextOffset = m_pIdx->m_poList[m_iNextOffset].m_iNext;
                }
                
                if(0 == m_iNextOffset ){
                    m_iCur++;
                    m_iNextOffset = 0;
                    m_iCurOffset = 0;
                    if(m_iCur>m_iHash){
                        return false;
                    }
                    continue;
                }
                
                break;
                
            }
            m_iCurOffset = m_iNextOffset;
			value = m_pIdx->m_poList[m_iCurOffset].m_iValue;
			key = m_pIdx->m_poList[m_iCurOffset].m_lKey;
			m_iNextOffset = m_pIdx->m_poList[m_iCurOffset].m_iNext;
			return true;		
		}

		Iteration ( unsigned int iHash, SHMIntHashIndex * pIdx):
		m_iCur(0), m_iCurOffset(0),m_iNextOffset(0), m_iHash(iHash), m_pIdx(pIdx)
		{}

		Iteration (const Iteration & right)
		{
			m_iCur = right.m_iCur;
			m_iHash = right.m_iHash;
			m_iCurOffset = right.m_iCurOffset;
			m_iNextOffset = right.m_iNextOffset;
			m_pIdx = right.m_pIdx;
		}

        bool setValue( unsigned int iValue ){
            if( m_iCurOffset ){
                m_pIdx->m_poList[m_iCurOffset].m_iValue = iValue;
                return true;
            }
            return false;
        }
        
	  private:
		unsigned int m_iCur;
		unsigned int m_iHash;
		unsigned int m_iCurOffset;
		unsigned int m_iNextOffset;
		
		SHMIntHashIndex * m_pIdx;
	};
	
	Iteration getIteration ()
	{
		return Iteration ( (*m_piHashValue)+1, this);
	}

    friend class Iteration;

    
    SHMIntHashIndex(char *shmname);

    
    SHMIntHashIndex(long shmkey);

    
    ~SHMIntHashIndex();

    
    void add(long key, unsigned int value);

    
    bool get(long key, unsigned int *pvalue);

	void eraseData(long key);
	void reset();

    
    
    
    void create(
        
        
        unsigned int itemnumber) ;
	
	
	void empty();
	
	int  getMemSize();

	int getUsedSize();
			
	unsigned long getMemAdress();
	
	time_t getLoadTime();
	
		

			

	unsigned int getCount()
	{
		if (*m_piUsed)
			return (*m_piUsed)-1;

		return 0;
	};

	unsigned int getTotal()
	{
		if (*m_piTotal)
			return (*m_piTotal);

		return 0;
	};

  private:
    
    void open();

    
    
    
    unsigned int *m_piHashValue;

    
    unsigned int *m_piTotal;

    
    unsigned int *m_piUsed;

    
    unsigned int *m_poHash;    

    
    SHMIntList *m_poList;    
    


};




#line 20 "/hss/opt/opthss/src/bill/src/mmdb/UserInfo.h"
#line 1 "/hss/opt/opthss/src/bill/src/public/SHMIntHashIndex_A.h"
 













#line 24 "/hss/opt/opthss/src/bill/src/public/SHMIntHashIndex_A.h"


class SHMIntList_A
{
    friend class SHMIntHashIndex_A;
public:
    
    long m_lKey;

    
    unsigned int m_iValue;

    
    unsigned int m_iNext;

};





class SHMIntHashIndex_A : public SHMAccess
{
public:

	class Iteration
	{
	  public:
		bool next(long & key, unsigned int & value)
		{
			unsigned int j;
            
            if(m_iCur>m_iHash){
                return false;
            }
            if( m_iNextOffset !=0
                && 0 != m_pIdx->m_poList[m_iNextOffset].m_iValue){
                
                 if(*m_puiPrePosition!=m_iNextOffset ){
                    m_puiPrePosition=&m_pIdx->m_poList[m_iCurOffset].m_iNext;
                } 
        
                m_iCurOffset = m_iNextOffset;

                value = m_pIdx->m_poList[m_iCurOffset].m_iValue;
                key = m_pIdx->m_poList[m_iCurOffset].m_lKey;
                m_iNextOffset = m_pIdx->m_poList[m_iCurOffset].m_iNext;
                return true;

            }
            if(0==m_iNextOffset){
                
                m_iCur++;
                m_iNextOffset = 0;
                m_iCurOffset = 0;
                m_puiPrePosition=& m_pIdx->m_poHash[m_iCur-1];
                if(m_iCur>m_iHash){
                    return false;
                }
            }
            while( 1 ){
                j=m_pIdx->m_poHash[m_iCur-1];
                m_puiPrePosition=& m_pIdx->m_poHash[m_iCur-1];
                if( 0 == j){
                    m_iCur++;
                    m_iNextOffset = 0;
                    m_iCurOffset = 0;
                    m_puiPrePosition=& m_pIdx->m_poHash[m_iCur-1];
                    if(m_iCur>m_iHash){
                        return false;
                    }
                    continue;
                }
                if(0 == m_iNextOffset )
                    m_iNextOffset = j;
                    
                while( m_iNextOffset != 0 
                    &&( 0 == m_pIdx->m_poList[m_iNextOffset].m_iValue ) ){
                    m_puiPrePosition=& m_pIdx->m_poList[m_iNextOffset].m_iNext;
                    m_iNextOffset = m_pIdx->m_poList[m_iNextOffset].m_iNext;
                    
                }
                
                if(0 == m_iNextOffset ){
                    m_iCur++;
                    m_iNextOffset = 0;
                    m_iCurOffset = 0;
                    m_puiPrePosition=& m_pIdx->m_poHash[m_iCur-1];
                    if(m_iCur>m_iHash){
                        return false;
                    }
                    continue;
                }
                
                break;
                
            }
            m_iCurOffset = m_iNextOffset;
			value = m_pIdx->m_poList[m_iCurOffset].m_iValue;
			key = m_pIdx->m_poList[m_iCurOffset].m_lKey;
			m_iNextOffset = m_pIdx->m_poList[m_iCurOffset].m_iNext;
			return true;		
		}

		Iteration ( unsigned int iHash, SHMIntHashIndex_A * pIdx):
		m_iCur(0), m_iCurOffset(0),m_iNextOffset(0),m_puiPrePosition(0), m_iHash(iHash), m_pIdx(pIdx)
		{}

		Iteration (const Iteration & right)
		{
			m_iCur = right.m_iCur;
			m_iHash = right.m_iHash;
			m_iCurOffset = right.m_iCurOffset;
			m_iNextOffset = right.m_iNextOffset;
			m_puiPrePosition = right.m_puiPrePosition;
			m_pIdx = right.m_pIdx;
		}

        bool setValue( unsigned int iValue ){
            if( m_iCurOffset ){
                m_pIdx->m_poList[m_iCurOffset].m_iValue = iValue;
                if(0 == iValue){
                    return removeMe();
                }
                return true;
            }
            return false;
        }
        
        bool removeMe(){
            
            SHMIntList_A * m_poList = m_pIdx->m_poList;
            unsigned int * m_piUsed = m_pIdx->m_piUsed;
            unsigned int * m_piTotal = m_pIdx->m_piTotal;
            unsigned int * m_piTail = m_pIdx->m_piTail;
            unsigned int * m_piHead = m_pIdx->m_piHead;


            if(m_puiPrePosition && (*m_puiPrePosition == m_iCurOffset) ){
                *m_puiPrePosition = m_iNextOffset;
                
                
                m_poList[m_iCurOffset].m_lKey = 0;
                m_poList[m_iCurOffset].m_iValue = 0;
                
                *m_puiPrePosition = m_poList[m_iCurOffset].m_iNext;
                m_poList[m_iCurOffset].m_iNext = 0;
                
                if( *m_piUsed <= *m_piTotal )
                    m_poList[*m_piTail].m_iNext = m_iCurOffset;
                else
                    *m_piHead = m_iCurOffset;
    
                *m_piTail = m_iCurOffset;
                (*m_piUsed)--;
                return true;
            }
            return false;
            
        }
	  private:
		unsigned int m_iCur;
		unsigned int m_iHash;
		unsigned int m_iCurOffset;
		unsigned int m_iNextOffset;
		unsigned int * m_puiPrePosition;
		
		SHMIntHashIndex_A * m_pIdx;
	};
	
	    
  public:
    Iteration getIteration ()
	{
		return Iteration ( (*m_piHashValue)+1, this);
	}
	
	friend class Iteration;
	
    
    SHMIntHashIndex_A(char *shmname);

    
    SHMIntHashIndex_A(long shmkey);

    
    ~SHMIntHashIndex_A();

    
    void add(long key, unsigned int value);

    
    bool get(long key, unsigned int *pvalue);

    bool revokeIdx(long key, unsigned int &value);
    void reset();  
    unsigned int malloc();
    void showDetail();
    
    
    
    
    void create(
        
        
        unsigned int itemnumber) ;
    
    
    void empty();
    
    unsigned int getMemSize();

	int getUsedSize();
			
	unsigned long getMemAdress();
	
	time_t getLoadTime();
	

    unsigned int getCount()
    {
        if (*m_piUsed)
            return (*m_piUsed)-1;

        return 0;
    };

    unsigned int getTotal()
    {
        if (*m_piTotal)
            return (*m_piTotal);

        return 0;
    };


  private:
    
    void open();

    
    
    
    unsigned int *m_piHashValue;

    
    unsigned int *m_piTotal;

    
    unsigned int *m_piUsed;

    
    unsigned int *m_poHash;

    
    SHMIntList_A *m_poList;

    unsigned int *m_piHead;
    unsigned int *m_piTail;
    unsigned int *m_piVersion; 
    unsigned int *m_piDelOver; 
};




#line 21 "/hss/opt/opthss/src/bill/src/mmdb/UserInfo.h"
#line 1 "/hss/opt/opthss/src/bill/src/public/BillingCycleMgr.h"
  
#line 1 "/hss/opt/opthss/src/bill/src/public/BillingCycleBase.h"
  





 







#line 1 "/hss/opt/opthss/src/bill/src/public/BillingCycle.h"
  






 

 








class BillingCycle
{
    friend class UserInfoInterface;

    friend class Serv;

  public:
    
    int getBillingCycleID() const;

    
    int getBillingCycleType() const;

    
    char *getBlockDate() const;

    
    char *getDueDate() const;

    
    char *getEndDate() const;

    
    char *getStartDate() const;

    
    char *getState() const;

    
    char *getStateDate() const;

    bool isFirstDay(Date &d);
    bool isFirstDay(char *sDate);

    bool isLastDay(Date &d);
    bool isLastDay(char *sDate);

    
    int getDays();
    
    BillingCycle();

    
    int m_iBillingCycleID;
    
    int m_iBillingCycleType;
    
    int m_iLastID;
    
    char m_sState[4];
    
    char m_sStartDate[16];
    
    char m_sEndDate[16];
    
    char m_sStateDate[16];
    
    char m_sDueDate[16];
    
    char m_sBlockDate[16];
    
    unsigned int m_iPre;


    
    unsigned int m_iNext;

  
    
    int m_iParent;

};



#line 16 "/hss/opt/opthss/src/bill/src/public/BillingCycleBase.h"





class BillingCycleBase
{
  public:
    
    BillingCycleBase();

  protected:
    
    static SHMData <BillingCycle> *m_poCycleData;

    
    static SHMIntHashIndex *m_poTypeIndex;

    
    static bool m_bAttached;

};



#line 6 "/hss/opt/opthss/src/bill/src/public/BillingCycleMgr.h"
class BillingCycle;

using namespace std;




class BillingCycleMgr : public BillingCycleBase
{
  public:
    
    BillingCycleMgr();

    
    ~BillingCycleMgr();

    
    BillingCycle *getBillingCycle(int iCycleType, char *sTime);

    BillingCycle *getOccurBillingCycle(int iCycleType, char *sTime);

    
    int getBillingCycles(vector <BillingCycle *> &ret, int cycleType, char *beginDate, char *endDate);

    
    BillingCycle *getBillingCycle(int iBillingCycleID);

    
    BillingCycle *getPreBillingCycle(int iBillingCycleID);

    int diffBillingCycle(int iBillingCycle1, int iBillingCycle2);

    bool endBillingCycle(int iBillingCycleID, bool changeDB=false);

    BillingCycle *getCurBillingCycle(int iCycleType, int iOffset);
};



#line 23 "/hss/opt/opthss/src/bill/src/mmdb/UserInfo.h"
#line 1 "/hss/opt/opthss/src/bill/src/public/AcctItemMgr.h"
  





class SimpleMatrix;
class ParamInfoMgr;

 

class AcctItem
{
    friend class AcctItemMgr;
    friend class AcctItemLoad;
    friend class ParamInfoMgr;
    friend class AssPriData;    
  public:
    
    AcctItem();

  private:
    
    int m_iAcctItemID;

    
    int m_iParentID;
		
		int m_iPartyRoleID;
		
    char m_sAcctItemCode[20];

    
    AcctItem *m_poParent;

    AcctItem *m_poOther;

    int m_iOffset;

    unsigned int m_iParentOffset;   
    unsigned int m_iOtherOffset;    


};

struct AcctItemChild
{
	int m_iAcctItemID;
	int m_iChildNum;
	int m_aoChildItemID[4096];
};

struct ItemGroupMemberB
{
	int m_iItemObjectID;
	int m_iObjectType;
	int m_iExcludeFlag;
	ItemGroupMemberB * m_poNext;
};

struct ItemGroupMember {
    int m_iItemTypeID;
    ItemGroupMember * m_poNext;

    int m_iItemGroupID;
    unsigned int m_iNextOffset;

};




class AcctItemMgr
{
  public:
    
    void load();

    
    void unload();

    
    bool getBelongGroup(int acctitem, int acctitemgroup );

    
    bool getBelongGroupB(int acctitem, int bacctitemgroup );

    bool getBelongGroupB(int acctitem, int bacctitemgroup, bool bDiscount);
    bool getBelongGroupB(int acctitem, int bacctitemgroup, ParamInfoMgr* pParamInfoMgr);

    
    AcctItemMgr();
	AcctItemMgr(int iMode);


    
    ~AcctItemMgr();

    
    bool getBelong(int iChildItem, int iParentItem);

    
    int getParent(int iChildItem);

    
    
    
    
    int getDisctItem(int iNormalItemType);

    bool isDisctItem(int iAcctItemType);

		bool isPartyRoleItem(int iAcctItemType,int iPartyRoleID);
		
    int *getAcctItems(int iAcctItemGroupID, int *number = 0);

    
    int *getAcctItemsB(int iBAcctItemGroupID, int * number = 0);

    
    int *getBaseAcctItemsB(int iBAcctItemGroupID, int * number = 0);

    
    
    
    
    
    int reverseDisctItem(int iDisctItemType);

  private:
    
    void loadGroup();

    
    void loadGroupB();

    
    void loadItem();

	void loadGroupMeberB();
	void loadBasicGroupMeberB();
	void analyzeItem();
	int getItemChild(int iAcctItemID,int * pItemChild);
	int getGroupDetail(long lGroupID);

    
    static HashList<int> *m_poItemSerial;

    
    static HashList<int> *m_poGroupSerial;

    
    static HashList<int> *m_poGroupSerialB;

    
    static SimpleMatrix *m_poMatrix;

    
    static SimpleMatrix *m_poMatrixB;

    
    static bool m_bUploaded;

    
    static HashList<AcctItem *> *m_poIndex;

    
    static AcctItem *m_poAcctItemList;

    static int m_iCount;
    
	static int * m_piIncludeDiscount;
    static ItemGroupMember ** m_pBasicMember;
    static ItemGroupMember ** m_pDisctMember;

	 
	static HashList<int> * m_poItemParentIndex;
	static ItemGroupMember * m_poItemParentList;

	static HashList<int> * m_poItemChildIndex;
	static AcctItemChild * m_poItemChildList;
	
	static HashList<int> * m_poGroupMemberBIndex;
	static ItemGroupMemberB * m_poGroupMebmerBList;

	static HashList<int> * m_poBasicGroupMemberBIndex;
	static ItemGroupMemberB * m_poBasicGroupMebmerBList;

	HashList<int> * m_poItemTemp;
	
	HashList<int> * m_poYes;
	HashList<int> * m_poNo;
	HashList<int> * m_poChildYes;
	HashList<int> * m_poChildNo;
     

	int m_aoAcctItemID[4096];
	int m_iIndex;

};


#line 24 "/hss/opt/opthss/src/bill/src/mmdb/UserInfo.h"
#line 1 "/hss/opt/opthss/src/bill/src/public/OrgMgr.h"
  







class Org
{
  public:
    
    Org();

  private:
    friend class OrgMgr;
    friend class UsrOrgLockMgr;

    friend class ParamInfoMgr;
	friend class SeekSHMTool;


    
    int m_iOrgID;

    
    int m_iParentID;

    
    int m_iLevel;

    
    Org *m_poParent;
    

    unsigned int m_iParentOffset;


};





class OrgMgr
{
  public:
    
    void load();

    
    void unload();

    
    bool getBelong(int iChildOrg, int iParentOrg);

    
    OrgMgr();

    
    ~OrgMgr();
    
    int getParentID(int iOrgID);

    
    int getLevelParentID(int iOrgID, int iLevel);
    
    
    int getLevel(int iOrgID);

  private:
    
    static HashList<Org *> *m_poOrgIndex;
    
    static bool m_bUploaded;


    
    static Org *m_poOrgList;


};



#line 25 "/hss/opt/opthss/src/bill/src/mmdb/UserInfo.h"




#line 80 "/hss/opt/opthss/src/bill/src/mmdb/UserInfo.h"

#line 94 "/hss/opt/opthss/src/bill/src/mmdb/UserInfo.h"

#line 105 "/hss/opt/opthss/src/bill/src/mmdb/UserInfo.h"

#line 116 "/hss/opt/opthss/src/bill/src/mmdb/UserInfo.h"

#line 128 "/hss/opt/opthss/src/bill/src/mmdb/UserInfo.h"

struct pathFullName
{
        char sFilePath[128];

        char sCustName[128];  
        char sProductName[128];  
        char sServName[128];  
        char sServTypeName[128];  
        char sServLocName[128];  
        char sServStateName[128];  
        char sServAttrName[128];  

        char sImsiMdnRelatName[128];  

        char sServIdenName[128];  
        char sServProdName[128];  
        char sServProdAttrName[128];  
        char sServAcctName[128];  
        char sAcctName[128];  
#line 154 "/hss/opt/opthss/src/bill/src/mmdb/UserInfo.h"
        char sOfferInsName[128];        
        char sOfferInsAttrName[128];    
        char sOfferInsDetailName[128];  
	char sOfferInsAgrName[128];  
	char sNpName[128];
};

#line 182 "/hss/opt/opthss/src/bill/src/mmdb/UserInfo.h"




















#line 210 "/hss/opt/opthss/src/bill/src/mmdb/UserInfo.h"































#line 254 "/hss/opt/opthss/src/bill/src/mmdb/UserInfo.h"












class CustGroupInfo
{
public:
    
    
    
    long m_lGroupID;

    
    
    
    long m_lCustID;

    
    
    
    unsigned int m_iNextOffset;

};




class CustInfo
{
    public:
    
    
    
    
    long m_lCustID;

    
    char m_sCustType[4];

    
    

    
    

    
    
    
    

    
    
    
   

    
    char m_sState[4];

    
    

    
    

    
    
    
    unsigned int m_iCustPlanOffset;
    
    unsigned int m_iServOffset;


    
    unsigned int m_iGroupOffset;

    unsigned int m_iAcctOffset;
    
    unsigned int m_iOfferDetailOffset;
};

struct AcctItemOweData
{				
		long acctItemId;
	
		long iServID;	
	
		long iAcctID;	
		
		long iAmount;		
	
		int iBillingCnt;
		
		unsigned int iNextAcctOffset;
	
		unsigned int iNextServOffset;		
	
		char state[4];		
	
		char isValid;
		
		int iParTID ;
		
		char m_sExpDate[16];
};

class AcctCreditInfo
{
public:
	long m_lAcctID;
	long m_lServID;
	int m_iCreditGrade;
	int m_iCreditAmount;
	unsigned int m_iNextOffset;
};





class AcctInfo
{
public:
    
    long m_lAcctID;

    
    long m_lCustID;

    
    int m_iCreditGrade;

    
    int m_iCreditAmount;

    
    char m_sState[4];

    
    

    unsigned int m_iNextOffset; 
    
    unsigned int m_iOfferDetailOffset;

};






class ServInfo
{
  public:
    
    
    
    long m_lServID;
    
    
    
    long m_lCustID;

    
    int m_iProductID;

    
    char m_sCreateDate[16];

    
    
    
    char m_sRentDate[16];

    
    char m_sNscDate[16];

    
    
    
    char m_sState[4];

    
    char m_sStateDate[16];

    
    
    
	
    int m_iCycleType;

    
    char m_sAccNbr[32];

    
    int m_iBillingMode;

    
    int m_iFreeType;

    
    
    
    

    
    
    
    unsigned int m_iCustNext;

    
    
    
    unsigned int m_iOfferInstanceOffset;

    
    
    
    unsigned int m_iServAcctOffset;

    
    
    
    unsigned int m_iStateOffset;

    
    
    
    unsigned int m_iServProductOffset;

    
    
    
    
    unsigned int m_iLocationOffset;

    
    

    
    unsigned int m_iGroupOffset;

    
    
    
    

    unsigned int m_iCustOffset;

    unsigned int m_iAttrOffset;

    unsigned int m_iServTypeOffset;

    unsigned int m_iServIdentOffset;
    
    
    unsigned int m_iOfferDetailOffset;
    
    unsigned int m_iBaseOfferOffset;
};



 
class ServTypeInfo
{
  public:
	long m_lServID;
	int m_iProductID;

	char m_sEffDate[16];
	char m_sExpDate[16];

	int m_iPricingPlanID;

	unsigned int m_iNextOffset;
};







class ServIdentInfo
{
public:

    
    
    
    char m_sAccNbr[32];

    
    
    
    long m_lServID;

    
    
    
    char m_sEffDate[16];

    
    
    
    char m_sExpDate[16];

    
    
    
    unsigned int m_iServOffset;

    
    
    
    unsigned int m_iNextOffset;

    
    
    
    unsigned int m_iServNextOffset;

    int m_iType;
    
    int m_iNetworkID;
    
    int m_iNetworkPriority;

};





class ServProductInfo
{
  public:
    
    
    
    long m_lServProductID;
    
    
    
    long m_lServID;
    
    
    
    int m_iProductID;
    
    
    
    char m_sEffDate[16];
    
    
    
    char m_sExpDate[16];

    
    
    
    unsigned int m_iNextOffset;

    
    
    
    unsigned int m_iServOffset;

    
    unsigned int m_iAttrOffset;

};




class OfferInstanceInfo
{
public:
    
    
    
    long m_lOfferInstanceID;

    
    
    
    int m_iOfferID;

    
    
    
    int m_iPricingPlan;

    
    
    
    char m_sEffDate[16];

    
    
    
    char m_sExpDate[16];

    
    
    
    

    
    
    
    unsigned int m_iParentOffset;
    
    
    
    unsigned int m_iNextOffset;
    
    char m_sState[4];
    
    long m_lDetailID;

};







class ServLocationInfo
{
  public:

    
    
    
    long m_lServID;

    
    
    
    int m_iOrgID;

    
    char m_sEffDate[16];

    
    char m_sExpDate[16];

    
    
    
    
    unsigned int m_iNextOffset;

    
    unsigned int m_iOrgNext;

};


class ProdOfferIns
{
public:
    
    long m_lProdOfferInsID;
    
    unsigned int m_iOfferDetailInsOffset;
    
    unsigned int m_iAccumuOffset;
    
    unsigned int m_iOfferAttrOffset;
    
    
    unsigned int m_iOfferAgreementOffset;
    
    
    int m_iOfferID;
    
    char m_sEffDate[16];
    
    char m_sExpDate[16];
};

class OfferDetailIns
{
public:
    
    long m_lOfferDetailInsID;
	
    long m_lOfferInsID;
    
    long m_lInsID;
    
    int m_iInsType;
    
    int m_iMemberID;
    
    unsigned int m_iParentOffset;
    
    unsigned int m_iNextDetailOffset;
    
    unsigned int m_iNextProdOfferOffset;
    
    char m_sEffDate[16];
    
    char m_sExpDate[16];
};

class OfferDetailInsBase
{
public:
    
    long m_lOfferDetailInsID;
	
    long m_lOfferInsID;
    
    long m_lInsID;
    
    int m_iInsType;
    
    int m_iMemberID;
    
    char m_sEffDate[16];
    
    char m_sExpDate[16];
};


class ProdOfferInsAttr
{
public:
    
    int m_iAttrID;
    
    char m_sEffDate[16];
    
    char m_sExpDate[16];
    
    char m_sAttrValue[32];
    
    long m_iAttrSeq;
    
    unsigned int m_iNextOfferInsAttrOffset;
};



class ProdOfferInsAgreement
{
public:
    
    long m_lAgreementInstID;
    
    long m_lProdOfferInsID;
    
    char m_sEffDate[16];
    
    char m_sExpDate[16];
    
    unsigned int m_iNextOfferInsAgreementOffset;
};



class ProductInfo
{
public:
    
    int m_iProductID;

    
    int m_iProviderID;

    
    int m_iPricingPlanID;
    
    int m_iNetworkID;
    
    int m_iNetworkPriority;
};






class ServAcctInfo
{

 public:
 	
 	
	long m_lServAcctID;
    
    
    
    long m_lAcctID;

    
    
    
    long m_lServID;

    
    
    
    int m_iAcctItemGroup;

    
    
    
    
    int m_iState;

    char m_sEffDate[16];

    char m_sExpDate[16];

    
    
    
    unsigned int m_iNextOffset;

    
    unsigned int m_iAcctNextOffset;
};






class CustPricingPlanInfo
{
public:
    
    long m_lCustID;

    
    int m_iPricingPlanID;

    
    int  m_iObjectType;

    
    long m_lObjectID;

    
    char m_sEffDate[16];

    
    char m_sExpDate[16];

    
    unsigned int m_iNextOffset;
    
    
    
    
    long m_lCustPlanID;

    
    unsigned int m_iParamOffset;


    
    unsigned int m_iObjectOffset;
};




class ServAttrInfo
{
public:
    
    
    
    long m_lServID;

    
    
    
    int m_iAttrID;

    
    
    
    char m_sValue[16];

    
    
    
    char m_sEffDate[16];

    
    
    
    char m_sExpDate[16];

    
    
    
    unsigned int m_iNextOffset;

};




class ServStateInfo
{
public:
    
    
    
    long m_lServID;

    
    
    
    int m_iOweType;

    
    
    
    char m_sState[4];

    
    
    
    char m_sEffDate[16];

    
    
    
    char m_sExpDate[16];

    
    
    
    unsigned int m_iNextOffset;

};




class ServProductAttrInfo
{
public:
    
    
    
    long m_lServProductID;

    
    
    
    int m_iAttrID;

    
    
    
    char m_sValue[16];

    
    
    
    char m_sEffDate[16];

    
    
    
    char m_sExpDate[16];

    
    
    
    unsigned int m_iNextOffset;

};






class ServPricingPlanInfo
{
public:
    
    
    
    int m_iPricingPlanID;

    
    
    
    char m_sEffDate[16];

    
    
    
    char m_sExpDate[16];

    
    
    
    unsigned int m_iNextOffset;

};




class OfferInfo
{
public:
    
    int m_iOfferID;

    
    int m_iPricingPlan;

    

};




class ServGroupInfo
{
public:
    
    
    
    long m_lGroupID;

    
    
    
    long m_lServID;

    
    
    
    char m_sEffDate[16];

    
    
    
    char m_sExpDate[16];

    
    
    
    unsigned int m_iNextOffset;

    unsigned int m_iGroupNext;

};

 
class ServGroupBaseInfo
{
public:
	long m_lGroupID;
	long m_lGroupServID;
	
	unsigned int m_iCustOffset;
	unsigned int m_iServOffset;

	
	int m_iGroupType; 
};




class CustAttrInfo
{
public:
    
    
    
    long m_lCustID;

    
    
    
    int m_iAttrID;

    
    
    
    char m_sValue[32];

    
    
    
    char m_sEffDate[16];

    
    
    
    char m_sExpDate[32];

    
    
    
    unsigned int m_iNextOffset;

};


class InstanceDetailUpdateInfo
{
public:
    
    long m_lDetailID;

    
    
    
    long m_lOfferInstanceID;

    
    
    
    int m_iOfferID;

    
    
    
    char m_sEffDate[16];

    
    
    
    char m_sExpDate[16];

    
    
    
    char  m_sObjectType[4];

    
    
    
    long m_lObjectID;

    
    char m_sState[4];

};


class CustPricingTariffInfo
{
  public:
    long m_lCustPlanID;
    int  m_iUnit;
    int  m_iRate;
    int  m_iPrecision;
    
    unsigned int m_iLeft;
    unsigned int m_iRight;
    int  m_iBalance;
};


class CustPricingParamInfo
{
  public:
    
    
    
    long m_lCustPlanID;

    
    int m_iParamID;

    
    long m_lValue;

    
    unsigned int m_iNextOffset;

};


class CustPricingObjectInfo
{
  public:
    
    long m_lCustPlanID;

    
    int m_iPricingObjectID;

    
    int m_iObjectType;

    
    long m_lObjectID;

    
    unsigned int m_iNextOffset;

};

#line 1344 "/hss/opt/opthss/src/bill/src/mmdb/UserInfo.h"


struct ImsiMdnRelation{
	long	m_lRelationID;
	char	m_sImsi[21];
	char	m_sAccNbr[33];
	char	m_sAreaCode[11];
	char	m_sEffDate[16];	
	char	m_sExpDate[16];	
	int 	m_itype;

	unsigned int m_iNextOffset; 
};



class NpInfo
{
	public:
	
		
		char m_sAccNbr[33]; 
		int  m_iOrgNetwork;
		int  m_iNetwork;
		int  m_iNpState;
		char m_sEffDate[16];
		char m_sExpDate[16];
		unsigned int  m_iNext;
};

class UserInfoBase
{

  public:
    
    UserInfoBase();
	UserInfoBase(pathFullName oFileName);
    
    operator bool();

 
    
    void bindData();

    
    
    
    static SHMData<CustInfo> *m_poCustData;

    
    
    
    static SHMIntHashIndex *m_poCustIndex;

    
    
    
    static SHMData<CustPricingPlanInfo> *m_poCustPricingPlanData;

    static SHMIntHashIndex * m_poCustPricingPlanIndex;

    static SHMData<CustPricingTariffInfo> *m_poCustTariffData;
    static SHMStringTreeIndex *m_poCustTariffIndex;

    
    
    
    static SHMData<CustGroupInfo> *m_poCustGroupData;

    
    
    
    


    
    
    
    static SHMData<ServAttrInfo> *m_poServAttrData;

    
    
    
    static SHMData<ServProductAttrInfo> * m_poServProductAttrData;

    
    
    
    static bool m_bAttached;

    
    
    
    static SHMData<ServLocationInfo> *m_poServLocationData;

    static SHMIntHashIndex * m_poServLocationIndex;


    
    
    
    static SHMData<ServIdentInfo> *m_poServIdentData;

  
    
    static CustInfo *m_poCust;

    
    
    
    static SHMData<ServStateInfo> *m_poServStateData;


    
    
    
    static SHMData<ServAcctInfo> *m_poServAcctData;

  
    
    static ServInfo *m_poServ;

    
    
    
    static SHMIntHashIndex *m_poProductIndex;


    
    static CustPricingPlanInfo *m_poCustPlan;

    
    
    
    static SHMData<OfferInfo> *m_poOfferData;


    
    
    
    static SHMStringTreeIndex *m_poServIdentIndex;

  
    
    static ServIdentInfo *m_poServIdent;

  
    
    static ProductInfo *m_poProduct;

    
    
    
    static SHMData<ServProductInfo> *m_poServProductData;


    
    static CustGroupInfo *m_poCustGroup;

  
    
    static ServProductInfo *m_poServProduct;
    
    
    
    static SHMData<ServPricingPlanInfo> *m_poServPricingPlanData;


    
    static ServLocationInfo *m_poServLocation;

  
    
    static ServAcctInfo *m_poServAcct;

    
    
    
    static SHMIntHashIndex *m_poOfferIndex;


    
    static OfferInstanceInfo *m_poOfferInstance;

    
    
    
    static SHMIntHashIndex *m_poServProductIndex;

    
    static SHMIntHashIndex * m_poServAcctIndex;


    
    static ServGroupInfo *m_poServGroup;

    
    
    
    static SHMData<ProductInfo> *m_poProductData;


    
    
    
    static SHMData<OfferInstanceInfo> *m_poOfferInstanceData;

  
    
    static SHMIntHashIndex *m_poOfferInstanceIndex;


    
    
    
    static SHMData<ServGroupInfo> *m_poServGroupData;

    static SHMData<ServGroupBaseInfo> * m_poServGroupBaseData;
    static SHMIntHashIndex * m_poServGroupBaseIndex;

    
    
    
    static SHMData<ServInfo> *m_poServData;

    static SHMData<ServTypeInfo> * m_poServTypeData;

    static SHMData<CustPricingParamInfo> * m_poCustPricingParamData;

    static SHMData<CustPricingObjectInfo> * m_poCustPricingObjectData;

    static SHMData<AcctInfo> * m_poAcctData;
    
    static AcctInfo * m_poAcct;

    static SHMIntHashIndex * m_poAcctIndex;

    
    
    
    static SHMIntHashIndex *m_poServIndex;
    
    
    static SHMData<ProdOfferIns> * m_poProdOfferInsData;
    static ProdOfferIns * m_poProdOfferIns;
    static SHMIntHashIndex * m_poProdOfferInsIndex;
    static SHMData<OfferDetailIns> * m_poOfferDetailInsData;
    static OfferDetailIns * m_poOfferDetailIns;
    static SHMIntHashIndex * m_poOfferDetailInsOfferInsIndex;
    static SHMData<ProdOfferInsAttr> * m_poProdOfferInsAttrData;
    static ProdOfferInsAttr * m_poProdOfferInsAttr;
    
		static SHMData<ProdOfferInsAgreement> * m_poProdOfferInsAgreementData;
		static ProdOfferInsAgreement * m_poProdOfferInsAgreement;
		
		
    
    static ServStateInfo *m_poServState;

    static ServAttrInfo * m_poServAttr;

    static ServProductAttrInfo * m_poServProductAttr;

    static CustAttrInfo * m_poCustAttr;

#line 1626 "/hss/opt/opthss/src/bill/src/mmdb/UserInfo.h"


	static ImsiMdnRelation * m_poImsiMdnRelation;
	static SHMData<ImsiMdnRelation> * m_poImsiMdnRelationData;
	static SHMStringTreeIndex* m_poImsiMdnRelationIndex;



	static SHMData<NpInfo> *m_poNpData;
	static NpInfo *m_poNp;
	static SHMStringTreeIndex* m_poNpIndex;


 
    
    
    
    void loadSHMInfo();
    
    void freeAll();
    
    void closeAll();

};


class ExPricingPlan
{
	public:
		int m_iPricingPlanID;
		unsigned int m_iCustPlanOffset;
};

#line 9 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoReader.h"




#line 1 "/hss/opt/opthss/src/bill/src/public/StateConvertMgr.h"
  








class StateConvert
{
public:
    char m_sServState[4];
    int  m_iProductID;
    int  m_iOfferID;
    char m_sBillingState[4];

    unsigned int m_iNextProdOffset;
    unsigned int m_iNextOfferOffset;
};


class StateConvertMgr
{
  public:
	char * getBillingState(char *sState, int iProductID, int iOfferID);

  public:
	StateConvertMgr();
	void load();
	void unload();

  private:
	int getOffset(char *sBillingState);

  private:

	static char m_poBuf[32][4];
	static HashList<HashList<HashList<int> *> *> * m_poIndex;

  private:
	static bool m_bUploaded;
};

#line 18 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoReader.h"
#line 1 "/hss/opt/opthss/src/bill/src/framework/Environment.h"
  



#line 278 "/hss/opt/opthss/src/bill/src/framework/Environment.h"

#line 19 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoReader.h"
#line 1 "/hss/opt/opthss/src/bill/src/mmdb/NetworkMgr.h"
  









 



class NetworkPriority
{
public:
    NetworkPriority()
    {
        Init(0,0);
    }
    NetworkPriority(int source, int networkid)
    {
    		Init(source,networkid);
    }
    bool Init(int source,int networkid)
    {
    	  m_iNetworkSourceID = source;
        m_iNetworkID = networkid;
        m_iPriority = 0;
        m_poNext = 0;    		
    		return true;
    }
    
    int m_iNetworkSourceID;
    
    int m_iNetworkID;
    
    int m_iPriority;
    
    NetworkPriority * m_poNext;
    
    static NetworkPriority NETWORK_NONE;
    

	unsigned int m_iNextOffset;


};
class NetworkPriorityMgr
{
    
    NetworkPriority * m_poNetworkPriList;
    
    HashList<NetworkPriority *> *m_poNetworkPriIndex;
    
    bool m_bUploaded;
    
public:
    
    void load();

    
    void unload();
    
    NetworkPriority * getPriority(int iNetworkSourceID);
    

	
	NetworkPriority *getHeadNetworkPriority();


    
    NetworkPriorityMgr();
    
    ~NetworkPriorityMgr();
};
#line 20 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoReader.h"
#line 1 "/hss/opt/opthss/src/bill/src/public/OfferMgr.h"
  






 





enum OfferType
{
    OFFER_TYPE_BASE = 0,
    OFFER_TYPE_DISCT
};

class OfferAttr
{
	public:
		int m_iAttrId;
		char m_sAttrValue[32];
		OfferAttr *m_poNext;
};
      
class Offer
{
public:
    
    int m_iOfferID;
    
    int m_iPricingPlan;
    
    int m_iPriority;
    
    OfferType m_iOfferType;
    
    char m_sEffDate[16];
    
    char m_sExpDate[16];
    
    int m_iBrandID;
    
    OfferAttr *m_poOfferAttr;
		
		
		int m_iAgreementLength;
		
};
class OfferMgr
{
  
  Offer * m_poOfferInfoList;

  
  HashList<Offer *> *m_poOfferInfoIndex;
  
  
  OfferAttr *m_poOfferAttrList;
  
  
  HashList<OfferAttr *> *m_poOfferAttrIndex;
    
  HashList<int> * m_poFreeOfferIndex;

	HashList<int>  * m_poSpeicalOfferAttrIndex;
    
	HashList<int>  * m_poNumberOfferAttrIndex;
	
  static bool m_bUploaded;
    
public:
    
  void load();
    
  void loadFreeOffer();

	
	void loadSpecialAttr();

	
	void loadNumberAttr();

    
  void unload();
    
  Offer * getOfferInfoByID(int iOfferID);
    
  bool isFreeOffer(int iOfferID);

	bool checkSpecialAttr(int iAttrID,int &iOperation);

	bool checkNumberAttr(int iAttrID);
	
	char * getOfferAttrValue(int iOfferId,int iAttrId,char *sDate);
 
	bool getbrand(int iOfferId,int &ibrandid );    
    
  OfferMgr();
    
  ~OfferMgr();

private:
	int m_iFlag;
	
	int m_iUsedDefaultAttr;
};
#line 21 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoReader.h"
#line 1 "/hss/opt/opthss/src/bill/src/mmdb/SHMFileInfo.h"
  





#line 1 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoSHMFileCtl.h"
  


#pragma push binding
#pragma binding default
#line 1 "/usr/include/dirent.h"
       







#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/dirent.h"

































 

















 





    

   struct dirent {
      ino_t d_ino;					 
      short d_reclen;				 
      short d_namlen;				 
      char  d_name[255 + 1];	 
   };



    

   struct dirent32 {
      ino32_t	d_ino;					 
      short		d_reclen;				 
      short		d_namlen;				 
      char		d_name[255 + 1];	 
   };






 






 




   

 


#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/_dirent_body.h"

































 


 
 

   struct __dirent {
      uint64_t __d_off;			 
      ino_t __d_ino;			 
      short    __d_reclen;		 
      short    __d_namlen;		 
      char     __d_name[255 + 1]; 
   };
#pragma pop
#line 103 "/usr/include/sys/dirent.h"



#line 134 "/usr/include/sys/dirent.h"

    

   typedef struct __dirdesc {
      int   __dd_fd;		 
      long  __dd_loc;
      long  __dd_size;
      long  __dd_bbase;
      long  __dd_entno;		 
      long  __dd_bsize;		 
      char  *__dd_buf;		 

        void  *__dd_lock;



   } DIR;


#line 167 "/usr/include/sys/dirent.h"


 



   extern "C" {






       
#    pragma extern opendir, readdir, rewinddir, closedir


     extern DIR *opendir (const char *);
     extern struct dirent *readdir (DIR *);
     extern void rewinddir (DIR *);
     extern int closedir (DIR *);
#line 203 "/usr/include/sys/dirent.h"
            
#         pragma extern readdir_r


          extern int readdir_r (DIR * , struct dirent * ,struct dirent * * );
#line 214 "/usr/include/sys/dirent.h"



       
#    pragma extern telldir, seekdir

     extern long telldir (DIR *);
     extern void seekdir (DIR *, long);









       
#    pragma extern scandir, alphasort

     extern int scandir (const char *, struct dirent * * *, int (*)(const struct dirent *), int (*)(const struct dirent * *, const struct dirent * *));




     extern int alphasort (const struct dirent * *, const struct dirent * *);



   }




 



   struct _dirdesc {	 
	int	__dd_fd;
	long	__dd_loc;
	long	__dd_size;
	long	__dd_bbase;
	long	__dd_entno;
	long	__dd_bsize;
	char	*__dd_buf;

        void    *__dd_lock;



   };












 











 











#line 318 "/usr/include/sys/dirent.h"










#pragma pop
#line 10 "/usr/include/dirent.h"

#pragma pop
#line 7 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoSHMFileCtl.h"
#line 1 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoMap.h"
  





#line 1 "/hss/opt/opthss/src/bill/src/public/SHMMapFile.h"
  






#pragma push binding
#pragma binding default
#line 1 "/usr/include/sys/mman.h"
 




 











#pragma push binding
#pragma binding default
#line 1 "/usr/include/machine/sys/mman.h"

































 









 






     
typedef __opaque128_t msemaphore;





#pragma pop
#line 19 "/usr/include/sys/mman.h"












 


 

#line 44 "/usr/include/sys/mman.h"



 








 



 




 


#line 75 "/usr/include/sys/mman.h"

 


 








 
 
 
#line 101 "/usr/include/sys/mman.h"
					
 


 
 










 





#line 133 "/usr/include/sys/mman.h"
 
 

 

 
#line 147 "/usr/include/sys/mman.h"

 
#line 159 "/usr/include/sys/mman.h"

 
#line 183 "/usr/include/sys/mman.h"



 





 
  enum __mlockall_flags {
	  MCL_CURRENT = 1,
	  MCL_FUTURE
  };



 


 











     extern "C" {





        
#     pragma extern msem_init, msem_remove, msem_lock, msem_unlock, madvise, mvalid, memcntl, mincore

    extern msemaphore *msem_init (msemaphore *, int);
    extern int msem_remove (msemaphore *);
    extern int msem_lock (volatile msemaphore *, int);
    extern int msem_unlock (volatile msemaphore *, int);
    extern int madvise (const caddr_t, size_t, int);
    extern int mvalid (caddr_t, size_t, int);
    extern int memcntl (caddr_t, size_t, int, caddr_t, int, int);
    extern int mincore (void *, size_t, unsigned char *);




          
#       pragma extern mmap

    extern void *mmap (void *, size_t, int, int, int, off_t);


        
#     pragma extern mprotect, msync, munmap

    extern int mprotect (void *, size_t, int);
    extern int msync (void *, size_t, int);
    extern int munmap (void *, size_t);


          
#       pragma extern mlockall, munlockall, mlock, munlock, shm_open, shm_unlink

    extern int mlockall (int);			         
    extern int munlockall (void);				 
    extern int mlock (const void *, size_t );	         
    extern int munlock (const void *, size_t );	         
    extern int shm_open (const char *, int, mode_t );		
								 
    extern int shm_unlink (const char *);		         


#line 273 "/usr/include/sys/mman.h"

#line 288 "/usr/include/sys/mman.h"


     }


#line 302 "/usr/include/sys/mman.h"

#pragma pop
#line 12 "/hss/opt/opthss/src/bill/src/public/SHMMapFile.h"




const int FILE_NAME_MAX = 128;
const int ONCE_MAX = 268435456;  
const int MEM_COPY_MAX = 1000000;

template <class T>
class SHMMapFile
{
    public:
        SHMMapFile(char * pFileName, SHMData<T> * pSHMPointer = 0L );
        
        ~SHMMapFile();
        
        operator T *();
        
        int create();
        
        int openMap();
        
        void reset();
        
        bool exist();
        
        unsigned int malloc();
        
        unsigned int getCount();
        
        unsigned int getTotal();
		
		int delFile();
        
		void munmapFile();
        
    private:
        
        int createFile();
        
        int openFile();
        
        int mmapFile(int iFd, long lSize = 0);
        
        void setMapFile();
        
        unsigned int * m_piTotal;
        
        unsigned int * m_piUsed;
		
#line 71 "/hss/opt/opthss/src/bill/src/public/SHMMapFile.h"
		
        T *m_pPointer;
		
        
		
        T *m_pSHMPointer;
        
        char * m_pFileName;
        
        unsigned long m_ulSize;
};

template <class T>
SHMMapFile<T>::SHMMapFile(char * pFileName, SHMData<T> * pSHMPointer )
{
    m_pFileName = new char[FILE_NAME_MAX+1];
    memcpy(m_pFileName, 0, FILE_NAME_MAX);
    memcpy(m_pFileName, pFileName, strlen(pFileName));
    
    if(pSHMPointer){
        m_pSHMPointer = (T *)( (char *)(pSHMPointer->getMemAddr()) );
        
        m_piTotal = (((unsigned int *)m_pSHMPointer) + 1);
        m_piUsed = m_piTotal + 1;
        
#line 109 "/hss/opt/opthss/src/bill/src/public/SHMMapFile.h"
        
        create();
    }else
        openMap();
}

template <class T>
SHMMapFile<T>::~SHMMapFile()
{
    delete[] m_pFileName;
}

template <class T>
SHMMapFile<T>::operator T *()
{
	return m_pPointer;
}

template <class T>
void SHMMapFile<T>::reset()
{
	*m_piUsed = 1;
}

template <class T>
bool SHMMapFile<T>::exist()
{
    return m_pPointer;
}

template <class T>
unsigned int SHMMapFile<T>::malloc()
{
#line 155 "/hss/opt/opthss/src/bill/src/public/SHMMapFile.h"
	if ((*m_piTotal) == (*m_piUsed))
		return 0;
    
	return ((*m_piUsed)++);

}

template <class T>
unsigned int SHMMapFile<T>::getCount()
{
#line 175 "/hss/opt/opthss/src/bill/src/public/SHMMapFile.h"
	if (*m_piUsed)
		return ((*m_piUsed)-1);

	return 0;

}

template <class T>
unsigned int SHMMapFile<T>::getTotal()
{




	if (*m_piTotal)
		return ((*m_piTotal)-1);

	return 0;

}

template <class T>
int SHMMapFile<T>::delFile()
{
    int iRet = 0;
	
	iRet = remove(m_pFileName);
    if(iRet == -1 && (*__errno()) == 2)
		iRet = 0;
    
    return iRet;
}

template <class T>
int SHMMapFile<T>::createFile()
{
    int iFd = 0;
    int iCnt = 0;
    int i = 0;
	long lTotal;
	



	lTotal = (*m_piTotal)*sizeof(T);

	
    m_ulSize = lTotal;
	
    if(lTotal%ONCE_MAX)
        iCnt = lTotal/ONCE_MAX + 1;
    else
        iCnt = lTotal/ONCE_MAX;
    
    iFd = open(m_pFileName, 0000002|0000400, 0000400|0000200);
    if(iFd == -1)
        return iFd;
    
    for(i = 0; i < (iCnt-1); i ++){
        lseek(iFd, ONCE_MAX-1, 2);
        write(iFd, "", 1);
    }
    
    if(i == (iCnt-1)){
        lseek(iFd, lTotal%ONCE_MAX-1, 2);
        write(iFd, "", 1);
    }
    
    return iFd;
}

template <class T>
int SHMMapFile<T>::openFile()
{
    int iFd = 0;
    
    iFd = open(m_pFileName, 0000002);
    
    return iFd;
}

template <class T>
int SHMMapFile<T>::mmapFile(int iFd, long lSize)
{
    int iRet = 0;
	
    if(!lSize)



        lSize = (*m_piTotal)*sizeof(T);

    
    m_pPointer = 0L;
    
    if(iFd == -1)
        return iRet;
    
    if(m_ulSize != lSize)
        m_ulSize = lSize;
    
    m_pPointer = (T *)mmap(0, (size_t)lSize, 0x1|0x2, 0x01, iFd, 0);
    if(m_pPointer == ((void *)-1L))
        return iRet;
    close(iFd);
    
    return iRet;
}

template <class T>
void SHMMapFile<T>::munmapFile()
{
    if(m_pPointer){
		msync((char *)m_pPointer, m_ulSize, 0x01);
    	munmap((char *)m_pPointer, m_ulSize);
    }
}

template <class T>
void SHMMapFile<T>::setMapFile()
{
    long i = 0;
    int iCnt = 0;
	
#line 317 "/hss/opt/opthss/src/bill/src/public/SHMMapFile.h"
    if((*m_piUsed)%MEM_COPY_MAX)
        iCnt = (*m_piUsed)/MEM_COPY_MAX + 1;
    else
        iCnt = (*m_piUsed)/MEM_COPY_MAX;
    
    for(i = 0; i < (iCnt-1); i ++){
        memcpy(m_pPointer + i*MEM_COPY_MAX, m_pSHMPointer + i*MEM_COPY_MAX, MEM_COPY_MAX*sizeof(T));
		
		printf("%s Finish: %d %%!\n", m_pFileName, ((i+1)*100)/iCnt);
    }
    
    if(i == (iCnt-1)){
        memcpy(m_pPointer + i*MEM_COPY_MAX, m_pSHMPointer + i*MEM_COPY_MAX, ((*m_piUsed)%MEM_COPY_MAX)*sizeof(T));
		
		printf("%s Finish: 100 %%!\n", m_pFileName);
    }

}

template <class T>
int SHMMapFile<T>::openMap()
{
    int iRet = 0;
    int iFd = -1;
	struct stat statbuf;
    
    iFd = openFile();
    stat(m_pFileName, &statbuf);
	
	m_ulSize = statbuf.st_size;
	
    iRet = mmapFile(iFd, m_ulSize);
    
    if(!iRet){
        m_piTotal = (((unsigned int *)m_pPointer) + 1);
        m_piUsed = m_piTotal + 1;
        
#line 367 "/hss/opt/opthss/src/bill/src/public/SHMMapFile.h"
    }
    
	return iRet;
}

template <class T>
int SHMMapFile<T>::create()
{
    int iRet = 0;
    int iFd = -1;
    
    delFile();
    iFd = createFile();
    
    iRet = mmapFile(iFd);
	
    setMapFile();
	
    printf("madvise ret: %d\n", madvise((char *)m_pPointer, m_ulSize, 4));
	
    munmapFile();
    printf("madvise ret: %d\n", madvise((char *)m_pPointer, m_ulSize, 4));
	return iRet;
}

#line 9 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoMap.h"

#line 22 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoMap.h"

#line 33 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoMap.h"

#line 66 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoMap.h"

#line 81 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoMap.h"

#line 96 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoMap.h"



































































 

const int ALL_DATA =             0;
const int ALL_INDEX =            1;

const int CUST_DATA =            2;
const int PROD_DATA =            3;
const int SERV_DATA =            4;
const int SERVTYPE_DATA =        5;
const int SERVLOC_DATA =         6;
const int SERVSTATE_DATA =       7;
const int SERVATTR_DATA =        8;

const int IMSIMDN_DATA =         9;
const int SERVIDENT_DATA =      10;
const int SERVPROD_DATA =       11;
const int SERVPRODATTR_DATA =   12;
const int SERVACCT_DATA =       13;
const int ACCT_DATA =           14;

#line 194 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoMap.h"
const int OFFERINS_DATA =       15;
const int OFFERINSATTR_DATA =   16;
const int OFFDETAILINS_DATA =   17;
const int OFFERINSAGGR_DATA =   18;
const int NP_DATA =             19;


#line 228 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoMap.h"

struct vectorData
{
    long lLen;
	int iOperType;
};

struct UserInfoManage
{
    pathFullName m_sFullName;
	UserInfoBase m_oUserInfoBase;
	int iOperMode[50];
};

class UserInfoMapBase
{
    friend class SHMFileCtl;
	
    public:
        UserInfoMapBase(pathFullName sFullName, UserInfoBase * poUserInfoBase = 0L, int iMode = 0);
		~UserInfoMapBase();
        operator bool();
        
        
        void setAllIndex();
		void setFileData(int iOperMode);
        
        
        UserInfoManage m_oUserInfoManage;
        
        void setAllData(int iMode, int * iOper);
        static bool sortFileLen(const vectorData & m1, const vectorData & m2);
        void assignData();
        
    protected:
        void bindData();
		void freeAll();
        
        static bool m_bAttached;
		
		
		
        static SHMMapFile<CustInfo> *m_poCustData;
        static SHMMapFile<ProductInfo> *m_poProductData;
        static SHMMapFile<ServInfo> *m_poServData;
        static SHMMapFile<ServTypeInfo> *m_poServTypeData;
        static SHMMapFile<ServLocationInfo> *m_poServLocationData;
        static SHMMapFile<ServStateInfo> *m_poServStateData;
        static SHMMapFile<ServAttrInfo> *m_poServAttrData;

        static SHMMapFile<ImsiMdnRelation> *m_poImsiMdnRelationData;

        static SHMMapFile<ServIdentInfo> *m_poServIdentData;
        static SHMMapFile<ServProductInfo> *m_poServProductData;
        static SHMMapFile<ServProductAttrInfo> *m_poServProductAttrData;
        static SHMMapFile<ServAcctInfo> *m_poServAcctData;
        static SHMMapFile<AcctInfo> *m_poAcctData;
#line 291 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoMap.h"
        static SHMMapFile<ProdOfferIns> *m_poProdOfferInsData;
        static SHMMapFile<ProdOfferInsAttr> *m_poProdOfferInsAttrData;
        static SHMMapFile<OfferDetailIns> *m_poOfferDetailInsData;
		static SHMMapFile<ProdOfferInsAgreement> *m_poProdOfferInsAgreementData;
        static SHMMapFile<NpInfo> *m_poNpData;
        
        static CustInfo *m_poCust;
        static ProductInfo *m_poProduct;
        static ServInfo *m_poServ;
        
        static ServLocationInfo *m_poServLocation;
        static ServStateInfo *m_poServState;
        static ServAttrInfo *m_poServAttr;

        static ImsiMdnRelation *m_poImsiMdnRelation;

        static ServIdentInfo *m_poServIdent;
        static ServProductInfo *m_poServProduct;
        static ServProductAttrInfo *m_poServProductAttr;
        static ServAcctInfo *m_poServAcct;
        static AcctInfo *m_poAcct;
#line 318 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoMap.h"
        static ProdOfferIns *m_poProdOfferIns;
        static ProdOfferInsAttr *m_poProdOfferInsAttr;
        static OfferDetailIns *m_poOfferDetailIns;
        static ProdOfferInsAgreement * m_poProdOfferInsAgreement;
        static NpInfo *m_poNp;
		
        static SHMIntHashIndex *m_poCustIndex;
        static SHMIntHashIndex *m_poProductIndex;
        static SHMIntHashIndex *m_poServIndex;
        static SHMIntHashIndex *m_poServLocationIndex;

        static SHMStringTreeIndex *m_poImsiMdnRelationIndex;

        static SHMStringTreeIndex *m_poServIdentIndex;
        static SHMIntHashIndex *m_poServProductIndex;
        static SHMIntHashIndex *m_poServAcctIndex;
        static SHMIntHashIndex *m_poAcctIndex;
#line 343 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoMap.h"
        static SHMIntHashIndex * m_poProdOfferInsIndex;
        static SHMIntHashIndex * m_poOfferDetailInsOfferInsIndex;
		
		static SHMStringTreeIndex *m_poNpIndex;
        
    private:
		
        
        
};
#line 8 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoSHMFileCtl.h"
#line 1 "/hss/opt/opthss/src/bill/src/lib/ReadIni.h"
  









class ReadIni {
private:

public:
	ReadIni ();
	~ReadIni ();
	char *trim( char *str );
	char *readIniString( char const *IniFile, char const *Section, char const *Ident, char *sItem, char *defstr );
	int readIniInteger( char const *IniFile, char const *Section, char const *Ident, int defint );
	unsigned int readIniUInteger( char const *IniFile, char const *Section, char const *Ident, int defint );
	char *readIniStr( FILE *fd, char *Section, char *Ident, char *sItem, char *defstr );
	int readIniInt( FILE *fd, char *Section, char *Ident, int defint );
	long readIniLong( char const *IniFile, char const *Section, char const *Ident, long defint );	
	int readIniUInt( FILE *fd, char *Section, char *Ident, int defint );
	char *TruncStr( char *sp , char *sDst , int len);
	int SectionCheck(char *IniFile,char *Section);
	char *SubStr (char *, char *, int);
};



#line 9 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoSHMFileCtl.h"

const int EXTERNAL_INTERFACE_STATE = 0;
const int FILE_POINT_STATE = 1;
const int SHM_POINT_STATE = 2;
const int CHANGE_POINT_STATE = 3;

const int PROCE_NUM_MAX = 2000;







struct SHMPointer
{
    SHMData<CustInfo> *m_poCustData;
    SHMData<ProductInfo> *m_poProductData;
    SHMData<ServInfo> *m_poServData;
	SHMData<ServTypeInfo> * m_poServTypeData;
	SHMData<ServLocationInfo> *m_poServLocationData;
	SHMData<ServStateInfo> *m_poServStateData;
	SHMData<ServAttrInfo> *m_poServAttrData;

	SHMData<ImsiMdnRelation> * m_poImsiMdnRelationData;

	SHMData<ServIdentInfo> *m_poServIdentData;
	SHMData<ServProductInfo> *m_poServProductData;
	SHMData<ServProductAttrInfo> * m_poServProductAttrData;
	SHMData<ServAcctInfo> *m_poServAcctData;
	SHMData<AcctInfo> * m_poAcctData;
#line 46 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoSHMFileCtl.h"
	SHMData<ProdOfferIns> * m_poProdOfferInsData;
	SHMData<ProdOfferInsAttr> * m_poProdOfferInsAttrData;
	SHMData<OfferDetailIns> * m_poOfferDetailInsData;
	SHMData<ProdOfferInsAgreement> * m_poProdOfferInsAgreementData;
    
	SHMData<OfferInfo> *m_poOfferData;
    SHMData<ServGroupBaseInfo> * m_poServGroupBaseData;
	SHMData<CustPricingTariffInfo> *m_poCustTariffData;
	SHMData<CustPricingObjectInfo> *m_poCustPricingObjectData;
	SHMData<CustPricingParamInfo>  *m_poCustPricingParamData;
    SHMData<NpInfo>  *m_poNpData;
	
	
	CustInfo *m_poCust;
	SHMIntHashIndex *m_poCustIndex;
	ProductInfo *m_poProduct;
	SHMIntHashIndex *m_poProductIndex;
	ServInfo *m_poServ;
    SHMIntHashIndex *m_poServIndex;
    ServLocationInfo *m_poServLocation;
    ServStateInfo *m_poServState;
	ServAttrInfo * m_poServAttr;

	ImsiMdnRelation * m_poImsiMdnRelation;
	SHMStringTreeIndex* m_poImsiMdnRelationIndex;

    ServIdentInfo *m_poServIdent;
	SHMStringTreeIndex *m_poServIdentIndex;
	ServProductInfo *m_poServProduct;
	SHMIntHashIndex *m_poServProductIndex;
	ServProductAttrInfo * m_poServProductAttr;
    ServAcctInfo *m_poServAcct;
	SHMIntHashIndex * m_poServAcctIndex;
	AcctInfo * m_poAcct;
	SHMIntHashIndex * m_poAcctIndex;
#line 91 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoSHMFileCtl.h"
	ProdOfferIns * m_poProdOfferIns;
	SHMIntHashIndex * m_poProdOfferInsIndex;
	ProdOfferInsAttr * m_poProdOfferInsAttr;
	OfferDetailIns * m_poOfferDetailIns;
	SHMIntHashIndex * m_poOfferDetailInsOfferInsIndex;
	ProdOfferInsAgreement * m_poProdOfferInsAgreement;
	
	OfferInstanceInfo *m_poOfferInstance;
	CustPricingPlanInfo *m_poCustPlan;
	ServGroupInfo *m_poServGroup;
	SHMIntHashIndex *m_poOfferIndex;
	SHMIntHashIndex *m_poServGroupBaseIndex;
	SHMStringTreeIndex *m_poCustTariffIndex;
	
	NpInfo *m_poNp;
	SHMStringTreeIndex *m_poNpIndex;
};

struct FilePointer
{
    SHMMapFile<CustInfo> *m_poCustData;
	SHMMapFile<ProductInfo> *m_poProductData;
	SHMMapFile<ServInfo> *m_poServData;
	SHMMapFile<ServTypeInfo> * m_poServTypeData;
	SHMMapFile<ServLocationInfo> *m_poServLocationData;
	SHMMapFile<ServStateInfo> *m_poServStateData;
	SHMMapFile<ServAttrInfo> *m_poServAttrData;

	SHMMapFile<ImsiMdnRelation> * m_poImsiMdnRelationData;

	SHMMapFile<ServIdentInfo> *m_poServIdentData;
	SHMMapFile<ServProductInfo> *m_poServProductData;
	SHMMapFile<ServProductAttrInfo> * m_poServProductAttrData;
	SHMMapFile<ServAcctInfo> *m_poServAcctData;
	SHMMapFile<AcctInfo> * m_poAcctData;
#line 132 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoSHMFileCtl.h"
	SHMMapFile<ProdOfferIns> * m_poProdOfferInsData;
	SHMMapFile<ProdOfferInsAttr> * m_poProdOfferInsAttrData;
	SHMMapFile<OfferDetailIns> * m_poOfferDetailInsData;
	SHMMapFile<ProdOfferInsAgreement> * m_poProdOfferInsAgreementData;
    
	SHMMapFile<OfferInfo> *m_poOfferData;
    SHMMapFile<ServGroupBaseInfo> * m_poServGroupBaseData;
	SHMMapFile<CustPricingTariffInfo> *m_poCustTariffData;
	SHMMapFile<CustPricingObjectInfo> *m_poCustPricingObjectData;
	SHMMapFile<CustPricingParamInfo>  *m_poCustPricingParamData;
    SHMMapFile<NpInfo>  *m_poNpData;
	
	
	CustInfo *m_poCust;
	SHMIntHashIndex *m_poCustIndex;
	ProductInfo *m_poProduct;
	SHMIntHashIndex *m_poProductIndex;
	ServInfo *m_poServ;
    SHMIntHashIndex *m_poServIndex;
    ServLocationInfo *m_poServLocation;
    ServStateInfo *m_poServState;
	ServAttrInfo * m_poServAttr;

	ImsiMdnRelation * m_poImsiMdnRelation;
	SHMStringTreeIndex* m_poImsiMdnRelationIndex;

    ServIdentInfo *m_poServIdent;
	SHMStringTreeIndex *m_poServIdentIndex;
	ServProductInfo *m_poServProduct;
	SHMIntHashIndex *m_poServProductIndex;
	ServProductAttrInfo * m_poServProductAttr;
    ServAcctInfo *m_poServAcct;
	SHMIntHashIndex * m_poServAcctIndex;
	AcctInfo * m_poAcct;
	SHMIntHashIndex * m_poAcctIndex;
#line 177 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoSHMFileCtl.h"
	ProdOfferIns * m_poProdOfferIns;
	SHMIntHashIndex * m_poProdOfferInsIndex;
	ProdOfferInsAttr * m_poProdOfferInsAttr;
	OfferDetailIns * m_poOfferDetailIns;
	SHMIntHashIndex * m_poOfferDetailInsOfferInsIndex;
	ProdOfferInsAgreement * m_poProdOfferInsAgreement;
	
	OfferInstanceInfo *m_poOfferInstance;
	CustPricingPlanInfo *m_poCustPlan;
	ServGroupInfo *m_poServGroup;
	SHMIntHashIndex *m_poOfferIndex;
	SHMIntHashIndex *m_poServGroupBaseIndex;
	SHMStringTreeIndex *m_poCustTariffIndex;
	
	NpInfo *m_poNp;
	SHMStringTreeIndex *m_poNpIndex;
};

struct fileName
{
    char sCust[64];
    char sProduct[64];
    char sServ[64];
    char sServType[64];
    char sServLoc[64];
    char sServState[64];
    char sServAttr[64];

    char sImsiMdnRelat[128];

    char sServIden[64];
    char sServProd[64];
    char sServProdAttr[64];
    char sServAcct[64];
    char sAcct[64];





    char sACCNbrOfferType[64];
    char sOfferIns[64];
    char sOfferInsAttr[64];
    char sOfferInsDetail[64];
    char sOfferInsAgr[64];
    char sNpName[64];
};



class ChangeDataState
{
    public:
        int m_iState[4];
		int m_iCurNum;
		int m_iProce[PROCE_NUM_MAX];
		int m_iProceMode[PROCE_NUM_MAX];
};

class SHMFileCtl
{
    public:
        SHMFileCtl();
		SHMFileCtl(bool bRebuild);
		SHMFileCtl(int iAppProgram);
        ~SHMFileCtl();
        
        static void * m_pChangePointer;
        static SHMData<ChangeDataState> *m_poState;
        static ChangeDataState * m_poStateData;
        static bool m_bAttached;
        
	    void initSHM();
		void initFile(bool bRebuild);
		
        void detachSHM();
        void detachFile();
        
        int changeUserInfo(int iChangeMode, bool bRebuild = false);
        int getDataState();
        
        pathFullName getFileName();
        void createFile(int iMode = 0);
        void removeFileAndIdx();
        
		int getSHMNattachNum();
        bool verifySHMFile(int iMark);
        
        void updateProce();
        void setProcessMode(int iMode, int iProc = 0);
		
	private:
		int initFileName();
		
		static SHMPointer * m_pSHMPointer;
		static FilePointer * m_pFilePointer;
		
		static UserInfoBase *m_poUserBase;
		static UserInfoMapBase *m_poUserMapBase;
		
		
		char m_sTIBS_HOME[80];
		pathFullName m_oPathFullName;
		fileName m_oFileName;
};

#line 9 "/hss/opt/opthss/src/bill/src/mmdb/SHMFileInfo.h"


class SHMFileInfo
{
    public:
        SHMFileInfo();
        ~SHMFileInfo();
		
        static UserInfoBase * m_pSHMFileExternal;
		
        static void refleshPointer();
		
    private:
        static UserInfoBase * m_pSHMInternal;
        static UserInfoBase * m_pFileInternal;
		
        static SHMFileCtl * m_pSHMFileCtl;
};
#line 22 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoReader.h"
class PricingCombine;
using namespace std;

class BillingCycleMgr;
class Serv;



#line 66 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoReader.h"

class UserInfoReader : public UserInfoBase
{
  public:
    
    UserInfoReader();
	UserInfoReader(int iMode);

  protected:
    
    static BillingCycleMgr * m_poBillingCycleMgr;

    
    static AcctItemMgr * m_poAcctItemMgr;

    
    static OrgMgr * m_poOrgMgr;

    static StateConvertMgr * m_poStateConvertMgr;
    
    static NetworkPriorityMgr * m_poNetworkMgr;
    
    static OfferMgr * m_poOfferMgr;
    
#line 97 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoReader.h"

    long execOperation(int iOperation,StdEvent * m_poEvent,int iAttrID = 0);
};








class UserInfoAttr
{
  public:
    
    int &getAttrID();

    
    char *getAttrValue();

    
    char *getEffDate();

    
    char *getExpDate();

  private:
    
    
    
    int m_iAttrID;

    
    char m_sAttrValue[32];

    
    char m_sEffDate[16];

    
    char m_sExpDate[16];

};


class ServProduct : public UserInfoReader
{
	friend class ServProductIteration;
	friend class Serv;
	friend class UserInfoInterface;
  public:
    
    long getServProductID();

    
    long getServID();

    
    int getProductID();

    bool getEff(char *sDate);

    int getUsingDay(char *sBeginDate, char *sEndDate, Serv * pServ = 0);

    
    char *getEffDate();

    
    char *getExpDate();

    
    char * getAttr(int attrid, char *sDate = 0);

    
    int getAttrs(vector<UserInfoAttr> &ret);

    
    
    
    
    
    ServProductInfo *getServProductInfo();

  private:
    
    ServProductInfo *m_poServProductInfo;

    
    ServInfo *m_poServInfo;

};


class ServProductIteration : public UserInfoReader
{
	friend class Serv;
  public:
    
    bool next(ServProduct &servProduct);
  private:
    
    unsigned int m_iCurOffset;


    
    bool m_bAll;
    
    char m_sTime[16];


};

class OfferInsQO : public UserInfoReader
{
public:
    
    ProdOfferIns* m_poOfferIns;
    
    OfferDetailIns* m_poDetailIns;
    
    int m_iPriority;
    
    int m_iOfferType;
    
    bool m_bAccued;
    
    char m_sTime[16];
    
    int getOfferInsAttr(ProdOfferInsAttr ret[30], char * sDate = 0);
    
    int getOfferInsAttrAndDate(ProdOfferInsAttr ret[30], char * sDate = 0);

    
    int getOfferInsAttrByAttrID(ProdOfferInsAttr ret[30], int iAttrID, char * sDate = 0,StdEvent * poEvent =0);
	
    int getOfferInsAttrCntByAttrID(int iAttrID,char* sDate =0,StdEvent * poEvent =0);
    
    char *getOfferAttr(int iAttrID, char *sDate = 0,StdEvent * poEvent =0);
    
    bool isOfferAttrValue(int iAttrID, char* iAttrVal, char *sDate = 0,StdEvent * poEvent =0);
    
    bool isOfferMember(int iMemberID, char *sDate = 0);
    
    int getOfferInsMember(OfferDetailIns ret[8192], 
                                                            char *sDate = 0);
    OfferDetailIns * getOneMemberIns(int iMemberID, char *sDate = 0);
    int getOfferInsMember(OfferDetailIns * ret[8192],
                            int iMemberID, char * sDate = 0);
    
    bool isOfferInsMember(long lServID, long lAcctID, int iMemberID, char *sDate = 0);
		
		
		bool getOfferInsAgreement(ProdOfferInsAgreement &ret,char * sDate = 0);
		

private:
    bool __isOfferMember(long lProdOfferInsID, int iMemberID, char *sDate = 0);
    
    int __getOfferInsMember(OfferDetailIns ret[8192], long lProdOfferInsID, char *sDate = 0);
    
    bool __isOfferInsMember(long lProdOfferInsID, long lServID, long lAcctID, int iMemberID, char *sDate);
};

class OfferInsIteration : public UserInfoReader
{
    friend class UserInfoInterface;
public:
    bool next(ProdOfferIns &offerins);
private:
    unsigned int m_iCurOffset;
};




class Serv : public UserInfoReader
{
    friend class ServIteration;
    friend class UserInfoInterface;

  public:

	
    
    
    long getServID();

    
    
    
    bool belongOfferInstance(long instanceid, char *sdate = 0);
    
	char const * getServTypeEffDate(char *sDate = 0);

        
    
    bool hasProduct(int nProductID,char* pBeginDate,char* pEndDate=0);

    char const * getAccNBR(int iType, char *stime);

    
    
    
    bool belongOffer(int offerid, char *sdate = 0);

    
    
    
    
    bool hasServProduct(int productid, ServProduct & sp, char *sdate) ;
    
    
    bool hasServProduct(int nServProductID,char* pBeginDate,char* pEndDate=0);

	
    bool hasServProductEx(int nServProductID,char* pBeginDate,char* pEndDate=0);

    
    
    
    char const *getProductEffDate(int productid, char *sdate = 0);

    
    char const *getServProductEffDate(long iServProductID, char *sdate = 0);

    
    
    
    int getOrgID(
        
        
        char *sDate = 0);

    
    
    
    long getAcctID(int acctitemtype);
    long getAcctID(int acctitemtype,char * sDate);
	long getAcctID(int acctitemtype,StdEvent * poEvent);    
    void getAcctID(vector<long> & vAcctID);
    void getAcctID(vector<long> & vAcctID,char * sDate);
	void getAcctID(vector<long> & vAcctID,StdEvent * poEvent);

    
    
    
    int getBillingCycleType();

    
    
    
    BillingCycle const * getBillingCycle(char *time = 0, int iCycleType = -1);

    
    
    
    int getPricingPlans(
        
        ExPricingPlan ret[64], char * sDate = 0);

    
    
    
    int getBasePricingPlan(char *sDate = 0);

    
    
    
    long getCustID();

    
    
    
    char * getCustType();

    
    
    
    int getCustServ(
        
        
        vector<long> &ret);

    int getProductID(char *sDate = 0);


    
    int getOffers(int  offers[5], char *sdate = 0);

    
    int getOfferInstances(long offerinstances[5], char *sdate = 0);

    
    bool getServProductIteration(ServProductIteration &servProductIteration, 
        
        
        
        
        char *sdate = 0,
        
        
        
        bool isall = false);

    bool getServProduct(long lServProductID, ServProduct & servProduct);

    
    bool belongOrg(int orgid);

    
    
    
    char *getState(char *sDate = 0);
    
    char *getPreState();

    
    char *getLatestState();

	
    char *getLatestStateDate();

    
    char *getBillingState(char *sDate = 0);

    
    bool getUsing(Date d);	

    
    int  getUsingDay(char *sBeginDate, char *sEndDate);

    
    bool belongServGroup(long groupid, char *sdate = 0);

    
    bool belongCustGroup(long groupid);
    
    char *getRentDate();

    
    
    char *getCreateDate();

    
    
    char *getNscDate();

    
    char *getStateDate(char * sDate = 0);
    
    
    
    
    
    ServInfo *getServInfo();
    
    
    
    
    
    CustInfo *getCustInfo();

    char * getAttr(int attrid, char *sDate = 0);
	char * getAttrNew(int attrid, char * sDate, char * m_sValue, int iSize);
    int getAttrs(vector<UserInfoAttr> &ret);


	bool isAttrValue(int attrid, char *sValue, char *sDate=0);
	bool isAttrValueMax(int attrid, char *sValue, char *sDate=0);

    int getAttrNumber(int attrid, char *sDate=0);

    void setTime(char *sDate);
    
    int getFreeType();
    
    int getOfferIns(OfferInsQO ret[512],char *sDate=0);
    
    int getBaseOfferIns(OfferInsQO * ret, char *sDate = 0);
    
    bool hasOffer (int iOfferID, char *sDate = 0);
    
    int getBaseOfferID(char *sDate = 0);
    int getOfferInsQO(OfferInsQO& ret,long lOfferInstID); 
    
    int getOfferInsBillingCycle(OfferInsQO ret[512], char *sDate);
    
		bool isServAttrChanged(const char *sBeginTime,const char *sEndTime);
		
		bool isServStateAttrChanged(const char *sBeginTime,const char *sEndTime);
		
		bool isServTypeChanged(const char *sBeginTime,const char *sEndTime);
		
		bool isServProductChanged(const char *sBeginTime,const char *sEndTime);
		
		bool isServProductAttrChanged(const char *sBeginTime,const char *sEndTime);
		
		bool isProdOffer_Ins_Attr_Detail_Changed(const char *sBeginTime,const char *sEndTime);
		
		bool isServChanged(const char *sBeginTime,const char *sEndTime);
    
  private:
    
    char m_sTime[16];

    
    ServInfo *m_poServInfo;

    
    CustInfo *m_poCustInfo;

    
    ServProductInfo *m_poServProductInfo;

    
    ServAcctInfo *m_poServAcctInfo;

};




class ServIteration : public UserInfoReader
{
  friend class UserInfoInterface;

  public:
    
    bool next(Serv &serv);
    bool nextByOrg(Serv &serv);

     
    bool belongCurServLocation(char *sTime);

  private:
    
    unsigned int m_iCurOffset;

    unsigned int m_iLastOffset;


    
    char m_sTime[16];

};

class CustIteration : public UserInfoReader
{
  public:
	friend class UserInfoInterface;

  public:
	bool next(long & lCustID);
	
  private:
	unsigned int m_iCurOffset;

};

class ServGroupIteration : public UserInfoReader
{
  public:
	friend class UserInfoInterface;

  public:
	bool next(long & lGroupID);

  private:
	unsigned int m_iCurOffset;
};





class UserInfoInterface : public UserInfoReader
{
  public:
    
    
    
    operator bool();

    static bool getAcctBelongOrg(long lAcctID, int iOrgID);
    static bool getCustBelongOrg(long lCustID, int iOrgID);
    static bool getServGroupBelongOrg(int iServGroupID, int iOrgID);

    
    
    
    static bool getServ(
        
        
        Serv &ret, 
        
        
        char *accnbr, 
        
        
        
        char stime[16], 
        int pNetworkID = 0,
        bool isPhy=false) ;

    
    static bool getServ_A(
        
        Serv &ret, 
        
        char *area_code,        
        
        char *accnbr, 
        
        char stime[16], 
        int pNetworkID = 0,
        bool isPhy=false) ;

	
    static bool getServ_Z(
        
        Serv &ret,
        
        char *area_code,       
        
        char *accnbr,
        
        char stime[16],
        bool isPhy=false);

	
	static bool getServ(
        
        Serv &ret, 
        
        char *accnbr, 
		
		long lServID,
        
        char stime[16],
        bool isPhy=false);

    static char const * convertAccNBR(char *accnbr, int iSrcType, int iDestType, char *stime);

    static bool getServProduct(long lServProductID, ServProduct & servProduct);

    
    
    
    static bool getServ(
        
        
        Serv &ret, 
        
        
        long servid, 
        
        
        
        char stime[16]) ;
    
    
    
    static bool getServ (
        
        Serv &ret,
        
        char *accnbr,
        
        int  iType,
        
        char *stime
    );

	
    static bool getServN (
        
        Serv &ret,
        
        char *accnbr,
        
        int  iType,
        
        char *stime,
		
		int pNetworkID = 0
    );
    
    static int getCustServ(long lCustID, vector<long> &vServ);
    static int getGroupServ(long lGroupID, vector<long> &vServ, char *sDate);
    static int getCustAcct(long lCustID, vector<long> &vAcct);

    static int getAcctCreditAmount(long lAcctID);
    static int getAcctCreditGrade(long lAcctID);

    
    
    
    UserInfoInterface();
	UserInfoInterface(int iMode);

    
    static bool getServIteration(ServIteration &servIteration);

    static bool getServIterByOrg(ServIteration &servIter, int iOrgID);

    static bool getCustIteration(CustIteration &custIteration);

    static bool getServGroupIteration(ServGroupIteration &servGroupIteration);
    
    static int getServOrg(long lServID, char * sDate);
   

    long getCustomParamValue (int iParamID, unsigned int iCustPlanOffset);

    int getCustomPricingPlans(ExPricingPlan ret[64],int iObjectType,long lObjectID,char *sDate);

    long getCustomObjectID(int iPlanObjectID, unsigned int iCustPlanOffset);

	bool isBindServObject(long lServID, unsigned int iCustPlanOffset);

    char const *getCustomPlanEffDate(unsigned int iCustPlanOffset);

    CustPricingObjectInfo const * getCustomObject(int iPlanObjectID, unsigned int iCustPlanOffset);

    int getPayInfo(vector<ServAcctInfo> &ret, long lAcctID, char * sDate=0);
	int getPayInfo(vector<ServAcctInfo> &ret, long lAcctID, StdEvent * poEvent);

    CustPricingTariffInfo * getCustTariff(unsigned int iCustPlanOffset, char *sCalledNBR);
    
    
    
    int getAcctOfferIns(OfferInsQO ret[512], long lAcctID, char *sDate);
    
    int getCustOfferIns(OfferInsQO ret[512], long lCustID, char *sDate);
    
    int getAllOfferInsByID(OfferInsQO ret[512], long lProdOfferInsID, char *sDate);
    int getOfferInsByID(OfferInsQO& ret,long lProdOfferInstID,char* sDate); 
	
    ProdOfferIns * getOfferIns(long lOfferInstID);

    
    bool getOfferInsIteration(OfferInsIteration &offerinsiter);
    
    bool isOfferInsBelongOrg(long lOfferInstID, int iOrgID, char * sDate);
    
    
    
    long getAcctID(long lServID, int acctitemtype);
    long getAcctID(long lServID, int acctitemtype, char * sDate);
	long getAcctID(long lServID, int acctitemtype, StdEvent * poEvent);
		
	
	static bool getNpInfo(NpInfo &oNpInfo,char *sAccNbr,char *sDate = 0);
	
	static bool clearServ(Serv &cur);








#line 765 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoReader.h"


	bool getImsiMdnRelationByImsi(ImsiMdnRelation &oRelation, char *sImsi,long iType, const char *sDate=0);
	void showImsiMdnRelationByImsi(char *sImsi, const char *sDate=0);
	void showAllImsiMdnRelation();
#line 776 "/hss/opt/opthss/src/bill/src/mmdb/UserInfoReader.h"
};


#line 17 "/hss/opt/opthss/src/bill/src/framework/Environment.h"

#line 1 "/hss/opt/opthss/src/bill/src/public/EventSection.h"
  









using namespace std;

class ExtendTempValue
{
  private:
    long  aLongValue[100];
    char  aStringValue[100][80];

    bool  bModFlag;
    
  public:
    ExtendTempValue () { bModFlag = true; }
    
    void setLongValue (int iPos, long lValue)
    {
        if (iPos<0 || iPos>99) return;
        aLongValue[iPos] = lValue;        
        bModFlag = true;
    }
    void setStringValue (int iPos, char *sValue)
    {
        if (iPos<0 || iPos>99) return;
	int iLen =strlen(sValue)>(80-1)?80-1:strlen(sValue);
        strncpy (aStringValue[iPos], sValue,iLen);
        aStringValue[iPos][iLen]=0;
	
	
	bModFlag = true;
    }
    
    long getLongValue (int iPos)
    {
        if (iPos<0 || iPos>99) return 0;
        return aLongValue[iPos];
    }
    void getStringValue (int iPos, char *sValue)
    {
        if (iPos<0 || iPos>99) return ;
        strcpy (sValue, aStringValue[iPos]);
    }
    
    void reset () {
        if (bModFlag) {
            memset (this, 0, sizeof (ExtendTempValue));
        }
    }
};


class EventSection : public StdEvent
{
  public:
    
    static void reset();
        
    
    EventSection *malloc();

    
    static EventSection *initMemory(int number);

    
    static void freeMemory();
    
    
    EventSection *insert();
    
    
    void bindUserInfo(bool bRebind = false);
    
    void unbindUserInfo();

    void setUserInfo (Serv *pServ = 0x0);

    
    EventSection *m_poNext;
    
    int m_iMeasureBegin;

	
	unsigned int m_iCustPlanOffset;
        
  private:
    
    static int m_iTotalNumber;

    
    static int m_iUsedNumber;

    
    static EventSection *m_poList;

  public:
    
    ExtendTempValue  m_oExtTempValue;
    
    
    int  m_iOutOverTimes;
    
    
    int  m_iInOverTimes;
    
    
    int  m_iOutOverTimesV6; 
    
    
    int  m_iInOverTimesV6; 
    
    
    int  m_iTrunkNotBillFlag;
    
    
    
    
    char m_sDupChkCallingNBR[41]; 
    
    
    
    char m_sDupChkCalledNBR[41];   
    
    
    char m_sMixStr[80]; 
    
	char m_sSeqKey[16];
	
	char m_sSeqIDCode[16];
    void resetExtAttrValue ()
    {
	    m_iOutOverTimes = 0;
	    m_iInOverTimes = 0;
	    m_iOutOverTimesV6 = 0;
	    m_iInOverTimesV6 = 0;
	    m_iTrunkNotBillFlag = 0;
	    m_sDupChkCallingNBR[0] = 0;
	    m_sDupChkCalledNBR[0] = 0;
	    m_sMixStr[0] = 0;
		m_sSeqKey[0] = 0;
		m_sSeqIDCode[0] = 0;
	   
	    
	    m_oExtTempValue.reset ();        
	 m_iBillingOrgIDEx_AD = 0;
        m_iBillingOrgIDEx_VS = 0;
        m_iCallingOrgIDEx_AD = 0;
        m_iCallingOrgIDEx_VS =0;
        m_iCalledOrgIDEx_AD =0;
        m_iCalledOrgIDEx_VS =0;
        m_iThirdOrgIDEx_AD =0;
        m_iThirdOrgIDEx_VS =0;
        m_iCalledCarrier = 0; 
	m_iOtherOrgIDEx_AD = 0;
	m_iOtherOrgIDEx_VS =0;
    }
	    
    int m_iBillingOrgIDEx_AD;
    int m_iBillingOrgIDEx_VS;
    int m_iOtherOrgIDEx_AD;
    int m_iOtherOrgIDEx_VS;
    int m_iCallingOrgIDEx_AD;
    int m_iCallingOrgIDEx_VS;
    int m_iCalledOrgIDEx_AD;
    int m_iCalledOrgIDEx_VS;
    int m_iThirdOrgIDEx_AD;
    int m_iThirdOrgIDEx_VS;
    int m_iCalledCarrier;
};





#line 19 "/hss/opt/opthss/src/bill/src/framework/Environment.h"


#line 1 "/hss/opt/opthss/src/bill/src/public/encode.h"
  




extern "C"
{
extern void encode(char *inblock,char * outblock);
extern void decode(char *inblock,char * outblock);
}


#line 24 "/hss/opt/opthss/src/bill/src/framework/Environment.h"







class ProdOfferDisctAggr;
class ProdOfferTotalData;
class UserInfoInterface;







class ParamInfoInterface;
class ParamInfoMgr;





using namespace std;
































































 



extern int g_argc;
extern char ** g_argv;














class Environment
{
  public:
    
    
    
    static void setDBLogin(char *name, char *pwd, char *str);

    
    
    
    static TOCIDatabase *getDBConn(bool bReconnect = false);
    static void commit();
    
    static void rollback();
    static void disconnect();    
    static void connectDB(TOCIDatabase * pDbConn, char const * sIniHeader);
    static void getConnectInfo(char const * sIniHeader,char *sUserName,char *sPasswd,char *sConnStr);

    
    



































































































 
    static bool m_bConnect;	
  private:
    
    static char m_sDBUser[24];

    
    static char m_sDBPwd[24];

    
    static char m_sDBStr[32];

    
    static TOCIDatabase m_oDBConn;

    
    static bool m_bDefaultConn;

    static void getDefaultLogin();

};





#line 24 "/hss/opt/opthss/src/bill/src/app_guard/WfPublic.h"
#line 1 "/hss/opt/opthss/src/bill/src/app_guard/ProcessInfo.h"
  
#line 1 "/hss/opt/opthss/src/include/../../etc/LocalDefine.h"
#line 81 "/hss/opt/opthss/src/include/../../etc/LocalDefine.h"



#line 6 "/hss/opt/opthss/src/bill/src/app_guard/ProcessInfo.h"






const int MAX_CMAMSG_CNT  = 32;
const int MAX_APPINFO__LEN = 256;   
const int MAX_CMAMSG_LEN  = 1024; 

const int MAX_OUTMSG_LEN  = 1024;  
const int INFO_Q_SIZE     = 100;   


 





const char WF_START  = 'B'; 
const char WF_NORMAL = 'E'; 
const char WF_ABORT = 'X';  
const char WF_STOP = 'K';   
const char WF_RUNNING = 'R'; 




 
#line 45 "/hss/opt/opthss/src/bill/src/app_guard/ProcessInfo.h"


const int PETRI_ST_NORMAL=0;
const int PETRI_ST_OUT_ACCT_RDY=1;
const int PETRI_ST_OUT_ACCT_PRE=2;
const int PETRI_ST_OUT_ACCTING=3;





typedef struct TMsgInfo {
    int iNewFlag;
    long lTime;
    int iMsgType;
    char sMsg[10];
}TMsgInfo;

typedef struct TProcessInfo 
{
    int  iProcessID;
    int  iAppID;
    int  iBillFlowID;
    int  iSysPID;

    int  iMqID; 
    char sName[96];
    char sExecFile[256];
    char sExecPath[256];
    char sParam[256];
    long lLoginTime;
    int  iState;
    long iAllTickets;
    long iNormalTickets;
    long iBlackTickets;
    long iErrTickets;
    long iOtherTickets;
    long iCurMsgPos;
    long iCurErrPos;
    TMsgInfo MsgItem[10];
    TMsgInfo ErrItem[10];
    int  iFreeFlag;
    
    time_t tSaveTime;
    long   lSaveTickets;
    int iBlockFlag; 
    int iTreatRate;
    int iIORate; 
    int iCPU;
    int iMEM;
    long lAllIOCnt;
    long lLatestIOCnt;
    long lLatestProcCnt;
    time_t tLatestCalcTime;
    char sFlowName[30];
    char sMsgInfo[100];

    

 
  
     
    int iVpID;	
    int iTaskNum; 
    int iNextTaskNum; 
    int iNextVpID;

	int iPetriState;
	int iLastState;
       
     
    int iFileID;        
    int iSendTickets;   
} TProcessInfo;

typedef struct THeadInfo {
    int iSysPID;
    int iProcNum;
    int iRefreshFlag;
    
    int iCpuUsed; 
    int iMemUsed;

    char bootTime[16]; 

    TProcessInfo ProcInfo;
}THeadInfo;


extern "C" {


int CreateShm (long lSize, void **pRet);
int AttachShm (long lSize, void **pRet);
int DetachShm ();
int DestroyShm ();
int InitPV ();
int DestroyPV ();
int P() ;
int V();


};



#line 26 "/hss/opt/opthss/src/bill/src/app_guard/WfPublic.h"




using namespace std;

const int MEMBER_NULL = -99;
const int USLEEP_LONG = 10000; 
const int MAX_SQL_LEN = 2048;
const int ORGID_STR_LEN = 256;
const int MAX_ORG_CNT = 100;
const int OUT_MSG_MIN_CNT = 3;








#line 60 "/hss/opt/opthss/src/bill/src/app_guard/WfPublic.h"

#line 69 "/hss/opt/opthss/src/bill/src/app_guard/WfPublic.h"



#line 84 "/hss/opt/opthss/src/bill/src/app_guard/WfPublic.h"























extern "C" {

void AllTrim(char sBuf[]);


void TrimHeadNull(char *src,int ilen);

void replace(char * sql,char *src,char *des);

}


class TWfLog {
 public:
    static void log(char const *fmt,...);
    static void log(int iErrCode,char const *fmt,...);
    static void log(char const *sFileName, int iLine, char const *fmt,...);
    static void writeLog(char *sMsg) ;
    static void writeLog2(char *sMsg) ;
    static void ignoreTuxBuildErr() {
        

    }
 private:    
    static Date m_oDate;
};









 
class TLogProcessMgr {
 public:
 
    
    
    static void updateLogProcess(int _iProcessLogID, char _cState, int _iAppPid = 0);
    
    
    static int insertLogProcess( int _iProcID, const char *sCommand,
        int iStaffID = -1,int iPlanID = -1 );
    
 private:
     static int getProcessLogID();
};




















 
class TParseBuff{
public:
    TParseBuff(); 
    TParseBuff(char *sInBuff); 

    void reset(); 
    bool parseBuff(char *sInBuff); 

    int  getBillFlowID() { return  m_iBillFlowID; }
    int  getProcessID()  { return  m_iProcessID; }
    int  getHostID()     { return  m_iHostID; }
    int  getStaffID()    { return  m_iStaffID; }
    int  getPlanID()     { return  m_iPlanID; }
    int  getLogMode()    { return  m_iLogMode; } 
    int  getLogID()      { return  m_iLogID; } 
    int  getAuthID()     { return  m_iAuthID; }
    int  getOperation()  { return  m_iOperation; } 
    int  getResult()     { return m_iResult; }
    unsigned long getProcessCnt() { return m_lProcessCnt; }
    unsigned long getNormalCnt() { return m_lNormalCnt; }
    unsigned long getErrorCnt() { return m_lErrorCnt; }
    unsigned long getBlackCnt() { return m_lBlackCnt; }
    unsigned long getOtherCnt() { return m_lOtherCnt; }
    
    int  getMainGuardIndex()      { return m_iMainGuardIndex; }
    void getHostAddr(char *ip)    { if (ip) strcpy(ip,m_sHostAddr); }
    void getSysUserName(char *usr)    { if (usr) strcpy(usr,m_sSysUserName); }
    void getOrgIDStr(char *str)   { if (str) strcpy(str,m_sOrgIDStr); }
    char const *getMsg(int iOffSet = 0)  {
        if (iOffSet <= m_iMsgOff)
            return m_sMsg[iOffSet];
        else return "";        
    }
    char getState()  { return m_cState; }
    
    void setBillFlowID(int id)  { m_iBillFlowID = id;}
    void setProcessID(int id)   { m_iProcessID = id;}
    void setHostID(int id)      { m_iHostID = id;}
    void setHostAddr(char* str) {
        strncpy(m_sHostAddr,str,15); 
        m_sHostAddr[15] = 0;
        AllTrim(m_sHostAddr);
    }
    void setSysUserName(char* str) {
        strncpy(m_sSysUserName,str,31); 
        m_sSysUserName[31] = 0;
        AllTrim(m_sSysUserName);
    }
    void setOrgIDStr(char* str) {
        strncpy(m_sOrgIDStr,str,ORGID_STR_LEN);
        m_sOrgIDStr[ORGID_STR_LEN] = 0;
        AllTrim(m_sOrgIDStr);
    }
    void setLogID(int id)  { m_iLogID = id;}
    void setAuthID(int id) { m_iAuthID = id;}
    void setResult(int id) { m_iResult = id;}
    void setStaffID(int id) { m_iStaffID = id;}
    void setPlanID(int id) { m_iPlanID =  id;}
    void setOperation(int id) { m_iOperation = id;}
    void setMainGuardIndex(int id) { m_iMainGuardIndex = id;}
    void setProcessCnt(unsigned long id) {m_lProcessCnt = id;}
    void setNormalCnt(unsigned long id) {m_lNormalCnt = id;}
    void setErrorCnt(unsigned long id) {m_lErrorCnt = id;}
    void setBlackCnt(unsigned long id) {m_lBlackCnt = id;}
    void setOtherCnt(unsigned long id) {m_lOtherCnt = id;}
    
    void setState(char _cState) { m_cState = _cState; }
    
    void addMsg(const char *msg); 
    bool getBuiltStr(char *sOutBuff); 
    char *getBuiltMsg(); 

    
private:
    bool parse(); 
    void formatBuff(); 
    void parseResultSave(char *pAtt, char *pValue);
    bool build(); 
    
    unsigned long stringToUL (char *pValue);
    
    char m_Str[2048*4+1]; 
    
    int  m_iBillFlowID;
    int  m_iProcessID;
    unsigned long m_lProcessCnt;
    unsigned long m_lNormalCnt;
    unsigned long m_lErrorCnt;
    unsigned long m_lBlackCnt;
    unsigned long m_lOtherCnt;
    int  m_iHostID;
    char m_sHostAddr[16];
    char m_sSysUserName[32];
    int  m_iStaffID;
    int  m_iPlanID;
    int  m_iLogMode;
    int  m_iLogID;
    int  m_iAuthID;
    int  m_iMainGuardIndex;
    int  m_iOperation; 
    char m_cState;     
    int  m_iResult;    
    char m_sOrgIDStr[ORGID_STR_LEN+1];
    char m_sMsg[100][256+1]; 
    int  m_iMsgOff;    
};




class TMntReqInfo{
 public:
    int   m_iStatus; 
    int   m_iRegNum;                 
    int   m_iBillFlowID;             
    int   m_iLogMode;                
    int   m_iStaffID;    
    char  m_sHostAddr[15];
    int   m_iIndex;                     
    int   m_igAuthID;                
    int   m_iAuthID;                 
    int   m_iProcessID;
    int   m_iOperation;
    char  m_cState;
    char  m_sOrgIDStr[ORGID_STR_LEN+1];
    char  m_sMsgBuf[MAX_CMAMSG_LEN]; 
    TMntReqInfo() { m_iRegNum = 0; }
};

class  TClientReqInfo{
 public:
    int  m_iStatus;
    char m_cState;      
    int  m_iRegNum;     
    int  m_iHostID; 
    char m_sSysUserName[32];
    int  m_iIndex;      
    int  m_iProcessID;
    int  m_iStaffID;
    int  m_iPlanID;
    int  m_iResult;
    int  m_iOperation;              
    int  m_iMainGuardIndex;         
    char m_sMsgBuf[MAX_OUTMSG_LEN];
    TClientReqInfo() { m_iRegNum = 0; }
};

class TAppReqInfo{
 public:
    int       m_iStatus;    
    int       m_iProcessID; 
    int       m_iAppPID;    
    int       m_iIndex;     
    char      m_cState;
    int       m_iSaveBufIdx;
};





class TAppInfo {

 friend class TSHMCMA;

 public:
    int        m_iProcessLogID; 
    int        m_iProcessID;    
    int        m_iMainGuardIndex; 
                         
    int        m_iBillFlowID;   
    char       m_cState; 
                         
    int        m_iAppPID;
    int	 	m_iAppType;
    unsigned long m_lProcessCnt;
    unsigned long m_lNormalCnt;
    unsigned long m_lErrorCnt;
    unsigned long m_lBlackCnt;
    unsigned long m_lOtherCnt;
    
    time_t         m_tLatestCalcTime; 
    unsigned long  m_lLatestProcCnt;  
    float          m_fTreatRate;      
    
    int        m_iInfoHead;
    int        m_iInfoTail;
    char       m_asMsg[INFO_Q_SIZE][MAX_APPINFO__LEN]; 
 	int        m_iRet ;
 	char       m_sErrMsg[MAX_APPINFO__LEN]; 

    TAppInfo() { init(); m_iProcessID = -1;}

    void init() {
        m_iProcessID = -1; bNewMsg = false; bNewState = true;
        m_cState = 'A'; m_iProcessLogID = -1; m_iMainGuardIndex = -1; 
        m_lProcessCnt = 0; m_lNormalCnt=0; m_lErrorCnt=0; m_lBlackCnt =0; m_lOtherCnt=0;
        m_iInfoHead = 0; m_iInfoTail = 0;  
        m_iRet=0; memset(m_sErrMsg,0,sizeof(m_sErrMsg) );
    }

    bool putRetInfo(int iRet, char *sRetInfo);
    bool getRetInfo(int & iRet, char *sOutInfo);
	
    void pushInfo(char *_sMsg);
    bool getInfo( char *_sMsg); 
    char getState() { bNewState = false; return m_cState; }
    bool checkNeedOutput();
    
    bool checkAlive(); 

    void setState( char _cState) { 
        m_cState = _cState; 
        bNewMsg = true;
        bNewState = true;
        TLogProcessMgr::updateLogProcess(m_iProcessLogID, _cState);
    }
    
    void forceOutput() { bNewMsg = true; }


    void getOtherProcessInfo();
    
 private:
    bool  bNewMsg;      
    bool  bNewState;    
    
};


class TAppSaveBuff {
 friend class TSHMCMA; 
 public:
    void init () 
    { 
        m_iProcessID = -1; 
        m_bExistEvent = false; 
        m_iEventState = 0;
        m_iServBlockFlag = 0;
        memset (m_lSaveValue, 0, sizeof(long)*5);
    }
    void saveEvent (StdEvent &Evt)    
    {
        m_oEvent = Evt;
        m_bExistEvent = true;
        m_iEventState = 0;
    }
    void setEventState (int _iState)  
    { 
        m_iEventState = _iState; 
    }
    bool getEvent (StdEvent &Evt) 
    {
        if (!m_bExistEvent)
            return false;
        Evt = m_oEvent;
        return true;
    }
    
    bool getEventState (int *piState) 
    {
        if (!m_bExistEvent)
            return false;        
        *piState = m_iEventState;
        return true;
    }
    
    void setSaveBuff (void *pt, int iLen) {
        int iAdjustLen = iLen<128 ? iLen:128;
        memcpy (m_sSaveBuf, pt, iAdjustLen);
    }
    void getSaveBuff (void *pt, int iLen) {
        int iAdjustLen = iLen<128 ? iLen:128;
        memcpy (pt, m_sSaveBuf, iAdjustLen);
    }
    bool setSaveValue (int iValueID, long lValue) {
        if (iValueID<1 || iValueID>5) return false;
        m_lSaveValue[iValueID-1] = lValue;
        return true;
    }
    bool getSaveValue (int iValueID, long &lValue) {
        if (iValueID<1 || iValueID>5) return false;
        lValue = m_lSaveValue[iValueID-1];
        if (lValue == 0) return false;
        return true;
    }
    
    void setServBlockFlag (int iFlag)
    {
        m_iServBlockFlag = iFlag;
    }
    int  getServBlockFlag ()
    {
        return m_iServBlockFlag;
    }
    
    int  getProcessID() { return m_iProcessID; }
    void setProcessID(int id) { m_iProcessID = id; }
    
 private:
    int  m_iProcessID;
    bool m_bExistEvent;
    int  m_iEventState; 
    StdEvent m_oEvent;
    unsigned char m_sSaveBuf[128];
    long m_lSaveValue[5];
    int  m_iServBlockFlag;
};

class TSHMCMA {
 public:
    
    int            m_iMonitorLock;  
    TMntReqInfo    MntReqInfo;      

    
    int            m_iAppLock;      
    TAppReqInfo    AppReqInfo;      
    TAppInfo       AppInfo[5096];
                                    
        
    
    int            m_iClientLock;   
    TClientReqInfo ClientReqInfo;   
    
    
    TAppSaveBuff   AppSaveBuff[5096];
    
    
    TAppInfo*  getAppInfoByProcID(int _iProcID) ;
    
    TAppSaveBuff* getAppSaveBuffByProcID(int _iProcID);
    
    int changeState(int _iProcID, char _cState) ;
    
    
    int getIdleAppInfo(int _iProcID, int &iIndex) ;
    
    void setMainGuardIndex(int _iProcID,int _iMainGuardIndex) ;
    
    void printShm() ;

};



#line 10 "/hss/opt/opthss/src/bill/src/app_guard/mntapi.h"


#line 1 "/hss/opt/opthss/src/bill/src/lib/KeyTree.h"
  






#line 1 "/hss/opt/opthss/src/bill/src/lib/Stack.h"
  

















template <class T>
class Stack
{
  public:
    
    class Item
    {
        friend class Stack;

      public:
        
        Item();

      private:
        
        T m_oBuf[16];
        Item * m_poNext;
        Item * m_poPre;
    };

    
    void push(T data);

    
    bool pop(T &data);

    void clear() {
        m_iCur = 0;
        m_poCur = m_poHead;
    }

    
    Stack();

    
    ~Stack();

  private:
    
    int m_iCur;

    
    Item *m_poCur;
    Item *m_poHead;

};




template <class T>
Stack<T>::Item::Item():m_poNext(0),m_poPre(0)
{
}


template <class T>
void Stack<T>::push(T data)
{
	m_poCur->m_oBuf[m_iCur++] = data;
	if (m_iCur == 16) {
		if (!(m_poCur->m_poNext)) {
			m_poCur->m_poNext = new Item;
			if (!(m_poCur->m_poNext))
				throw Exception((100200000+1), (*__errno()), 83, "/hss/opt/opthss/src/bill/src/lib/Stack.h");
            m_poCur->m_poNext->m_poPre=m_poCur;
		}

		m_poCur = m_poCur->m_poNext;
		m_iCur = 0;
	}
}


template <class T>
bool Stack<T>::pop(T &data)
{
	if (!m_iCur) {
		if (m_poCur->m_poPre) {
			m_poCur = m_poCur->m_poPre;
			data = m_poCur->m_oBuf[15];
			m_iCur = 15;
			return true;
		}
		return false;
	} else {
		m_iCur--;
		data = m_poCur->m_oBuf[m_iCur];
		return true;
	}
}


template <class T>
Stack<T>::Stack()
{
	m_poCur = new Item;
	if (!m_poCur)
		throw Exception((100200000+1), (*__errno()), 117, "/hss/opt/opthss/src/bill/src/lib/Stack.h");
	m_iCur = 0;
    m_poHead = m_poCur;
}


template <class T>
Stack<T>::~Stack()
{
	Item *p ;
	while ((p= m_poCur->m_poNext)!=0) {
		m_poCur->m_poNext = p->m_poNext;
		delete p;
	}

	while ((p=m_poCur->m_poPre)!=0) {
		m_poCur->m_poPre = p->m_poPre;
		delete p;
	}

	delete m_poCur;
}

#line 12 "/hss/opt/opthss/src/bill/src/lib/KeyTree.h"


template <class T>
class KeyTree
{
  public:
    
    void add(char *key, T data);

    
    void add(int key, T data);

    
    void destroy();

    
    bool get(int key, T *value) const;

    
    bool get(char *key, T *value) const;
    bool getMax(char *key, T *value, char *retKey=0) const;
    bool getMax(char *key, T *value, int *pMatchLen) const;

    
    KeyTree();

    
    virtual ~KeyTree();

    unsigned int getCount() {return m_iCount;}

  private:

    KeyTree<T> * m_poNext[10];
    KeyList<T> * m_poValue;
    unsigned int m_iMaxDeep;
    unsigned int m_iCount;
};


template <class T>
void KeyTree<T>::add(char *key, T data)
{
    
    unsigned char *p = (unsigned char *) key;
    KeyTree<T> * po = (KeyTree<T> *) this;
    int i;
    while (*p)
    {
        i = (*p) % 10;
        if (!(po->m_poNext[i]))
        {
            po->m_poNext[i] = new KeyTree<T> ();
            m_iCount++;
            if (!(po->m_poNext[i]))
                throw Exception((100110000+1), (*__errno()), 67, "/hss/opt/opthss/src/bill/src/lib/KeyTree.h");
        }

        po = po->m_poNext[i];
        p++;
    }

    
    if (!(po->m_poValue)) {
        po->m_poValue = new KeyList<T> (key, data);
        if (!(po->m_poValue)) throw Exception((100110000+1), (*__errno()), 77, "/hss/opt/opthss/src/bill/src/lib/KeyTree.h");
        m_iMaxDeep = (m_iMaxDeep>strlen((const char *)p) ? m_iMaxDeep : strlen((const char *)p));    
    } else {
        po->m_poValue->add (key, data);
    }
}


template <class T>
void KeyTree<T>::add(int key, T data)
{
    
    int p = key;
    KeyTree<T> * po = (KeyTree<T> *) this;
    int i(0);
    unsigned int j(0);

    while (p)
    {
        i = p % 10;
        
        if (!(po->m_poNext[i]))
        {
            po->m_poNext[i] = new KeyTree<T> ();
            m_iCount++;
            if (!(po->m_poNext[i]))
                throw Exception((100110000+1), (*__errno()), 103, "/hss/opt/opthss/src/bill/src/lib/KeyTree.h");
        }

        po = po->m_poNext[i];
        p = p /10;
        j++;
    }

    
    if (!(po->m_poValue)) {
        po->m_poValue = new KeyList<T> (key, data);
        m_iMaxDeep = m_iMaxDeep>j ? m_iMaxDeep : j;
    } else {
        po->m_poValue->add (key, data);
    }
}



template <class T>
void KeyTree<T>::destroy()
{
    
    int i;

    Stack<KeyTree<T> *> stack;
    Stack<int> stack1;

    KeyTree<T> * p = (KeyTree<T> *) this;

    

    while (p) {
        for (i=0; i<10; i++) {
            if (p->m_poNext[i]) {
                stack.push (p);
                stack1.push (i);
                p = p->m_poNext[i];
                goto _CONTINUEWHILE;
            }
        }

        if (!stack.pop (p)) {
            if (m_poValue) {
                delete m_poValue;
                m_poValue = 0;
            }
            return;
        }

        stack1.pop (i);
        delete p->m_poNext[i];
        p->m_poNext[i] = 0;

        _CONTINUEWHILE:
            ;
    } 

}


template <class T>
bool KeyTree<T>::get(int key, T *value) const
{
    
    int p = key;  
    KeyTree<T> * po = (KeyTree<T> *) this;
    int i;
    while (p)
    {
        i = p % 10;
        if (!(po->m_poNext[i]))
            return false;

        po = po->m_poNext[i];
        p = p / 10;
    }

    
    if (!(po->m_poValue)) return false;

    return po->m_poValue->get(key, value);
}


template <class T>
bool KeyTree<T>::get(char *key, T *value) const
{
    
    
    unsigned char *p = (unsigned char *) key;
    KeyTree<T> * po = (KeyTree<T> *) this;
    int i;
    while (*p)
    {
        i = (*p) % 10;
        if (!(po->m_poNext[i]))
            return false;

        po = po->m_poNext[i];
        p++;
    }

    
    if (!(po->m_poValue)) return false;

    return po->m_poValue->get(key, value);
}

template <class T>
bool KeyTree<T>::getMax(char *key, T *value, char *retKey) const
{
    static Stack<KeyTree<T> *> stack;
    static Stack<char *> stack1;

    static KeyTree<T> * pTree;
    static char * pKeyPos;

    stack.clear ();
    stack1.clear ();

    
    unsigned char *p = (unsigned char *) key;
    unsigned char *pukey = p;
    
    KeyTree<T> * po = (KeyTree<T> *) this;
    int i;
    for (; *p; p++)
    {
        i = (*p) % 10;
        if (!(po->m_poNext[i])) {
            if (p == pukey) {
                return false;
            }

            break;
        }

        po = po->m_poNext[i];
        
        if (po->m_poValue) { 
            stack.push (po);
            stack1.push ((char *)p+1);
        }
    }









 
    static char sTemp[100];
    
    while (stack.pop(pTree) && stack1.pop(pKeyPos)) 
    {
        strncpy (sTemp, key, pKeyPos-key);
        sTemp[pKeyPos-key] = 0;
        
        if (pTree->m_poValue->get(sTemp, value)) 
        {
            if (retKey) strcpy(retKey, sTemp);
            return true;
        }
    }
    
    return false;
}


template <class T>
bool KeyTree<T>::getMax(char *key, T *value, int *pMatchLen) const
{
    static Stack<KeyTree<T> *> stack;
    static Stack<char *> stack1;

    static KeyTree<T> * pTree;
    static char * pKeyPos;

    stack.clear ();
    stack1.clear ();

    
    unsigned char *p = (unsigned char *) key;
    unsigned char *pukey = p;
    
    KeyTree<T> * po = (KeyTree<T> *) this;
    int i;
    for (; *p; p++)
    {
        i = (*p) % 10;
        if (!(po->m_poNext[i])) {
            if (p == pukey) {
                return false;
            }

            break;
        }

        po = po->m_poNext[i];
        
        if (po->m_poValue) { 
            stack.push (po);
            stack1.push ((char *)p+1);
        }
    }

    static char sTemp[100];
    
    while (stack.pop(pTree) && stack1.pop(pKeyPos)) 
    {
        *pMatchLen = pKeyPos-key;
        strncpy (sTemp, key, *pMatchLen);
        sTemp[*pMatchLen] = 0;
        
        if (pTree->m_poValue->get(sTemp, value)) 
        {
            return true;
        }
    }
    
    return false;
}



template <class T>
KeyTree<T>::KeyTree() : m_poValue(0) , m_iMaxDeep(0), m_iCount(0)
{
    memset (m_poNext, 0, sizeof(m_poNext));
}



template <class T>
KeyTree<T>::~KeyTree()
{
    destroy ();
}


#line 14 "/hss/opt/opthss/src/bill/src/app_guard/mntapi.h"


const int WF_MAX_FILE_NAME_LEN = 256;



extern "C" {


	
     
    int ConnectTerminalMonitor (int iProcID=-1);
    int DisconnectTerminalMonitor (int iState = 0);
    int AddTicketStat (int iType, int iNum=1);
    int SetProcState (int iState);
    int WriteMsg(int code, const char *fmt, ...);
    int WriteErr(int code, const char *fmt, ...);
    int GetBillFlowID ();
    void SetProcHead(THeadInfo*);    
    
    
    bool ConnectMonitor(int iProcID=-1);
    
    
    
    bool DisConnectMonitor(char cMode = WF_NORMAL);
    
    






 

	void PutPetriRet(int iRet, char *sRetInfo);
	void ClearPetriRet();
    bool Pprintf(int iAlertCode,bool bInsertDB,int iFileID,char const *fmt,...);   
    
    
 
    bool Pprintf_ex(int iAlertCode,bool bInsertDB,int iFileID,TAppInfo *pAppInfo,char const *fmt,...); 
    
    bool AddProcessCnt(int _iAddCnt=1); 
        
    int GetProcessID();   
    
    
    bool SaveLastEvent(StdEvent *pEvt);
    
    
    bool GetLastEvent(StdEvent *pEvt);
    
    
    bool SetEventState (int _iState);
    bool GetEventState (int *piState);
    
    
    
    
    bool SetSaveBuff (void *pt, int iLen);
    bool GetSaveBuff (void *pt, int iLen);
    
    
    bool SetSaveValue (int iValueID, long lValue);
    bool GetSaveValue (int iValueID, long &lValue);

    
    bool SetServBlockFlag (int iFlag, int iProcessID = 0);
    
    int  GetServBlockFlag (int iProcessID = 0);
    
    
    bool CheckProcAlive (int iProcessID);


    bool SetSaveValueByProcID (int iValueID, long lValue, int iProcessID);
    bool GetSaveValueByProcID (int iValueID, long &lValue, int iProcessID);
    int AddSendTickets(int iFileID,int iTickets);
    int GetLastSendTickets(int iFileID);
    

};


class TStatLog;

class TStatLogMgr {
public:
    
    static void addInEvent(int _iFileID, int _iEvtTypeID, int iCnt=1);
    static void addInEvent(int _iFileID, StdEvent *pEvt, int iCnt=1);
    static void addInEventEX(int _iFileID, StdEvent *pEvt, int iCnt=1);
    
    static void addInEventEX(int _iFileID, int _iEventTypeID,int iFromProcessID,int iCnt=1);
	  static void addOutEventEX(int _iFileID, int _iEventTypeID, StdEvent *pEvt, int iFromProcessID,int iDesProcessID[],int iDesProIDCount,int iCnt=1);
    
    
    static void addOutEvent(int _iFileID, int _iEvtTypeID, StdEvent *pEvt, int iCnt=1);
    static void addOutEvent(int _iFileID, StdEvent *pEvt, int iCnt=1);
    static void addOutEventEX(int _iFileID, int iFromProcessId, StdEvent *pEvt, int _iDesProcessID[],int _iDesProIDCount, int iCnt=1);
    
    static void addRemainAEX (int _iFileID, StdEvent *pEvt, int iCnt=1);
    static void addRemainBEX (int _iFileID, StdEvent *pEvt, int iCnt=1);
    
    static void addRemainA (int _iFileID, int iCnt=1);
    static void addRemainB (int _iFileID, int iCnt=1);
    static void addDistributeRemianA(int _iFileID, int iAppID,int iFromProcessId,StdEvent *pEvt, int _iDesProcessID[],int _iDesProIDCount, int iCnt);
    static void addDistributeRemianB(int _iFileID, int iFromProcessId,StdEvent *pEvt,int _iDesProIDCount, int iCnt);
    
    static void insertLog(int _iFileID);      
    static void insertLogEx(int _iFileID,int _iFromProcessID,int _iProcessIDBuf[],int _iProCount);      
    
    static void setForceFlag(bool bFlag);
    
    static void insertLogForce();
    ~TStatLogMgr();

private:
	static void addDistributeRemianB(int _iFileID, int iFromProcessID,int iDesProIDCount,int iCnt);
	static void addDistributeRemianA(int _iFileID, int iAppID, int iFromProcessID,int iDesProcessID[],int iDesProIDCount,int iCnt);
		
	static int getParentSecLevelEvtType(int _iEvtTypeID);
    static void initSecLevelEventType();
    static TStatLog *searchLogByFileID(int iFileID);
    static TStatLog *searchLogEX(string sMapKey);
    static void addDistributeRemianA(int _iFileID, int iCnt=1);
    static void addDistributeRemianB(int _iFileID, int iCnt=1);
    
private:
    
    static TStatLog *m_poLog;
    static KeyTree<int>* m_pSecLevelEventType;
    
    
    static map<string,TStatLog *> m_mapStatLog;
	static map<string, TStatLog*>::iterator m_mapIter;
    static string m_strMapKey;
    static char m_sTMapKey[64]; 
    
    static bool m_bForceFlag;
private:
#line 187 "/hss/opt/opthss/src/bill/src/app_guard/mntapi.h"
};


class TStatLog {

friend class TStatLogMgr;
public:
    TStatLog(int _iFileID = 0,int _iFromProcessID = 0,int _iDescProcessID = 0) {
        reset();
        m_iFileID = _iFileID;
        m_iDescProcessID = _iDescProcessID;
    	m_iFromProcessID = _iFromProcessID;
    }
    
    void addInEvent(int _iEvtTypeID, int iCnt=1);   
    void addOutEvent(int _iEvtTypeID, StdEvent *pEvt, int iCnt=1);  
    void insertLog();      
    void insertLogEx();      
    void setFileID (int _iFileID) { m_iFileID = _iFileID; }
    
private:
    void addInNormal(int iCnt=1);   
    void addInBlack(int iCnt=1);    
    void addInDup(int iCnt=1);      
    void addInPreErr(int iCnt=1);   
    void addInPricErr(int iCnt =1); 
    void addInUseless(int iCnt=1);  
    void addOutNormal(StdEvent *pEvt, int iCnt=1);  
    void addOutBlack(StdEvent *pEvt, int iCnt=1);   
    void addOutDup(StdEvent *pEvt, int iCnt=1);     
    void addOutPreErr(StdEvent *pEvt, int iCnt=1);  
    void addOutPricErr(StdEvent *pEvt, int iCnt=1); 
    void addOutUseless(StdEvent *pEvt, int iCnt=1); 
    void addFormatErr(int iCnt=1);  
    void addOutFormatErr(StdEvent *pEvt, int iCnt=1);
    
    void addRemainA (int iCnt=1) {m_iRemainA += iCnt;}
    void addRemainB (int iCnt=1) {m_iRemainB += iCnt;}
    
    void addDistributeRemianA(int iCnt=1);
    void addDistributeRemianB(int iCnt=1);
  
public:
    int m_iFileID;   
    char m_sFileName[WF_MAX_FILE_NAME_LEN]; 
    int m_iInNormal; 
    int m_iInBlack;  
    int m_iInDup;    
    int m_iInPreErr;   
    int m_iInPricErr;  
    int m_iInUseless;  
    int m_iOutNormal;  
    int m_iOutBlack;   
    int m_iOutDup;     
    int m_iOutPreErr;  
    int m_iOutPricErr; 
    int m_iOutUseless; 
    int m_iFormatErr;  
    int m_iOutFormatErr; 
    int m_iRemainA;  
    int m_iRemainB;  
    
    int m_iDistributeRemainA; 
    int m_iDistributeRemainB; 
    
    int m_iDescProcessID;
    int m_iFromProcessID;

	int m_iTempProcessID;
	
	long m_lNormalDuration; 
	long m_lNormalAmount; 
	long m_lNormalCharge; 
	
	long m_lBlackDuration;
	long m_lBlackAmount;
	long m_lBlackCharge;
	
	long m_lDupDuration;
	long m_lDupAmount;
	long m_lDupCharge;
	
	long m_lPreErrDuration;
	long m_lPreErrAmount;
	long m_lPreErrCharge;
	
	long m_lPricErrDuration;
	long m_lPricErrAmount;
	long m_lPricErrCharge;
	
	long m_lUseLessDuration;
	long m_lUseLessAmount;
	long m_lUseLessCharge;
	
	long m_lFormatErrDuration;
	long m_lFormatErrAmount;
	long m_lFormatErrCharge;
    
#line 292 "/hss/opt/opthss/src/bill/src/app_guard/mntapi.h"
    TStatLog* m_poNext;
    
private:
    void reset();
};






class TAlertLogMgr {
 public:
    int        m_iProcessID;
    int        m_iAppPID;
    int        m_iBillFlowID;
    int        m_iInforType;   
    char       m_sRecordTime;  
    char       m_sInfor[MAX_APPINFO__LEN];
};


class MntAPI {
  public:
    static TProcessInfo *m_pProcInfoHead;
    static THeadInfo * m_poInfoHead; 
    
    
    
    
    
    
    
    
    
    
    
    
    static int  stopProcess (int iProcID, int iWaitSecs=0, bool bCheckMQ=false);
    
    
    static int  getMsgNumber (int iProcID);
    
    
    
    
    
    
    
    
    static int  startProcess (int iProcID);
  
  private:
    static TProcessInfo * getProcessInfo (int iProcID);
    
};



#line 13 "Application.cpp"

#line 21 "Application.cpp"



static CommandCom *g_poKern = 0L;
int g_iModuID = -1;
int g_iProcID = -1;
int g_iNodeID = -1;
char g_sAppName[32] = {0}; 
volatile sig_atomic_t g_sigReceived = 0;
volatile sig_atomic_t g_iAlarmRcv = 0;

bool ReceiveStop(void);
void SigHandler(int sig);

void SigHandler(int sig)
{
	g_sigReceived = sig;
}

bool RcvExcepSig(void) {
	if (g_sigReceived) {
		return g_sigReceived != 15;
	}
	return false;
}

bool ReceiveStop(void)
{
	return (g_sigReceived==0)? false: true;
}

static void catchAlarmSig(int sig)
{
    g_iAlarmRcv = 0;   		
    return;
}

#line 157 "Application.cpp"

int SigHandlerSet(int sig, void (*handler)(int))
{
    struct sigaction new_action;
    struct sigaction old_action;
    
    memset(&new_action, 0x00, sizeof(new_action));
    memset(&old_action, 0x00, sizeof(old_action));

    new_action. __handler . __sa_handler = handler;
    sigemptyset(&new_action.sa_mask);
    sigfillset (&new_action.sa_mask);

    if (sigaction(sig, &new_action, &old_action) != 0) 
    	return -1;	
    
    return 0;
}

int HandleSigactions()
{
    
    sigset_t mask_action;
    sigemptyset(&mask_action);
    sigaddset(&mask_action, 1);
    sigaddset(&mask_action, 2);
    sigaddset(&mask_action, 3);
    
 
    sigaddset(&mask_action, 13);
    if (sigprocmask(000, &mask_action, 0) != 0) {
    	perror("sigprocmask");
    	return -1;	
    }
    
    if (SigHandlerSet(15, SigHandler) != 0) 
    	return -1;
	if (SigHandlerSet(17, SigHandler) != 0)
		return -1;
    
    if (SigHandlerSet(14, catchAlarmSig) != 0)
        return -1;
    return 0;	

}


Application::Application()
{
	memset(m_sEnvAppDly, 0x00, sizeof(m_sEnvAppDly));
	memset(m_sHostName, 0x00, sizeof(m_sHostName));	
}

int Application::appInit(ABMException &oExp)
{
    
    char *p = getenv("HSSDIR");
    if (p == 0L) {
        (oExp). addErr("Application.cpp", 215,"%s !","HSSDIR");
        directLog(1, 3, 14, "%s !", "HSSDIR");
        return -1;
    }
    strncpy(m_sEnvAppDly, p, sizeof(m_sEnvAppDly)-2);
    if (m_sEnvAppDly[strlen(m_sEnvAppDly)-1] != '/') 
        m_sEnvAppDly[strlen(m_sEnvAppDly)] = '/';
	char *pserver = getenv("HSSSERVER");

	
	g_poKern = getKernel();
	char sDefValue[256], sKerValue[256];
	g_poKern->readIniString("SYSTEM","hssserver", sKerValue, "hss");
	if (!pserver || strcmp(pserver, sKerValue)) {
		(oExp). addErr("Application.cpp", 229,"envirement HSSSERVER lost or not equ %s, programe exit!",sKerValue);
		directLog(1, 3, 14, "env \"HSSSERVER\" not equ param[STSTEM.hssserver] value:  %s, modify .profile try again!", sKerValue);
		return -1;
	}
    
	
    char sLogFile[256];
	snprintf(sLogFile, sizeof(sLogFile), "%slog/%s_%d_%d.log",         						m_sEnvAppDly, g_sAppName, g_iProcID, getpid());

	LogV2::setFileName(sLogFile);
    
	
	char  sLockFile[256];
	snprintf(sLockFile, sizeof(sLockFile), "%sdata/lock/%s_%d.lock",                                  m_sEnvAppDly, g_sAppName, g_iProcID);	

    if (tryLock(sLockFile, oExp) != 0) {
        (oExp). addErr("Application.cpp", 245,", -p!");
        directLog(1, 4, 196, "%s -p %d -m %d , -p!",             g_sAppName, g_iProcID, g_iModuID);

        return -1;   
    }
	
	
	int opt;
	if (gethostname(m_sHostName, sizeof(m_sHostName)) != 0) {
	}
	
	
    if (HandleSigactions() != 0) {
        (oExp). addErr("Application.cpp", 258,"!");
        directLog(1, 3, 6, "!");
        return -1;	
    }
    
    if (!ConnectMonitor(g_iProcID) || ConnectTerminalMonitor(g_iProcID)) {
        (oExp). addErr("Application.cpp", 264,"GUARD_MAIN!");
        directLog(1, 4, 4, "GUARD_MAIN!");
        return -1;    
    }
    
    return 0;
}


Application::~Application ( ) 
{

}

int Application::tryLock(const char *pfname, ABMException &oExp)
{
	int  fd;
	char buf[16];
	memset(buf,'\0',sizeof(buf));
	if ((fd=open(pfname, 0000001|0000400, 0000400|0000200|0000040|0000004)) < 0) {
		(oExp). addErr("Application.cpp", 284,"! errno=%d",(*__errno()));
		return -1;
	}
	struct flock lock;
	lock.l_type = 02;
	lock.l_start = 0;
	lock.l_whence = 0;
	lock.l_len = 0;
	if (fcntl(fd, 6, &lock) < 0) {
		(oExp). addErr("Application.cpp", 293,"! errno=%d",(*__errno()));
		return -1;
	}
	
	if (ftruncate(fd, 0) < 0) {
		(oExp). addErr("Application.cpp", 298,"ftruncate! errno=%d",(*__errno()));
		return -1;
	}
	snprintf(buf, sizeof(buf), "%ld\n", (long)getpid());	
	if (write(fd, buf, strlen(buf)) != (int)strlen(buf)) {
		(oExp). addErr("Application.cpp", 303,"write! errno=%d",(*__errno()));
		return -1;
	}
	return 0;
		
}

int Application::destory()
{
    DisConnectMonitor('E');
    DisconnectTerminalMonitor(0);    
	return 0;	
}

int Application::init(ABMException &oExp)
{
	return 0;	
}
